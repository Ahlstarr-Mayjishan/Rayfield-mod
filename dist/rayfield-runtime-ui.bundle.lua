-- AUTO-GENERATED by scripts/build-bundle.lua
local bundle = _G.__RAYFIELD_BUNDLE_SOURCES or {}
_G.__RAYFIELD_BUNDLE_SOURCES = bundle
_G.__RAYFIELD_BUNDLE_MODE = "bundle_first"

local function put(path, source)
    bundle[path] = source
end

local BUNDLE_NAME = "rayfield-runtime-ui"

put("src/feature/drag/cleanup.lua", [[local Cleanup = {}

function Cleanup.disconnectAll(connections)
	if type(connections) ~= "table" then
		return
	end
	for i = #connections, 1, -1 do
		local conn = connections[i]
		if conn then
			pcall(function()
				conn:Disconnect()
			end)
		end
		connections[i] = nil
	end
end

return Cleanup]])
put("src/feature/drag/controller.lua", [[-- Rayfield Drag/Detach System Module
-- Handles element detachment, mini windows, drag preview, and dock/undock logic

local DragModule = {}
local compileString = loadstring or load
if not compileString then
	error("No Lua compiler function available (loadstring/load)")
end

local MODULE_ROOT_URL = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"

local function loadSubmodule(localName, relativePath)
	local useStudio = false
	local okRun, runService = pcall(function()
		return game:GetService("RunService")
	end)
	if okRun and runService then
		local okStudio, studio = pcall(function()
			return runService:IsStudio()
		end)
		useStudio = okStudio and studio or false
	end

	if useStudio then
		local okRequire, module = pcall(function()
			return require(script.Parent[localName])
		end)
		if okRequire and module then
			return module
		end
	end

	return compileString(game:HttpGet(MODULE_ROOT_URL .. relativePath))()
end

local DragInputLib = loadSubmodule("input", "src/feature/drag/input.lua")
local DragWindowLib = loadSubmodule("window", "src/feature/drag/window.lua")
local DragDockLib = loadSubmodule("dock", "src/feature/drag/dock.lua")

-- Initialize module with dependencies
function DragModule.init(ctx)
	local self = {}

	-- Inject dependencies
	self.UserInputService = ctx.UserInputService
	self.TweenService = ctx.TweenService
	self.Animation = ctx.Animation or ctx.TweenService
	self.RunService = ctx.RunService
	self.HttpService = ctx.HttpService
	self.Main = ctx.Main
	self.Topbar = ctx.Topbar
	self.Elements = ctx.Elements
	self.Rayfield = ctx.Rayfield
	self.Icons = ctx.Icons
	self.getIcon = ctx.getIcon
	self.getAssetUri = ctx.getAssetUri
	self.getSelectedTheme = ctx.getSelectedTheme
	self.rayfieldDestroyed = ctx.rayfieldDestroyed
	self.ElementSync = ctx.ElementSync

	-- Extract code starts here

	local DETACH_HOLD_DURATION = 3
	local DETACH_HEADER_HEIGHT = 28
	local DETACH_MIN_WIDTH = 250
	local DETACH_MIN_HEIGHT = 90
	local DETACH_GHOST_FOLLOW_SPEED = 0.22
	local DETACH_WINDOW_DRAG_FOLLOW_SPEED = 0.28
	local DETACH_POP_IN_DURATION = 0.2
	local DETACH_POP_OUT_DURATION = 0.14
	local DETACH_CUE_HOVER_TRANSPARENCY = 0.52
	local DETACH_CUE_HOLD_TRANSPARENCY = 0.34
	local DETACH_CUE_READY_TRANSPARENCY = 0.24
	local DETACH_CUE_IDLE_THICKNESS = 1
	local DETACH_CUE_HOVER_THICKNESS = 1.35
	local DETACH_CUE_HOLD_THICKNESS = 1.9
	local DETACH_CUE_READY_THICKNESS = 2.2
	local DETACH_MERGE_DETECT_PADDING = 56
	local MERGE_INDICATOR_HEIGHT = 3
	local MERGE_INDICATOR_MARGIN = 8
	local MERGE_INDICATOR_TWEEN_DURATION = 0.12
	local DETACH_MOD_BUILD = "overlay-indicator-v1"
	_G.__RAYFIELD_MOD_BUILD = DETACH_MOD_BUILD
	
	local inputManager = DragInputLib.create(self.UserInputService)
	local windowManager = DragWindowLib.create({
		UserInputService = self.UserInputService,
		RunService = self.RunService,
		HttpService = self.HttpService,
		Rayfield = self.Rayfield,
		Main = self.Main,
		rayfieldDestroyed = self.rayfieldDestroyed,
		mergeDetectPadding = DETACH_MERGE_DETECT_PADDING,
		followSpeed = DETACH_WINDOW_DRAG_FOLLOW_SPEED,
		getInputPosition = function(input)
			return inputManager.getInputPosition(input)
		end,
		registerSharedInput = function(id, onChanged, onEnded)
			inputManager.register(id, onChanged, onEnded)
		end,
		unregisterSharedInput = function(id)
			inputManager.unregister(id)
		end,
		onDestroyInput = function()
			inputManager.disconnect()
		end
	})

	local function ensureSharedInputConnections()
		inputManager.ensure()
	end

	local function registerSharedInput(id, onChanged, onEnded)
		inputManager.register(id, onChanged, onEnded)
	end

	local function unregisterSharedInput(id)
		inputManager.unregister(id)
	end

	local function registerDetachedWindow(record)
		windowManager.registerDetachedWindow(record)
	end

	local function unregisterDetachedWindow(record)
		windowManager.unregisterDetachedWindow(record)
	end

	local function isPointNearFrame(point, frame, padding)
		return windowManager.isPointNearFrame(point, frame, padding)
	end

	local function findMergeTargetWindow(point, excludeRecord)
		return windowManager.findMergeTargetWindow(point, excludeRecord)
	end

	local function ensureDetachedLayer()
		return windowManager.ensureDetachedLayer()
	end

	windowManager.prewarmDetachedLayer()

	local function getInputPosition(input)
		return inputManager.getInputPosition(input)
	end

	local function clampDetachedPosition(desiredPosition, windowSize)
		return windowManager.clampDetachedPosition(desiredPosition, windowSize)
	end

	local function isOutsideMain(point)
		return windowManager.isOutsideMain(point)
	end

	local function isInsideMain(point)
		return windowManager.isInsideMain(point)
	end

	local function makeFloatingDraggable(frame, dragHandle, onDragEnd)
		return windowManager.makeFloatingDraggable(frame, dragHandle, onDragEnd)
	end
	
	local function createElementDetacher(guiObject, elementName, elementType)
		if not guiObject or not guiObject:IsA("GuiObject") then
			return nil
		end
	
		if elementType == "Section" or elementType == "Divider" then
			return nil
		end
	
		local dragInputSources = {}
		local adaptiveHoldDuration = DETACH_HOLD_DURATION
		local hoverCounter = 0
	
		local function addDragInputSource(source)
			if not (source and source:IsA("GuiObject")) then
				return
			end
			if table.find(dragInputSources, source) then
				return
			end
			source.Active = true
			table.insert(dragInputSources, source)
		end
	
		if elementType == "Button" then
			adaptiveHoldDuration = 2.2
		elseif elementType == "Dropdown" then
			adaptiveHoldDuration = 1.85
		elseif elementType == "Input" then
			adaptiveHoldDuration = 1.7
		end
	
		-- Prefer Interact for elements like Button/Toggle, then Title, then fallback to full element.
		addDragInputSource(guiObject:FindFirstChild("Interact"))
		addDragInputSource(guiObject:FindFirstChild("Title"))
		if elementType == "Dropdown" then
			addDragInputSource(guiObject:FindFirstChild("Selected"))
		end
		if elementType == "Input" then
			local inputFrame = guiObject:FindFirstChild("InputFrame")
			addDragInputSource(inputFrame)
			if inputFrame then
				addDragInputSource(inputFrame:FindFirstChild("InputBox"))
			end
		end
		if elementType ~= "Input" and elementType ~= "Dropdown" then
			addDragInputSource(guiObject)
		end
		if #dragInputSources == 0 then
			addDragInputSource(guiObject)
		end
	
		local detached = false
		local floatingWindow = nil
		local floatingContent = nil
		local floatingWindowWidth = nil
		local floatingDragCleanup = nil
		local floatingTitleBar = nil
		local floatingStroke = nil
		local floatingTitleLabel = nil
		local floatingDockButton = nil

		local function resyncElement(reason)
			if not (guiObject and guiObject.GetAttribute and self.ElementSync and type(self.ElementSync.resync) == "function") then
				return
			end
			local syncToken = guiObject:GetAttribute("RayfieldElementSyncToken")
			if type(syncToken) ~= "string" or syncToken == "" then
				return
			end
			pcall(self.ElementSync.resync, syncToken, reason or "drag_update")
		end
		local detachedPlaceholder = nil
		local windowRecord = nil
		local windowConnections = {}
		local eventConnections = {}
		local originalState = nil
		local rememberedState = nil
		local detacherId = self.HttpService:GenerateGUID(false)
	
		local pressInput = nil
		local pressToken = 0
		local pressing = false
		local dragArmed = false
		local pointerPosition = nil
		local dragGhost = nil
		local ghostTargetPosition = nil
		local ghostFollowConnection = nil
		local hoverActive = false
		local cueFrame = nil
		local cueStroke = nil
		local cueGlowStroke = nil
		local cueBlurStroke = nil
		local cueThemeConnection = nil
		local mergePreviewRecord = nil
		local clearMergePreview = nil
		local destroyDragGhost
		local mergeIndicator = nil
		local mergeIndicatorRecord = nil
		local mergeIndicatorTween = nil
		local lastMergeUpdateTime = 0
		local lastMergeInsertIndex = nil
		local mainDropIndicator = nil
		local mainDropIndicatorTween = nil
		local lastMainDropInsertIndex = nil
		local MERGE_UPDATE_INTERVAL = 0.05 -- ~20fps for preview, smooth enough while light
		local getOrderedMainDockChildren
		local calculateMainInsertIndex
		local reorderInMainAt
		local isGuiActiveInCurrentPage
		local isPointInsideGui
		local syncCueHoverFromPointer
		local resetDragState
	
		local function getDetachCueColor()
			return self.getSelectedTheme().SliderProgress or self.getSelectedTheme().TextColor or Color3.fromRGB(120, 170, 255)
		end
	
		local function ensureDetachCue()
			if self.rayfieldDestroyed() or not (guiObject and guiObject.Parent) or not (self.Main and self.Main.Parent) then
				if cueThemeConnection then
					cueThemeConnection:Disconnect()
					cueThemeConnection = nil
				end
				if cueFrame then
					cueFrame:Destroy()
					cueFrame = nil
					cueStroke = nil
					cueGlowStroke = nil
					cueBlurStroke = nil
				end
				return false
			end
	
			if cueFrame and cueFrame.Parent and cueStroke and cueStroke.Parent and cueGlowStroke and cueGlowStroke.Parent and cueBlurStroke and cueBlurStroke.Parent then
				return true
			end
	
			if cueThemeConnection then
				cueThemeConnection:Disconnect()
				cueThemeConnection = nil
			end
	
			cueFrame = Instance.new("Frame")
			cueFrame.Name = "DetachCue"
			cueFrame.BackgroundTransparency = 1
			cueFrame.BorderSizePixel = 0
			cueFrame.Size = UDim2.fromScale(1, 1)
			cueFrame.Position = UDim2.fromOffset(0, 0)
			cueFrame.ZIndex = (guiObject.ZIndex or 1) + 6
			cueFrame.Active = false
			cueFrame.Parent = guiObject
	
			local sourceCorner = guiObject:FindFirstChildOfClass("UICorner")
			if sourceCorner then
				local cueCorner = Instance.new("UICorner")
				cueCorner.CornerRadius = sourceCorner.CornerRadius
				cueCorner.Parent = cueFrame
			end
	
			cueStroke = Instance.new("UIStroke")
			cueStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
			cueStroke.Color = getDetachCueColor()
			cueStroke.Thickness = DETACH_CUE_IDLE_THICKNESS
			cueStroke.Transparency = 1
			cueStroke.Parent = cueFrame

			cueGlowStroke = Instance.new("UIStroke")
			cueGlowStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
			cueGlowStroke.Color = getDetachCueColor()
			cueGlowStroke.Thickness = DETACH_CUE_IDLE_THICKNESS + 1.4
			cueGlowStroke.Transparency = 1
			cueGlowStroke.Parent = cueFrame

			cueBlurStroke = Instance.new("UIStroke")
			cueBlurStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
			cueBlurStroke.Color = getDetachCueColor()
			cueBlurStroke.Thickness = DETACH_CUE_IDLE_THICKNESS + 3.2
			cueBlurStroke.Transparency = 1
			cueBlurStroke.Parent = cueFrame
	
			cueThemeConnection = self.Main:GetPropertyChangedSignal("BackgroundColor3"):Connect(function()
				if cueStroke and cueStroke.Parent then
					cueStroke.Color = getDetachCueColor()
				end
				if cueGlowStroke and cueGlowStroke.Parent then
					cueGlowStroke.Color = getDetachCueColor()
				end
				if cueBlurStroke and cueBlurStroke.Parent then
					cueBlurStroke.Color = getDetachCueColor()
				end
			end)
	
			return true
		end
	
		local function setDetachCue(transparency, thickness, duration)
			if not cueStroke or not cueStroke.Parent then
				return
			end
			local glowTransparency = (transparency >= 0.99)
				and 1
				or math.clamp(transparency + 0.34, 0.45, 0.98)
			local glowThickness = thickness + 1.4
			local blurTransparency = (transparency >= 0.99)
				and 1
				or math.clamp(transparency + 0.52, 0.7, 0.995)
			local blurThickness = thickness + 3.2
	
			if not duration or duration <= 0 then
				cueStroke.Transparency = transparency
				cueStroke.Thickness = thickness
				if cueGlowStroke and cueGlowStroke.Parent then
					cueGlowStroke.Transparency = glowTransparency
					cueGlowStroke.Thickness = glowThickness
				end
				if cueBlurStroke and cueBlurStroke.Parent then
					cueBlurStroke.Transparency = blurTransparency
					cueBlurStroke.Thickness = blurThickness
				end
				return
			end
	
			self.Animation:Create(cueStroke, TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
				Transparency = transparency,
				Thickness = thickness
			}):Play()
			if cueGlowStroke and cueGlowStroke.Parent then
				self.Animation:Create(cueGlowStroke, TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
					Transparency = glowTransparency,
					Thickness = glowThickness
				}):Play()
			end
			if cueBlurStroke and cueBlurStroke.Parent then
				self.Animation:Create(cueBlurStroke, TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
					Transparency = blurTransparency,
					Thickness = blurThickness
				}):Play()
			end
		end
	
		local function refreshDetachCue()
			if not ensureDetachCue() then
				return
			end
			if detached then
				setDetachCue(1, DETACH_CUE_IDLE_THICKNESS, 0.1)
				return
			end
	
			if dragArmed then
				setDetachCue(DETACH_CUE_READY_TRANSPARENCY, DETACH_CUE_READY_THICKNESS, 0.08)
				return
			end
	
			if pressing then
				setDetachCue(DETACH_CUE_HOLD_TRANSPARENCY, DETACH_CUE_HOLD_THICKNESS, 0.08)
				return
			end
	
			if hoverActive then
				setDetachCue(DETACH_CUE_HOVER_TRANSPARENCY, DETACH_CUE_HOVER_THICKNESS, 0.12)
			else
				setDetachCue(1, DETACH_CUE_IDLE_THICKNESS, 0.12)
			end
		end

		isGuiActiveInCurrentPage = function(targetGui)
			if not targetGui or not targetGui.Parent then
				return false
			end
			if detached then
				return false
			end
			if not targetGui.Visible then
				return false
			end
			local currentPage = self.Elements and self.Elements.UIPageLayout and self.Elements.UIPageLayout.CurrentPage
			if not currentPage or not currentPage.Parent then
				return false
			end
			return targetGui:IsDescendantOf(currentPage)
		end

		isPointInsideGui = function(point, targetGui)
			if not point or not targetGui or not targetGui.Parent then
				return false
			end
			if targetGui.AbsoluteSize.X <= 0 or targetGui.AbsoluteSize.Y <= 0 then
				return false
			end
			local pos = targetGui.AbsolutePosition
			local size = targetGui.AbsoluteSize
			return point.X >= pos.X
				and point.Y >= pos.Y
				and point.X <= (pos.X + size.X)
				and point.Y <= (pos.Y + size.Y)
		end

		syncCueHoverFromPointer = function(point, force)
			local pointer = point
			if not pointer then
				pointer = self.UserInputService:GetMouseLocation()
			end

			local shouldHover = false
			local currentPage = self.Elements and self.Elements.UIPageLayout and self.Elements.UIPageLayout.CurrentPage
			if currentPage and isGuiActiveInCurrentPage(guiObject) then
				for _, source in ipairs(dragInputSources) do
					if source and source.Parent and source.Visible and source:IsDescendantOf(guiObject) and source:IsDescendantOf(currentPage) then
						if isPointInsideGui(pointer, source) then
							shouldHover = true
							break
						end
					end
				end
			end

			if force or hoverActive ~= shouldHover then
				hoverCounter = shouldHover and 1 or 0
				hoverActive = shouldHover
				if not pressing and not dragArmed then
					refreshDetachCue()
				end
			end
		end

		resetDragState = function(reason)
			if reason then
				-- No-op hook kept for lightweight diagnostics if needed later.
			end
			pressing = false
			pressInput = nil
			dragArmed = false
			pressToken += 1
			if clearMergePreview then
				clearMergePreview(false)
			end
			if destroyDragGhost then
				destroyDragGhost(true)
			end
			hoverCounter = 0
			hoverActive = false
			refreshDetachCue()
		end
	
		local function runHoldCueProgress(token)
			local started = os.clock()
			while pressing and pressToken == token and not dragArmed and not detached do
				local progress = math.clamp((os.clock() - started) / adaptiveHoldDuration, 0, 1)
				local transparency = DETACH_CUE_HOVER_TRANSPARENCY + ((DETACH_CUE_HOLD_TRANSPARENCY - DETACH_CUE_HOVER_TRANSPARENCY) * progress)
				local thickness = DETACH_CUE_HOVER_THICKNESS + ((DETACH_CUE_HOLD_THICKNESS - DETACH_CUE_HOVER_THICKNESS) * progress)
				setDetachCue(transparency, thickness, 0)
				task.wait()
			end
		end
	
		local function cleanupDetachCue()
			if cueThemeConnection then
				cueThemeConnection:Disconnect()
				cueThemeConnection = nil
			end
			if cueFrame then
				cueFrame:Destroy()
				cueFrame = nil
				cueStroke = nil
				cueGlowStroke = nil
				cueBlurStroke = nil
			end
		end
	
		local function cleanupWindowConnections()
			for _, connection in ipairs(windowConnections) do
				if connection then
					connection:Disconnect()
				end
			end
			table.clear(windowConnections)
		end

		local dockManager = DragDockLib.create()
	
		local function getOrderedGuiChildren(parent, excludeA, excludeB)
			return dockManager.getOrderedGuiChildren(parent, excludeA, excludeB)
		end
	
		local function normalizeOrderedGuiLayout(ordered)
			dockManager.normalizeOrderedGuiLayout(ordered)
		end
	
		local function parentUsesLayoutOrder(parent)
			return dockManager.parentUsesLayoutOrder(parent)
		end
	
		local function resolveInsertIndexFromState(parent, state, ordered)
			return dockManager.resolveInsertIndexFromState(parent, state, ordered)
		end
	
		local function captureCurrentElementState()
			local parent = guiObject.Parent
			local siblingIndex = nil
			local previousSibling = nil
			local nextSibling = nil
	
			if parent and parentUsesLayoutOrder(parent) then
				local ordered = getOrderedGuiChildren(parent)
				for index, child in ipairs(ordered) do
					if child == guiObject then
						siblingIndex = index
						previousSibling = ordered[index - 1]
						nextSibling = ordered[index + 1]
						break
					end
				end
			end
	
			return {
				Parent = parent,
				AnchorPoint = guiObject.AnchorPoint,
				Position = guiObject.Position,
				Size = guiObject.Size,
				LayoutOrder = guiObject.LayoutOrder,
				SiblingIndex = siblingIndex,
				PreviousSibling = previousSibling,
				NextSibling = nextSibling
			}
		end
	
		local function updateDetachedPlaceholder()
			if not detachedPlaceholder then
				return
			end
	
			local height = math.max(guiObject.AbsoluteSize.Y, 36)
			detachedPlaceholder.Size = UDim2.new(1, 0, 0, height)
		end
	
		local function destroyDetachedPlaceholder()
			if detachedPlaceholder then
				detachedPlaceholder:Destroy()
				detachedPlaceholder = nil
			end
		end
	
		local function createDetachedPlaceholder()
			if detachedPlaceholder or not originalState or not originalState.Parent then
				return
			end
	
			detachedPlaceholder = Instance.new("Frame")
			detachedPlaceholder.Name = "DetachPlaceholder"
			detachedPlaceholder.BackgroundColor3 = self.getSelectedTheme().SecondaryElementBackground
			detachedPlaceholder.BackgroundTransparency = 0.82
			detachedPlaceholder.BorderSizePixel = 0
			detachedPlaceholder.LayoutOrder = originalState.LayoutOrder
			detachedPlaceholder.Parent = originalState.Parent
	
			if parentUsesLayoutOrder(originalState.Parent) then
				local ordered = getOrderedGuiChildren(originalState.Parent, detachedPlaceholder)
				local insertIndex = resolveInsertIndexFromState(originalState.Parent, originalState, ordered)
				if type(insertIndex) ~= "number" then
					insertIndex = #ordered + 1
				end
				insertIndex = math.clamp(insertIndex, 1, #ordered + 1)
				table.insert(ordered, insertIndex, detachedPlaceholder)
				normalizeOrderedGuiLayout(ordered)
				detachedPlaceholder:SetAttribute("DetachSlotIndex", insertIndex)
			else
				detachedPlaceholder:SetAttribute("DetachSlotIndex", nil)
			end
	
			local sourceCorner = guiObject:FindFirstChildOfClass("UICorner")
			if sourceCorner then
				local placeholderCorner = Instance.new("UICorner")
				placeholderCorner.CornerRadius = sourceCorner.CornerRadius
				placeholderCorner.Parent = detachedPlaceholder
			end
	
			local placeholderStroke = Instance.new("UIStroke")
			placeholderStroke.Color = self.getSelectedTheme().SliderProgress or self.getSelectedTheme().ElementStroke
			placeholderStroke.Thickness = 1.2
			placeholderStroke.Transparency = 0.35
			placeholderStroke.Parent = detachedPlaceholder
	
			local placeholderLabel = Instance.new("TextLabel")
			placeholderLabel.Name = "Hint"
			placeholderLabel.BackgroundTransparency = 1
			placeholderLabel.Size = UDim2.new(1, -12, 1, 0)
			placeholderLabel.Position = UDim2.new(0, 6, 0, 0)
			placeholderLabel.Text = "Detached slot (origin): " .. tostring(elementName)
			placeholderLabel.TextColor3 = self.getSelectedTheme().TextColor
			placeholderLabel.TextTransparency = 0.35
			placeholderLabel.TextSize = 11
			placeholderLabel.Font = Enum.Font.Gotham
			placeholderLabel.TextXAlignment = Enum.TextXAlignment.Left
			placeholderLabel.Parent = detachedPlaceholder
	
			updateDetachedPlaceholder()
		end
	
		destroyDragGhost = function(instant)
			if clearMergePreview then
				clearMergePreview(true)
			end
	
			if ghostFollowConnection then
				ghostFollowConnection:Disconnect()
				ghostFollowConnection = nil
			end
	
			if not dragGhost then
				ghostTargetPosition = nil
				return
			end
	
			local ghost = dragGhost
			dragGhost = nil
			ghostTargetPosition = nil
	
			if instant then
				ghost:Destroy()
				return
			end
	
			local shrinkWidth = math.max(math.floor(ghost.AbsoluteSize.X * 0.9), 120)
			local shrinkHeight = math.max(math.floor(ghost.AbsoluteSize.Y * 0.88), 26)
			self.Animation:Create(ghost, TweenInfo.new(DETACH_POP_OUT_DURATION, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
				BackgroundTransparency = 1,
				Size = UDim2.fromOffset(shrinkWidth, shrinkHeight)
			}):Play()
	
			for _, child in ipairs(ghost:GetChildren()) do
				if child:IsA("TextLabel") then
					self.Animation:Create(child, TweenInfo.new(DETACH_POP_OUT_DURATION, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {TextTransparency = 1}):Play()
				elseif child:IsA("UIStroke") then
					self.Animation:Create(child, TweenInfo.new(DETACH_POP_OUT_DURATION, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {Transparency = 1}):Play()
				end
			end
	
			task.delay(DETACH_POP_OUT_DURATION + 0.03, function()
				if ghost and ghost.Parent then
					ghost:Destroy()
				end
			end)
		end
	
		local function updateGhostPosition()
			if not dragGhost or not pointerPosition then
				return
			end
	
			local size = dragGhost.AbsoluteSize
			ghostTargetPosition = Vector2.new(
				pointerPosition.X - (size.X / 2),
				pointerPosition.Y - (size.Y / 2)
			)
		end
	
		local function createDragGhost()
			if dragGhost then
				return
			end
	
			local layer = ensureDetachedLayer()
			local targetSize = Vector2.new(
				math.max(guiObject.AbsoluteSize.X, 160),
				math.max(guiObject.AbsoluteSize.Y, 34)
			)
			local startSize = Vector2.new(
				math.max(math.floor(targetSize.X * 0.9), 120),
				math.max(math.floor(targetSize.Y * 0.88), 26)
			)
	
			dragGhost = Instance.new("Frame")
			dragGhost.Name = "DetachGhost"
			dragGhost.Size = UDim2.fromOffset(startSize.X, startSize.Y)
			dragGhost.BorderSizePixel = 0
			dragGhost.BackgroundColor3 = self.getSelectedTheme().SecondaryElementBackground
			dragGhost.BackgroundTransparency = 1
			dragGhost.ZIndex = 250
			dragGhost.Parent = layer
	
			local ghostCorner = Instance.new("UICorner")
			ghostCorner.CornerRadius = UDim.new(0, 8)
			ghostCorner.Parent = dragGhost
	
			local ghostStroke = Instance.new("UIStroke")
			ghostStroke.Thickness = 1.5
			ghostStroke.Color = self.getSelectedTheme().ElementStroke
			ghostStroke.Transparency = 1
			ghostStroke.Parent = dragGhost
	
			local ghostLabel = Instance.new("TextLabel")
			ghostLabel.BackgroundTransparency = 1
			ghostLabel.Size = UDim2.new(1, -14, 1, 0)
			ghostLabel.Position = UDim2.new(0, 7, 0, 0)
			ghostLabel.Text = "Detach: " .. tostring(elementName)
			ghostLabel.TextSize = 12
			ghostLabel.Font = Enum.Font.Gotham
			ghostLabel.TextColor3 = self.getSelectedTheme().TextColor
			ghostLabel.TextTransparency = 1
			ghostLabel.TextXAlignment = Enum.TextXAlignment.Left
			ghostLabel.ZIndex = 251
			ghostLabel.Parent = dragGhost
	
			updateGhostPosition()
			if ghostTargetPosition then
				dragGhost.Position = UDim2.fromOffset(ghostTargetPosition.X, ghostTargetPosition.Y)
			end
	
			ghostFollowConnection = self.RunService.RenderStepped:Connect(function(deltaTime)
				if not dragGhost or not ghostTargetPosition then
					return
				end
	
				local current = Vector2.new(dragGhost.Position.X.Offset, dragGhost.Position.Y.Offset)
				local alpha = math.clamp(deltaTime * (DETACH_GHOST_FOLLOW_SPEED * 60), 0, 1)
				local nextPosition = current:Lerp(ghostTargetPosition, alpha)
				dragGhost.Position = UDim2.fromOffset(math.floor(nextPosition.X + 0.5), math.floor(nextPosition.Y + 0.5))
			end)
	
			self.Animation:Create(dragGhost, TweenInfo.new(DETACH_POP_IN_DURATION, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
				Size = UDim2.fromOffset(targetSize.X, targetSize.Y),
				BackgroundTransparency = 0.25
			}):Play()
			self.Animation:Create(ghostStroke, TweenInfo.new(DETACH_POP_IN_DURATION * 0.85, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Transparency = 0}):Play()
			self.Animation:Create(ghostLabel, TweenInfo.new(DETACH_POP_IN_DURATION * 0.85, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {TextTransparency = 0}):Play()
		end
	
		local function clearMergeIndicator(instant)
			if mergeIndicatorTween then
				pcall(function() mergeIndicatorTween:Cancel() end)
				mergeIndicatorTween = nil
			end
	
			if mergeIndicator then
				local indicator = mergeIndicator
				mergeIndicator = nil
				mergeIndicatorRecord = nil
	
				if instant then
					indicator:Destroy()
					return
				end
	
				self.Animation:Create(indicator, TweenInfo.new(0.08, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
					BackgroundTransparency = 1
				}):Play()
				for _, child in ipairs(indicator:GetChildren()) do
					if child:IsA("TextLabel") then
						self.Animation:Create(child, TweenInfo.new(0.08, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
							TextTransparency = 1,
							BackgroundTransparency = 1
						}):Play()
					end
				end
				task.delay(0.09, function()
					if indicator and indicator.Parent then
						indicator:Destroy()
					end
				end)
			else
				mergeIndicatorRecord = nil
			end
		end
	
		local function calculateRecordInsertIndex(record, point)
			if not (record and record.content and record.content.Parent and point) then
				return nil
			end
	
			local ordered = getOrderedGuiChildren(record.content)
			local insertIndex = #ordered + 1
	
			for index, child in ipairs(ordered) do
				local childCenterY = child.AbsolutePosition.Y + (child.AbsoluteSize.Y * 0.5)
				if point.Y <= childCenterY then
					insertIndex = index
					break
				end
			end
	
			return insertIndex, ordered
		end
	
		local function getMergeSiblingNameForPreview(child)
			if not (child and child:IsA("GuiObject")) then
				return nil
			end
	
			local title = child:FindFirstChild("Title")
			if title and title:IsA("TextLabel") then
				local text = tostring(title.Text or ""):gsub("^%s+", ""):gsub("%s+$", "")
				if text ~= "" then
					return text
				end
			end
	
			return tostring(child.Name or "")
		end
	
		local function computeIndicatorY(record, insertIndex, ordered)
			local content = record.content
			if not ordered or #ordered == 0 then
				return content.AbsolutePosition.Y + 4
			end
	
			if insertIndex <= 1 then
				local first = ordered[1]
				return first.AbsolutePosition.Y - 2
			end
	
			if insertIndex > #ordered then
				local last = ordered[#ordered]
				return last.AbsolutePosition.Y + last.AbsoluteSize.Y + 2
			end
	
			local before = ordered[insertIndex - 1]
			local after = ordered[insertIndex]
			local beforeBottom = before.AbsolutePosition.Y + before.AbsoluteSize.Y
			local afterTop = after.AbsolutePosition.Y
			return (beforeBottom + afterTop) / 2
		end
	
		local function ensureMergeIndicator(record, insertIndex, ordered)
			if not (record and record.content and record.content.Parent) then
				clearMergeIndicator(true)
				return
			end
	
			-- Recycle: just update record reference, no destroy/recreate needed
			mergeIndicatorRecord = record
	
			local layer = ensureDetachedLayer()
			-- Convert screen-space AbsolutePosition to layer-local coordinates
			-- This handles IgnoreGuiInset correctly regardless of setting
			local layerOffset = layer.AbsolutePosition
			local contentX = record.content.AbsolutePosition.X - layerOffset.X
			local contentW = record.content.AbsoluteSize.X
			local indicatorW = math.max(contentW - (MERGE_INDICATOR_MARGIN * 2), 20)
			local indicatorX = contentX + MERGE_INDICATOR_MARGIN
			local indicatorY = computeIndicatorY(record, insertIndex, ordered) - layerOffset.Y - math.floor(MERGE_INDICATOR_HEIGHT / 2)
	
			if not mergeIndicator then
				mergeIndicator = Instance.new("Frame")
				mergeIndicator.Name = "MergeIndicator"
				mergeIndicator.BackgroundColor3 = getDetachCueColor()
				mergeIndicator.BackgroundTransparency = 0.05
				mergeIndicator.BorderSizePixel = 0
				mergeIndicator.Size = UDim2.fromOffset(indicatorW, MERGE_INDICATOR_HEIGHT)
				mergeIndicator.Position = UDim2.fromOffset(indicatorX, indicatorY)
				mergeIndicator.ZIndex = 210
				mergeIndicator.Parent = layer
	
				local corner = Instance.new("UICorner")
				corner.CornerRadius = UDim.new(0, 2)
				corner.Parent = mergeIndicator
	
				local label = Instance.new("TextLabel")
				label.Name = "ReviewLabel"
				label.BackgroundColor3 = getDetachCueColor()
				label.BackgroundTransparency = 0.08
				label.BorderSizePixel = 0
				label.Size = UDim2.fromOffset(0, 16)
				label.AutomaticSize = Enum.AutomaticSize.X
				label.Position = UDim2.fromOffset(0, -18)
				label.Font = Enum.Font.GothamBold
				label.TextSize = 10
				label.TextColor3 = self.getSelectedTheme().TextColor
				label.TextTransparency = 0.05
				label.Text = ""
				label.Parent = mergeIndicator
	
				local labelPadding = Instance.new("UIPadding")
				labelPadding.PaddingLeft = UDim.new(0, 5)
				labelPadding.PaddingRight = UDim.new(0, 5)
				labelPadding.Parent = label
	
				local labelCorner = Instance.new("UICorner")
				labelCorner.CornerRadius = UDim.new(0, 4)
				labelCorner.Parent = label
			end
	
			-- Update label text
			local orderedCount = ordered and #ordered or 0
			local indexNumber = math.clamp(math.floor(tonumber(insertIndex) or 1), 1, orderedCount + 1)
			local hint = "at end"
			local targetSibling = type(ordered) == "table" and ordered[indexNumber] or nil
			if targetSibling then
				local siblingName = getMergeSiblingNameForPreview(targetSibling)
				if siblingName and siblingName ~= "" then
					hint = "before " .. siblingName
				else
					hint = "before next"
				end
			end
	
			local reviewLabel = mergeIndicator:FindFirstChild("ReviewLabel")
			if reviewLabel and reviewLabel:IsA("TextLabel") then
				reviewLabel.Text = string.format("#%d · %s", indexNumber, hint)
				reviewLabel.BackgroundColor3 = getDetachCueColor()
			end
	
			-- Update indicator color/size in case theme changed
			mergeIndicator.BackgroundColor3 = getDetachCueColor()
			mergeIndicator.Size = UDim2.fromOffset(indicatorW, MERGE_INDICATOR_HEIGHT)
	
			-- Tween to new position
			local targetPos = UDim2.fromOffset(indicatorX, indicatorY)
	
			if mergeIndicatorTween then
				pcall(function() mergeIndicatorTween:Cancel() end)
				mergeIndicatorTween = nil
			end
	
			local tween = self.Animation:Create(mergeIndicator, TweenInfo.new(
				MERGE_INDICATOR_TWEEN_DURATION, Enum.EasingStyle.Quad, Enum.EasingDirection.Out
			), { Position = targetPos })
			mergeIndicatorTween = tween
			tween.Completed:Connect(function()
				if mergeIndicatorTween == tween then
					mergeIndicatorTween = nil
				end
			end)
			tween:Play()
		end
	
		getOrderedMainDockChildren = function(tabPage, excludeA, excludeB)
			if not (tabPage and tabPage.Parent) then
				return {}
			end

			local rawChildren = tabPage:GetChildren()
			local insertionOrder = {}
			for index, child in ipairs(rawChildren) do
				insertionOrder[child] = index
			end

			local function isDockCandidate(child)
				if not (child and child:IsA("GuiObject")) then
					return false
				end
				if child == excludeA or child == excludeB then
					return false
				end
				if not child.Visible then
					return false
				end

				local childName = tostring(child.Name)
				if childName == "Placeholder"
					or childName == "DetachPlaceholder"
					or childName == "SearchTitle-fsefsefesfsefesfesfThanks" then
					return false
				end

				return true
			end

			local ordered = {}
			for _, child in ipairs(rawChildren) do
				if isDockCandidate(child) then
					table.insert(ordered, child)
				end
			end

			table.sort(ordered, function(a, b)
				if a.LayoutOrder ~= b.LayoutOrder then
					return a.LayoutOrder < b.LayoutOrder
				end
				return (insertionOrder[a] or 0) < (insertionOrder[b] or 0)
			end)

			return ordered
		end

		calculateMainInsertIndex = function(tabPage, point, excludeA, excludeB)
			if not (tabPage and tabPage.Parent and point) then
				return nil, {}
			end

			local ordered = getOrderedMainDockChildren(tabPage, excludeA, excludeB)
			local insertIndex = #ordered + 1
			for index, child in ipairs(ordered) do
				local childCenterY = child.AbsolutePosition.Y + (child.AbsoluteSize.Y * 0.5)
				if point.Y <= childCenterY then
					insertIndex = index
					break
				end
			end
			return insertIndex, ordered
		end
	
		local function computeMainIndicatorY(tabPage, insertIndex, ordered)
			if not ordered or #ordered == 0 then
				return tabPage.AbsolutePosition.Y + 4
			end
			if insertIndex <= 1 then
				return ordered[1].AbsolutePosition.Y - 2
			end
			if insertIndex > #ordered then
				local last = ordered[#ordered]
				return last.AbsolutePosition.Y + last.AbsoluteSize.Y + 2
			end
			local before = ordered[insertIndex - 1]
			local after = ordered[insertIndex]
			return (before.AbsolutePosition.Y + before.AbsoluteSize.Y + after.AbsolutePosition.Y) / 2
		end
	
		local function clearMainDropPreview(instant)
			if mainDropIndicatorTween then
				pcall(function() mainDropIndicatorTween:Cancel() end)
				mainDropIndicatorTween = nil
			end
			lastMainDropInsertIndex = nil
			if mainDropIndicator then
				local indicator = mainDropIndicator
				mainDropIndicator = nil
				if instant then
					indicator:Destroy()
					return
				end
				self.Animation:Create(indicator, TweenInfo.new(0.08, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
					BackgroundTransparency = 1
				}):Play()
				for _, child in ipairs(indicator:GetChildren()) do
					if child:IsA("TextLabel") then
						self.Animation:Create(child, TweenInfo.new(0.08, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
							TextTransparency = 1,
							BackgroundTransparency = 1
						}):Play()
					end
				end
				task.delay(0.09, function()
					if indicator and indicator.Parent then
						indicator:Destroy()
					end
				end)
			end
		end
	
		local function showMainDropPreview(point)
			local currentTabPage = self.Elements.UIPageLayout.CurrentPage
			if not (currentTabPage and currentTabPage.Parent) then
				clearMainDropPreview(false)
				return
			end
			local targetState = originalState or rememberedState
			if targetState and targetState.Parent and currentTabPage ~= targetState.Parent then
				clearMainDropPreview(false)
				return
			end
			local excludeSelf = (not detached) and guiObject or nil
			local insertIndex, ordered = calculateMainInsertIndex(currentTabPage, point, excludeSelf)
			if not insertIndex then
				clearMainDropPreview(false)
				return
			end
			lastMainDropInsertIndex = insertIndex
	
			local layer = ensureDetachedLayer()
			local layerOffset = layer.AbsolutePosition
			local contentX = currentTabPage.AbsolutePosition.X - layerOffset.X
			local contentW = currentTabPage.AbsoluteSize.X
			local indicatorW = math.max(contentW - (MERGE_INDICATOR_MARGIN * 2), 20)
			local indicatorX = contentX + MERGE_INDICATOR_MARGIN
			local indicatorY = computeMainIndicatorY(currentTabPage, insertIndex, ordered) - layerOffset.Y - math.floor(MERGE_INDICATOR_HEIGHT / 2)
	
			if not mainDropIndicator then
				mainDropIndicator = Instance.new("Frame")
				mainDropIndicator.Name = "MainDropIndicator"
				mainDropIndicator.BackgroundColor3 = getDetachCueColor()
				mainDropIndicator.BackgroundTransparency = 0.05
				mainDropIndicator.BorderSizePixel = 0
				mainDropIndicator.Size = UDim2.fromOffset(indicatorW, MERGE_INDICATOR_HEIGHT)
				mainDropIndicator.Position = UDim2.fromOffset(indicatorX, indicatorY)
				mainDropIndicator.ZIndex = 210
				mainDropIndicator.Parent = layer
	
				local corner = Instance.new("UICorner")
				corner.CornerRadius = UDim.new(0, 2)
				corner.Parent = mainDropIndicator
	
				local label = Instance.new("TextLabel")
				label.Name = "ReviewLabel"
				label.BackgroundColor3 = getDetachCueColor()
				label.BackgroundTransparency = 0.08
				label.BorderSizePixel = 0
				label.Size = UDim2.fromOffset(0, 16)
				label.AutomaticSize = Enum.AutomaticSize.X
				label.Position = UDim2.fromOffset(0, -18)
				label.Font = Enum.Font.GothamBold
				label.TextSize = 10
				label.TextColor3 = self.getSelectedTheme().TextColor
				label.TextTransparency = 0.05
				label.Text = ""
				label.Parent = mainDropIndicator
	
				local labelPadding = Instance.new("UIPadding")
				labelPadding.PaddingLeft = UDim.new(0, 5)
				labelPadding.PaddingRight = UDim.new(0, 5)
				labelPadding.Parent = label
	
				local labelCorner = Instance.new("UICorner")
				labelCorner.CornerRadius = UDim.new(0, 4)
				labelCorner.Parent = label
			end
	
			local orderedCount = #ordered
			local indexNumber = math.clamp(insertIndex, 1, orderedCount + 1)
			local hint = "at end"
			local targetSibling = ordered[indexNumber]
			if targetSibling then
				local siblingName = getMergeSiblingNameForPreview(targetSibling)
				if siblingName and siblingName ~= "" then
					hint = "before " .. siblingName
				else
					hint = "before next"
				end
			end
	
			local reviewLabel = mainDropIndicator:FindFirstChild("ReviewLabel")
			if reviewLabel and reviewLabel:IsA("TextLabel") then
				reviewLabel.Text = string.format("Dock #%d · %s", indexNumber, hint)
				reviewLabel.BackgroundColor3 = getDetachCueColor()
			end
	
			mainDropIndicator.BackgroundColor3 = getDetachCueColor()
			mainDropIndicator.Size = UDim2.fromOffset(indicatorW, MERGE_INDICATOR_HEIGHT)
	
			local targetPos = UDim2.fromOffset(indicatorX, indicatorY)
			if mainDropIndicatorTween then
				pcall(function() mainDropIndicatorTween:Cancel() end)
				mainDropIndicatorTween = nil
			end
			local tween = self.Animation:Create(mainDropIndicator, TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), { Position = targetPos })
			mainDropIndicatorTween = tween
			tween.Completed:Connect(function()
				if mainDropIndicatorTween == tween then
					mainDropIndicatorTween = nil
				end
			end)
			tween:Play()
		end
	
		clearMergePreview = function(instant)
			local previous = mergePreviewRecord
			mergePreviewRecord = nil
			lastMergeInsertIndex = nil
			clearMergeIndicator(instant)
			clearMainDropPreview(instant)
	
			if not previous or not previous.stroke or not previous.stroke.Parent then
				return
			end
	
			local targetThickness = 1.5
			local targetColor = self.getSelectedTheme().ElementStroke
			if instant then
				previous.stroke.Thickness = targetThickness
				previous.stroke.Color = targetColor
				return
			end
	
			self.Animation:Create(previous.stroke, TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
				Thickness = targetThickness,
				Color = targetColor
			}):Play()
		end
	
		local function updateMergePreview(point)
			if not dragArmed or not point then
				clearMergePreview(false)
				return
			end
	
			-- Throttle: cap at ~20 updates/sec to avoid per-pixel recalculation
			local now = os.clock()
			if now - lastMergeUpdateTime < MERGE_UPDATE_INTERVAL then
				return
			end
			lastMergeUpdateTime = now
	
			local excludeRecord = detached and windowRecord or nil
			local targetRecord = findMergeTargetWindow(point, excludeRecord)
			if targetRecord ~= mergePreviewRecord then
				local previous = mergePreviewRecord
				mergePreviewRecord = nil
				lastMergeInsertIndex = nil
	
				if previous and previous.stroke and previous.stroke.Parent then
					self.Animation:Create(previous.stroke, TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
						Thickness = 1.5,
						Color = self.getSelectedTheme().ElementStroke
					}):Play()
				end
	
				if targetRecord and targetRecord.stroke and targetRecord.stroke.Parent then
					mergePreviewRecord = targetRecord
					self.Animation:Create(targetRecord.stroke, TweenInfo.new(0.08, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
						Thickness = 2.35,
						Color = self.getSelectedTheme().SliderProgress or self.getSelectedTheme().TextColor
					}):Play()
				end
			end
	
			if targetRecord then
				clearMainDropPreview(false)
				local insertIndex, ordered = calculateRecordInsertIndex(targetRecord, point)
				lastMergeInsertIndex = insertIndex
				ensureMergeIndicator(targetRecord, insertIndex, ordered)
			elseif isInsideMain(point) and (detached or isGuiActiveInCurrentPage(guiObject)) then
				clearMergeIndicator(false)
				lastMergeInsertIndex = nil
				showMainDropPreview(point)
			else
				clearMergeIndicator(false)
				clearMainDropPreview(false)
				lastMergeInsertIndex = nil
			end
		end
	
		local function getWindowElementCount(record)
			if not (record and record.elements) then
				return 0
			end
			local count = 0
			for _ in pairs(record.elements) do
				count += 1
			end
			return count
		end
	
		local function updateWindowRecordLayout(record)
			if not (record and record.frame and record.frame.Parent) then
				return
			end
	
			local count = getWindowElementCount(record)
			if count <= 0 then
				return
			end
	
			local contentHeight = ((record.layout and record.layout.AbsoluteContentSize.Y) or 0) + 8
			local windowHeight = math.max(contentHeight + DETACH_HEADER_HEIGHT + 12, DETACH_MIN_HEIGHT)
			record.frame.Size = UDim2.fromOffset(record.width or DETACH_MIN_WIDTH, windowHeight)
			record.content.Size = UDim2.new(1, -10, 1, -(DETACH_HEADER_HEIGHT + 10))
	
			if record.titleLabel then
				if count == 1 then
					for _, entry in pairs(record.elements) do
						record.titleLabel.Text = tostring(entry.name or elementName)
						break
					end
				else
					record.titleLabel.Text = string.format("Merged (%d)", count)
				end
			end
	
			if record.dockButton then
				if count > 1 then
					record.dockButton.Size = UDim2.fromOffset(64, 20)
					record.dockButton.Position = UDim2.new(1, -70, 0.5, -10)
					record.dockButton.Text = "DockAll"
				else
					record.dockButton.Size = UDim2.fromOffset(48, 20)
					record.dockButton.Position = UDim2.new(1, -54, 0.5, -10)
					record.dockButton.Text = "Dock"
				end
			end
		end
	
		local function destroyWindowRecord(record)
			if not record then
				return
			end
	
			if record.dragCleanup then
				record.dragCleanup()
				record.dragCleanup = nil
			end
	
			if record.connections then
				for _, connection in ipairs(record.connections) do
					if connection then
						connection:Disconnect()
					end
				end
				table.clear(record.connections)
			end
	
			unregisterDetachedWindow(record)
	
			if record.frame then
				record.frame:Destroy()
			end
	
			if windowRecord == record then
				windowRecord = nil
			end
		end
	
		local function cleanupFloatingWindow()
			if floatingDragCleanup then
				floatingDragCleanup()
				floatingDragCleanup = nil
			end
	
			cleanupWindowConnections()
	
			local record = windowRecord
			if record and record.elements then
				record.elements[detacherId] = nil
				if getWindowElementCount(record) <= 0 then
					destroyWindowRecord(record)
				else
					updateWindowRecordLayout(record)
				end
			end
	
			windowRecord = nil
			destroyDetachedPlaceholder()
			floatingWindow = nil
			floatingContent = nil
			floatingWindowWidth = nil
			floatingTitleBar = nil
			floatingStroke = nil
			floatingTitleLabel = nil
			floatingDockButton = nil
		end
	
		local dockBack
		local dockBackToPosition
		local moveToWindowRecord
		local moveDetachedAt

		reorderInMainAt = function(point, requestedInsertIndex)
			if detached then
				return false
			end
			if not (guiObject and guiObject.Parent) then
				return false
			end

			local currentTabPage = self.Elements.UIPageLayout.CurrentPage
			if not currentTabPage or currentTabPage ~= guiObject.Parent then
				return false
			end
			if not parentUsesLayoutOrder(currentTabPage) then
				return false
			end

			local ordered = getOrderedMainDockChildren(currentTabPage, guiObject)
			local insertIndex = tonumber(requestedInsertIndex)
			if type(insertIndex) == "number" then
				insertIndex = math.floor(insertIndex)
			else
				insertIndex = nil
			end
			if type(insertIndex) ~= "number" then
				local calculated
				calculated, ordered = calculateMainInsertIndex(currentTabPage, point, guiObject)
				insertIndex = calculated
			end
			if type(insertIndex) ~= "number" then
				return false
			end

			insertIndex = math.clamp(insertIndex, 1, #ordered + 1)
			table.insert(ordered, insertIndex, guiObject)
			normalizeOrderedGuiLayout(ordered)

			local latestState = captureCurrentElementState()
			rememberedState = {
				Parent = latestState.Parent,
				AnchorPoint = latestState.AnchorPoint,
				Position = latestState.Position,
				Size = latestState.Size,
				LayoutOrder = latestState.LayoutOrder,
				SiblingIndex = latestState.SiblingIndex,
				PreviousSibling = latestState.PreviousSibling,
				NextSibling = latestState.NextSibling
			}
			resyncElement("reorder_main")
			return true
		end
	
		local function reorderElementInRecord(record, requestedInsertIndex)
			if not (record and record.content and record.content.Parent) then
				return false
			end
	
			local ordered = getOrderedGuiChildren(record.content)
			local currentIndex = nil
			for index, child in ipairs(ordered) do
				if child == guiObject then
					currentIndex = index
					break
				end
			end
			if not currentIndex then
				return false
			end
	
			local insertIndex = tonumber(requestedInsertIndex)
			if type(insertIndex) == "number" then
				insertIndex = math.floor(insertIndex)
			else
				insertIndex = currentIndex
			end
	
			table.remove(ordered, currentIndex)
			insertIndex = math.clamp(insertIndex, 1, #ordered + 1)
			table.insert(ordered, insertIndex, guiObject)
			normalizeOrderedGuiLayout(ordered)
			record.nextOrder = (#ordered + 1) * 10
			updateWindowRecordLayout(record)
			resyncElement("reorder_detached")
			return true
		end
	
		local function attachToWindowRecord(record, requestedInsertIndex)
			if not (record and record.content and record.content.Parent) then
				return false
			end
	
			windowRecord = record
			floatingWindow = record.frame
			floatingContent = record.content
			floatingWindowWidth = record.width
			floatingTitleBar = record.titleBar
			floatingStroke = record.stroke
			floatingTitleLabel = record.titleLabel
			floatingDockButton = record.dockButton
			floatingDragCleanup = nil
	
			local elementHeight = math.max(guiObject.AbsoluteSize.Y, 36)
	
			guiObject.Parent = record.content
			guiObject.AnchorPoint = Vector2.zero
			guiObject.Position = UDim2.new(0, 0, 0, 0)
			guiObject.Size = UDim2.new(1, 0, 0, elementHeight)
	
			local ordered = getOrderedGuiChildren(record.content, guiObject)
			local insertIndex = tonumber(requestedInsertIndex)
			if type(insertIndex) == "number" then
				insertIndex = math.clamp(math.floor(insertIndex), 1, #ordered + 1)
			else
				insertIndex = #ordered + 1
			end
			table.insert(ordered, insertIndex, guiObject)
			normalizeOrderedGuiLayout(ordered)
			record.nextOrder = (#ordered + 1) * 10
	
			record.elements[detacherId] = {
				name = elementName,
				dock = function(skipAnimation)
					return dockBack(skipAnimation)
				end,
				mergeTo = function(targetRecord)
					return moveToWindowRecord(targetRecord)
				end
			}
	
			createDetachedPlaceholder()
	
			cleanupWindowConnections()
			table.insert(windowConnections, guiObject:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
				updateWindowRecordLayout(record)
				updateDetachedPlaceholder()
			end))
	
			detached = true
			updateWindowRecordLayout(record)
			updateDetachedPlaceholder()
			resyncElement("detach_attach")
			return true
		end
	
		moveToWindowRecord = function(targetRecord, requestedInsertIndex)
			if not detached then
				return false
			end
			if not (targetRecord and targetRecord.content and targetRecord.content.Parent) then
				return false
			end
			if targetRecord == windowRecord then
				return reorderElementInRecord(targetRecord, requestedInsertIndex)
			end
	
			local previousRecord = windowRecord
			cleanupWindowConnections()
	
			if previousRecord and previousRecord.elements then
				previousRecord.elements[detacherId] = nil
			end
	
			local attached = attachToWindowRecord(targetRecord, requestedInsertIndex)
			if not attached then
				if previousRecord and previousRecord.content and previousRecord.content.Parent then
					attachToWindowRecord(previousRecord)
				end
				return false
			end
	
			if previousRecord then
				if getWindowElementCount(previousRecord) <= 0 then
					destroyWindowRecord(previousRecord)
				else
					updateWindowRecordLayout(previousRecord)
				end
			end
	
			return true
		end
	
		moveDetachedAt = function(point)
			if not detached then
				return false
			end
	
			local currentRecord = windowRecord
			if not (currentRecord and currentRecord.content and currentRecord.content.Parent) then
				return false
			end
	
			local targetRecord = findMergeTargetWindow(point, currentRecord)
	
			-- Float → Float: merge into another floating window (takes priority over self.Main)
			if targetRecord then
				local targetInsertIndex = nil
				if mergeIndicatorRecord == targetRecord and lastMergeInsertIndex then
					targetInsertIndex = lastMergeInsertIndex
				end
				if type(targetInsertIndex) ~= "number" then
					targetInsertIndex = calculateRecordInsertIndex(targetRecord, point)
				end
				return moveToWindowRecord(targetRecord, targetInsertIndex)
			end
	
			-- Float → self.Main: dock back to a specific position in the self.Main UI
			if isInsideMain(point) then
				local targetInsertIndex = lastMainDropInsertIndex
				local targetState = originalState or rememberedState
				if type(targetInsertIndex) ~= "number" then
					local currentTabPage = self.Elements.UIPageLayout.CurrentPage
					if targetState and targetState.Parent and currentTabPage == targetState.Parent then
						targetInsertIndex = calculateMainInsertIndex(currentTabPage, point)
					end
				end
				if type(targetInsertIndex) == "number" then
					return dockBackToPosition(targetInsertIndex)
				end
				return dockBack()
			end
	
			-- Float → same window: reorder within current window
			if not isPointNearFrame(point, currentRecord.frame, DETACH_MERGE_DETECT_PADDING) then
				return false
			end
			local targetInsertIndex = nil
			if mergeIndicatorRecord == currentRecord and lastMergeInsertIndex then
				targetInsertIndex = lastMergeInsertIndex
			end
			if type(targetInsertIndex) ~= "number" then
				targetInsertIndex = calculateRecordInsertIndex(currentRecord, point)
			end
	
			return moveToWindowRecord(currentRecord, targetInsertIndex)
		end
	
		local function createWindowRecord(point, windowWidth, windowHeight)
			local layer = ensureDetachedLayer()
			local desiredPosition = Vector2.new(point.X - (windowWidth / 2), point.Y - (DETACH_HEADER_HEIGHT / 2))
			local clampedPosition = clampDetachedPosition(desiredPosition, Vector2.new(windowWidth, windowHeight))
			local finalPosition = Vector2.new(clampedPosition.X, clampedPosition.Y)
	
			local startSize = Vector2.new(
				math.max(math.floor(windowWidth * 0.92), 140),
				math.max(math.floor(windowHeight * 0.9), 70)
			)
			local startPosition = Vector2.new(
				finalPosition.X + math.floor((windowWidth - startSize.X) / 2),
				finalPosition.Y + 8
			)
	
			local record = {
				id = self.HttpService:GenerateGUID(false),
				frame = nil,
				titleBar = nil,
				content = nil,
				layout = nil,
				stroke = nil,
				titleLabel = nil,
				dockButton = nil,
				width = windowWidth,
				elements = {},
				nextOrder = 1,
				connections = {},
				dragCleanup = nil
			}
	
			record.frame = Instance.new("Frame")
			record.frame.Name = "Detached-" .. guiObject.Name
			record.frame.Size = UDim2.fromOffset(startSize.X, startSize.Y)
			record.frame.Position = UDim2.fromOffset(startPosition.X, startPosition.Y)
			record.frame.BackgroundColor3 = self.getSelectedTheme().SecondaryElementBackground
			record.frame.BackgroundTransparency = 1
			record.frame.BorderSizePixel = 0
			record.frame.ZIndex = 200
			record.frame.Parent = layer
	
			local floatingCorner = Instance.new("UICorner")
			floatingCorner.CornerRadius = UDim.new(0, 9)
			floatingCorner.Parent = record.frame
	
			record.stroke = Instance.new("UIStroke")
			record.stroke.Color = self.getSelectedTheme().ElementStroke
			record.stroke.Thickness = 1.5
			record.stroke.Transparency = 1
			record.stroke.Parent = record.frame
	
			record.titleBar = Instance.new("Frame")
			record.titleBar.Name = "TitleBar"
			record.titleBar.Size = UDim2.new(1, 0, 0, DETACH_HEADER_HEIGHT)
			record.titleBar.BackgroundColor3 = self.getSelectedTheme().ElementBackground
			record.titleBar.BackgroundTransparency = 1
			record.titleBar.BorderSizePixel = 0
			record.titleBar.ZIndex = 201
			record.titleBar.Parent = record.frame
	
			record.titleLabel = Instance.new("TextLabel")
			record.titleLabel.Name = "Title"
			record.titleLabel.BackgroundTransparency = 1
			record.titleLabel.Size = UDim2.new(1, -72, 1, 0)
			record.titleLabel.Position = UDim2.new(0, 10, 0, 0)
			record.titleLabel.Text = tostring(elementName)
			record.titleLabel.TextColor3 = self.getSelectedTheme().TextColor
			record.titleLabel.TextSize = 12
			record.titleLabel.TextTransparency = 1
			record.titleLabel.Font = Enum.Font.GothamSemibold
			record.titleLabel.TextXAlignment = Enum.TextXAlignment.Left
			record.titleLabel.ZIndex = 202
			record.titleLabel.Parent = record.titleBar
	
			record.dockButton = Instance.new("TextButton")
			record.dockButton.Name = "DockButton"
			record.dockButton.Size = UDim2.fromOffset(48, 20)
			record.dockButton.Position = UDim2.new(1, -54, 0.5, -10)
			record.dockButton.BackgroundColor3 = self.getSelectedTheme().ElementBackgroundHover
			record.dockButton.BackgroundTransparency = 1
			record.dockButton.BorderSizePixel = 0
			record.dockButton.Text = "Dock"
			record.dockButton.TextColor3 = self.getSelectedTheme().TextColor
			record.dockButton.TextSize = 10
			record.dockButton.TextTransparency = 1
			record.dockButton.Font = Enum.Font.GothamBold
			record.dockButton.ZIndex = 202
			record.dockButton.Parent = record.titleBar
	
			local dockCorner = Instance.new("UICorner")
			dockCorner.CornerRadius = UDim.new(0, 6)
			dockCorner.Parent = record.dockButton
	
			record.content = Instance.new("Frame")
			record.content.Name = "Content"
			record.content.BackgroundTransparency = 1
			record.content.BorderSizePixel = 0
			record.content.Size = UDim2.new(1, -10, 1, -(DETACH_HEADER_HEIGHT + 10))
			record.content.Position = UDim2.fromOffset(5, DETACH_HEADER_HEIGHT + 5)
			record.content.ClipsDescendants = true
			record.content.ZIndex = 201
			record.content.Parent = record.frame
	
			record.layout = Instance.new("UIListLayout")
			record.layout.Padding = UDim.new(0, 6)
			record.layout.SortOrder = Enum.SortOrder.LayoutOrder
			record.layout.Parent = record.content
	
			record.dragCleanup = makeFloatingDraggable(record.frame, record.titleBar, function(releasePoint)
				if not (record.frame and record.frame.Parent) then
					return
				end
	
				local point = releasePoint
				if not point then
					local absPos = record.frame.AbsolutePosition
					local absSize = record.frame.AbsoluteSize
					point = Vector2.new(absPos.X + (absSize.X * 0.5), absPos.Y + (absSize.Y * 0.5))
				end
	
				local targetRecord = findMergeTargetWindow(point, record)
				if not targetRecord then
					return
				end
	
				local mergeHandlers = {}
				for _, entry in pairs(record.elements) do
					if entry and entry.mergeTo then
						table.insert(mergeHandlers, entry.mergeTo)
					end
				end
	
				for _, mergeFn in ipairs(mergeHandlers) do
					pcall(function()
						mergeFn(targetRecord)
					end)
				end
			end)
	
			table.insert(record.connections, record.dockButton.MouseButton1Click:Connect(function()
				local docks = {}
				for _, entry in pairs(record.elements) do
					if entry and entry.dock then
						table.insert(docks, entry.dock)
					end
				end
				for _, dockFn in ipairs(docks) do
					pcall(function()
						dockFn(true)
					end)
				end
			end))
	
			registerDetachedWindow(record)
	
			self.Animation:Create(record.frame, TweenInfo.new(DETACH_POP_IN_DURATION, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
				Size = UDim2.fromOffset(windowWidth, windowHeight),
				Position = UDim2.fromOffset(finalPosition.X, finalPosition.Y),
				BackgroundTransparency = 0
			}):Play()
			self.Animation:Create(record.stroke, TweenInfo.new(DETACH_POP_IN_DURATION * 0.85, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Transparency = 0}):Play()
			self.Animation:Create(record.titleBar, TweenInfo.new(DETACH_POP_IN_DURATION * 0.85, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundTransparency = 0}):Play()
			self.Animation:Create(record.titleLabel, TweenInfo.new(DETACH_POP_IN_DURATION * 0.85, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {TextTransparency = 0}):Play()
			self.Animation:Create(record.dockButton, TweenInfo.new(DETACH_POP_IN_DURATION * 0.85, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
				BackgroundTransparency = 0,
				TextTransparency = 0
			}):Play()
	
			return record
		end
	
		dockBack = function(skipWindowAnimation)
			if not detached then
				return false
			end
	
			local targetState = originalState or rememberedState
			local targetParent = targetState and targetState.Parent
			if not targetParent or not targetParent.Parent then
				cleanupFloatingWindow()
				detached = false
				originalState = nil
				return false
			end
	
			local record = windowRecord
			local recordCountBefore = getWindowElementCount(record)
			local shouldCollapse = (not skipWindowAnimation) and record and record.frame and record.frame.Parent and recordCountBefore <= 1
	
			if shouldCollapse then
				local collapseWidth = math.max(math.floor(record.frame.Size.X.Offset * 0.94), 120)
				local collapseHeight = math.max(math.floor(record.frame.Size.Y.Offset * 0.92), 70)
				self.Animation:Create(record.frame, TweenInfo.new(DETACH_POP_OUT_DURATION, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
					BackgroundTransparency = 1,
					Size = UDim2.fromOffset(collapseWidth, collapseHeight)
				}):Play()
				if record.stroke then
					self.Animation:Create(record.stroke, TweenInfo.new(DETACH_POP_OUT_DURATION, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {Transparency = 1}):Play()
				end
				if record.titleBar then
					self.Animation:Create(record.titleBar, TweenInfo.new(DETACH_POP_OUT_DURATION, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {BackgroundTransparency = 1}):Play()
				end
				if record.titleLabel then
					self.Animation:Create(record.titleLabel, TweenInfo.new(DETACH_POP_OUT_DURATION, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {TextTransparency = 1}):Play()
				end
				if record.dockButton then
					self.Animation:Create(record.dockButton, TweenInfo.new(DETACH_POP_OUT_DURATION, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
						BackgroundTransparency = 1,
						TextTransparency = 1
					}):Play()
				end
				task.wait(DETACH_POP_OUT_DURATION)
			end
	
			local placeholder = detachedPlaceholder
			guiObject.Parent = targetParent
			guiObject.AnchorPoint = targetState.AnchorPoint
			guiObject.Position = targetState.Position
			guiObject.Size = targetState.Size
	
			if parentUsesLayoutOrder(targetParent) then
				local ordered = getOrderedGuiChildren(targetParent, guiObject, placeholder)
				local slotIndex = nil
	
				if placeholder and placeholder.Parent == targetParent then
					slotIndex = placeholder:GetAttribute("DetachSlotIndex")
				end
				if type(slotIndex) ~= "number" then
					slotIndex = resolveInsertIndexFromState(targetParent, targetState, ordered)
				end
	
				if type(slotIndex) == "number" then
					slotIndex = math.clamp(slotIndex, 1, #ordered + 1)
					table.insert(ordered, slotIndex, guiObject)
					normalizeOrderedGuiLayout(ordered)
				else
					guiObject.LayoutOrder = targetState.LayoutOrder
				end
			else
				guiObject.LayoutOrder = targetState.LayoutOrder
			end
	
			destroyDetachedPlaceholder()
	
			if record and record.elements then
				record.elements[detacherId] = nil
				if getWindowElementCount(record) <= 0 then
					destroyWindowRecord(record)
				else
					updateWindowRecordLayout(record)
				end
			end
	
			windowRecord = nil
			floatingWindow = nil
			floatingContent = nil
			floatingWindowWidth = nil
			floatingTitleBar = nil
			floatingStroke = nil
			floatingTitleLabel = nil
			floatingDockButton = nil
			cleanupWindowConnections()
	
			detached = false
			originalState = nil
			hoverCounter = 0
			hoverActive = false
			refreshDetachCue()
			resyncElement("dock_back")
			return true
		end
	
		dockBackToPosition = function(insertIndex)
			if not detached then
				return false
			end
	
			local targetState = originalState or rememberedState
			if not targetState then
				return dockBack()
			end
	
			local currentTabPage = self.Elements.UIPageLayout.CurrentPage
			if not (currentTabPage and currentTabPage.Parent) then
				return dockBack()
			end
	
			-- Only allow position-aware dock to the original parent tab page
			local targetParent = targetState.Parent
			if targetParent ~= currentTabPage then
				return dockBack()
			end
	
			local record = windowRecord
			local recordCountBefore = getWindowElementCount(record)
			local shouldCollapse = record and record.frame and record.frame.Parent and recordCountBefore <= 1
	
			if shouldCollapse then
				local collapseWidth = math.max(math.floor(record.frame.Size.X.Offset * 0.94), 120)
				local collapseHeight = math.max(math.floor(record.frame.Size.Y.Offset * 0.92), 70)
				self.Animation:Create(record.frame, TweenInfo.new(DETACH_POP_OUT_DURATION, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
					BackgroundTransparency = 1,
					Size = UDim2.fromOffset(collapseWidth, collapseHeight)
				}):Play()
				if record.stroke then
					self.Animation:Create(record.stroke, TweenInfo.new(DETACH_POP_OUT_DURATION, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {Transparency = 1}):Play()
				end
				if record.titleBar then
					self.Animation:Create(record.titleBar, TweenInfo.new(DETACH_POP_OUT_DURATION, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {BackgroundTransparency = 1}):Play()
				end
				if record.titleLabel then
					self.Animation:Create(record.titleLabel, TweenInfo.new(DETACH_POP_OUT_DURATION, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {TextTransparency = 1}):Play()
				end
				if record.dockButton then
					self.Animation:Create(record.dockButton, TweenInfo.new(DETACH_POP_OUT_DURATION, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
						BackgroundTransparency = 1,
						TextTransparency = 1
					}):Play()
				end
				task.wait(DETACH_POP_OUT_DURATION)
			end
	
			local placeholder = detachedPlaceholder
			guiObject.Parent = targetParent
			guiObject.AnchorPoint = targetState.AnchorPoint
			guiObject.Position = targetState.Position
			guiObject.Size = targetState.Size
	
			if parentUsesLayoutOrder(targetParent) then
				local ordered
				if targetParent == currentTabPage then
					ordered = getOrderedMainDockChildren(targetParent, guiObject, placeholder)
				else
					ordered = getOrderedGuiChildren(targetParent, guiObject, placeholder)
				end
				local clampedIndex = math.clamp(insertIndex, 1, #ordered + 1)
				table.insert(ordered, clampedIndex, guiObject)
				normalizeOrderedGuiLayout(ordered)
			else
				guiObject.LayoutOrder = targetState.LayoutOrder
			end
	
			destroyDetachedPlaceholder()
	
			if record and record.elements then
				record.elements[detacherId] = nil
				if getWindowElementCount(record) <= 0 then
					destroyWindowRecord(record)
				else
					updateWindowRecordLayout(record)
				end
			end
	
			windowRecord = nil
			floatingWindow = nil
			floatingContent = nil
			floatingWindowWidth = nil
			floatingTitleBar = nil
			floatingStroke = nil
			floatingTitleLabel = nil
			floatingDockButton = nil
			cleanupWindowConnections()
	
			detached = false
			originalState = nil
			hoverCounter = 0
			hoverActive = false
			refreshDetachCue()
			resyncElement("dock_back_to_position")
			return true
		end
	
		local function detachAt(point)
			if detached or not guiObject.Parent then
				return false
			end
	
			originalState = captureCurrentElementState()
			rememberedState = {
				Parent = originalState.Parent,
				AnchorPoint = originalState.AnchorPoint,
				Position = originalState.Position,
				Size = originalState.Size,
				LayoutOrder = originalState.LayoutOrder,
				SiblingIndex = originalState.SiblingIndex,
				PreviousSibling = originalState.PreviousSibling,
				NextSibling = originalState.NextSibling
			}
	
			if not originalState.Parent then
				return false
			end
	
			local elementHeight = math.max(guiObject.AbsoluteSize.Y, 36)
			local windowWidth = math.max(guiObject.AbsoluteSize.X + 20, DETACH_MIN_WIDTH)
			local windowHeight = math.max(elementHeight + DETACH_HEADER_HEIGHT + 12, DETACH_MIN_HEIGHT)
	
			local targetRecord = findMergeTargetWindow(point, nil)
			local targetInsertIndex = nil
			if targetRecord then
				if mergeIndicatorRecord == targetRecord and lastMergeInsertIndex then
					targetInsertIndex = lastMergeInsertIndex
				end
				if type(targetInsertIndex) ~= "number" then
					targetInsertIndex = calculateRecordInsertIndex(targetRecord, point)
				end
			end
			if not targetRecord then
				targetRecord = createWindowRecord(point, windowWidth, windowHeight)
			end
			if not targetRecord then
				return false
			end
	
			local attached = attachToWindowRecord(targetRecord, targetInsertIndex)
			if not attached then
				return false
			end
	
			if targetRecord.stroke then
				local baseThickness = targetRecord.stroke.Thickness
				targetRecord.stroke.Thickness = baseThickness + 0.9
				self.Animation:Create(targetRecord.stroke, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
					Thickness = baseThickness
				}):Play()
			end

			refreshDetachCue()
			resyncElement("detach")
			return true
		end
	
		local function handleDetachHoverEnter()
			if detached then
				return
			end
			hoverCounter = 1
			hoverActive = true
			syncCueHoverFromPointer(self.UserInputService:GetMouseLocation(), true)
		end
	
		local function handleDetachHoverLeave()
			hoverCounter = 0
			hoverActive = false
			syncCueHoverFromPointer(self.UserInputService:GetMouseLocation(), true)
		end
	
		local function handleDetachInputBegan(input)
			local inputType = input.UserInputType
			if inputType ~= Enum.UserInputType.MouseButton1 and inputType ~= Enum.UserInputType.Touch then
				return
			end
			if elementType == "Input" and self.UserInputService:GetFocusedTextBox() then
				return
			end
			if pressing or dragArmed then
				return
			end
	
			ensureDetachCue()
			pressing = true
			pressInput = input
			pressToken += 1
			dragArmed = false
			pointerPosition = getInputPosition(input)
			local token = pressToken
			refreshDetachCue()
			task.spawn(runHoldCueProgress, token)
	
			task.delay(adaptiveHoldDuration, function()
				if pressToken ~= token or not pressing then
					return
				end
				dragArmed = true
				refreshDetachCue()
				createDragGhost()
			end)
		end
	
		for _, source in ipairs(dragInputSources) do
			table.insert(eventConnections, source.MouseEnter:Connect(handleDetachHoverEnter))
			table.insert(eventConnections, source.MouseLeave:Connect(handleDetachHoverLeave))
			table.insert(eventConnections, source.InputBegan:Connect(handleDetachInputBegan))
		end

		local currentPageSignal = self.Elements and self.Elements.UIPageLayout and self.Elements.UIPageLayout:GetPropertyChangedSignal("CurrentPage")
		if currentPageSignal then
			table.insert(eventConnections, currentPageSignal:Connect(function()
				local pointer = self.UserInputService:GetMouseLocation()
				syncCueHoverFromPointer(pointer, true)
				if pressing and not isGuiActiveInCurrentPage(guiObject) then
					resetDragState("page_changed")
				end
			end))
		end

		table.insert(eventConnections, guiObject:GetPropertyChangedSignal("Visible"):Connect(function()
			syncCueHoverFromPointer(self.UserInputService:GetMouseLocation(), true)
		end))
	
		-- Use shared global dispatcher instead of per-element InputChanged/InputEnded
		registerSharedInput(detacherId, function(input) -- InputChanged
			if input.UserInputType == Enum.UserInputType.MouseMovement then
				pointerPosition = getInputPosition(input)
				if not pressing then
					syncCueHoverFromPointer(pointerPosition, false)
				end
			end

			if not pressing or not pressInput then
				return
			end
	
			local matchesTouch = input == pressInput
			local matchesMouse = pressInput.UserInputType == Enum.UserInputType.MouseButton1 and input.UserInputType == Enum.UserInputType.MouseMovement
			if not matchesTouch and not matchesMouse then
				return
			end
	
			pointerPosition = getInputPosition(input)
			if dragArmed then
				updateGhostPosition()
				updateMergePreview(pointerPosition)
			end
		end, function(input) -- InputEnded
			if not pressInput then
				return
			end
	
			local sameTouch = input == pressInput
			local mouseEnded = pressInput.UserInputType == Enum.UserInputType.MouseButton1 and input.UserInputType == Enum.UserInputType.MouseButton1
			if not sameTouch and not mouseEnded then
				return
			end
	
			pressing = false
			pressInput = nil
			pressToken += 1
	
			-- Snapshot cached insert indices before clearMergePreview wipes them
			local cachedMainDropIndex = lastMainDropInsertIndex
			local cachedMergeInsertIndex = lastMergeInsertIndex
			clearMergePreview(false)
	
			local dropPoint = pointerPosition or self.UserInputService:GetMouseLocation()
			if dragArmed then
				dragArmed = false
				destroyDragGhost()
				if detached then
					if dropPoint then
						-- Restore cached index so moveDetachedAt can use the indicator's value
						lastMainDropInsertIndex = cachedMainDropIndex
						lastMergeInsertIndex = cachedMergeInsertIndex
						if not moveDetachedAt(dropPoint) then
							refreshDetachCue()
						end
						lastMainDropInsertIndex = nil
						lastMergeInsertIndex = nil
					else
						refreshDetachCue()
					end
				else
					local hasMergeTarget = dropPoint and findMergeTargetWindow(dropPoint, nil) ~= nil
					local canReorderInMain = dropPoint and isInsideMain(dropPoint) and isGuiActiveInCurrentPage(guiObject)
					if canReorderInMain then
						lastMainDropInsertIndex = cachedMainDropIndex
						local reordered = reorderInMainAt(dropPoint, lastMainDropInsertIndex)
						lastMainDropInsertIndex = nil
						if not reordered then
							if dropPoint and (isOutsideMain(dropPoint) or hasMergeTarget) then
								if not detachAt(dropPoint) then
									refreshDetachCue()
								end
							else
								refreshDetachCue()
							end
						else
							syncCueHoverFromPointer(dropPoint, true)
						end
					elseif dropPoint and (isOutsideMain(dropPoint) or hasMergeTarget) then
						if not detachAt(dropPoint) then
							refreshDetachCue()
						end
					else
						refreshDetachCue()
					end
				end
			else
				destroyDragGhost()
				refreshDetachCue()
			end
		end)
	
		local function fullCleanup()
			unregisterSharedInput(detacherId)
			destroyDragGhost(true)
			cleanupFloatingWindow()
			cleanupDetachCue()
			for _, connection in ipairs(eventConnections) do
				if connection then
					connection:Disconnect()
				end
			end
			table.clear(eventConnections)
		end
	
		local function connectIfAvailable(signalName, callback)
			local ok, signal = pcall(function()
				return guiObject[signalName]
			end)
			if ok and signal and signal.Connect then
				table.insert(eventConnections, signal:Connect(callback))
			end
		end

		-- Cleanup when guiObject is destroyed
		connectIfAvailable("Destroying", fullCleanup)
	
		-- Safety net: cleanup if element leaves the DataModel without being destroyed
		-- (e.g. parent set to nil, or ancestor removed)
		connectIfAvailable("AncestryChanged", function()
			if not guiObject:IsDescendantOf(game) then
				task.defer(function()
					-- Re-check after defer in case of rapid reparent
					if not guiObject:IsDescendantOf(game) then
						fullCleanup()
					end
				end)
			else
				task.defer(function()
					if guiObject and guiObject.Parent then
						syncCueHoverFromPointer(self.UserInputService:GetMouseLocation(), true)
						if pressing and not isGuiActiveInCurrentPage(guiObject) then
							resetDragState("reparent")
						end
					end
				end)
			end
		end)

		task.defer(function()
			if guiObject and guiObject.Parent then
				syncCueHoverFromPointer(self.UserInputService:GetMouseLocation(), true)
			end
		end)
	
		return {
			Detach = function(position)
				local pos = position or self.UserInputService:GetMouseLocation()
				return detachAt(pos)
			end,
			Dock = function()
				return dockBack()
			end,
			GetRememberedState = function()
				if not rememberedState then
					return nil
				end
				return {
					Parent = rememberedState.Parent,
					AnchorPoint = rememberedState.AnchorPoint,
					Position = rememberedState.Position,
					Size = rememberedState.Size,
					LayoutOrder = rememberedState.LayoutOrder,
					SiblingIndex = rememberedState.SiblingIndex,
					PreviousSibling = rememberedState.PreviousSibling,
					NextSibling = rememberedState.NextSibling
				}
			end,
			IsDetached = function()
				return detached
			end,
			Destroy = fullCleanup
		}
	end

	-- Export main function
	self.makeElementDetachable = createElementDetacher
	
	return self
end

return DragModule
]])
put("src/feature/drag/detach-gesture.lua", [[local DetachGesture = {}

function DetachGesture.shouldStartHold(startTick, nowTick, holdDuration)
	holdDuration = holdDuration or 3
	return (nowTick - startTick) >= holdDuration
end

function DetachGesture.isDragThresholdExceeded(startPosition, currentPosition, threshold)
	threshold = threshold or 4
	if not startPosition or not currentPosition then
		return false
	end
	return (currentPosition - startPosition).Magnitude >= threshold
end

return DetachGesture]])
put("src/feature/drag/dock.lua", [[local DragDock = {}

local function getOrderedGuiChildren(parent, excludeA, excludeB)
	if not parent then
		return {}
	end

	local rawChildren = parent:GetChildren()
	local insertionOrder = {}
	for index, child in ipairs(rawChildren) do
		insertionOrder[child] = index
	end

	local ordered = {}
	for _, child in ipairs(rawChildren) do
		if child:IsA("GuiObject") and child ~= excludeA and child ~= excludeB then
			table.insert(ordered, child)
		end
	end

	table.sort(ordered, function(a, b)
		if a.LayoutOrder ~= b.LayoutOrder then
			return a.LayoutOrder < b.LayoutOrder
		end
		return (insertionOrder[a] or 0) < (insertionOrder[b] or 0)
	end)

	return ordered
end

local function normalizeOrderedGuiLayout(ordered)
	for index, child in ipairs(ordered) do
		child.LayoutOrder = index * 10
	end
end

local function parentUsesLayoutOrder(parent)
	if not parent then
		return false
	end
	local listLayout = parent:FindFirstChildOfClass("UIListLayout")
	if not listLayout then
		return false
	end
	if listLayout.SortOrder ~= Enum.SortOrder.LayoutOrder then
		listLayout.SortOrder = Enum.SortOrder.LayoutOrder
	end
	return true
end

local function resolveInsertIndexFromState(parent, state, ordered)
	if not (parent and state) then
		return nil
	end

	local candidates = ordered or getOrderedGuiChildren(parent)

	if state.NextSibling and state.NextSibling.Parent == parent then
		for index, child in ipairs(candidates) do
			if child == state.NextSibling then
				return index
			end
		end
	end

	if state.PreviousSibling and state.PreviousSibling.Parent == parent then
		for index, child in ipairs(candidates) do
			if child == state.PreviousSibling then
				return index + 1
			end
		end
	end

	if type(state.SiblingIndex) == "number" then
		return math.floor(state.SiblingIndex)
	end

	return nil
end

function DragDock.create()
	return {
		getOrderedGuiChildren = getOrderedGuiChildren,
		normalizeOrderedGuiLayout = normalizeOrderedGuiLayout,
		parentUsesLayoutOrder = parentUsesLayoutOrder,
		resolveInsertIndexFromState = resolveInsertIndexFromState
	}
end

return DragDock
]])
put("src/feature/drag/init.lua", [[local client = _G and _G.__RayfieldApiClient
if not client then
	error("Rayfield ApiClient is not initialized")
end

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
return client.fetchAndExecute(root .. "src/feature/drag/controller.lua")]])
put("src/feature/drag/input.lua", [[local DragInput = {}

function DragInput.create(UserInputService)
	local sharedInputChanged = {}
	local sharedInputEnded = {}
	local sharedInputConnections = nil

	local function ensureSharedInputConnections()
		if sharedInputConnections then
			return
		end
		sharedInputConnections = {
			UserInputService.InputChanged:Connect(function(input)
				for _, cb in pairs(sharedInputChanged) do
					cb(input)
				end
			end),
			UserInputService.InputEnded:Connect(function(input)
				for _, cb in pairs(sharedInputEnded) do
					cb(input)
				end
			end)
		}
	end

	local function registerSharedInput(id, onChanged, onEnded)
		ensureSharedInputConnections()
		if onChanged then
			sharedInputChanged[id] = onChanged
		end
		if onEnded then
			sharedInputEnded[id] = onEnded
		end
	end

	local function unregisterSharedInput(id)
		sharedInputChanged[id] = nil
		sharedInputEnded[id] = nil
	end

	local function disconnectSharedInput()
		table.clear(sharedInputChanged)
		table.clear(sharedInputEnded)
		if sharedInputConnections then
			for _, connection in ipairs(sharedInputConnections) do
				if connection then
					connection:Disconnect()
				end
			end
			sharedInputConnections = nil
		end
	end

	local function getInputPosition(input)
		if input and input.Position then
			return Vector2.new(input.Position.X, input.Position.Y)
		end
		return UserInputService:GetMouseLocation()
	end

	return {
		ensure = ensureSharedInputConnections,
		register = registerSharedInput,
		unregister = unregisterSharedInput,
		disconnect = disconnectSharedInput,
		getInputPosition = getInputPosition
	}
end

return DragInput
]])
put("src/feature/drag/merge-indicator.lua", [[local MergeIndicator = {}

function MergeIndicator.computeInsertIndex(slotPositions, pointerX)
	local index = #slotPositions + 1
	for i, x in ipairs(slotPositions) do
		if pointerX < x then
			index = i
			break
		end
	end
	return index
end

return MergeIndicator]])
put("src/feature/drag/window.lua", [[local DragWindow = {}

function DragWindow.create(ctx)
	local detachedScreenGui = nil
	local detachedLayer = nil
	local detachedCleanupBound = false
	local detachedWindowsRegistry = {}

	local function getInputPosition(input)
		if type(ctx.getInputPosition) == "function" then
			return ctx.getInputPosition(input)
		end
		if input and input.Position then
			return Vector2.new(input.Position.X, input.Position.Y)
		end
		return ctx.UserInputService:GetMouseLocation()
	end

	local function registerDetachedWindow(record)
		if not record then
			return
		end
		table.insert(detachedWindowsRegistry, record)
	end

	local function unregisterDetachedWindow(record)
		for i = #detachedWindowsRegistry, 1, -1 do
			if detachedWindowsRegistry[i] == record then
				table.remove(detachedWindowsRegistry, i)
				break
			end
		end
	end

	local function isPointNearFrame(point, frame, padding)
		if not (point and frame and frame.Parent) then
			return false
		end

		local pad = padding or 0
		local framePosition = frame.AbsolutePosition
		local frameSize = frame.AbsoluteSize
		local minX = framePosition.X - pad
		local minY = framePosition.Y - pad
		local maxX = framePosition.X + frameSize.X + pad
		local maxY = framePosition.Y + frameSize.Y + pad
		return point.X >= minX and point.X <= maxX and point.Y >= minY and point.Y <= maxY
	end

	local function findMergeTargetWindow(point, excludeRecord)
		for _, record in ipairs(detachedWindowsRegistry) do
			if record ~= excludeRecord and record.frame and record.frame.Parent and isPointNearFrame(point, record.frame, ctx.mergeDetectPadding) then
				return record
			end
		end
		return nil
	end

	local function ensureDetachedLayer()
		if detachedLayer and detachedLayer.Parent then
			return detachedLayer
		end

		if detachedScreenGui and not detachedScreenGui.Parent then
			detachedScreenGui = nil
			detachedLayer = nil
		end

		if not detachedScreenGui then
			local existing = ctx.Rayfield.Parent and ctx.Rayfield.Parent:FindFirstChild("self.Rayfield-DetachedWindows")
			if existing and existing:IsA("ScreenGui") then
				detachedScreenGui = existing
			else
				detachedScreenGui = Instance.new("ScreenGui")
				detachedScreenGui.Name = "self.Rayfield-DetachedWindows"
				detachedScreenGui.ResetOnSpawn = false
				detachedScreenGui.IgnoreGuiInset = ctx.Rayfield.IgnoreGuiInset
				detachedScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
				detachedScreenGui.DisplayOrder = math.max((ctx.Rayfield.DisplayOrder or 100) + 1, 101)
				detachedScreenGui.Parent = ctx.Rayfield.Parent
			end
		end

		detachedLayer = detachedScreenGui:FindFirstChild("WindowLayer")
		if not detachedLayer then
			detachedLayer = Instance.new("Frame")
			detachedLayer.Name = "WindowLayer"
			detachedLayer.BackgroundTransparency = 1
			detachedLayer.BorderSizePixel = 0
			detachedLayer.Size = UDim2.fromScale(1, 1)
			detachedLayer.Parent = detachedScreenGui
		end

		if not detachedCleanupBound then
			detachedCleanupBound = true
			ctx.Rayfield.Destroying:Connect(function()
				if detachedScreenGui then
					detachedScreenGui:Destroy()
					detachedScreenGui = nil
					detachedLayer = nil
				end
				table.clear(detachedWindowsRegistry)
				if type(ctx.onDestroyInput) == "function" then
					ctx.onDestroyInput()
				end
			end)
		end

		return detachedLayer
	end

	local function prewarmDetachedLayer()
		task.defer(function()
			if ctx.rayfieldDestroyed and ctx.rayfieldDestroyed() then
				return
			end
			pcall(ensureDetachedLayer)
		end)
	end

	local function clampDetachedPosition(desiredPosition, windowSize)
		local layer = ensureDetachedLayer()
		local layerSize = layer.AbsoluteSize
		local maxX = math.max(layerSize.X - windowSize.X, 0)
		local maxY = math.max(layerSize.Y - windowSize.Y, 0)
		return Vector2.new(
			math.clamp(desiredPosition.X, 0, maxX),
			math.clamp(desiredPosition.Y, 0, maxY)
		)
	end

	local function isOutsideMain(point)
		local mainPosition = ctx.Main.AbsolutePosition
		local mainSize = ctx.Main.AbsoluteSize
		return point.X < mainPosition.X
			or point.Y < mainPosition.Y
			or point.X > (mainPosition.X + mainSize.X)
			or point.Y > (mainPosition.Y + mainSize.Y)
	end

	local function isInsideMain(point)
		return not isOutsideMain(point)
	end

	local function makeFloatingDraggable(frame, dragHandle, onDragEnd)
		local dragging = false
		local dragInput = nil
		local dragStartPointer = nil
		local dragStartFramePosition = nil
		local targetPosition = Vector2.new(frame.Position.X.Offset, frame.Position.Y.Offset)
		local connections = {}
		local dragId = ctx.HttpService and ctx.HttpService:GenerateGUID(false) or tostring(math.random())

		dragHandle.Active = true

		table.insert(connections, dragHandle.InputBegan:Connect(function(input)
			local inputType = input.UserInputType
			if inputType ~= Enum.UserInputType.MouseButton1 and inputType ~= Enum.UserInputType.Touch then
				return
			end

			dragging = true
			dragInput = input
			dragStartPointer = getInputPosition(input)
			dragStartFramePosition = targetPosition
		end))

		ctx.registerSharedInput(dragId, function(input)
			if not dragging or not dragInput then
				return
			end

			local matchesTouch = input == dragInput
			local matchesMouse = dragInput.UserInputType == Enum.UserInputType.MouseButton1 and input.UserInputType == Enum.UserInputType.MouseMovement
			if not matchesTouch and not matchesMouse then
				return
			end

			local currentPointer = getInputPosition(input)
			local delta = currentPointer - dragStartPointer
			local desired = dragStartFramePosition + delta
			targetPosition = clampDetachedPosition(desired, frame.AbsoluteSize)
		end, function(input)
			if not dragging or not dragInput then
				return
			end

			local mouseEnded = dragInput.UserInputType == Enum.UserInputType.MouseButton1 and input.UserInputType == Enum.UserInputType.MouseButton1
			if input == dragInput or mouseEnded then
				local releasePoint = getInputPosition(input)
				dragging = false
				dragInput = nil
				if typeof(onDragEnd) == "function" then
					task.defer(onDragEnd, releasePoint, frame)
				end
			end
		end)

		table.insert(connections, ctx.RunService.RenderStepped:Connect(function(deltaTime)
			if not dragging then
				targetPosition = Vector2.new(frame.Position.X.Offset, frame.Position.Y.Offset)
				return
			end

			local current = Vector2.new(frame.Position.X.Offset, frame.Position.Y.Offset)
			local alpha = math.clamp(deltaTime * ((ctx.followSpeed or 0.28) * 60), 0, 1)
			local nextPosition = current:Lerp(targetPosition, alpha)
			frame.Position = UDim2.fromOffset(math.floor(nextPosition.X + 0.5), math.floor(nextPosition.Y + 0.5))
		end))

		return function()
			ctx.unregisterSharedInput(dragId)
			for _, connection in ipairs(connections) do
				if connection then
					connection:Disconnect()
				end
			end
			table.clear(connections)
		end
	end

	return {
		registerDetachedWindow = registerDetachedWindow,
		unregisterDetachedWindow = unregisterDetachedWindow,
		isPointNearFrame = isPointNearFrame,
		findMergeTargetWindow = findMergeTargetWindow,
		ensureDetachedLayer = ensureDetachedLayer,
		prewarmDetachedLayer = prewarmDetachedLayer,
		clampDetachedPosition = clampDetachedPosition,
		isOutsideMain = isOutsideMain,
		isInsideMain = isInsideMain,
		makeFloatingDraggable = makeFloatingDraggable
	}
end

return DragWindow
]])
put("src/feature/enhanced/advanced.lua", [=[--[[
	Rayfield Advanced Features - Complete Module

	Tính năng:
	✅ Animation API - Animate bất kỳ property nào
	✅ Drag & Drop - Kéo thả elements (giữ 3 giây)
	✅ Detachable Windows - Tách element thành cửa sổ riêng
	✅ State Persistence - Lưu trạng thái elements
	✅ Performance Monitor - Theo dõi hiệu suất
	✅ Default Templates - Main & Settings tabs mặc định

]]

local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")

local function buildFallbackAnimateFacade()
	local engine = (_G and _G.__RayfieldSharedAnimationEngine) or nil
	if not engine then
		local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
		local okEngineLib, engineLib = pcall(function()
			if _G and _G.__RayfieldApiClient then
				return _G.__RayfieldApiClient.fetchAndExecute(root .. "src/core/animation/engine.lua")
			end
			return nil
		end)
		if okEngineLib and engineLib and type(engineLib.new) == "function" then
			local okEngine, createdEngine = pcall(function()
				return engineLib.new({
					TweenService = TweenService,
					RunService = RunService,
					mode = "raw"
				})
			end)
			if okEngine then
				engine = createdEngine
			end
		end
	end

	if not engine then
		return {
			Create = function(_, guiObject, tweenInfo, goals)
				local creator = TweenService["Create"]
				if type(creator) == "function" then
					return creator(TweenService, guiObject, tweenInfo, goals)
				end
				return nil
			end,
			UI = function()
				return nil
			end,
			Text = function()
				return nil
			end,
			GetEngine = function()
				return nil
			end
		}
	end

	return {
		Create = function(_, guiObject, tweenInfo, goals)
			return engine:Create(guiObject, tweenInfo, goals)
		end,
		UI = function()
			return nil
		end,
		Text = function()
			return nil
		end,
		GetEngine = function()
			return engine
		end
	}
end

local Animation = (_G and _G.__RayfieldSharedAnimateFacade) or buildFallbackAnimateFacade()

local RayfieldAdvanced = {Version = "1.1.0"}

-- ============================================
-- 1. SHARED ANIMATION LAYER
-- ============================================
-- Legacy standalone AnimationAPI bridge removed.
-- Enhanced module now relies on shared `Rayfield.Animate` runtime layer.

-- ============================================
-- 2. STATE PERSISTENCE
-- ============================================

local StatePersistence = {}
StatePersistence.__index = StatePersistence

function StatePersistence.new(configFolder)
	local self = setmetatable({}, StatePersistence)
	self.configFolder = configFolder or "RayfieldAdvanced"
	self.stateFile = self.configFolder .. "/element_states.json"
	self.states = {}

	if makefolder and not isfolder(self.configFolder) then
		pcall(makefolder, self.configFolder)
	end

	self:Load()
	return self
end

function StatePersistence:SaveState(elementId, state)
	self.states[elementId] = {
		visible = state.visible,
		position = state.position,
		size = state.size,
		detached = state.detached or false,
		timestamp = tick()
	}
	self:Save()
end

function StatePersistence:GetState(elementId)
	return self.states[elementId]
end

function StatePersistence:Save()
	if not writefile then return end
	local success, encoded = pcall(function()
		return HttpService:JSONEncode(self.states)
	end)
	if success then
		pcall(writefile, self.stateFile, encoded)
	end
end

function StatePersistence:Load()
	if not readfile or not isfile then return end
	local success, content = pcall(readfile, self.stateFile)
	if not success then return end

	local decoded
	success, decoded = pcall(function()
		return HttpService:JSONDecode(content)
	end)
	if success and decoded then
		self.states = decoded
	end
end

-- Export modules
RayfieldAdvanced.StatePersistence = StatePersistence




-- ============================================
-- 3. PERFORMANCE MONITOR
-- ============================================

local PerformanceMonitor = {}
PerformanceMonitor.__index = PerformanceMonitor

function PerformanceMonitor.new()
	local self = setmetatable({}, PerformanceMonitor)

	self.elementCount = 0
	self.detachedWindowCount = 0
	self.activeAnimations = 0
	self.memoryUsage = 0
	self.fps = 0
	self.startTime = tick()

	self:StartMonitoring()
	return self
end

function PerformanceMonitor:StartMonitoring()
	local lastUpdate = tick()
	local frames = 0

	RunService.RenderStepped:Connect(function()
		frames = frames + 1
		if tick() - lastUpdate >= 1 then
			self.fps = frames
			frames = 0
			lastUpdate = tick()
		end
	end)

	task.spawn(function()
		while true do
			task.wait(5)
			local stats = game:GetService("Stats")
			self.memoryUsage = stats:GetTotalMemoryUsageMb()
		end
	end)
end

function PerformanceMonitor:GetStats()
	return {
		elementCount = self.elementCount,
		detachedWindows = self.detachedWindowCount,
		activeAnimations = self.activeAnimations,
		memoryUsage = self.memoryUsage,
		fps = self.fps,
		uptime = tick() - self.startTime
	}
end

function PerformanceMonitor:PrintStats()
	local stats = self:GetStats()
	print("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")
	print("📊 Rayfield Performance Stats")
	print("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")
	print(string.format("Elements: %d", stats.elementCount))
	print(string.format("Detached Windows: %d", stats.detachedWindows))
	print(string.format("Active Animations: %d", stats.activeAnimations))
	print(string.format("Memory: %.2f MB", stats.memoryUsage))
	print(string.format("FPS: %d", stats.fps))
	print(string.format("Uptime: %.1f seconds", stats.uptime))
	print("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")
end

-- ============================================
-- 4. DRAG & DROP MANAGER
-- ============================================

local DragDropManager = {}
DragDropManager.__index = DragDropManager

function DragDropManager.new(performanceMonitor)
	local self = setmetatable({}, DragDropManager)

	self.performanceMonitor = performanceMonitor
	self.draggingElement = nil
	self.isDragging = false
	self.dragThreshold = 3
	self.detachedWindows = {}

	return self
end

function DragDropManager:EnableDrag(element, guiObject)
	local holding = false
	local holdIndicator = nil
	local holdThemeConnection = nil

	local function getHoldIndicatorColor()
		local fallback = Color3.fromRGB(100, 200, 255)
		if not guiObject then
			return fallback
		end

		local cursor = guiObject
		while cursor do
			local themeValues = cursor:FindFirstChild("ThemeValues")
			if themeValues and themeValues:IsA("Folder") then
				local sliderProgress = themeValues:FindFirstChild("SliderProgress")
				if sliderProgress and sliderProgress:IsA("Color3Value") then
					return sliderProgress.Value
				end
			end
			cursor = cursor.Parent
		end

		return fallback
	end

	local function cleanupHoldThemeSync()
		if holdThemeConnection then
			holdThemeConnection:Disconnect()
			holdThemeConnection = nil
		end
	end

	local function bindHoldThemeSync()
		cleanupHoldThemeSync()
		if not guiObject then
			return
		end

		local cursor = guiObject
		while cursor do
			local themeValues = cursor:FindFirstChild("ThemeValues")
			if themeValues and themeValues:IsA("Folder") then
				local sliderProgress = themeValues:FindFirstChild("SliderProgress")
				if sliderProgress and sliderProgress:IsA("Color3Value") then
					holdThemeConnection = sliderProgress:GetPropertyChangedSignal("Value"):Connect(function()
						if holdIndicator and holdIndicator.Parent then
							holdIndicator.BackgroundColor3 = sliderProgress.Value
						end
					end)
					break
				end
			end
			cursor = cursor.Parent
		end
	end

	guiObject.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or
		   input.UserInputType == Enum.UserInputType.Touch then
			holding = true

			holdIndicator = Instance.new("Frame")
			holdIndicator.Name = "HoldIndicator"
			holdIndicator.Size = UDim2.new(0, 0, 0, 3)
			holdIndicator.Position = UDim2.new(0, 0, 1, -3)
			holdIndicator.BackgroundColor3 = getHoldIndicatorColor()
			holdIndicator.BorderSizePixel = 0
			holdIndicator.ZIndex = 1000
			holdIndicator.Parent = guiObject
			bindHoldThemeSync()

			local progressTween = Animation:Create(
				holdIndicator,
				TweenInfo.new(self.dragThreshold, Enum.EasingStyle.Linear),
				{Size = UDim2.new(1, 0, 0, 3)}
			)
			progressTween:Play()

			local holdStartTime = tick()
			task.spawn(function()
				while holding and tick() - holdStartTime < self.dragThreshold do
					task.wait(0.1)
				end

				if holding and tick() - holdStartTime >= self.dragThreshold then
					self:StartDragging(element, guiObject)
				end

				if holdIndicator then
					Animation:Create(holdIndicator, TweenInfo.new(0.2, Enum.EasingStyle.Exponential),
						{BackgroundTransparency = 1}):Play()
					task.wait(0.2)
					if holdIndicator then
						holdIndicator:Destroy()
						holdIndicator = nil
					end
					cleanupHoldThemeSync()
				end
			end)
		end
	end)

	guiObject.InputEnded:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or
		   input.UserInputType == Enum.UserInputType.Touch then
			holding = false
			cleanupHoldThemeSync()
		end
	end)
end

function DragDropManager:StartDragging(element, guiObject)
	self.isDragging = true
	self.draggingElement = {
		element = element,
		guiObject = guiObject,
		originalParent = guiObject.Parent,
		originalPosition = guiObject.Position,
		originalSize = guiObject.Size,
		originalTransparency = guiObject.BackgroundTransparency
	}

	guiObject.BackgroundTransparency = 0.5
	guiObject.ZIndex = 1000

	print("🎯 Drag mode! Kéo ra ngoài để tách cửa sổ")
	self:TrackDragMovement(guiObject)
end

return RayfieldAdvanced
]=])
put("src/feature/enhanced/create-enhanced-rayfield.lua", [=[--[[

	Rayfield Interface Suite - Enhanced Version 2.0
	
	Tính năng mới:
	✅ Memory Leak Detection tự động
	✅ Performance Profiler
	✅ Hybrid Mode (fast + protected callbacks)
	✅ Priority Queue cho Remote Calls
	✅ Exception System với auto-disable
	✅ Audit Log cho security
	✅ API Reference đầy đủ
	✅ Migration helpers

	Tác giả: Enhanced by Community
	Version: 2.0.0

]]

local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")

-- ============================================
-- PHẦN 1: MEMORY LEAK DETECTOR
-- ============================================

local MemoryLeakDetector = {}
MemoryLeakDetector.__index = MemoryLeakDetector

local function resolveCompatibility()
	if type(_G) == "table" and type(_G.__RayfieldCompatibility) == "table" then
		return _G.__RayfieldCompatibility
	end
	return nil
end

local function getService(name)
	local compatibility = resolveCompatibility()
	if compatibility and type(compatibility.getService) == "function" then
		local service = compatibility.getService(name)
		if service then
			return service
		end
	end
	return game:GetService(name)
end

local function safeGetChildren(instance)
	local ok, children = pcall(function()
		return instance:GetChildren()
	end)
	if ok and type(children) == "table" then
		return children
	end
	return {}
end

local function safeGetDescendants(instance)
	local ok, descendants = pcall(function()
		return instance:GetDescendants()
	end)
	if ok and type(descendants) == "table" then
		return descendants
	end
	return {}
end

function MemoryLeakDetector.new()
	local self = setmetatable({}, MemoryLeakDetector)
	
	-- Tracking
	self.snapshots = {}
	self.maxSnapshots = 10
	self.checkInterval = 120 -- seconds (increased from 30 for performance)
	self.leakThreshold = 10 * 1024 * 1024 -- 10MB growth
	self.suspectedLeaks = {}
	self.enabled = true -- Toggle to disable in production
	
	-- Object tracking
	self.objectCounts = {}
	self.lastObjectCounts = {}
	
	-- Scan behavior
	self.scanMode = "ui" -- "ui", "mixed", "game"
	self.scanTargets = {"Workspace", "Players"} -- legacy targets for "game" mode
	self.customScanRoots = nil
	self.maxScanDescendants = 50000
	self.scanBudgetWarning = 20000
	self.lastScanMeta = nil
	
	-- Callbacks
	self.onLeakDetected = nil
	self.running = false
	self.monitorThread = nil
	
	self:startMonitoring()
	
	return self
end

function MemoryLeakDetector:setScanMode(mode)
	local normalized = tostring(mode or ""):lower()
	if normalized ~= "ui" and normalized ~= "mixed" and normalized ~= "game" then
		warn("[Memory Leak Detector] Invalid scan mode: " .. tostring(mode) .. " (use 'ui', 'mixed', or 'game')")
		return false
	end
	self.scanMode = normalized
	return true
end

function MemoryLeakDetector:setScanRoots(roots)
	if roots == nil then
		self.customScanRoots = nil
		return true
	end
	if type(roots) ~= "table" then
		warn("[Memory Leak Detector] setScanRoots expects table or nil")
		return false
	end

	local sanitized = {}
	local seen = {}
	for _, root in ipairs(roots) do
		if typeof(root) == "Instance" and not seen[root] then
			seen[root] = true
			table.insert(sanitized, root)
		end
	end
	self.customScanRoots = sanitized
	return true
end

function MemoryLeakDetector:_resolveUiRoots()
	if type(self.customScanRoots) == "table" and #self.customScanRoots > 0 then
		return self.customScanRoots
	end

	local roots = {}
	local seen = {}
	local function addRoot(root)
		if typeof(root) ~= "Instance" then
			return
		end
		if seen[root] then
			return
		end
		seen[root] = true
		table.insert(roots, root)
	end

	local compatibility = resolveCompatibility()
	local coreGui = getService("CoreGui")
	local players = getService("Players")
	local localPlayer = players and players.LocalPlayer or nil

	if type(_G) == "table" then
		addRoot(_G.Rayfield)
		local rayfieldUi = _G.RayfieldUI
		if type(rayfieldUi) == "table" and typeof(rayfieldUi.ScreenGui) == "Instance" then
			addRoot(rayfieldUi.ScreenGui)
		end
	end

	if compatibility and type(compatibility.tryGetHui) == "function" then
		local hui = compatibility.tryGetHui()
		if hui then
			for _, child in ipairs(safeGetChildren(hui)) do
				if child.Name == "Rayfield" or child.Name == "Key" then
					addRoot(child)
				end
			end
		end
	end

	if coreGui then
		for _, child in ipairs(safeGetChildren(coreGui)) do
			if child.Name == "Rayfield" or child.Name == "Key" then
				addRoot(child)
			end
		end
	end

	local playerGui = nil
	if localPlayer then
		playerGui = localPlayer:FindFirstChildOfClass("PlayerGui")
	end
	if playerGui then
		for _, child in ipairs(safeGetChildren(playerGui)) do
			if child.Name == "Rayfield" or child.Name == "Key" then
				addRoot(child)
			end
		end
	end

	return roots
end

function MemoryLeakDetector:_resolveGameRoots()
	local roots = {}
	for _, targetName in ipairs(self.scanTargets) do
		local target = game:FindFirstChild(targetName)
		if target then
			table.insert(roots, target)
		end
	end
	return roots
end

function MemoryLeakDetector:_resolveScanRoots()
	if self.scanMode == "game" then
		return self:_resolveGameRoots()
	end
	return self:_resolveUiRoots()
end

function MemoryLeakDetector:_scanRoots(collectBreakdown)
	local objectBreakdown = collectBreakdown and {} or nil
	local totalCount = 0
	local totalDescendantsVisited = 0
	local truncated = false
	local roots = self:_resolveScanRoots()

	for _, root in ipairs(roots) do
		local descendants = safeGetDescendants(root)
		totalDescendantsVisited += #descendants
		local allowed = #descendants
		local remainingBudget = self.maxScanDescendants - totalCount
		if remainingBudget <= 0 then
			truncated = true
			break
		end
		if allowed > remainingBudget then
			allowed = remainingBudget
			truncated = true
		end

		for index = 1, allowed do
			local obj = descendants[index]
			totalCount += 1
			if objectBreakdown then
				local className = obj.ClassName
				objectBreakdown[className] = (objectBreakdown[className] or 0) + 1
			end
		end
	end

	if totalDescendantsVisited > self.scanBudgetWarning then
		warn(string.format(
			"[Memory Leak Detector] Scan budget warning: visited=%d mode=%s roots=%d",
			totalDescendantsVisited,
			tostring(self.scanMode),
			#roots
		))
	end

	self.lastScanMeta = {
		mode = self.scanMode,
		rootCount = #roots,
		visited = totalDescendantsVisited,
		counted = totalCount,
		truncated = truncated
	}

	return totalCount, objectBreakdown
end

function MemoryLeakDetector:getTargetedInstanceCount()
	local count = self:_scanRoots(false)
	return count
end

function MemoryLeakDetector:_getMixedLightweightStats()
	local workspace = getService("Workspace")
	local players = getService("Players")
	local stats = {
		workspaceChildren = workspace and #safeGetChildren(workspace) or 0,
		playersChildren = players and #safeGetChildren(players) or 0
	}
	return stats
end

function MemoryLeakDetector:takeSnapshot()
	local statsService = getService("Stats")
	local instanceCount, objectBreakdown = self:_scanRoots(true)
	local snapshot = {
		timestamp = tick(),
		totalMemory = statsService and statsService:GetTotalMemoryUsageMb() or 0,
		instanceCount = instanceCount,
		objectBreakdown = objectBreakdown or {},
		scanMode = self.scanMode
	}
	
	if self.scanMode == "mixed" then
		snapshot.mixedStats = self:_getMixedLightweightStats()
	end
	if self.lastScanMeta then
		snapshot.scanMeta = self.lastScanMeta
	end
	
	table.insert(self.snapshots, snapshot)
	
	-- Keep only recent snapshots
	if #self.snapshots > self.maxSnapshots then
		table.remove(self.snapshots, 1)
	end
	
	return snapshot
end

function MemoryLeakDetector:detectLeaks()
	if #self.snapshots < 3 then
		return nil -- Need at least 3 snapshots
	end
	
	local leaks = {}
	local oldest = self.snapshots[1]
	local newest = self.snapshots[#self.snapshots]
	
	-- Check total memory growth
	local memoryGrowth = (newest.totalMemory - oldest.totalMemory) * 1024 * 1024
	local timeSpan = newest.timestamp - oldest.timestamp
	local growthRate = memoryGrowth / timeSpan -- bytes per second
	
	if memoryGrowth > self.leakThreshold then
		table.insert(leaks, {
			type = "memory",
			severity = "high",
			growth = memoryGrowth,
			rate = growthRate,
			message = string.format(
				"Memory leak detected: %.2f MB growth in %.1f seconds (%.2f KB/s)",
				memoryGrowth / 1024 / 1024,
				timeSpan,
				growthRate / 1024
			)
		})
	end
	
	-- Check object count growth
	for className, newCount in pairs(newest.objectBreakdown) do
		local oldCount = oldest.objectBreakdown[className] or 0
		local growth = newCount - oldCount
		
		if growth > 100 then -- More than 100 new objects
			table.insert(leaks, {
				type = "object",
				severity = "medium",
				className = className,
				growth = growth,
				message = string.format(
					"Object leak detected: %s increased by %d instances",
					className,
					growth
				)
			})
		end
	end
	
	return #leaks > 0 and leaks or nil
end

function MemoryLeakDetector:setEnabled(enabled)
	self.enabled = enabled
	if enabled then
		print("[Memory Leak Detector] Enabled")
	else
		print("[Memory Leak Detector] Disabled")
	end
end

function MemoryLeakDetector:startMonitoring()
	if self.monitorThread then
		return
	end
	self.running = true
	self.monitorThread = task.spawn(function()
		while self.running do
			task.wait(self.checkInterval)
			if not self.running then
				break
			end
			
			if not self.enabled then continue end
			
			-- Take snapshot
			self:takeSnapshot()
			
			-- Detect leaks
			local leaks = self:detectLeaks()
			
			if leaks then
				for _, leak in ipairs(leaks) do
					warn("[Memory Leak Detector] " .. leak.message)
					
					-- Track suspected leaks
					table.insert(self.suspectedLeaks, {
						leak = leak,
						timestamp = tick()
					})
					
					-- Callback
					if self.onLeakDetected then
						pcall(self.onLeakDetected, leak)
					end
				end
			end
		end
		self.monitorThread = nil
	end)
end

function MemoryLeakDetector:stopMonitoring()
	self.running = false
	if self.monitorThread then
		pcall(task.cancel, self.monitorThread)
		self.monitorThread = nil
	end
end

function MemoryLeakDetector:destroy()
	self:setEnabled(false)
	self:stopMonitoring()
	self.onLeakDetected = nil
end

function MemoryLeakDetector:getReport()
	local report = {
		snapshots = #self.snapshots,
		suspectedLeaks = #self.suspectedLeaks,
		currentMemory = 0,
		details = {},
		scanMode = self.scanMode
	}
	
	if #self.snapshots > 0 then
		local latest = self.snapshots[#self.snapshots]
		report.currentMemory = latest.totalMemory
		report.instanceCount = latest.instanceCount
		report.scanMeta = latest.scanMeta
		if latest.mixedStats then
			report.mixedStats = latest.mixedStats
		end
		
		-- Top 10 object types
		local sorted = {}
		for className, count in pairs(latest.objectBreakdown) do
			table.insert(sorted, {className = className, count = count})
		end
		table.sort(sorted, function(a, b) return a.count > b.count end)
		
		for i = 1, math.min(10, #sorted) do
			table.insert(report.details, sorted[i])
		end
	end
	
	return report
end

-- ============================================
-- PHẦN 2: PERFORMANCE PROFILER
-- ============================================

local PerformanceProfiler = {}
PerformanceProfiler.__index = PerformanceProfiler

function PerformanceProfiler.new()
	local self = setmetatable({}, PerformanceProfiler)
	
	self.profiles = {}
	self.activeProfiles = {}
	self.maxProfiles = 1000
	
	return self
end

function PerformanceProfiler:startProfile(identifier)
	self.activeProfiles[identifier] = {
		startTime = tick(),
		startMemory = collectgarbage("count")
	}
end

function PerformanceProfiler:endProfile(identifier)
	local active = self.activeProfiles[identifier]
	if not active then return nil end
	
	local duration = tick() - active.startTime
	local memoryDelta = collectgarbage("count") - active.startMemory
	
	-- Store profile
	if not self.profiles[identifier] then
		self.profiles[identifier] = {
			calls = 0,
			totalTime = 0,
			minTime = math.huge,
			maxTime = 0,
			avgTime = 0,
			totalMemory = 0
		}
	end
	
	local profile = self.profiles[identifier]
	profile.calls = profile.calls + 1
	profile.totalTime = profile.totalTime + duration
	profile.minTime = math.min(profile.minTime, duration)
	profile.maxTime = math.max(profile.maxTime, duration)
	profile.avgTime = profile.totalTime / profile.calls
	profile.totalMemory = profile.totalMemory + memoryDelta
	
	self.activeProfiles[identifier] = nil
	
	return {
		duration = duration,
		memory = memoryDelta
	}
end

function PerformanceProfiler:getProfile(identifier)
	return self.profiles[identifier]
end

function PerformanceProfiler:getAllProfiles()
	return self.profiles
end

function PerformanceProfiler:printReport()
	print("\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")
	print("📊 Performance Profile Report")
	print("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")
	
	-- Sort by total time
	local sorted = {}
	for identifier, profile in pairs(self.profiles) do
		table.insert(sorted, {
			identifier = identifier,
			profile = profile
		})
	end
	table.sort(sorted, function(a, b)
		return a.profile.totalTime > b.profile.totalTime
	end)
	
	for i, data in ipairs(sorted) do
		if i > 20 then break end -- Top 20
		
		local p = data.profile
		print(string.format(
			"%d. %s\n   Calls: %d | Avg: %.3fms | Max: %.3fms | Total: %.2fs",
			i,
			data.identifier,
			p.calls,
			p.avgTime * 1000,
			p.maxTime * 1000,
			p.totalTime
		))
	end
	
	print("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n")
end

-- ============================================
-- PHẦN 3: ENHANCED ERROR MANAGER (V2)
-- ============================================

local ErrorManager = {}
ErrorManager.__index = ErrorManager

function ErrorManager.new()
	local self = setmetatable({}, ErrorManager)
	
	-- Circuit Breaker
	self.errorThreshold = 5
	self.resetTimeout = 30
	self.errorCount = {}
	self.circuitState = {}
	self.lastErrorTime = {}
	
	-- Rate Limiting
	self.rateLimits = {}
	self.callHistory = {}
	
	-- Error logging
	self.errorLog = {}
	self.maxLogSize = 100
	
	-- Fatal error
	self.fatalErrorOccurred = false
	self.shutdownCallbacks = {}
	
	-- Exception System V2
	self.exceptionList = {}
	self.exceptionMode = false
	self.exceptionModeTimer = nil
	self.auditLog = {} -- NEW: Security audit log
	
	return self
end

function ErrorManager:isCircuitOpen(identifier)
	if self.exceptionMode or self.exceptionList[identifier] then
		return false
	end
	
	if not self.circuitState[identifier] then
		self.circuitState[identifier] = "closed"
		self.errorCount[identifier] = 0
		return false
	end
	
	local state = self.circuitState[identifier]
	
	if state == "open" then
		local timeSinceError = tick() - (self.lastErrorTime[identifier] or 0)
		if timeSinceError >= self.resetTimeout then
			self.circuitState[identifier] = "half-open"
			return false
		end
		return true
	end
	
	return false
end

function ErrorManager:recordError(identifier, errorMessage)
	self.errorCount[identifier] = (self.errorCount[identifier] or 0) + 1
	self.lastErrorTime[identifier] = tick()
	
	table.insert(self.errorLog, {
		identifier = identifier,
		message = errorMessage,
		timestamp = tick(),
		count = self.errorCount[identifier]
	})
	
	if #self.errorLog > self.maxLogSize then
		table.remove(self.errorLog, 1)
	end
	
	if self.errorCount[identifier] >= self.errorThreshold then
		self.circuitState[identifier] = "open"
		warn(string.format(
			"[Rayfield Circuit Breaker] Circuit mở cho '%s' sau %d lỗi",
			identifier,
			self.errorCount[identifier]
		))
		return true
	end
	
	return false
end

function ErrorManager:recordSuccess(identifier)
	if self.circuitState[identifier] == "half-open" then
		self.circuitState[identifier] = "closed"
	end
	self.errorCount[identifier] = 0
end

function ErrorManager:checkRateLimit(identifier, maxCallsPerSecond)
	if self.exceptionMode or self.exceptionList[identifier] then
		return true, nil
	end
	
	maxCallsPerSecond = maxCallsPerSecond or 10
	
	if not self.callHistory[identifier] then
		self.callHistory[identifier] = {}
	end
	
	local now = tick()
	local history = self.callHistory[identifier]
	
	for i = #history, 1, -1 do
		if now - history[i] > 1 then
			table.remove(history, i)
		end
	end
	
	if #history >= maxCallsPerSecond then
		return false, "Rate limit exceeded"
	end
	
	table.insert(history, now)
	return true, nil
end

-- NEW: Exception with auto-disable
function ErrorManager:addException(identifier, duration)
	self.exceptionList[identifier] = true
	
	-- Audit log
	table.insert(self.auditLog, {
		action = "add_exception",
		identifier = identifier,
		duration = duration,
		timestamp = tick()
	})
	
	print(string.format(
		"⚠️ [Exception] '%s' bypassed protection%s",
		identifier,
		duration and string.format(" for %ds", duration) or ""
	))
	
	-- Auto-disable after duration
	if duration then
		task.delay(duration, function()
			if self.exceptionList[identifier] then
				self:removeException(identifier)
				print(string.format("✅ [Exception] '%s' protection restored", identifier))
			end
		end)
	end
end

function ErrorManager:removeException(identifier)
	self.exceptionList[identifier] = nil
	
	table.insert(self.auditLog, {
		action = "remove_exception",
		identifier = identifier,
		timestamp = tick()
	})
end

-- NEW: Global exception with confirmation
function ErrorManager:setExceptionMode(enabled, duration, confirmed)
	if enabled and not confirmed then
		warn("⚠️⚠️⚠️ [SECURITY WARNING] ⚠️⚠️⚠️")
		warn("You are about to DISABLE ALL PROTECTION!")
		warn("Call again with confirmed=true to proceed")
		return false
	end
	
	self.exceptionMode = enabled
	
	-- Audit log
	table.insert(self.auditLog, {
		action = enabled and "enable_global_exception" or "disable_global_exception",
		duration = duration,
		timestamp = tick()
	})
	
	if enabled then
		warn("⚠️⚠️⚠️ [Exception Mode] ALL PROTECTION DISABLED!")
		
		-- Auto-disable
		if duration then
			if self.exceptionModeTimer then
				task.cancel(self.exceptionModeTimer)
			end
			
			self.exceptionModeTimer = task.delay(duration, function()
				self:setExceptionMode(false, nil, true)
				print("✅ [Exception Mode] Protection restored automatically")
			end)
		end
	else
		print("✅ [Exception Mode] Protection enabled")
		if self.exceptionModeTimer then
			task.cancel(self.exceptionModeTimer)
			self.exceptionModeTimer = nil
		end
	end
	
	return true
end

function ErrorManager:isException(identifier)
	return self.exceptionMode or self.exceptionList[identifier] == true
end

function ErrorManager:getAuditLog()
	return self.auditLog
end

function ErrorManager:printAuditLog()
	print("\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")
	print("🔒 Security Audit Log")
	print("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")
	
	for i, entry in ipairs(self.auditLog) do
		print(string.format(
			"[%d] %s: %s (%.1fs ago)",
			i,
			entry.action,
			entry.identifier or "global",
			tick() - entry.timestamp
		))
	end
	
	print("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n")
end

function ErrorManager:onShutdown(callback)
	table.insert(self.shutdownCallbacks, callback)
end

function ErrorManager:triggerFatalError(reason)
	if self.fatalErrorOccurred then return end
	
	self.fatalErrorOccurred = true
	warn("[Rayfield Fatal Error] " .. reason)
	
	for _, callback in ipairs(self.shutdownCallbacks) do
		pcall(callback)
	end
end

-- ============================================
-- PHẦN 4: ENHANCED GARBAGE COLLECTOR
-- ============================================

local GarbageCollector = {}
GarbageCollector.__index = GarbageCollector

function GarbageCollector.new()
	local self = setmetatable({}, GarbageCollector)
	
	self.trackedObjects = {}
	self.weakReferences = setmetatable({}, {__mode = "v"})
	self.connections = {}
	self.timers = {}
	
	self.autoCleanupInterval = 60
	self.maxTrackedObjects = 1000
	
	self:startAutoCleanup()
	
	return self
end

function GarbageCollector:track(object, identifier, cleanupFunc)
	if #self.trackedObjects >= self.maxTrackedObjects then
		self:cleanup()
	end
	
	table.insert(self.trackedObjects, {
		object = object,
		identifier = identifier,
		cleanupFunc = cleanupFunc,
		createdAt = tick()
	})
	
	self.weakReferences[identifier] = object
end

function GarbageCollector:trackConnection(connection, identifier)
	self.connections[identifier] = connection
end

function GarbageCollector:trackTimer(thread, identifier)
	self.timers[identifier] = thread
end

function GarbageCollector:cleanup()
	local cleaned = 0
	
	for i = #self.trackedObjects, 1, -1 do
		local tracked = self.trackedObjects[i]
		local obj = tracked.object
		
		local exists = pcall(function()
			return obj.Parent ~= nil
		end)
		
		if not exists or (obj.Parent == nil) then
			if tracked.cleanupFunc then
				pcall(tracked.cleanupFunc)
			end
			table.remove(self.trackedObjects, i)
			cleaned = cleaned + 1
		end
	end
	
	for identifier, connection in pairs(self.connections) do
		if not connection.Connected then
			self.connections[identifier] = nil
			cleaned = cleaned + 1
		end
	end
	
	if cleaned > 0 then
		print(string.format("[GC] Cleaned %d objects", cleaned))
	end
	
	return cleaned
end

function GarbageCollector:cleanupAll()
	for identifier, connection in pairs(self.connections) do
		pcall(function()
			connection:Disconnect()
		end)
	end
	self.connections = {}
	
	for identifier, thread in pairs(self.timers) do
		pcall(function()
			task.cancel(thread)
		end)
	end
	self.timers = {}
	
	for _, tracked in ipairs(self.trackedObjects) do
		if tracked.cleanupFunc then
			pcall(tracked.cleanupFunc)
		end
	end
	self.trackedObjects = {}
	
	print("[GC] Full cleanup completed")
end

function GarbageCollector:startAutoCleanup()
	local thread = task.spawn(function()
		while true do
			task.wait(self.autoCleanupInterval)
			self:cleanup()
		end
	end)
	
	self.timers["autoCleanup"] = thread
end

-- ============================================
-- PHẦN 5: PRIORITY REMOTE PROTECTION
-- ============================================

local RemoteProtection = {}
RemoteProtection.__index = RemoteProtection

function RemoteProtection.new(errorManager)
	local self = setmetatable({}, RemoteProtection)
	
	self.errorManager = errorManager
	
	-- Priority queues
	self.queues = {
		critical = {},
		high = {},
		normal = {},
		low = {}
	}
	
	self.maxQueueSize = {
		critical = 100,
		high = 75,
		normal = 50,
		low = 25
	}
	
	self.processingQueue = false
	self.timeout = 10 -- Increased from 5
	
	return self
end

function RemoteProtection:safeRemoteCall(remoteObject, method, priority, ...)
	priority = priority or "normal"
	local args = {...}
	
	if self.errorManager.fatalErrorOccurred then
		return false, "Fatal error occurred"
	end
	
	local queue = self.queues[priority]
	local maxSize = self.maxQueueSize[priority]
	
	if #queue >= maxSize then
		warn(string.format("[Remote] %s queue full", priority))
		return false, "Queue full"
	end
	
	table.insert(queue, {
		remote = remoteObject,
		method = method,
		args = args,
		timestamp = tick(),
		priority = priority
	})
	
	if not self.processingQueue then
		self:processQueue()
	end
	
	return true, "Queued"
end

function RemoteProtection:processQueue()
	self.processingQueue = true
	
	task.spawn(function()
		local priorities = {"critical", "high", "normal", "low"}
		
		while true do
			local hasWork = false
			
			-- Process in priority order
			for _, priority in ipairs(priorities) do
				local queue = self.queues[priority]
				
				if #queue > 0 then
					hasWork = true
					local callData = table.remove(queue, 1)
					
					-- Check timeout
					if tick() - callData.timestamp > self.timeout then
						warn(string.format("[Remote] Timeout: %s", priority))
					else
						local success, result = pcall(function()
							return callData.remote[callData.method](callData.remote, unpack(callData.args))
						end)
						
						if not success then
							warn("[Remote Error] " .. tostring(result))
							self.errorManager:recordError("RemoteCall", tostring(result))
						end
					end
					
					-- Delay based on priority
					local delays = {
						critical = 0.05,
						high = 0.1,
						normal = 0.15,
						low = 0.2
					}
					task.wait(delays[priority])
					break -- Process one at a time
				end
			end
			
			if not hasWork then
				break
			end
		end
		
		self.processingQueue = false
	end)
end

function RemoteProtection:getQueueStatus()
	local status = {}
	for priority, queue in pairs(self.queues) do
		status[priority] = {
			count = #queue,
			max = self.maxQueueSize[priority]
		}
	end
	return status
end

-- ============================================
-- PHẦN 6: HYBRID CALLBACK SYSTEM
-- ============================================

local function createHybridCallback(callback, identifier, errorManager, profiler, options)
	options = options or {}
	
	local mode = options.mode or "protected" -- "protected" or "fast"
	local rateLimit = options.rateLimit or 10
	local circuitBreaker = options.circuitBreaker ~= false
	local profile = options.profile ~= false
	
	if mode == "fast" then
		-- Fast path: minimal overhead
		return function(...)
			if profile and profiler then
				profiler:startProfile(identifier)
			end
			
			local success, result = pcall(callback, ...)
			
			if profile and profiler then
				profiler:endProfile(identifier)
			end
			
			if not success then
				warn(string.format("[Fast Callback] '%s' error: %s", identifier, tostring(result)))
			end
			
			return result
		end
	else
		-- Protected path: full protection
		return function(...)
			-- Fatal error check
			if errorManager.fatalErrorOccurred then
				return nil
			end
			
			-- Exception check
			if errorManager:isException(identifier) then
				if profile and profiler then
					profiler:startProfile(identifier)
				end
				
				local success, result = pcall(callback, ...)
				
				if profile and profiler then
					profiler:endProfile(identifier)
				end
				
				return result
			end
			
			-- Circuit breaker
			if circuitBreaker and errorManager:isCircuitOpen(identifier) then
				return nil
			end
			
			-- Rate limit
			local allowed, rateLimitError = errorManager:checkRateLimit(identifier, rateLimit)
			if not allowed then
				return nil
			end
			
			-- Profile start
			if profile and profiler then
				profiler:startProfile(identifier)
			end
			
			-- Execute
			local success, result = pcall(callback, ...)
			
			-- Profile end
			if profile and profiler then
				profiler:endProfile(identifier)
			end
			
			-- Handle result
			if success then
				errorManager:recordSuccess(identifier)
				return result
			else
				local circuitOpened = errorManager:recordError(identifier, tostring(result))
				
				if circuitOpened then
					errorManager:triggerFatalError(
						string.format("Circuit breaker opened for '%s'", identifier)
					)
				end
				
				return nil
			end
		end
	end
end

-- ============================================
-- PHẦN 7: ENHANCED WRAPPER
-- ============================================

local function createEnhancedRayfield(originalRayfield)
	local errorManager = ErrorManager.new()
	local garbageCollector = GarbageCollector.new()
	local remoteProtection = RemoteProtection.new(errorManager)
	local memoryLeakDetector = MemoryLeakDetector.new()
	local profiler = PerformanceProfiler.new()
	
	-- Shutdown callback
	errorManager:onShutdown(function()
		memoryLeakDetector:destroy()
		garbageCollector:cleanupAll()
	end)
	
	-- Leak detection callback
	memoryLeakDetector.onLeakDetected = function(leak)
		if leak.severity == "high" then
			warn("[Memory Leak] Triggering emergency cleanup")
			garbageCollector:cleanup()
		end
	end
	
	-- Wrap CreateWindow
	local originalCreateWindow = originalRayfield.CreateWindow
	originalRayfield.CreateWindow = function(selfOrSettings, maybeSettings)
		-- Support both call styles:
		-- 1) Rayfield:CreateWindow(settings)  -> selfOrSettings = Rayfield, maybeSettings = settings
		-- 2) Rayfield.CreateWindow(settings)  -> selfOrSettings = settings, maybeSettings = nil
		local self = originalRayfield
		local settings = maybeSettings

		if selfOrSettings == originalRayfield then
			self = selfOrSettings
		elseif maybeSettings == nil then
			settings = selfOrSettings
		end

		if type(settings) ~= "table" then
			settings = {}
		end

		local window = originalCreateWindow(self, settings)
		
		garbageCollector:track(window, "MainWindow", function()
			if window.Destroy then
				pcall(window.Destroy, window)
			end
		end)
		
		return window
	end

	-- Ensure background workers are stopped on explicit destroy
	local originalDestroy = originalRayfield.Destroy
	if type(originalDestroy) == "function" then
		originalRayfield.Destroy = function(self, ...)
			memoryLeakDetector:destroy()
			garbageCollector:cleanupAll()
			return originalDestroy(self, ...)
		end
	end
	
	-- New APIs
	originalRayfield.GetErrorManager = function()
		return errorManager
	end
	
	originalRayfield.GetGarbageCollector = function()
		return garbageCollector
	end
	
	originalRayfield.GetRemoteProtection = function()
		return remoteProtection
	end
	
	originalRayfield.GetMemoryLeakDetector = function()
		return memoryLeakDetector
	end
	
	originalRayfield.GetProfiler = function()
		return profiler
	end

	originalRayfield.IsHealthy = function()
		return not errorManager.fatalErrorOccurred
	end
	
	originalRayfield.GetErrorLog = function()
		return errorManager.errorLog
	end
	
	originalRayfield.ForceCleanup = function()
		return garbageCollector:cleanup()
	end
	
	originalRayfield.GetMemoryReport = function()
		return memoryLeakDetector:getReport()
	end
	
	originalRayfield.GetPerformanceReport = function()
		profiler:printReport()
	end
	
	originalRayfield.GetAuditLog = function()
		return errorManager:getAuditLog()
	end
	
	return originalRayfield, errorManager, garbageCollector, remoteProtection, memoryLeakDetector, profiler
end

-- ============================================
-- EXPORT
-- ============================================

return {
	ErrorManager = ErrorManager,
	GarbageCollector = GarbageCollector,
	RemoteProtection = RemoteProtection,
	MemoryLeakDetector = MemoryLeakDetector,
	PerformanceProfiler = PerformanceProfiler,
	createHybridCallback = createHybridCallback,
	createEnhancedRayfield = createEnhancedRayfield,
	Version = "2.0.0"
}
]=])
put("src/feature/enhanced/create-enhanced-rayfield-fn.lua", [[local client = _G and _G.__RayfieldApiClient
if not client then
	error("Rayfield ApiClient is not initialized")
end

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
local Enhanced = client.fetchAndExecute(root .. "src/feature/enhanced/create-enhanced-rayfield.lua")
return Enhanced.createEnhancedRayfield]])
put("src/feature/enhanced/error-manager.lua", [[local client = _G and _G.__RayfieldApiClient
if not client then
	error("Rayfield ApiClient is not initialized")
end

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
local Enhanced = client.fetchAndExecute(root .. "src/feature/enhanced/create-enhanced-rayfield.lua")
return Enhanced.ErrorManager]])
put("src/feature/enhanced/garbage-collector.lua", [[local client = _G and _G.__RayfieldApiClient
if not client then
	error("Rayfield ApiClient is not initialized")
end

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
local Enhanced = client.fetchAndExecute(root .. "src/feature/enhanced/create-enhanced-rayfield.lua")
return Enhanced.GarbageCollector]])
put("src/feature/enhanced/init.lua", [[local client = _G and _G.__RayfieldApiClient
if not client then
	error("Rayfield ApiClient is not initialized")
end

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
return client.fetchAndExecute(root .. "src/feature/enhanced/create-enhanced-rayfield.lua")]])
put("src/feature/enhanced/memory-leak-detector.lua", [[local client = _G and _G.__RayfieldApiClient
if not client then
	error("Rayfield ApiClient is not initialized")
end

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
local Enhanced = client.fetchAndExecute(root .. "src/feature/enhanced/create-enhanced-rayfield.lua")
return Enhanced.MemoryLeakDetector]])
put("src/feature/enhanced/profiler.lua", [[local client = _G and _G.__RayfieldApiClient
if not client then
	error("Rayfield ApiClient is not initialized")
end

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
local Enhanced = client.fetchAndExecute(root .. "src/feature/enhanced/create-enhanced-rayfield.lua")
return Enhanced.PerformanceProfiler]])
put("src/feature/enhanced/remote-protection.lua", [[local client = _G and _G.__RayfieldApiClient
if not client then
	error("Rayfield ApiClient is not initialized")
end

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
local Enhanced = client.fetchAndExecute(root .. "src/feature/enhanced/create-enhanced-rayfield.lua")
return Enhanced.RemoteProtection]])
put("src/feature/mini-window/controller.lua", [[-- Custom Mini Window System
-- Creates a small floating widget separate from Rayfield

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")

local function buildFallbackAnimateFacade()
	local engine = (_G and _G.__RayfieldSharedAnimationEngine) or nil
	if not engine then
		local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
		local okEngineLib, engineLib = pcall(function()
			if _G and _G.__RayfieldApiClient then
				return _G.__RayfieldApiClient.fetchAndExecute(root .. "src/core/animation/engine.lua")
			end
			return nil
		end)
		if okEngineLib and engineLib and type(engineLib.new) == "function" then
			local okEngine, createdEngine = pcall(function()
				return engineLib.new({
					TweenService = TweenService,
					RunService = game:GetService("RunService"),
					mode = "raw"
				})
			end)
			if okEngine then
				engine = createdEngine
			end
		end
	end

	if not engine then
		return {
			Create = function(_, object, tweenInfo, goals)
				local creator = TweenService["Create"]
				if type(creator) == "function" then
					return creator(TweenService, object, tweenInfo, goals)
				end
				return nil
			end
		}
	end

	return {
		Create = function(_, object, tweenInfo, goals)
			return engine:Create(object, tweenInfo, goals)
		end
	}
end

local Animation = (_G and _G.__RayfieldSharedAnimateFacade) or buildFallbackAnimateFacade()

local MiniWindow = {}
MiniWindow.__index = MiniWindow

function MiniWindow.new(config)
    local self = setmetatable({}, MiniWindow)
    
    config = config or {}
    self.Title = config.Title or "Mini Window"
    self.Size = config.Size or UDim2.new(0, 200, 0, 300)
    self.Position = config.Position or UDim2.new(1, -220, 0.5, -150)
    self.Buttons = {}
    self.Labels = {}
    self.Animation = Animation
    
    self:CreateUI()
    
    return self
end

function MiniWindow:CreateUI()
    -- Create ScreenGui
    self.ScreenGui = Instance.new("ScreenGui")
    self.ScreenGui.Name = "MiniWindow"
    self.ScreenGui.ResetOnSpawn = false
    self.ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    
    -- Main Frame
    self.Frame = Instance.new("Frame")
    self.Frame.Name = "MainFrame"
    self.Frame.Size = self.Size
    self.Frame.Position = self.Position
    self.Frame.BackgroundColor3 = Color3.fromRGB(25, 25, 35)
    self.Frame.BorderSizePixel = 0
    self.Frame.Parent = self.ScreenGui
    
    -- Corner
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 8)
    corner.Parent = self.Frame
    
    -- Stroke
    local stroke = Instance.new("UIStroke")
    stroke.Color = Color3.fromRGB(60, 60, 80)
    stroke.Thickness = 2
    stroke.Parent = self.Frame
    
    -- Title Bar
    self.TitleBar = Instance.new("Frame")
    self.TitleBar.Name = "TitleBar"
    self.TitleBar.Size = UDim2.new(1, 0, 0, 30)
    self.TitleBar.BackgroundColor3 = Color3.fromRGB(35, 35, 50)
    self.TitleBar.BorderSizePixel = 0
    self.TitleBar.Parent = self.Frame
    
    local titleCorner = Instance.new("UICorner")
    titleCorner.CornerRadius = UDim.new(0, 8)
    titleCorner.Parent = self.TitleBar
    
    -- Title Text
    self.TitleLabel = Instance.new("TextLabel")
    self.TitleLabel.Name = "Title"
    self.TitleLabel.Size = UDim2.new(1, -40, 1, 0)
    self.TitleLabel.Position = UDim2.new(0, 10, 0, 0)
    self.TitleLabel.BackgroundTransparency = 1
    self.TitleLabel.Text = self.Title
    self.TitleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    self.TitleLabel.TextSize = 14
    self.TitleLabel.Font = Enum.Font.GothamBold
    self.TitleLabel.TextXAlignment = Enum.TextXAlignment.Left
    self.TitleLabel.Parent = self.TitleBar
    
    -- Close Button
    self.CloseButton = Instance.new("TextButton")
    self.CloseButton.Name = "Close"
    self.CloseButton.Size = UDim2.new(0, 20, 0, 20)
    self.CloseButton.Position = UDim2.new(1, -25, 0.5, -10)
    self.CloseButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
    self.CloseButton.Text = "×"
    self.CloseButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    self.CloseButton.TextSize = 16
    self.CloseButton.Font = Enum.Font.GothamBold
    self.CloseButton.BorderSizePixel = 0
    self.CloseButton.Parent = self.TitleBar
    
    local closeCorner = Instance.new("UICorner")
    closeCorner.CornerRadius = UDim.new(1, 0)
    closeCorner.Parent = self.CloseButton
    
    self.CloseButton.MouseButton1Click:Connect(function()
        self:Toggle()
    end)
    
    -- Content Frame
    self.Content = Instance.new("ScrollingFrame")
    self.Content.Name = "Content"
    self.Content.Size = UDim2.new(1, -10, 1, -40)
    self.Content.Position = UDim2.new(0, 5, 0, 35)
    self.Content.BackgroundTransparency = 1
    self.Content.BorderSizePixel = 0
    self.Content.ScrollBarThickness = 4
    self.Content.ScrollBarImageColor3 = Color3.fromRGB(100, 100, 120)
    self.Content.Parent = self.Frame
    
    -- Layout
    self.Layout = Instance.new("UIListLayout")
    self.Layout.Padding = UDim.new(0, 5)
    self.Layout.SortOrder = Enum.SortOrder.LayoutOrder
    self.Layout.Parent = self.Content
    
    -- Make draggable
    self:MakeDraggable()
    
    -- Parent to PlayerGui
    self.ScreenGui.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")
end

function MiniWindow:MakeDraggable()
    local dragging = false
    local dragInput, mousePos, framePos
    
    self.TitleBar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            mousePos = input.Position
            framePos = self.Frame.Position
            
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)
    
    UserInputService.InputChanged:Connect(function(input)
        if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
            local delta = input.Position - mousePos
            self.Frame.Position = UDim2.new(
                framePos.X.Scale,
                framePos.X.Offset + delta.X,
                framePos.Y.Scale,
                framePos.Y.Offset + delta.Y
            )
        end
    end)
end

function MiniWindow:AddButton(name, callback)
    local button = Instance.new("TextButton")
    button.Name = name
    button.Size = UDim2.new(1, -10, 0, 30)
    button.BackgroundColor3 = Color3.fromRGB(45, 45, 60)
    button.Text = name
    button.TextColor3 = Color3.fromRGB(255, 255, 255)
    button.TextSize = 12
    button.Font = Enum.Font.Gotham
    button.BorderSizePixel = 0
    button.Parent = self.Content
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 6)
    corner.Parent = button
    
    button.MouseButton1Click:Connect(callback)
    
    button.MouseEnter:Connect(function()
        Animation:Create(button, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(60, 60, 80)}):Play()
    end)
    
    button.MouseLeave:Connect(function()
        Animation:Create(button, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(45, 45, 60)}):Play()
    end)
    
    table.insert(self.Buttons, button)
    self:UpdateContentSize()
    
    return button
end

function MiniWindow:AddLabel(text)
    local label = Instance.new("TextLabel")
    label.Name = "Label"
    label.Size = UDim2.new(1, -10, 0, 25)
    label.BackgroundTransparency = 1
    label.Text = text
    label.TextColor3 = Color3.fromRGB(200, 200, 200)
    label.TextSize = 11
    label.Font = Enum.Font.Gotham
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.Parent = self.Content
    
    table.insert(self.Labels, label)
    self:UpdateContentSize()
    
    return label
end

function MiniWindow:UpdateContentSize()
    local contentSize = self.Layout.AbsoluteContentSize
    self.Content.CanvasSize = UDim2.new(0, 0, 0, contentSize.Y + 10)
end

function MiniWindow:Toggle()
    self.Frame.Visible = not self.Frame.Visible
end

function MiniWindow:Show()
    self.Frame.Visible = true
end

function MiniWindow:Hide()
    self.Frame.Visible = false
end

function MiniWindow:AddToggle(name, defaultValue, callback)
    local container = Instance.new("Frame")
    container.Name = name
    container.Size = UDim2.new(1, -10, 0, 30)
    container.BackgroundColor3 = Color3.fromRGB(45, 45, 60)
    container.BorderSizePixel = 0
    container.Parent = self.Content

    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 6)
    corner.Parent = container

    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1, -40, 1, 0)
    label.Position = UDim2.new(0, 10, 0, 0)
    label.BackgroundTransparency = 1
    label.Text = name
    label.TextColor3 = Color3.fromRGB(255, 255, 255)
    label.TextSize = 12
    label.Font = Enum.Font.Gotham
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.Parent = container

    local toggle = Instance.new("TextButton")
    toggle.Size = UDim2.new(0, 40, 0, 20)
    toggle.Position = UDim2.new(1, -45, 0.5, -10)
    toggle.BackgroundColor3 = defaultValue and Color3.fromRGB(100, 255, 100) or Color3.fromRGB(80, 80, 90)
    toggle.Text = defaultValue and "ON" or "OFF"
    toggle.TextColor3 = Color3.fromRGB(255, 255, 255)
    toggle.TextSize = 10
    toggle.Font = Enum.Font.GothamBold
    toggle.BorderSizePixel = 0
    toggle.Parent = container

    local toggleCorner = Instance.new("UICorner")
    toggleCorner.CornerRadius = UDim.new(0, 10)
    toggleCorner.Parent = toggle

    local state = defaultValue

    toggle.MouseButton1Click:Connect(function()
        state = not state
        toggle.Text = state and "ON" or "OFF"
        Animation:Create(toggle, TweenInfo.new(0.2), {
            BackgroundColor3 = state and Color3.fromRGB(100, 255, 100) or Color3.fromRGB(80, 80, 90)
        }):Play()
        callback(state)
    end)

    self:UpdateContentSize()

    return {
        Container = container,
        Toggle = toggle,
        SetValue = function(value)
            state = value
            toggle.Text = state and "ON" or "OFF"
            toggle.BackgroundColor3 = state and Color3.fromRGB(100, 255, 100) or Color3.fromRGB(80, 80, 90)
        end,
        GetValue = function()
            return state
        end
    }
end

function MiniWindow:AddSlider(name, min, max, defaultValue, callback)
    local container = Instance.new("Frame")
    container.Name = name
    container.Size = UDim2.new(1, -10, 0, 50)
    container.BackgroundColor3 = Color3.fromRGB(45, 45, 60)
    container.BorderSizePixel = 0
    container.Parent = self.Content

    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 6)
    corner.Parent = container

    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1, -20, 0, 20)
    label.Position = UDim2.new(0, 10, 0, 5)
    label.BackgroundTransparency = 1
    label.Text = name .. ": " .. defaultValue
    label.TextColor3 = Color3.fromRGB(255, 255, 255)
    label.TextSize = 11
    label.Font = Enum.Font.Gotham
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.Parent = container

    local sliderBg = Instance.new("Frame")
    sliderBg.Size = UDim2.new(1, -20, 0, 6)
    sliderBg.Position = UDim2.new(0, 10, 1, -15)
    sliderBg.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
    sliderBg.BorderSizePixel = 0
    sliderBg.Parent = container

    local sliderBgCorner = Instance.new("UICorner")
    sliderBgCorner.CornerRadius = UDim.new(1, 0)
    sliderBgCorner.Parent = sliderBg

    local sliderFill = Instance.new("Frame")
    sliderFill.Size = UDim2.new((defaultValue - min) / (max - min), 0, 1, 0)
    sliderFill.BackgroundColor3 = Color3.fromRGB(100, 150, 255)
    sliderFill.BorderSizePixel = 0
    sliderFill.Parent = sliderBg

    local sliderFillCorner = Instance.new("UICorner")
    sliderFillCorner.CornerRadius = UDim.new(1, 0)
    sliderFillCorner.Parent = sliderFill

    local currentValue = defaultValue
    local dragging = false

    local function updateSlider(input)
        local pos = (input.Position.X - sliderBg.AbsolutePosition.X) / sliderBg.AbsoluteSize.X
        pos = math.clamp(pos, 0, 1)
        currentValue = math.floor(min + (max - min) * pos)
        sliderFill.Size = UDim2.new(pos, 0, 1, 0)
        label.Text = name .. ": " .. currentValue
        callback(currentValue)
    end

    sliderBg.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            updateSlider(input)
        end
    end)

    sliderBg.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = false
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
            updateSlider(input)
        end
    end)

    self:UpdateContentSize()

    return {
        Container = container,
        SetValue = function(value)
            currentValue = math.clamp(value, min, max)
            local pos = (currentValue - min) / (max - min)
            sliderFill.Size = UDim2.new(pos, 0, 1, 0)
            label.Text = name .. ": " .. currentValue
        end,
        GetValue = function()
            return currentValue
        end
    }
end

function MiniWindow:Destroy()
    self.ScreenGui:Destroy()
end

return MiniWindow

]])
put("src/feature/mini-window/dock.lua", [[local MiniWindowDock = {}

function MiniWindowDock.shouldDock(dropPosition, dockBounds)
	if not dropPosition or not dockBounds then
		return false
	end
	return dropPosition.X >= dockBounds.X and dropPosition.X <= (dockBounds.X + dockBounds.Width)
		and dropPosition.Y >= dockBounds.Y and dropPosition.Y <= (dockBounds.Y + dockBounds.Height)
end

return MiniWindowDock]])
put("src/feature/mini-window/drag.lua", [[local MiniWindowDrag = {}

function MiniWindowDrag.clamp(position, viewport, size)
	local x = math.clamp(position.X, 0, math.max(0, viewport.X - size.X))
	local y = math.clamp(position.Y, 0, math.max(0, viewport.Y - size.Y))
	return Vector2.new(x, y)
end

return MiniWindowDrag]])
put("src/feature/mini-window/init.lua", [[local client = _G and _G.__RayfieldApiClient
if not client then
	error("Rayfield ApiClient is not initialized")
end

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
return client.fetchAndExecute(root .. "src/feature/mini-window/controller.lua")]])
put("src/feature/mini-window/layout.lua", [[local MiniWindowController = {}

function MiniWindowController.new(runtime)
	return {
		runtime = runtime
	}
end

return MiniWindowController]])
put("src/feature/reorder/engine.lua", [[local ReorderEngine = {}

local function getOrderedGuiChildren(parent, excludes)
	excludes = excludes or {}
	local deny = {}
	for _, obj in ipairs(excludes) do
		deny[obj] = true
	end

	local rawChildren = parent and parent:GetChildren() or {}
	local insertionOrder = {}
	for index, child in ipairs(rawChildren) do
		insertionOrder[child] = index
	end

	local ordered = {}
	for _, child in ipairs(rawChildren) do
		if child:IsA("GuiObject") and not deny[child] then
			table.insert(ordered, child)
		end
	end

	table.sort(ordered, function(a, b)
		if a.LayoutOrder ~= b.LayoutOrder then
			return a.LayoutOrder < b.LayoutOrder
		end
		return (insertionOrder[a] or 0) < (insertionOrder[b] or 0)
	end)

	return ordered
end

local function normalizeOrderedGuiLayout(ordered, step)
	step = step or 10
	for index, child in ipairs(ordered) do
		child.LayoutOrder = index * step
	end
end

local function calculateInsertIndex(ordered, point)
	if not point then
		return #ordered + 1
	end
	local insertIndex = #ordered + 1
	for index, child in ipairs(ordered) do
		local centerY = child.AbsolutePosition.Y + (child.AbsoluteSize.Y * 0.5)
		if point.Y <= centerY then
			insertIndex = index
			break
		end
	end
	return insertIndex
end

function ReorderEngine.init()
	return {
		getOrderedGuiChildren = getOrderedGuiChildren,
		normalizeOrderedGuiLayout = normalizeOrderedGuiLayout,
		calculateInsertIndex = calculateInsertIndex
	}
end

return ReorderEngine
]])
put("src/feature/reorder/preview.lua", [[local ReorderPreview = {}

function ReorderPreview.init(ctx)
	local tweenService = ctx and ctx.TweenService
	local indicator = nil
	local indicatorTween = nil

	local function clear(instant)
		if indicatorTween then
			pcall(function() indicatorTween:Cancel() end)
			indicatorTween = nil
		end
		if indicator then
			local target = indicator
			indicator = nil
			if instant or not tweenService then
				target:Destroy()
				return
			end
			indicatorTween = tweenService:Create(target, TweenInfo.new(0.08, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
				BackgroundTransparency = 1
			})
			indicatorTween:Play()
			task.delay(0.09, function()
				if target and target.Parent then
					target:Destroy()
				end
			end)
		end
	end

	local function show(parent, x, y, width, color)
		if not parent then
			return
		end
		if not indicator then
			indicator = Instance.new("Frame")
			indicator.Name = "ReorderIndicator"
			indicator.BorderSizePixel = 0
			indicator.Size = UDim2.fromOffset(width, 3)
			indicator.ZIndex = 210
			indicator.Parent = parent
		end
		indicator.BackgroundColor3 = color
		indicator.BackgroundTransparency = 0.08
		indicator.Size = UDim2.fromOffset(width, 3)
		indicator.Position = UDim2.fromOffset(x, y)
		indicator.Visible = true
	end

	return {
		show = show,
		clear = clear
	}
end

return ReorderPreview
]])
put("src/feature/tabsplit/controller.lua", [[-- Rayfield Tab Split Module
-- Handles long-hold tab split into secondary panels (non-float detached windows)

local TabSplitModule = {}
local compileString = loadstring or load
if not compileString then
	error("No Lua compiler function available (loadstring/load)")
end

local MODULE_ROOT_URL = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"

local function loadSubmodule(localName, relativePath)
	local useStudio = false
	local okRun, runService = pcall(function()
		return game:GetService("RunService")
	end)
	if okRun and runService then
		local okStudio, studio = pcall(function()
			return runService:IsStudio()
		end)
		useStudio = okStudio and studio or false
	end

	if useStudio then
		local okRequire, module = pcall(function()
			return require(script.Parent[localName])
		end)
		if okRequire and module then
			return module
		end
	end

	return compileString(game:HttpGet(MODULE_ROOT_URL .. relativePath))()
end

local TabSplitStateLib = loadSubmodule("state", "src/feature/tabsplit/state.lua")
local TabSplitPanelLib = loadSubmodule("panel", "src/feature/tabsplit/panel.lua")
local TabSplitDragDockLib = loadSubmodule("dragdock", "src/feature/tabsplit/dragdock.lua")

function TabSplitModule.init(ctx)
	local self = {}

	self.UserInputService = ctx.UserInputService
	self.RunService = ctx.RunService
	self.TweenService = ctx.TweenService
	self.Animation = ctx.Animation or ctx.TweenService
	self.HttpService = ctx.HttpService
	self.Rayfield = ctx.Rayfield
	self.Main = ctx.Main
	self.Topbar = ctx.Topbar
	self.TabList = ctx.TabList
	self.Elements = ctx.Elements
	self.getSelectedTheme = ctx.getSelectedTheme
	self.rayfieldDestroyed = ctx.rayfieldDestroyed
	self.useMobileSizing = ctx.useMobileSizing
	self.Notify = ctx.Notify
	self.getBlockedState = ctx.getBlockedState

	local enabled = ctx.enabled ~= false
	local holdDuration = tonumber(ctx.holdDuration) or 3
	if holdDuration < 0.5 then
		holdDuration = 0.5
	end

	local allowSettingsSplit = ctx.allowSettingsSplit == true
	local maxSplitTabs = tonumber(ctx.maxSplitTabs)
	if maxSplitTabs and maxSplitTabs < 1 then
		maxSplitTabs = nil
	end

	local splitRoot = nil
	local splitPanels = {}
	local tabToPanel = {}
	local panelOrder = {}
	local tabRecords = {}
	local tabGestureCleanup = {}
	local splitHidden = false
	local splitMinimized = false
	local splitIndex = 0

	local rootConnections = {}
	local tabZIndexState = setmetatable({}, { __mode = "k" })

	local DRAG_THRESHOLD = 4
	local PANEL_MARGIN = 8
	local TAB_GHOST_FOLLOW_SPEED = 0.24
	local TAB_CUE_HOVER_TRANSPARENCY = 0.52
	local TAB_CUE_HOLD_TRANSPARENCY = 0.34
	local TAB_CUE_READY_TRANSPARENCY = 0.24
	local TAB_CUE_IDLE_THICKNESS = 1
	local TAB_CUE_HOVER_THICKNESS = 1.35
	local TAB_CUE_HOLD_THICKNESS = 1.9
	local TAB_CUE_READY_THICKNESS = 2.2

	local stateManager = TabSplitStateLib.create({
		UserInputService = self.UserInputService,
		Main = self.Main,
		TabList = self.TabList
	})

	local function isDestroyed()
		return self.rayfieldDestroyed and self.rayfieldDestroyed()
	end

	local function isBlocked()
		if isDestroyed() then
			return true
		end
		if type(self.getBlockedState) == "function" then
			local ok, result = pcall(self.getBlockedState)
			if ok and result then
				return true
			end
		end
		return false
	end

	local function safeNotify(data)
		if type(self.Notify) == "function" then
			pcall(self.Notify, data)
		end
	end

	local function ensureSharedInput()
		stateManager.ensureSharedInput()
	end

	local function registerSharedInput(id, onChanged, onEnded)
		stateManager.registerSharedInput(id, onChanged, onEnded)
	end

	local function unregisterSharedInput(id)
		stateManager.unregisterSharedInput(id)
	end

	local function disconnectSharedInput()
		stateManager.disconnectSharedInput()
	end

	local function getInputPosition(input)
		return stateManager.getInputPosition(input)
	end

	local function isPointInside(guiObject, point, padding)
		return stateManager.isPointInside(guiObject, point, padding)
	end

	local function isPointInsideMain(point)
		return stateManager.isPointInsideMain(point)
	end

	local function isPointInsideTabList(point)
		return stateManager.isPointInsideTabList(point)
	end

	local function clampPositionToViewport(root, desiredPosition, panelSize)
		return stateManager.clampPositionToViewport(root, desiredPosition, panelSize, PANEL_MARGIN)
	end

	local function hasZIndex(guiObject)
		return stateManager.hasZIndex(guiObject)
	end

	local function getOriginalZState(tabRecord)
		local state = tabZIndexState[tabRecord]
		if state then
			return state
		end

		state = {
			Original = setmetatable({}, { __mode = "k" }),
			DescendantConn = nil,
			LastBaseZ = 200,
			LastAppliedBase = nil
		}
		tabZIndexState[tabRecord] = state
		return state
	end

	local function captureOriginalZIndex(tabRecord)
		if not (tabRecord and tabRecord.TabPage) then
			return
		end

		local state = getOriginalZState(tabRecord)
		local objects = { tabRecord.TabPage }
		for _, descendant in ipairs(tabRecord.TabPage:GetDescendants()) do
			table.insert(objects, descendant)
		end

		for _, object in ipairs(objects) do
			if hasZIndex(object) and state.Original[object] == nil then
				state.Original[object] = object.ZIndex
			end
		end
	end

	local function applySplitZIndex(tabRecord, zBase)
		if not (tabRecord and tabRecord.TabPage) then
			return
		end

		local state = getOriginalZState(tabRecord)
		local nextBase = zBase or state.LastBaseZ or 200
		state.LastBaseZ = nextBase

		captureOriginalZIndex(tabRecord)

		if state.LastAppliedBase ~= nextBase then
			for object, original in pairs(state.Original) do
				if object and object.Parent and hasZIndex(object) then
					object.ZIndex = nextBase + original
				end
			end
			state.LastAppliedBase = nextBase
		end

		if not state.DescendantConn then
			state.DescendantConn = tabRecord.TabPage.DescendantAdded:Connect(function(descendant)
				if not tabRecord.IsSplit then
					return
				end
				if not hasZIndex(descendant) then
					return
				end
				if state.Original[descendant] == nil then
					state.Original[descendant] = descendant.ZIndex
				end
				descendant.ZIndex = state.LastBaseZ + state.Original[descendant]
			end)
		end
	end

	local function restoreOriginalZIndex(tabRecord)
		local state = tabZIndexState[tabRecord]
		if not state then
			return
		end

		if state.DescendantConn then
			state.DescendantConn:Disconnect()
			state.DescendantConn = nil
		end

		for object, original in pairs(state.Original) do
			if object and object.Parent and hasZIndex(object) then
				object.ZIndex = original
			end
		end

		tabZIndexState[tabRecord] = nil
	end

	local function getPanelSize(root)
		local viewport = root.AbsoluteSize
		local mainSize = self.Main.AbsoluteSize

		local panelWidth = math.clamp(math.floor(mainSize.X * 0.68), 250, 420)
		local panelHeight = math.clamp(math.floor(mainSize.Y), 180, math.max(180, viewport.Y - 12))
		return Vector2.new(panelWidth, panelHeight)
	end

	local function setPanelLayer(panelData, baseZ)
		panelData.LayerZ = baseZ
		panelData.Frame.ZIndex = baseZ
		panelData.Header.ZIndex = baseZ + 1
		panelData.Content.ZIndex = baseZ + 1
		panelData.Title.ZIndex = baseZ + 2
		panelData.DockButton.ZIndex = baseZ + 2
		applySplitZIndex(panelData.TabRecord, baseZ + 2)
	end

	local setPanelHoverState
	local applyPanelTheme

	local function ensureSplitRoot()
		if splitRoot and splitRoot.Parent then
			return splitRoot
		end

		splitRoot = Instance.new("Frame")
		splitRoot.Name = "TabSplitRoot"
		splitRoot.BackgroundTransparency = 1
		splitRoot.BorderSizePixel = 0
		splitRoot.Size = UDim2.fromScale(1, 1)
		splitRoot.ZIndex = 180
		splitRoot.Visible = (not splitHidden) and (not splitMinimized)
		splitRoot.Parent = self.Rayfield

		table.insert(rootConnections, self.Main:GetPropertyChangedSignal("AbsolutePosition"):Connect(function()
			self.layoutPanels()
		end))
		table.insert(rootConnections, self.Main:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
			self.layoutPanels()
		end))
		table.insert(rootConnections, self.Rayfield:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
			self.layoutPanels()
		end))
		table.insert(rootConnections, self.Main:GetPropertyChangedSignal("BackgroundColor3"):Connect(function()
			for _, panelData in pairs(splitPanels) do
				if panelData then
					applyPanelTheme(panelData)
				end
			end
		end))

		return splitRoot
	end

	local function refreshRootVisibility()
		if splitRoot and splitRoot.Parent then
			splitRoot.Visible = (not splitHidden) and (not splitMinimized)
		end
	end

	if enabled then
		task.defer(function()
			if isDestroyed() then
				return
			end
			ensureSplitRoot()
			refreshRootVisibility()
		end)
	end

	local function createGhost(text, position)
		local root = ensureSplitRoot()
		local theme = self.getSelectedTheme and self.getSelectedTheme()

		local ghost = Instance.new("Frame")
		ghost.Name = "TabSplitGhost"
		ghost.BackgroundColor3 = (theme and theme.ElementBackground) or Color3.fromRGB(35, 35, 35)
		ghost.BackgroundTransparency = 0.18
		ghost.BorderSizePixel = 0
		ghost.Size = UDim2.fromOffset(170, 28)
		ghost.Position = UDim2.fromOffset(position.X - 85, position.Y - 14)
		ghost.ZIndex = 240
		ghost.Parent = root

		local corner = Instance.new("UICorner")
		corner.CornerRadius = UDim.new(0, 7)
		corner.Parent = ghost

		local stroke = Instance.new("UIStroke")
		stroke.Thickness = 1.2
		stroke.Transparency = 0.2
		stroke.Color = (theme and theme.ElementStroke) or Color3.fromRGB(90, 90, 90)
		stroke.Parent = ghost

		local label = Instance.new("TextLabel")
		label.BackgroundTransparency = 1
		label.Size = UDim2.new(1, -10, 1, 0)
		label.Position = UDim2.new(0, 5, 0, 0)
		label.Text = text
		label.Font = Enum.Font.GothamSemibold
		label.TextSize = 11
		label.TextXAlignment = Enum.TextXAlignment.Left
		label.TextColor3 = (theme and theme.TextColor) or Color3.fromRGB(255, 255, 255)
		label.ZIndex = ghost.ZIndex + 1
		label.Parent = ghost

		return ghost
	end

	local function updateGhostPosition(ghost, point)
		if ghost and ghost.Parent and point then
			ghost.Position = UDim2.fromOffset(point.X - math.floor(ghost.AbsoluteSize.X / 2), point.Y - math.floor(ghost.AbsoluteSize.Y / 2))
		end
	end

	local function clearGhost(ghost)
		if ghost and ghost.Parent then
			self.Animation:Create(ghost, TweenInfo.new(0.08, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
				BackgroundTransparency = 1
			}):Play()
			task.delay(0.09, function()
				if ghost and ghost.Parent then
					ghost:Destroy()
				end
			end)
		end
	end

	if enabled then
		task.defer(function()
			if isDestroyed() then
				return
			end
			local warmGhost = createGhost("", Vector2.new(-9999, -9999))
			if warmGhost then
				warmGhost:Destroy()
			end
		end)
	end

	local function getSplitPanelCount()
		return #panelOrder
	end

	local function canSplitTab(tabRecord)
		if not enabled then
			return false, "Tab split is disabled for this window."
		end
		if isBlocked() then
			return false, "Tab split is temporarily blocked while UI is busy."
		end
		if not tabRecord then
			return false, "Invalid tab."
		end
		if tabRecord.IsSplit then
			return false, "This tab is already split."
		end
		if tabRecord.Name == "Rayfield Settings" and tabRecord.Ext and not allowSettingsSplit then
			return false, "Splitting Rayfield Settings is disabled."
		end
		if maxSplitTabs and getSplitPanelCount() >= maxSplitTabs then
			return false, "Reached max split tabs: " .. tostring(maxSplitTabs)
		end
		local dockedCount = 0
		for _, record in ipairs(tabRecords) do
			if not record.IsSplit and record.TabPage and record.TabPage.Parent == self.Elements then
				dockedCount += 1
			end
		end
		if dockedCount <= 1 then
			return false, "At least one tab must remain in main UI."
		end
		return true
	end

	local function chooseFallbackTab(excluded)
		for _, record in ipairs(tabRecords) do
			if record ~= excluded and not record.IsSplit and record.TabPage and record.TabPage.Parent == self.Elements then
				return record
			end
		end
		return nil
	end

	setPanelHoverState = function(panelData, active, instant)
		if not (panelData and panelData.Frame and panelData.Frame.Parent) then
			return
		end

		panelData.HoverActive = active and true or false

		local theme = self.getSelectedTheme and self.getSelectedTheme()
		local accent = (theme and theme.SliderProgress) or Color3.fromRGB(112, 189, 255)
		local strokeColor = (theme and theme.ElementStroke) or Color3.fromRGB(85, 85, 85)

		if panelData.GlowStroke then
			panelData.GlowStroke.Color = accent
		end
		if panelData.SoftGlowStroke then
			panelData.SoftGlowStroke.Color = accent
		end
		if panelData.Stroke then
			panelData.Stroke.Color = active and accent:Lerp(strokeColor, 0.35) or strokeColor
		end

		local duration = instant and 0 or 0.12
		if panelData.Stroke then
			self.Animation:Create(panelData.Stroke, TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
				Thickness = active and 1.35 or 1,
				Transparency = active and 0.22 or 0.35
			}):Play()
		end
		if panelData.GlowStroke then
			self.Animation:Create(panelData.GlowStroke, TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
				Thickness = active and 2.8 or 1.1,
				Transparency = active and 0.62 or 1
			}):Play()
		end
		if panelData.SoftGlowStroke then
			self.Animation:Create(panelData.SoftGlowStroke, TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
				Thickness = active and 4.6 or 2.8,
				Transparency = active and 0.84 or 1
			}):Play()
		end
	end

	applyPanelTheme = function(panelData)
		if not panelData then
			return
		end
		local theme = self.getSelectedTheme and self.getSelectedTheme()
		if not theme then
			return
		end

		panelData.Frame.BackgroundColor3 = theme.SecondaryElementBackground or panelData.Frame.BackgroundColor3
		panelData.Header.BackgroundColor3 = theme.Topbar or panelData.Header.BackgroundColor3
		panelData.Title.TextColor3 = theme.TextColor or panelData.Title.TextColor3
		panelData.DockButton.BackgroundColor3 = theme.ElementBackgroundHover or panelData.DockButton.BackgroundColor3
		panelData.DockButton.TextColor3 = theme.TextColor or panelData.DockButton.TextColor3
		setPanelHoverState(panelData, panelData.HoverActive or panelData.Dragging, true)
	end

	local function removePanelRecord(panelId)
		for i = #panelOrder, 1, -1 do
			if panelOrder[i] == panelId then
				table.remove(panelOrder, i)
				break
			end
		end
		splitPanels[panelId] = nil
	end

	local function cleanupPanel(panelData)
		if not panelData then
			return
		end

		if panelData.InputId then
			unregisterSharedInput(panelData.InputId)
		end

		if panelData.Cleanup then
			for _, cleanupFn in ipairs(panelData.Cleanup) do
				pcall(cleanupFn)
			end
			table.clear(panelData.Cleanup)
		end

		if panelData.Frame and panelData.Frame.Parent then
			panelData.Frame:Destroy()
		end
	end

	local function bringPanelToFront(panelData)
		if not panelData then
			return
		end

		for i = #panelOrder, 1, -1 do
			if panelOrder[i] == panelData.Id then
				table.remove(panelOrder, i)
				break
			end
		end
		table.insert(panelOrder, panelData.Id)
		self.layoutPanels()
	end

	local function attachPanelDrag(panelData)
		TabSplitDragDockLib.attachPanelDrag(panelData, {
			dragThreshold = DRAG_THRESHOLD,
			isBlocked = isBlocked,
			getInputPosition = getInputPosition,
			isPointInside = isPointInside,
			bringPanelToFront = bringPanelToFront,
			setPanelHoverState = setPanelHoverState,
			isPointInsideTabList = isPointInsideTabList,
			dockTab = function(tabRecord)
				self.dockTab(tabRecord)
			end,
			ensureSplitRoot = ensureSplitRoot,
			getPanelSize = getPanelSize,
			clampPositionToViewport = clampPositionToViewport,
			layoutPanels = function()
				self.layoutPanels()
			end,
			registerSharedInput = registerSharedInput
		})
	end

	local function createPanelShell(tabRecord)
		local root = ensureSplitRoot()
		splitIndex += 1
		local panelId = self.HttpService:GenerateGUID(false) .. "-" .. tostring(splitIndex)
		local theme = self.getSelectedTheme and self.getSelectedTheme()
		local panelData = TabSplitPanelLib.createShell({
			root = root,
			panelId = panelId,
			tabRecord = tabRecord,
			theme = theme,
			inputId = self.HttpService:GenerateGUID(false),
			baseZ = 190,
			setPanelHoverState = setPanelHoverState
		})

		table.insert(panelData.Cleanup, panelData.DockButton.MouseButton1Click:Connect(function()
			self.dockTab(tabRecord)
		end))

		applyPanelTheme(panelData)
		attachPanelDrag(panelData)
		return panelData
	end

	function self.layoutPanels()
		if isDestroyed() then
			return
		end

		local root = ensureSplitRoot()
		if not root or not root.Parent then
			return
		end

		if #panelOrder <= 0 then
			return
		end

		local panelSize = getPanelSize(root)
		local mainPos = self.Main.AbsolutePosition
		local mainSize = self.Main.AbsoluteSize

		local rightX = mainPos.X + mainSize.X + 16
		local leftX = mainPos.X - panelSize.X - 16
		local baseX = rightX
		if baseX + panelSize.X > root.AbsoluteSize.X - PANEL_MARGIN then
			baseX = math.max(PANEL_MARGIN, leftX)
		end

		for index, panelId in ipairs(panelOrder) do
			local panelData = splitPanels[panelId]
			if panelData and panelData.Frame and panelData.Frame.Parent then
				local baseZ = 190 + ((index - 1) * 8)
				setPanelLayer(panelData, baseZ)
				panelData.Frame.Size = UDim2.fromOffset(panelSize.X, panelSize.Y)

				if not panelData.Dragging then
					if panelData.ManualPosition then
						local clampedManual = clampPositionToViewport(root, panelData.ManualPosition, panelSize)
						panelData.ManualPosition = clampedManual
						panelData.Frame.Position = UDim2.fromOffset(clampedManual.X, clampedManual.Y)
					else
						local step = index - 1
						local targetX = math.clamp(baseX + ((step % 2) * 18), PANEL_MARGIN, math.max(PANEL_MARGIN, root.AbsoluteSize.X - panelSize.X - PANEL_MARGIN))
						local targetY = math.clamp(mainPos.Y + (step * 26), PANEL_MARGIN, math.max(PANEL_MARGIN, root.AbsoluteSize.Y - panelSize.Y - PANEL_MARGIN))
						self.Animation:Create(panelData.Frame, TweenInfo.new(0.16, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
							Position = UDim2.fromOffset(targetX, targetY)
						}):Play()
					end
				end
			end
		end
	end

	function self.splitTab(tabRecord, dropPoint)
		local allowed, reason = canSplitTab(tabRecord)
		if not allowed then
			if reason then
				safeNotify({
					Title = "Tab Split",
					Content = reason,
					Duration = 3
				})
			end
			return false
		end

		if not (tabRecord.TabPage and tabRecord.TabButton and tabRecord.TabPage.Parent) then
			return false
		end

		if isPointInsideMain(dropPoint) then
			return false
		end

		if self.Elements.UIPageLayout.CurrentPage == tabRecord.TabPage then
			local fallback = chooseFallbackTab(tabRecord)
			if fallback and type(fallback.Activate) == "function" then
				fallback.Activate(true)
			end
		end

		local panelData = createPanelShell(tabRecord)
		splitPanels[panelData.Id] = panelData
		table.insert(panelOrder, panelData.Id)
		tabToPanel[tabRecord] = panelData.Id

		local root = ensureSplitRoot()
		local panelSize = getPanelSize(root)
		local splitDropPoint = dropPoint or getInputPosition()
		local desiredStart = Vector2.new(
			splitDropPoint.X - math.floor(panelSize.X * 0.5),
			splitDropPoint.Y - 14
		)
		panelData.ManualPosition = clampPositionToViewport(root, desiredStart, panelSize)
		panelData.Frame.Position = UDim2.fromOffset(panelData.ManualPosition.X, panelData.ManualPosition.Y)

		tabRecord.IsSplit = true
		tabRecord.SplitPanelId = panelData.Id

		tabRecord.TabButton.Visible = false
		local interact = tabRecord.TabButton:FindFirstChild("Interact")
		if interact then
			interact.Visible = false
		end

		tabRecord.TabPage.Parent = panelData.Content
		tabRecord.TabPage.AnchorPoint = Vector2.zero
		tabRecord.TabPage.Position = UDim2.new(0, 0, 0, 0)
		tabRecord.TabPage.Size = UDim2.new(1, 0, 1, 0)
		tabRecord.TabPage.Visible = true
		tabRecord.TabPage.Active = true
		panelData.Content.Active = true
		panelData.Content.ClipsDescendants = true

		captureOriginalZIndex(tabRecord)
		bringPanelToFront(panelData)
		self.layoutPanels()
		refreshRootVisibility()
		self.syncMinimized(splitMinimized)

		return true
	end

	function self.dockTab(tabRecord)
		if not tabRecord then
			return false
		end

		local panelId = tabToPanel[tabRecord] or tabRecord.SplitPanelId
		if not panelId then
			return false
		end

		local panelData = splitPanels[panelId]
		if not panelData then
			tabRecord.IsSplit = false
			tabRecord.SplitPanelId = nil
			tabToPanel[tabRecord] = nil
			restoreOriginalZIndex(tabRecord)
			return false
		end

		if tabRecord.TabPage then
			tabRecord.TabPage.Parent = self.Elements
			tabRecord.TabPage.AnchorPoint = Vector2.zero
			tabRecord.TabPage.Position = UDim2.new(0, 0, 0, 0)
			tabRecord.TabPage.Size = UDim2.new(1, 0, 1, 0)
			tabRecord.TabPage.Visible = true
			tabRecord.TabPage.Active = true
		end

		restoreOriginalZIndex(tabRecord)

		if tabRecord.TabButton then
			local shouldBeVisible = tabRecord.DefaultVisible
			if shouldBeVisible == nil then
				shouldBeVisible = true
			end
			tabRecord.TabButton.Visible = shouldBeVisible
			local interact = tabRecord.TabButton:FindFirstChild("Interact")
			if interact then
				interact.Visible = shouldBeVisible
			end
		end

		tabRecord.IsSplit = false
		tabRecord.SplitPanelId = nil
		tabToPanel[tabRecord] = nil

		removePanelRecord(panelId)
		cleanupPanel(panelData)

		if type(tabRecord.Activate) == "function" then
			tabRecord.Activate(true)
		end

		self.layoutPanels()
		return true
	end

	local function unregisterTab(tabRecord)
		local cleanup = tabGestureCleanup[tabRecord]
		if not cleanup then
			return
		end

		if cleanup.InputId then
			unregisterSharedInput(cleanup.InputId)
		end
		if cleanup.Connections then
			for _, connection in ipairs(cleanup.Connections) do
				if connection then
					connection:Disconnect()
				end
			end
			table.clear(cleanup.Connections)
		end
		if cleanup.ClearVisuals then
			pcall(cleanup.ClearVisuals)
		end

		tabGestureCleanup[tabRecord] = nil
		for i = #tabRecords, 1, -1 do
			if tabRecords[i] == tabRecord then
				table.remove(tabRecords, i)
				break
			end
		end
	end

	function self.registerTab(tabRecord)
		if not tabRecord or tabGestureCleanup[tabRecord] then
			return
		end
		if not (tabRecord.TabButton and tabRecord.TabButton.Parent) then
			return
		end

		table.insert(tabRecords, tabRecord)
		tabRecord.IsSplit = false
		tabRecord.SplitPanelId = nil
		tabRecord.SuppressNextClick = false
		captureOriginalZIndex(tabRecord)

		local interact = tabRecord.TabButton:FindFirstChild("Interact")
		if not interact then
			return
		end

		local inputId = self.HttpService:GenerateGUID(false)
		local connections = {}
		local state = {
			pressing = false,
			dragArmed = false,
			pressInput = nil,
			pointer = nil,
			holdToken = 0,
			ghost = nil,
			ghostTarget = nil,
			ghostFollowConnection = nil,
			hoverCounter = 0,
			hoverActive = false,
			cueFrame = nil,
			cueStroke = nil,
			cueGlowStroke = nil,
			cueBlurStroke = nil,
			cueThemeConnection = nil
		}

		local function getCueColor()
			local theme = self.getSelectedTheme and self.getSelectedTheme()
			return (theme and theme.SliderProgress) or Color3.fromRGB(112, 189, 255)
		end

		local function ensureCue()
			if isDestroyed() or not (tabRecord.TabButton and tabRecord.TabButton.Parent) then
				return false
			end

			if state.cueFrame and state.cueFrame.Parent and state.cueStroke and state.cueGlowStroke and state.cueBlurStroke then
				return true
			end

			if state.cueThemeConnection then
				state.cueThemeConnection:Disconnect()
				state.cueThemeConnection = nil
			end

			state.cueFrame = Instance.new("Frame")
			state.cueFrame.Name = "TabSplitCue"
			state.cueFrame.BackgroundTransparency = 1
			state.cueFrame.BorderSizePixel = 0
			state.cueFrame.Size = UDim2.fromScale(1, 1)
			state.cueFrame.Position = UDim2.fromOffset(0, 0)
			state.cueFrame.ZIndex = tabRecord.TabButton.ZIndex + 8
			state.cueFrame.Active = false
			state.cueFrame.Parent = tabRecord.TabButton

			local sourceCorner = tabRecord.TabButton:FindFirstChildOfClass("UICorner")
			if sourceCorner then
				local cueCorner = Instance.new("UICorner")
				cueCorner.CornerRadius = sourceCorner.CornerRadius
				cueCorner.Parent = state.cueFrame
			end

			state.cueStroke = Instance.new("UIStroke")
			state.cueStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
			state.cueStroke.Color = getCueColor()
			state.cueStroke.Thickness = TAB_CUE_IDLE_THICKNESS
			state.cueStroke.Transparency = 1
			state.cueStroke.Parent = state.cueFrame

			state.cueGlowStroke = Instance.new("UIStroke")
			state.cueGlowStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
			state.cueGlowStroke.Color = getCueColor()
			state.cueGlowStroke.Thickness = TAB_CUE_IDLE_THICKNESS + 1.4
			state.cueGlowStroke.Transparency = 1
			state.cueGlowStroke.Parent = state.cueFrame

			state.cueBlurStroke = Instance.new("UIStroke")
			state.cueBlurStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
			state.cueBlurStroke.Color = getCueColor()
			state.cueBlurStroke.Thickness = TAB_CUE_IDLE_THICKNESS + 3.2
			state.cueBlurStroke.Transparency = 1
			state.cueBlurStroke.Parent = state.cueFrame

			state.cueThemeConnection = self.Main:GetPropertyChangedSignal("BackgroundColor3"):Connect(function()
				local cueColor = getCueColor()
				if state.cueStroke and state.cueStroke.Parent then
					state.cueStroke.Color = cueColor
				end
				if state.cueGlowStroke and state.cueGlowStroke.Parent then
					state.cueGlowStroke.Color = cueColor
				end
				if state.cueBlurStroke and state.cueBlurStroke.Parent then
					state.cueBlurStroke.Color = cueColor
				end
			end)

			return true
		end

		local function setCue(transparency, thickness, duration)
			if not ensureCue() or not (state.cueStroke and state.cueStroke.Parent) then
				return
			end

			local glowTransparency = (transparency >= 0.99)
				and 1
				or math.clamp(transparency + 0.34, 0.45, 0.98)
			local glowThickness = thickness + 1.4
			local blurTransparency = (transparency >= 0.99)
				and 1
				or math.clamp(transparency + 0.52, 0.7, 0.995)
			local blurThickness = thickness + 3.2

			if not duration or duration <= 0 then
				state.cueStroke.Transparency = transparency
				state.cueStroke.Thickness = thickness
				if state.cueGlowStroke and state.cueGlowStroke.Parent then
					state.cueGlowStroke.Transparency = glowTransparency
					state.cueGlowStroke.Thickness = glowThickness
				end
				if state.cueBlurStroke and state.cueBlurStroke.Parent then
					state.cueBlurStroke.Transparency = blurTransparency
					state.cueBlurStroke.Thickness = blurThickness
				end
				return
			end

			self.Animation:Create(state.cueStroke, TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
				Transparency = transparency,
				Thickness = thickness
			}):Play()

			if state.cueGlowStroke and state.cueGlowStroke.Parent then
				self.Animation:Create(state.cueGlowStroke, TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
					Transparency = glowTransparency,
					Thickness = glowThickness
				}):Play()
			end
			if state.cueBlurStroke and state.cueBlurStroke.Parent then
				self.Animation:Create(state.cueBlurStroke, TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
					Transparency = blurTransparency,
					Thickness = blurThickness
				}):Play()
			end
		end

		local function refreshCue()
			if tabRecord.IsSplit then
				setCue(1, TAB_CUE_IDLE_THICKNESS, 0.08)
				return
			end

			if state.dragArmed then
				setCue(TAB_CUE_READY_TRANSPARENCY, TAB_CUE_READY_THICKNESS, 0.08)
				return
			end

			if state.pressing then
				setCue(TAB_CUE_HOLD_TRANSPARENCY, TAB_CUE_HOLD_THICKNESS, 0.08)
				return
			end

			if state.hoverActive then
				setCue(TAB_CUE_HOVER_TRANSPARENCY, TAB_CUE_HOVER_THICKNESS, 0.12)
			else
				setCue(1, TAB_CUE_IDLE_THICKNESS, 0.12)
			end
		end

		local function runCueProgress(token)
			local started = os.clock()
			while state.pressing and state.holdToken == token and not state.dragArmed and not tabRecord.IsSplit do
				local progress = math.clamp((os.clock() - started) / holdDuration, 0, 1)
				local transparency = TAB_CUE_HOVER_TRANSPARENCY + ((TAB_CUE_HOLD_TRANSPARENCY - TAB_CUE_HOVER_TRANSPARENCY) * progress)
				local thickness = TAB_CUE_HOVER_THICKNESS + ((TAB_CUE_HOLD_THICKNESS - TAB_CUE_HOVER_THICKNESS) * progress)
				setCue(transparency, thickness, 0)
				task.wait()
			end
		end

		local function cleanupCue()
			if state.cueThemeConnection then
				state.cueThemeConnection:Disconnect()
				state.cueThemeConnection = nil
			end
			if state.cueFrame and state.cueFrame.Parent then
				state.cueFrame:Destroy()
			end
			state.cueFrame = nil
			state.cueStroke = nil
			state.cueGlowStroke = nil
			state.cueBlurStroke = nil
		end

		local function stopGhostFollow()
			if state.ghostFollowConnection then
				state.ghostFollowConnection:Disconnect()
				state.ghostFollowConnection = nil
			end
		end

		local function startGhostFollow()
			stopGhostFollow()
			state.ghostFollowConnection = self.RunService.RenderStepped:Connect(function(deltaTime)
				if not (state.ghost and state.ghost.Parent and state.ghostTarget) then
					return
				end

				local halfWidth = math.floor(state.ghost.AbsoluteSize.X * 0.5)
				local halfHeight = math.floor(state.ghost.AbsoluteSize.Y * 0.5)
				local desired = Vector2.new(state.ghostTarget.X - halfWidth, state.ghostTarget.Y - halfHeight)
				local current = Vector2.new(state.ghost.Position.X.Offset, state.ghost.Position.Y.Offset)
				local alpha = math.clamp(deltaTime * (TAB_GHOST_FOLLOW_SPEED * 60), 0, 1)
				local nextPosition = current:Lerp(desired, alpha)

				state.ghost.Position = UDim2.fromOffset(math.floor(nextPosition.X + 0.5), math.floor(nextPosition.Y + 0.5))
			end)
		end

		local function clearVisuals()
			stopGhostFollow()
			clearGhost(state.ghost)
			state.ghost = nil
			state.ghostTarget = nil
			cleanupCue()
		end

		local function beginPress(input)
			if isBlocked() then
				return
			end

			state.pressing = true
			state.dragArmed = false
			state.pressInput = input
			state.pointer = getInputPosition(input)
			state.ghostTarget = state.pointer
			state.holdToken += 1
			local token = state.holdToken

			refreshCue()
			task.spawn(runCueProgress, token)

			task.delay(holdDuration, function()
				if token ~= state.holdToken or not state.pressing then
					return
				end

				local allowed, reason = canSplitTab(tabRecord)
				if not allowed then
					if reason and reason ~= "This tab is already split." then
						safeNotify({
							Title = "Tab Split",
							Content = reason,
							Duration = 2.8
						})
					end
					tabRecord.SuppressNextClick = true
					refreshCue()
					return
				end

				state.dragArmed = true
				tabRecord.SuppressNextClick = true
				refreshCue()
				state.ghost = createGhost("Split: " .. tostring(tabRecord.Name), state.pointer)
				state.ghostTarget = state.pointer
				startGhostFollow()
			end)
		end

		local function finishPress(input)
			if not state.pressInput then
				return
			end

			local sameTouch = input == state.pressInput
			local mouseEnded = state.pressInput.UserInputType == Enum.UserInputType.MouseButton1 and input.UserInputType == Enum.UserInputType.MouseButton1
			if not sameTouch and not mouseEnded then
				return
			end

			state.pressing = false
			state.pressInput = nil
			state.holdToken += 1

			if state.dragArmed then
				state.dragArmed = false
				stopGhostFollow()
				local dropPoint = state.pointer or getInputPosition(input)
				clearGhost(state.ghost)
				state.ghost = nil
				state.ghostTarget = nil
				tabRecord.SuppressNextClick = true

				if not isPointInsideMain(dropPoint) then
					self.splitTab(tabRecord, dropPoint)
				end
			else
				stopGhostFollow()
				clearGhost(state.ghost)
				state.ghost = nil
				state.ghostTarget = nil
			end

			refreshCue()
		end

		table.insert(connections, interact.InputBegan:Connect(function(input)
			local inputType = input.UserInputType
			if inputType ~= Enum.UserInputType.MouseButton1 and inputType ~= Enum.UserInputType.Touch then
				return
			end
			beginPress(input)
		end))

		table.insert(connections, tabRecord.TabButton.AncestryChanged:Connect(function()
			if not tabRecord.TabButton:IsDescendantOf(game) then
				unregisterTab(tabRecord)
			end
		end))

		table.insert(connections, interact.MouseEnter:Connect(function()
			if tabRecord.IsSplit then
				return
			end
			state.hoverCounter += 1
			state.hoverActive = state.hoverCounter > 0
			refreshCue()
		end))

		table.insert(connections, interact.MouseLeave:Connect(function()
			state.hoverCounter = math.max(0, state.hoverCounter - 1)
			state.hoverActive = state.hoverCounter > 0
			if not state.pressing and not state.dragArmed then
				refreshCue()
			end
		end))

		registerSharedInput(inputId, function(input)
			if not state.pressing or not state.pressInput then
				return
			end

			local sameTouch = input == state.pressInput
			local mouseMove = state.pressInput.UserInputType == Enum.UserInputType.MouseButton1 and input.UserInputType == Enum.UserInputType.MouseMovement
			if not sameTouch and not mouseMove then
				return
			end

			state.pointer = getInputPosition(input)
			if state.dragArmed and state.ghost then
				state.ghostTarget = state.pointer
				updateGhostPosition(state.ghost, state.pointer)
			end
		end, finishPress)

		refreshCue()

		tabGestureCleanup[tabRecord] = {
			InputId = inputId,
			Connections = connections,
			ClearVisuals = clearVisuals
		}
	end

	function self.syncHidden(isHidden)
		splitHidden = isHidden and true or false
		refreshRootVisibility()
	end

	function self.syncMinimized(isMinimized)
		splitMinimized = isMinimized and true or false
		refreshRootVisibility()
		for _, panelData in pairs(splitPanels) do
			if panelData and panelData.Frame and panelData.Frame.Parent then
				panelData.Frame.Visible = (not splitHidden) and (not splitMinimized)
				if splitHidden or splitMinimized then
					panelData.HoverPanel = false
					panelData.HoverHeader = false
					panelData.HoverDock = false
					panelData.HoverActive = false
					panelData.Dragging = false
					setPanelHoverState(panelData, false, true)
				end
			end
		end
	end

	function self.destroy()
		for tabRecord, panelId in pairs(tabToPanel) do
			if panelId then
				restoreOriginalZIndex(tabRecord)
			end
		end

		for tabRecord, _ in pairs(tabGestureCleanup) do
			unregisterTab(tabRecord)
		end

		for _, panelData in pairs(splitPanels) do
			cleanupPanel(panelData)
		end

		table.clear(splitPanels)
		table.clear(tabToPanel)
		table.clear(panelOrder)
		table.clear(tabRecords)

		local zRecords = {}
		for tabRecord, _ in pairs(tabZIndexState) do
			table.insert(zRecords, tabRecord)
		end
		for _, tabRecord in ipairs(zRecords) do
			restoreOriginalZIndex(tabRecord)
		end

		for _, connection in ipairs(rootConnections) do
			if connection then
				connection:Disconnect()
			end
		end
		table.clear(rootConnections)

		disconnectSharedInput()

		if splitRoot and splitRoot.Parent then
			splitRoot:Destroy()
		end
		splitRoot = nil
	end

	return self
end

return TabSplitModule
]])
put("src/feature/tabsplit/dragdock.lua", [[local TabSplitDragDock = {}

function TabSplitDragDock.attachPanelDrag(panelData, opts)
	local state = {
		pressing = false,
		dragging = false,
		pressInput = nil,
		startPointer = nil,
		startPosition = nil,
		pointer = nil
	}

	local function resetState()
		state.pressing = false
		state.dragging = false
		state.pressInput = nil
		state.startPointer = nil
		state.startPosition = nil
		state.pointer = nil
		panelData.Dragging = false
		opts.setPanelHoverState(panelData, panelData.HoverActive, false)
	end

	local function beginPress(input)
		if opts.isBlocked() or not (panelData.Frame and panelData.Frame.Parent) then
			return
		end

		local pointer = opts.getInputPosition(input)
		if opts.isPointInside(panelData.DockButton, pointer, 0) then
			return
		end

		state.pressing = true
		state.dragging = false
		state.pressInput = input
		state.startPointer = pointer
		state.pointer = pointer
		if panelData.ManualPosition then
			state.startPosition = panelData.ManualPosition
		else
			state.startPosition = Vector2.new(panelData.Frame.AbsolutePosition.X, panelData.Frame.AbsolutePosition.Y)
		end

		opts.bringPanelToFront(panelData)
	end

	local function finishPress(input)
		if not state.pressInput then
			return
		end

		local sameTouch = input == state.pressInput
		local mouseEnded = state.pressInput.UserInputType == Enum.UserInputType.MouseButton1 and input.UserInputType == Enum.UserInputType.MouseButton1
		if not sameTouch and not mouseEnded then
			return
		end

		local wasDragging = state.dragging
		local dropPoint = state.pointer or opts.getInputPosition(input)
		resetState()

		if not wasDragging then
			return
		end

		if opts.isPointInsideTabList(dropPoint) then
			opts.dockTab(panelData.TabRecord)
			return
		end

		local root = opts.ensureSplitRoot()
		local panelSize = opts.getPanelSize(root)
		local currentPosition = panelData.ManualPosition or Vector2.new(panelData.Frame.AbsolutePosition.X, panelData.Frame.AbsolutePosition.Y)
		local clamped = opts.clampPositionToViewport(root, currentPosition, panelSize)
		panelData.ManualPosition = clamped
		panelData.Frame.Position = UDim2.fromOffset(clamped.X, clamped.Y)
		opts.layoutPanels()
	end

	table.insert(panelData.Cleanup, panelData.Header.InputBegan:Connect(function(input)
		local inputType = input.UserInputType
		if inputType ~= Enum.UserInputType.MouseButton1 and inputType ~= Enum.UserInputType.Touch then
			return
		end
		beginPress(input)
	end))

	opts.registerSharedInput(panelData.InputId, function(input)
		if not state.pressing or not state.pressInput then
			return
		end

		local sameTouch = input == state.pressInput
		local mouseMove = state.pressInput.UserInputType == Enum.UserInputType.MouseButton1 and input.UserInputType == Enum.UserInputType.MouseMovement
		if not sameTouch and not mouseMove then
			return
		end

		state.pointer = opts.getInputPosition(input)
		local delta = state.pointer - state.startPointer
		if not state.dragging and delta.Magnitude >= opts.dragThreshold then
			state.dragging = true
			panelData.Dragging = true
			opts.setPanelHoverState(panelData, true, false)
		end

		if state.dragging then
			local root = opts.ensureSplitRoot()
			local panelSize = opts.getPanelSize(root)
			local desired = state.startPosition + delta
			local clamped = opts.clampPositionToViewport(root, desired, panelSize)
			panelData.ManualPosition = clamped
			panelData.Frame.Position = UDim2.fromOffset(clamped.X, clamped.Y)
		end
	end, finishPress)

	table.insert(panelData.Cleanup, resetState)
end

return TabSplitDragDock
]])
put("src/feature/tabsplit/hover-effects.lua", [[local HoverEffects = {}

function HoverEffects.resolveAccent(theme)
	theme = theme or {}
	return theme.SliderProgress or theme.TabStroke or Color3.fromRGB(110, 175, 240)
end

function HoverEffects.getHoverStrokeState(isHovered)
	if isHovered then
		return {
			thickness = 1.2,
			transparency = 0.35
		}
	end
	return {
		thickness = 1,
		transparency = 0.5
	}
end

return HoverEffects]])
put("src/feature/tabsplit/init.lua", [[local client = _G and _G.__RayfieldApiClient
if not client then
	error("Rayfield ApiClient is not initialized")
end

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
return client.fetchAndExecute(root .. "src/feature/tabsplit/controller.lua")]])
put("src/feature/tabsplit/layout-free-drag.lua", [[local LayoutFreeDrag = {}

function LayoutFreeDrag.clampToViewport(position, size, viewportSize, margin)
	margin = margin or 8
	local x = math.clamp(position.X.Offset, margin, math.max(margin, viewportSize.X - size.X.Offset - margin))
	local y = math.clamp(position.Y.Offset, margin, math.max(margin, viewportSize.Y - size.Y.Offset - margin))
	return UDim2.new(0, x, 0, y)
end

return LayoutFreeDrag]])
put("src/feature/tabsplit/panel.lua", [[local TabSplitPanel = {}

function TabSplitPanel.bindHover(panelData, syncPanelHover)
	table.insert(panelData.Cleanup, panelData.Frame.MouseEnter:Connect(function()
		panelData.HoverPanel = true
		syncPanelHover()
	end))
	table.insert(panelData.Cleanup, panelData.Frame.MouseLeave:Connect(function()
		panelData.HoverPanel = false
		syncPanelHover()
	end))
	table.insert(panelData.Cleanup, panelData.Header.MouseEnter:Connect(function()
		panelData.HoverHeader = true
		syncPanelHover()
	end))
	table.insert(panelData.Cleanup, panelData.Header.MouseLeave:Connect(function()
		panelData.HoverHeader = false
		syncPanelHover()
	end))
	table.insert(panelData.Cleanup, panelData.DockButton.MouseEnter:Connect(function()
		panelData.HoverDock = true
		syncPanelHover()
	end))
	table.insert(panelData.Cleanup, panelData.DockButton.MouseLeave:Connect(function()
		panelData.HoverDock = false
		syncPanelHover()
	end))
end

function TabSplitPanel.createShell(opts)
	local panel = Instance.new("Frame")
	panel.Name = "TabSplitPanel-" .. tostring(opts.tabRecord.Name)
	panel.BackgroundColor3 = (opts.theme and opts.theme.SecondaryElementBackground) or Color3.fromRGB(35, 35, 35)
	panel.BorderSizePixel = 0
	panel.ZIndex = opts.baseZ
	panel.Parent = opts.root

	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 9)
	corner.Parent = panel

	local stroke = Instance.new("UIStroke")
	stroke.Color = (opts.theme and opts.theme.ElementStroke) or Color3.fromRGB(80, 80, 80)
	stroke.Thickness = 1.1
	stroke.Transparency = 0.25
	stroke.Parent = panel

	local glowStroke = Instance.new("UIStroke")
	glowStroke.Color = (opts.theme and opts.theme.SliderProgress) or Color3.fromRGB(112, 189, 255)
	glowStroke.Thickness = 1.2
	glowStroke.Transparency = 1
	glowStroke.Parent = panel

	local softGlowStroke = Instance.new("UIStroke")
	softGlowStroke.Color = (opts.theme and opts.theme.SliderProgress) or Color3.fromRGB(112, 189, 255)
	softGlowStroke.Thickness = 2.8
	softGlowStroke.Transparency = 1
	softGlowStroke.Parent = panel

	local header = Instance.new("Frame")
	header.Name = "Header"
	header.BackgroundColor3 = (opts.theme and opts.theme.Topbar) or Color3.fromRGB(25, 25, 25)
	header.BorderSizePixel = 0
	header.Size = UDim2.new(1, 0, 0, 34)
	header.ZIndex = panel.ZIndex + 1
	header.Parent = panel
	header.Active = true

	local headerCorner = Instance.new("UICorner")
	headerCorner.CornerRadius = UDim.new(0, 9)
	headerCorner.Parent = header

	local title = Instance.new("TextLabel")
	title.Name = "Title"
	title.BackgroundTransparency = 1
	title.Size = UDim2.new(1, -96, 1, 0)
	title.Position = UDim2.new(0, 10, 0, 0)
	title.Text = tostring(opts.tabRecord.Name)
	title.TextColor3 = (opts.theme and opts.theme.TextColor) or Color3.fromRGB(255, 255, 255)
	title.Font = Enum.Font.GothamSemibold
	title.TextSize = 12
	title.TextXAlignment = Enum.TextXAlignment.Left
	title.ZIndex = header.ZIndex + 1
	title.Parent = header

	local dockButton = Instance.new("TextButton")
	dockButton.Name = "Dock"
	dockButton.Size = UDim2.fromOffset(64, 22)
	dockButton.Position = UDim2.new(1, -74, 0.5, -11)
	dockButton.BackgroundColor3 = (opts.theme and opts.theme.ElementBackgroundHover) or Color3.fromRGB(55, 55, 55)
	dockButton.BorderSizePixel = 0
	dockButton.Text = "Dock"
	dockButton.TextColor3 = (opts.theme and opts.theme.TextColor) or Color3.fromRGB(255, 255, 255)
	dockButton.Font = Enum.Font.GothamBold
	dockButton.TextSize = 10
	dockButton.ZIndex = header.ZIndex + 1
	dockButton.Parent = header

	local dockCorner = Instance.new("UICorner")
	dockCorner.CornerRadius = UDim.new(0, 6)
	dockCorner.Parent = dockButton

	local content = Instance.new("Frame")
	content.Name = "Content"
	content.BackgroundTransparency = 1
	content.BorderSizePixel = 0
	content.Position = UDim2.fromOffset(0, 34)
	content.Size = UDim2.new(1, 0, 1, -34)
	content.ClipsDescendants = true
	content.Active = true
	content.ZIndex = panel.ZIndex + 1
	content.Parent = panel

	local panelData = {
		Id = opts.panelId,
		Frame = panel,
		Header = header,
		Title = title,
		DockButton = dockButton,
		Content = content,
		Stroke = stroke,
		GlowStroke = glowStroke,
		SoftGlowStroke = softGlowStroke,
		TabRecord = opts.tabRecord,
		Cleanup = {},
		InputId = opts.inputId,
		ManualPosition = nil,
		Dragging = false,
		HoverPanel = false,
		HoverHeader = false,
		HoverDock = false,
		HoverActive = false,
		LayerZ = opts.baseZ
	}

	local function syncPanelHover()
		panelData.HoverActive = panelData.HoverPanel or panelData.HoverHeader or panelData.HoverDock
		if not panelData.Dragging then
			opts.setPanelHoverState(panelData, panelData.HoverActive, false)
		end
	end

	TabSplitPanel.bindHover(panelData, syncPanelHover)
	return panelData
end

return TabSplitPanel
]])
put("src/feature/tabsplit/state.lua", [[local TabSplitState = {}

function TabSplitState.create(ctx)
	local sharedInputChanged = {}
	local sharedInputEnded = {}
	local sharedInputConnections = nil

	local function ensureSharedInput()
		if sharedInputConnections then
			return
		end

		sharedInputConnections = {
			ctx.UserInputService.InputChanged:Connect(function(input)
				for _, cb in pairs(sharedInputChanged) do
					cb(input)
				end
			end),
			ctx.UserInputService.InputEnded:Connect(function(input)
				for _, cb in pairs(sharedInputEnded) do
					cb(input)
				end
			end)
		}
	end

	local function registerSharedInput(id, onChanged, onEnded)
		ensureSharedInput()
		if type(onChanged) == "function" then
			sharedInputChanged[id] = onChanged
		end
		if type(onEnded) == "function" then
			sharedInputEnded[id] = onEnded
		end
	end

	local function unregisterSharedInput(id)
		sharedInputChanged[id] = nil
		sharedInputEnded[id] = nil
	end

	local function disconnectSharedInput()
		table.clear(sharedInputChanged)
		table.clear(sharedInputEnded)
		if sharedInputConnections then
			for _, connection in ipairs(sharedInputConnections) do
				if connection then
					connection:Disconnect()
				end
			end
			sharedInputConnections = nil
		end
	end

	local function getInputPosition(input)
		if input and input.Position then
			return Vector2.new(input.Position.X, input.Position.Y)
		end
		return ctx.UserInputService:GetMouseLocation()
	end

	local function isPointInside(guiObject, point, padding)
		if not (guiObject and guiObject.Parent and point) then
			return false
		end

		local pad = padding or 0
		local absPos = guiObject.AbsolutePosition
		local absSize = guiObject.AbsoluteSize
		return point.X >= (absPos.X - pad)
			and point.X <= (absPos.X + absSize.X + pad)
			and point.Y >= (absPos.Y - pad)
			and point.Y <= (absPos.Y + absSize.Y + pad)
	end

	local function isPointInsideMain(point)
		return isPointInside(ctx.Main, point, 0)
	end

	local function isPointInsideTabList(point)
		return isPointInside(ctx.TabList, point, 10)
	end

	local function clampPositionToViewport(root, desiredPosition, panelSize, panelMargin)
		local margin = panelMargin or 8
		local viewport = root.AbsoluteSize
		local clampedX = math.clamp(
			desiredPosition.X,
			margin,
			math.max(margin, viewport.X - panelSize.X - margin)
		)
		local clampedY = math.clamp(
			desiredPosition.Y,
			margin,
			math.max(margin, viewport.Y - panelSize.Y - margin)
		)
		return Vector2.new(clampedX, clampedY)
	end

	local function hasZIndex(guiObject)
		return pcall(function()
			local _ = guiObject.ZIndex
		end)
	end

	return {
		ensureSharedInput = ensureSharedInput,
		registerSharedInput = registerSharedInput,
		unregisterSharedInput = unregisterSharedInput,
		disconnectSharedInput = disconnectSharedInput,
		getInputPosition = getInputPosition,
		isPointInside = isPointInside,
		isPointInsideMain = isPointInsideMain,
		isPointInsideTabList = isPointInsideTabList,
		clampPositionToViewport = clampPositionToViewport,
		hasZIndex = hasZIndex
	}
end

return TabSplitState
]])
put("src/feature/tabsplit/zindex.lua", [[local ZIndex = {}

function ZIndex.capture(root)
	local map = setmetatable({}, { __mode = "k" })
	if not root then
		return map
	end
	for _, descendant in ipairs(root:GetDescendants()) do
		if descendant:IsA("GuiObject") then
			map[descendant] = descendant.ZIndex
		end
	end
	if root:IsA("GuiObject") then
		map[root] = root.ZIndex
	end
	return map
end

function ZIndex.apply(root, map, zBase)
	if not root or not map then
		return
	end
	zBase = zBase or 20
	for instance, original in pairs(map) do
		if instance and instance.Parent and instance:IsA("GuiObject") then
			instance.ZIndex = math.max(original, zBase)
		end
	end
end

function ZIndex.restore(map)
	if not map then
		return
	end
	for instance, original in pairs(map) do
		if instance and instance.Parent and instance:IsA("GuiObject") then
			instance.ZIndex = original
		end
	end
end

return ZIndex]])
put("src/legacy/forward.lua", [[local Forward = {}

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
local compileString = loadstring or load
if not compileString then
	error("No Lua compiler function available (loadstring/load)")
end

local function compileChunk(source, label)
	if type(source) ~= "string" then
		error("Invalid Lua source for " .. tostring(label) .. ": " .. type(source))
	end
	source = source:gsub("^\239\187\191", "")
	source = source:gsub("^\0+", "")
	local chunk, err = compileString(source)
	if not chunk then
		error("Failed to compile " .. tostring(label) .. ": " .. tostring(err))
	end
	return chunk
end

local clientSource = game:HttpGet(root .. "src/api/client.lua")
local client = compileChunk(clientSource, "src/api/client.lua")()
if type(client) ~= "table" or type(client.fetchAndExecute) ~= "function" then
	error("Invalid API client bootstrap: missing fetchAndExecute")
end

if _G and _G.__RayfieldWidgetBootstrap == nil then
	local okBootstrap, bootstrapModule = pcall(client.fetchAndExecute, root .. "src/ui/elements/widgets/bootstrap.lua")
	if not okBootstrap then
		error("Failed to preload widget bootstrap: " .. tostring(bootstrapModule))
	end
	if type(bootstrapModule) ~= "table" or type(bootstrapModule.bootstrapWidget) ~= "function" then
		error("Invalid widget bootstrap module: missing bootstrapWidget")
	end
	_G.__RayfieldWidgetBootstrap = bootstrapModule
end

local loader = client.fetchAndExecute(root .. "src/api/loader.lua")
if type(loader) ~= "table" or type(loader.load) ~= "function" then
	error("Invalid API loader bootstrap: missing loader.load")
end

local function getScriptRef()
	local scriptRef = nil
	pcall(function()
		scriptRef = script
	end)
	return scriptRef
end

function Forward.module(moduleName)
	return loader.load(moduleName, {
		tryStudioRequire = false,
		scriptRef = getScriptRef()
	})
end

function Forward.path(path)
	return loader.loadPath(path)
end

return Forward
]])
put("src/legacy/map.lua", [[return {
	legacyWrappers = {
		"Main loader/rayfield-modified.lua",
		"Main loader/rayfield-all-in-one.lua",
		"feature/rayfield-all-in-one.lua",
		"feature/rayfield-theme.lua",
		"feature/rayfield-settings.lua",
		"feature/rayfield-config.lua",
		"feature/rayfield-utilities.lua",
		"feature/rayfield-ui-state.lua",
		"feature/rayfield-elements.lua",
		"feature/rayfield-elements-extracted.lua",
		"feature/rayfield-drag.lua",
		"feature/rayfield-tab-split.lua",
		"feature/mini-window-system.lua",
		"feature/rayfield-enhanced.lua",
		"feature/rayfield-advanced-features.lua"
	}
}
]])
put("src/services/config.lua", [[-- Rayfield Configuration Management Module
-- Handles configuration save/load and color packing

local ConfigModule = {}

function ConfigModule.init(ctx)
	local self = {}
	
	-- Inject dependencies
	self.HttpService = ctx.HttpService
	self.RayfieldLibrary = ctx.RayfieldLibrary
	self.callSafely = ctx.callSafely
	self.ConfigurationFolder = ctx.ConfigurationFolder
	self.ConfigurationExtension = ctx.ConfigurationExtension
	self.getCFileName = ctx.getCFileName
	self.getCEnabled = ctx.getCEnabled
	self.getGlobalLoaded = ctx.getGlobalLoaded
	self.useStudio = ctx.useStudio
	self.debugX = ctx.debugX
	
	-- Color packing/unpacking utilities
	local function PackColor(Color)
		return {R = Color.R * 255, G = Color.G * 255, B = Color.B * 255}
	end
	
	local function UnpackColor(Color)
		return Color3.fromRGB(Color.R, Color.G, Color.B)
	end

	local function cloneValue(value)
		if type(value) ~= "table" then
			return value
		end
		local out = {}
		for key, nested in pairs(value) do
			out[key] = cloneValue(nested)
		end
		return out
	end

	local function valuesEqual(left, right)
		if left == right then
			return true
		end
		if type(left) ~= "table" or type(right) ~= "table" then
			return false
		end
		for key, value in pairs(left) do
			if not valuesEqual(value, right[key]) then
				return false
			end
		end
		for key in pairs(right) do
			if left[key] == nil then
				return false
			end
		end
		return true
	end

	local function getPersistValue(flag)
		if type(flag) ~= "table" then
			return nil
		end

		if flag.Type == "ColorPicker" and flag.Color then
			return PackColor(flag.Color)
		end

		if type(flag.GetPersistValue) == "function" then
			local ok, value = pcall(flag.GetPersistValue, flag)
			if ok then
				return cloneValue(value)
			end
		end

		local value = flag.CurrentValue
		if value == nil then
			value = flag.CurrentKeybind or flag.CurrentOption or flag.Color
		end
		return cloneValue(value)
	end

	-- Load configuration from JSON string
	local function LoadConfiguration(Configuration)
		local success, Data = pcall(function() return self.HttpService:JSONDecode(Configuration) end)
		local changed = false
		
		if not success then 
			warn('Rayfield had an issue decoding the configuration file, please try delete the file and reopen Rayfield.') 
			return 
		end
		
		-- Iterate through current UI elements' flags
		for FlagName, Flag in pairs(self.RayfieldLibrary.Flags) do
			local FlagValue = Data[FlagName]
			
			if (typeof(FlagValue) == 'boolean' and FlagValue == false) or FlagValue then
				local beforeValue = getPersistValue(Flag)
				local nextValue = cloneValue(FlagValue)
				if Flag.Type == "ColorPicker" then
					nextValue = UnpackColor(FlagValue)
				end
				if type(Flag.Set) == "function" then
					local okSet, errSet = pcall(Flag.Set, Flag, nextValue)
					if not okSet then
						warn("Rayfield | Failed to apply flag '" .. tostring(FlagName) .. "': " .. tostring(errSet))
					end
				else
					warn("Rayfield | Flag '" .. tostring(FlagName) .. "' is missing Set()")
				end
				local afterValue = getPersistValue(Flag)
				if not valuesEqual(beforeValue, afterValue) then
					changed = true
				end
			else
				warn("Rayfield | Unable to find '"..FlagName.. "' in the save file.")
				print("The error above may not be an issue if new elements have been added or not been set values.")
			end
		end
		
		return changed
	end
	
	-- Save configuration to file
	local function SaveConfiguration()
		if not self.getCEnabled() or not self.getGlobalLoaded() then return end
		
		if self.debugX then
			print('Saving')
		end
		
		local Data = {}
		for i, v in pairs(self.RayfieldLibrary.Flags) do
			Data[i] = getPersistValue(v)
		end
		
		if self.useStudio then
			if script.Parent:FindFirstChild('configuration') then 
				script.Parent.configuration:Destroy() 
			end
			
			local ScreenGui = Instance.new("ScreenGui")
			ScreenGui.Parent = script.Parent
			ScreenGui.Name = 'configuration'
			
			local TextBox = Instance.new("TextBox")
			TextBox.Parent = ScreenGui
			TextBox.Size = UDim2.new(0, 800, 0, 50)
			TextBox.AnchorPoint = Vector2.new(0.5, 0)
			TextBox.Position = UDim2.new(0.5, 0, 0, 30)
			TextBox.Text = self.HttpService:JSONEncode(Data)
			TextBox.ClearTextOnFocus = false
		end
		
		if self.debugX then
			warn(self.HttpService:JSONEncode(Data))
		end
		
		self.callSafely(writefile, self.ConfigurationFolder .. "/" .. self.getCFileName() .. self.ConfigurationExtension, tostring(self.HttpService:JSONEncode(Data)))
	end
	
	-- Export functions
	self.PackColor = PackColor
	self.UnpackColor = UnpackColor
	self.LoadConfiguration = LoadConfiguration
	self.SaveConfiguration = SaveConfiguration
	
	return self
end

return ConfigModule
]])
put("src/services/element-sync.lua", [[-- Rayfield unified element state/visual synchronization service
-- Pipeline: normalize -> applyVisual -> emitCallback -> persist

local ElementSyncModule = {}

local TRACE_FLAG = "__RAYFIELD_ELEMENT_SYNC_TRACE"
local TRACE_PREFIX = "[RAYFIELD][ELEMENT_SYNC]"

local function trim(value)
	if type(value) ~= "string" then
		return ""
	end
	local out = value:gsub("^%s+", "")
	out = out:gsub("%s+$", "")
	return out
end

local function cloneArray(source)
	local result = {}
	if type(source) ~= "table" then
		return result
	end
	for index, value in ipairs(source) do
		result[index] = value
	end
	return result
end

local function cloneTable(source)
	if type(source) ~= "table" then
		return source
	end
	local result = {}
	for key, value in pairs(source) do
		if type(value) == "table" then
			result[key] = cloneTable(value)
		else
			result[key] = value
		end
	end
	return result
end

local function deepEqual(left, right, seen)
	if left == right then
		return true
	end
	if type(left) ~= "table" or type(right) ~= "table" then
		return false
	end

	seen = seen or {}
	if seen[left] and seen[left] == right then
		return true
	end
	seen[left] = right

	for key, value in pairs(left) do
		if not deepEqual(value, right[key], seen) then
			return false
		end
	end

	for key in pairs(right) do
		if left[key] == nil then
			return false
		end
	end

	return true
end

local function defaultWarn(message)
	warn(TRACE_PREFIX .. " " .. tostring(message))
end

local function shouldTrace()
	return type(_G) == "table" and _G[TRACE_FLAG] == true
end

local function trace(branchId, payload)
	if not shouldTrace() then
		return
	end
	local data = payload or {}
	print(string.format(
		"%s branch_id=%s stage=%s token=%s reason=%s",
		TRACE_PREFIX,
		tostring(branchId or "unknown"),
		tostring(data.stage or "n/a"),
		tostring(data.token or "n/a"),
		tostring(data.reason or "n/a")
	))
end

local function fail(code, message)
	error(string.format("[%s] %s", tostring(code), tostring(message)), 2)
end

local function normalizeBoolean(rawValue)
	return rawValue == true
end

local function normalizeNumberRange(rawValue, options)
	local opts = options or {}
	local minValue = tonumber(opts.min) or 0
	local maxValue = tonumber(opts.max) or 1
	if maxValue <= minValue then
		maxValue = minValue + 1
	end

	local increment = tonumber(opts.increment) or 1
	if increment <= 0 then
		increment = 1
	end

	local value = tonumber(rawValue)
	if value == nil then
		value = tonumber(opts.default) or minValue
	end
	value = math.clamp(value, minValue, maxValue)
	value = math.floor((value / increment) + 0.5) * increment
	value = math.floor((value * 10000000) + 0.5) / 10000000
	value = math.clamp(value, minValue, maxValue)
	return value
end

local function normalizeText(rawValue, options)
	local opts = options or {}
	local value = rawValue
	if value == nil then
		value = opts.default
	end
	if value == nil then
		value = ""
	end
	value = tostring(value)
	if opts.trim ~= false then
		value = trim(value)
	end
	return value
end

local function normalizeSelection(rawSelection, options)
	local opts = options or {}
	local allowedMap = {}
	local normalizedAllowed = {}

	if type(opts.allowedValues) == "table" then
		for _, entry in ipairs(opts.allowedValues) do
			local key = tostring(entry)
			if not allowedMap[key] then
				allowedMap[key] = true
				table.insert(normalizedAllowed, key)
			end
		end
	end

	local function toArray(value)
		local out = {}
		if value == nil then
			return out
		end
		if type(value) == "string" then
			out[1] = value
			return out
		end
		if type(value) ~= "table" then
			out[1] = tostring(value)
			return out
		end

		if #value > 0 then
			for _, entry in ipairs(value) do
				if entry ~= nil then
					table.insert(out, tostring(entry))
				end
			end
		else
			for _, entry in pairs(value) do
				if entry ~= nil then
					table.insert(out, tostring(entry))
				end
			end
		end
		return out
	end

	local multiple = opts.multiple == true
	local dedupe = {}
	local normalized = {}
	for _, entry in ipairs(toArray(rawSelection)) do
		if (next(allowedMap) == nil or allowedMap[entry]) and not dedupe[entry] then
			dedupe[entry] = true
			table.insert(normalized, entry)
		end
	end

	if not multiple and #normalized > 1 then
		normalized = { normalized[1] }
	end

	local fallbackApplied = false
	local fallbackPolicy = tostring(opts.clearBehavior or "default"):lower()
	if fallbackPolicy ~= "none" and #normalized == 0 then
		local fallback = {}
		for _, entry in ipairs(toArray(opts.defaultSelection)) do
			if (next(allowedMap) == nil or allowedMap[entry]) and not dedupe[entry] then
				dedupe[entry] = true
				table.insert(fallback, entry)
			end
		end
		if not multiple and #fallback > 1 then
			fallback = { fallback[1] }
		end
		if #fallback > 0 then
			normalized = fallback
			fallbackApplied = true
		end
	end

	local previous = opts.previousSelection
	local changed = not deepEqual(previous, normalized)
	return normalized, {
		fallbackApplied = fallbackApplied,
		changed = changed,
		allowedValues = normalizedAllowed
	}
end

function ElementSyncModule.init(ctx)
	local self = {}
	local context = ctx or {}
	local warningFn = type(context.warn) == "function" and context.warn or defaultWarn

	local records = {}
	local recordsByTab = {}
	local tokenCounter = 0

	local function unregister(token)
		local record = records[token]
		if not record then
			return false
		end
		records[token] = nil

		local tabId = record.tabId or "__global"
		local tabBucket = recordsByTab[tabId]
		if tabBucket then
			tabBucket[token] = nil
			if next(tabBucket) == nil then
				recordsByTab[tabId] = nil
			end
		end

		trace("UNREGISTER", {
			stage = "unregister",
			token = token,
			reason = "record_removed"
		})
		return true
	end

	local function register(spec)
		if type(spec) ~= "table" then
			fail("E_SPEC_INVALID", "register(spec) expects table")
		end
		if type(spec.getState) ~= "function" then
			fail("E_SPEC_INVALID", "spec.getState must be a function")
		end
		if type(spec.normalize) ~= "function" then
			fail("E_SPEC_INVALID", "spec.normalize must be a function")
		end
		if type(spec.applyVisual) ~= "function" then
			fail("E_SPEC_INVALID", "spec.applyVisual must be a function")
		end
		if type(spec.emitCallback) ~= "function" then
			fail("E_SPEC_INVALID", "spec.emitCallback must be a function")
		end
		if type(spec.persist) ~= "function" then
			fail("E_SPEC_INVALID", "spec.persist must be a function")
		end

		tokenCounter += 1
		local token = "element_sync_" .. tostring(tokenCounter)
		spec.token = token
		records[token] = spec

		local tabId = spec.tabId or "__global"
		recordsByTab[tabId] = recordsByTab[tabId] or {}
		recordsByTab[tabId][token] = true

		trace("REGISTER", {
			stage = "register",
			token = token,
			reason = tostring(spec.name or "unnamed")
		})
		return token
	end

	local function isRecordActive(record)
		if not record then
			return false
		end
		if type(record.isAlive) == "function" then
			local ok, alive = pcall(record.isAlive)
			if not ok or alive == false then
				return false
			end
		end
		return true
	end

	local function commit(token, nextState, options)
		options = options or {}
		local record = records[token]
		if not record then
			return false, { error = "record_missing" }
		end
		if not isRecordActive(record) then
			unregister(token)
			return false, { error = "record_inactive" }
		end

		local previousState = nil
		local okPrev, prevResult = pcall(record.getState)
		if okPrev then
			previousState = cloneTable(prevResult)
		end

		trace("COMMIT_NORMALIZE", {
			stage = "normalize",
			token = token,
			reason = options.reason or "unknown"
		})
		local normalizeOk, normalizedState, normalizeMeta = pcall(record.normalize, nextState, {
			previousState = previousState,
			reason = options.reason,
			source = options.source,
			options = options
		})
		if not normalizeOk then
			warningFn("normalize failed for token=" .. tostring(token) .. " error=" .. tostring(normalizedState))
			return false, { error = "normalize_failed", detail = normalizedState }
		end

		local meta = type(normalizeMeta) == "table" and normalizeMeta or {}
		local changed = meta.changed
		if changed == nil then
			changed = not deepEqual(previousState, normalizedState)
		end
		local fallbackApplied = meta.fallbackApplied == true
		local emitCallback = options.emitCallback
		if emitCallback == nil then
			emitCallback = true
		end
		local shouldPersist = options.persist
		if shouldPersist == nil then
			shouldPersist = true
		end

		trace("COMMIT_VISUAL", {
			stage = "applyVisual",
			token = token,
			reason = options.reason or "unknown"
		})
		local visualOk, visualErr = pcall(record.applyVisual, normalizedState, {
			previousState = previousState,
			changed = changed,
			fallbackApplied = fallbackApplied,
			reason = options.reason,
			source = options.source,
			options = options
		})
		if not visualOk then
			warningFn("applyVisual failed for token=" .. tostring(token) .. " error=" .. tostring(visualErr))
		end

		local callbackOk = true
		local callbackErr = nil
		local shouldEmit = emitCallback and (changed or fallbackApplied or options.forceCallback == true)
		if shouldEmit then
			trace("COMMIT_CALLBACK", {
				stage = "emitCallback",
				token = token,
				reason = options.reason or "unknown"
			})
			callbackOk, callbackErr = pcall(record.emitCallback, normalizedState, {
				previousState = previousState,
				changed = changed,
				fallbackApplied = fallbackApplied,
				reason = options.reason,
				source = options.source,
				options = options
			})
			if not callbackOk and type(record.onCallbackError) == "function" then
				pcall(record.onCallbackError, callbackErr)
			end
		end

		local isExt = false
		if type(record.isExt) == "function" then
			local okExt, value = pcall(record.isExt)
			isExt = okExt and value == true or false
		end

		if shouldPersist and callbackOk and not isExt then
			trace("COMMIT_PERSIST", {
				stage = "persist",
				token = token,
				reason = options.reason or "unknown"
			})
			local okPersist, persistErr = pcall(record.persist, normalizedState, {
				previousState = previousState,
				changed = changed,
				fallbackApplied = fallbackApplied,
				reason = options.reason,
				source = options.source,
				options = options
			})
			if not okPersist then
				warningFn("persist failed for token=" .. tostring(token) .. " error=" .. tostring(persistErr))
			end
		end

		local result = {
			token = token,
			normalized = cloneTable(normalizedState),
			changed = changed,
			fallbackApplied = fallbackApplied,
			callbackOk = callbackOk,
			callbackError = callbackErr,
			reason = options.reason,
			source = options.source
		}

		return callbackOk, result
	end

	local function resync(token, reason)
		local record = records[token]
		if not record then
			return false
		end
		if type(record.isVisibleContext) == "function" then
			local okVisible, visible = pcall(record.isVisibleContext)
			if not okVisible or visible == false then
				return false
			end
		end
		local okState, currentState = pcall(record.getState)
		if not okState then
			return false
		end
		local _, result = commit(token, currentState, {
			reason = reason or "resync",
			source = "resync",
			emitCallback = false,
			persist = false,
			forceCallback = false
		})
		return result ~= nil
	end

	local function resyncTab(tabId, reason)
		local bucket = recordsByTab[tabId or "__global"]
		if not bucket then
			return 0
		end
		local syncedCount = 0
		for token in pairs(bucket) do
			if resync(token, reason or "resync_tab") then
				syncedCount += 1
			end
		end
		return syncedCount
	end

	local function destroy()
		for token in pairs(records) do
			records[token] = nil
		end
		for tabId in pairs(recordsByTab) do
			recordsByTab[tabId] = nil
		end
	end

	self.register = register
	self.unregister = unregister
	self.commit = commit
	self.resync = resync
	self.resyncTab = resyncTab
	self.destroy = destroy
	self.normalize = {
		boolean = normalizeBoolean,
		numberRange = normalizeNumberRange,
		text = normalizeText,
		selection = normalizeSelection
	}

	return self
end

return ElementSyncModule
]])
put("src/services/keybind-sequence.lua", [[local KeybindSequence = {}

local DEFAULT_MAX_STEPS = 4
local DEFAULT_STEP_TIMEOUT_MS = 800

local MODIFIER_ORDER = {
	"LeftControl",
	"RightControl",
	"LeftShift",
	"RightShift",
	"LeftAlt",
	"RightAlt"
}

local MODIFIER_SET = {
	LeftControl = true,
	RightControl = true,
	LeftShift = true,
	RightShift = true,
	LeftAlt = true,
	RightAlt = true
}

local TOKEN_ALIASES = {
	ctrl = "LeftControl",
	control = "LeftControl",
	leftctrl = "LeftControl",
	leftcontrol = "LeftControl",
	rightctrl = "RightControl",
	rightcontrol = "RightControl",
	shift = "LeftShift",
	leftshift = "LeftShift",
	rightshift = "RightShift",
	alt = "LeftAlt",
	leftalt = "LeftAlt",
	rightalt = "RightAlt"
}

local DISPLAY_TOKEN_MAP = {
	LeftControl = "Ctrl",
	RightControl = "Ctrl",
	LeftShift = "Shift",
	RightShift = "Shift",
	LeftAlt = "Alt",
	RightAlt = "Alt"
}

local function trim(value)
	if type(value) ~= "string" then
		return ""
	end
	local out = value:gsub("^%s+", "")
	out = out:gsub("%s+$", "")
	return out
end

local function split(value, separator)
	local list = {}
	if type(value) ~= "string" or value == "" then
		return list
	end

	local pattern = string.format("([^%s]+)", separator)
	for token in string.gmatch(value, pattern) do
		table.insert(list, token)
	end
	return list
end

local function toNumber(value, fallback)
	local numberValue = tonumber(value)
	if numberValue == nil then
		return fallback
	end
	return numberValue
end

local function resolveToken(rawToken)
	if typeof(rawToken) == "EnumItem" and rawToken.EnumType == Enum.KeyCode then
		return rawToken.Name
	end

	local token = trim(tostring(rawToken or ""))
	if token == "" then
		return nil, "empty_token"
	end

	token = token:gsub("^Enum%.KeyCode%.", "")
	token = token:gsub("^KeyCode%.", "")
	local lowerToken = string.lower(token)

	if TOKEN_ALIASES[lowerToken] then
		return TOKEN_ALIASES[lowerToken]
	end

	local ok, keyCode = pcall(function()
		return Enum.KeyCode[token]
	end)
	if ok and keyCode then
		return keyCode.Name
	end

	return nil, "invalid_token:" .. tostring(token)
end

local function isModifierName(name)
	return MODIFIER_SET[name] == true
end

local function orderedModifierNames(modifierMap)
	local ordered = {}
	for _, modifierName in ipairs(MODIFIER_ORDER) do
		if modifierMap[modifierName] then
			table.insert(ordered, modifierName)
		end
	end
	return ordered
end

local function parseStep(stepString)
	local tokens = split(stepString, "+")
	if #tokens == 0 then
		return nil, "step_empty"
	end

	local modifierMap = {}
	local primary = nil

	for _, token in ipairs(tokens) do
		local resolvedToken, resolveErr = resolveToken(token)
		if not resolvedToken then
			return nil, resolveErr
		end

		if isModifierName(resolvedToken) then
			modifierMap[resolvedToken] = true
		else
			if primary ~= nil then
				return nil, "step_has_multiple_primary"
			end
			primary = resolvedToken
		end
	end

	if primary == nil then
		return nil, "step_missing_primary"
	end

	local modifiersOrdered = orderedModifierNames(modifierMap)
	local canonicalParts = {}
	for _, modifierName in ipairs(modifiersOrdered) do
		table.insert(canonicalParts, modifierName)
	end
	table.insert(canonicalParts, primary)

	return {
		primary = primary,
		modifierMap = modifierMap,
		modifiersOrdered = modifiersOrdered,
		canonical = table.concat(canonicalParts, "+")
	}
end

local function buildCanonicalFromSteps(steps)
	local parts = {}
	for _, step in ipairs(steps) do
		table.insert(parts, step.canonical)
	end
	return table.concat(parts, ">")
end

function KeybindSequence.parseCanonical(rawValue, options)
	local opts = options or {}
	local maxSteps = math.max(1, math.floor(toNumber(opts.maxSteps, DEFAULT_MAX_STEPS)))

	if rawValue == nil then
		return nil, nil, "binding_is_nil"
	end

	if typeof(rawValue) == "EnumItem" and rawValue.EnumType == Enum.KeyCode then
		rawValue = rawValue.Name
	end

	if type(rawValue) ~= "string" then
		return nil, nil, "binding_not_string"
	end

	local binding = trim(rawValue)
	if binding == "" then
		return nil, nil, "binding_empty"
	end

	local rawSteps = split(binding, ">")
	if #rawSteps == 0 then
		return nil, nil, "binding_has_no_steps"
	end
	if #rawSteps > maxSteps then
		return nil, nil, "binding_exceeds_max_steps"
	end

	local steps = {}
	for index, rawStep in ipairs(rawSteps) do
		local step, stepErr = parseStep(rawStep)
		if not step then
			return nil, nil, string.format("step_%d_%s", index, tostring(stepErr))
		end
		table.insert(steps, step)
	end

	local canonical = buildCanonicalFromSteps(steps)
	return canonical, steps, nil
end

function KeybindSequence.normalize(rawValue, options)
	local canonical, steps, parseErr = KeybindSequence.parseCanonical(rawValue, options)
	if canonical then
		return canonical, steps, nil
	end

	if type(rawValue) == "table" then
		if type(rawValue.Canonical) == "string" then
			return KeybindSequence.parseCanonical(rawValue.Canonical, options)
		end
		if type(rawValue.CurrentKeybind) == "string" then
			return KeybindSequence.parseCanonical(rawValue.CurrentKeybind, options)
		end
	end

	return nil, nil, parseErr
end

function KeybindSequence.parseUserInput(text, customParser, options)
	local opts = options or {}
	local fallbackToDefault = opts.fallbackToDefault ~= false

	if type(customParser) == "function" then
		local ok, customValueOrErr, maybeErr = pcall(customParser, text)
		if ok and customValueOrErr ~= nil then
			local canonical, steps, normalizeErr = KeybindSequence.normalize(customValueOrErr, options)
			if canonical then
				return canonical, steps, nil
			end
			if not fallbackToDefault then
				return nil, nil, normalizeErr
			end
		elseif not ok and not fallbackToDefault then
			return nil, nil, tostring(customValueOrErr)
		elseif ok and customValueOrErr == nil and not fallbackToDefault then
			return nil, nil, tostring(maybeErr or "custom_parser_returned_nil")
		end
	end

	return KeybindSequence.normalize(text, options)
end

function KeybindSequence.formatDisplay(rawValue, customFormatter, options)
	local canonical = nil
	local steps = nil
	if type(rawValue) == "table" and type(rawValue.canonical) == "string" and type(rawValue.steps) == "table" then
		canonical = rawValue.canonical
		steps = rawValue.steps
	elseif type(rawValue) == "table" and rawValue[1] and rawValue[1].canonical then
		steps = rawValue
		canonical = buildCanonicalFromSteps(steps)
	else
		canonical, steps = KeybindSequence.normalize(rawValue, options)
	end

	if not canonical or not steps then
		return ""
	end

	if type(customFormatter) == "function" then
		local ok, customText = pcall(customFormatter, canonical, steps)
		if ok and type(customText) == "string" and customText ~= "" then
			return customText
		end
	end

	local stepLabels = {}
	for _, step in ipairs(steps) do
		local tokens = {}
		for _, modifierName in ipairs(step.modifiersOrdered) do
			table.insert(tokens, DISPLAY_TOKEN_MAP[modifierName] or modifierName)
		end
		table.insert(tokens, DISPLAY_TOKEN_MAP[step.primary] or step.primary)
		table.insert(stepLabels, table.concat(tokens, " + "))
	end

	return table.concat(stepLabels, " > ")
end

function KeybindSequence.matchStep(input, stepSpec, userInputService)
	if not input or not stepSpec then
		return false
	end

	if input.UserInputType ~= Enum.UserInputType.Keyboard then
		return false
	end
	if not input.KeyCode or input.KeyCode == Enum.KeyCode.Unknown then
		return false
	end
	if input.KeyCode.Name ~= stepSpec.primary then
		return false
	end

	if not userInputService or type(userInputService.IsKeyDown) ~= "function" then
		return false
	end

	for modifierName in pairs(stepSpec.modifierMap) do
		local modifierCode = Enum.KeyCode[modifierName]
		if modifierCode and not userInputService:IsKeyDown(modifierCode) then
			return false
		end
	end

	return true
end

function KeybindSequence.captureStepFromInput(input, userInputService)
	if not input or input.UserInputType ~= Enum.UserInputType.Keyboard or not input.KeyCode or input.KeyCode == Enum.KeyCode.Unknown then
		return nil, nil, "input_not_keyboard"
	end

	local primaryName = input.KeyCode.Name
	if isModifierName(primaryName) then
		return nil, nil, "input_modifier_only"
	end

	local modifierTokens = {}
	if userInputService and type(userInputService.IsKeyDown) == "function" then
		for _, modifierName in ipairs(MODIFIER_ORDER) do
			local modifierCode = Enum.KeyCode[modifierName]
			if modifierCode and userInputService:IsKeyDown(modifierCode) then
				table.insert(modifierTokens, modifierName)
			end
		end
	end

	table.insert(modifierTokens, primaryName)
	local canonicalStep = table.concat(modifierTokens, "+")
	local stepSpec, stepErr = parseStep(canonicalStep)
	if not stepSpec then
		return nil, nil, stepErr
	end
	return stepSpec.canonical, stepSpec, nil
end

function KeybindSequence.newMatcher(options)
	local opts = options or {}
	local maxSteps = math.max(1, math.floor(toNumber(opts.maxSteps, DEFAULT_MAX_STEPS)))
	local timeoutMs = math.max(1, math.floor(toNumber(opts.stepTimeoutMs, DEFAULT_STEP_TIMEOUT_MS)))
	local timeoutSeconds = timeoutMs / 1000

	local stateIndex = 1
	local stateLastStepTime = nil
	local cachedCanonical = nil
	local cachedSteps = nil

	local function reset()
		stateIndex = 1
		stateLastStepTime = nil
	end

	local function ensureParsed(binding)
		if type(binding) == "table" and binding.canonical and binding.steps then
			return binding.canonical, binding.steps, nil
		end

		local canonical, steps, parseErr = KeybindSequence.normalize(binding, {
			maxSteps = maxSteps
		})
		if not canonical then
			return nil, nil, parseErr
		end

		return canonical, steps, nil
	end

	local function setBinding(binding)
		local canonical, steps, parseErr = ensureParsed(binding)
		if not canonical then
			return nil, nil, parseErr
		end
		cachedCanonical = canonical
		cachedSteps = steps
		reset()
		return canonical, steps, nil
	end

	local function consume(input, binding, userInputService, processed)
		if processed then
			return false, nil, nil
		end

		local canonical = cachedCanonical
		local steps = cachedSteps

		if binding ~= nil then
			local nextCanonical, nextSteps, parseErr = ensureParsed(binding)
			if not nextCanonical then
				reset()
				return false, nil, parseErr
			end
			if nextCanonical ~= cachedCanonical then
				cachedCanonical = nextCanonical
				cachedSteps = nextSteps
				reset()
			end
			canonical = cachedCanonical
			steps = cachedSteps
		end

		if not canonical or not steps or #steps == 0 then
			return false, nil, "binding_not_initialized"
		end

		local now = os.clock()
		if stateLastStepTime and (now - stateLastStepTime) > timeoutSeconds then
			reset()
		end

		local expectedStep = steps[stateIndex]
		if expectedStep and KeybindSequence.matchStep(input, expectedStep, userInputService) then
			if stateIndex >= #steps then
				reset()
				return true, expectedStep, nil
			end
			stateIndex += 1
			stateLastStepTime = now
			return false, expectedStep, nil
		end

		local firstStep = steps[1]
		if stateIndex ~= 1 and firstStep and KeybindSequence.matchStep(input, firstStep, userInputService) then
			if #steps == 1 then
				reset()
				return true, firstStep, nil
			end
			stateIndex = 2
			stateLastStepTime = now
			return false, firstStep, nil
		end

		reset()
		return false, nil, nil
	end

	return {
		reset = reset,
		setBinding = setBinding,
		consume = consume
	}
end

KeybindSequence.DEFAULT_MAX_STEPS = DEFAULT_MAX_STEPS
KeybindSequence.DEFAULT_STEP_TIMEOUT_MS = DEFAULT_STEP_TIMEOUT_MS

return KeybindSequence
]])
put("src/services/settings.lua", [=[--[[
	Rayfield Settings/Config System Module
	Extracted from rayfield-modified.lua
	
	This module handles:
	- Settings table management
	- Loading/saving settings from/to file
	- Settings UI creation
	- Setting overrides
]]

local SettingsModule = {}

-- Default settings table structure
SettingsModule.defaultSettings = {
	General = {
		rayfieldOpen = {Type = 'bind', Value = 'K', Name = 'Rayfield Keybind'},
	},
	System = {
		usageAnalytics = {Type = 'toggle', Value = true, Name = 'Anonymised Analytics'},
	}
}

-- Initialize module with dependencies
function SettingsModule.init(ctx)
	local self = {}
	
	-- Store dependencies from context
	self.RayfieldFolder = ctx.RayfieldFolder
	self.ConfigurationExtension = ctx.ConfigurationExtension
	self.HttpService = ctx.HttpService
	self.useStudio = ctx.useStudio
	self.callSafely = ctx.callSafely
	self.Topbar = ctx.Topbar
	self.TabList = ctx.TabList
	self.Elements = ctx.Elements
	
	-- State variables
	self.settingsTable = {}
	self.overriddenSettings = {}
	self.cachedSettings = nil
	self.settingsInitialized = false
	self.settingsCreated = false
	
	-- Initialize settings table with defaults
	for category, settings in pairs(SettingsModule.defaultSettings) do
		self.settingsTable[category] = {}
		for name, setting in pairs(settings) do
			self.settingsTable[category][name] = {
				Type = setting.Type,
				Value = setting.Value,
				Name = setting.Name,
				Element = nil
			}
		end
	end
	
	-- Override a setting value
	function self.overrideSetting(category, name, value)
		self.overriddenSettings[category .. "." .. name] = value
	end
	
	-- Get setting value (checks overrides first)
	function self.getSetting(category, name)
		if self.overriddenSettings[category .. "." .. name] ~= nil then
			return self.overriddenSettings[category .. "." .. name]
		elseif self.settingsTable[category][name] ~= nil then
			return self.settingsTable[category][name].Value
		end
	end
	
	-- Save settings to file
	function self.saveSettings()
		local encoded
		local success, err = pcall(function()
			encoded = self.HttpService:JSONEncode(self.settingsTable)
		end)

		if success then
			if self.useStudio then
				if script.Parent['get.val'] then
					script.Parent['get.val'].Value = encoded
				end
			end
			self.callSafely(writefile, self.RayfieldFolder..'/settings'..self.ConfigurationExtension, encoded)
		end
	end
	
	-- Update a setting and save
	function self.updateSetting(category, setting, value)
		if not self.settingsInitialized then
			return
		end
		self.settingsTable[category][setting].Value = value
		self.overriddenSettings[category .. "." .. setting] = nil
		self.saveSettings()
	end
	
	-- Load settings from file
	function self.loadSettings()
		local file = nil

		local success, result = pcall(function()
			task.spawn(function()
				if self.callSafely(isfolder, self.RayfieldFolder) then
					if self.callSafely(isfile, self.RayfieldFolder..'/settings'..self.ConfigurationExtension) then
						file = self.callSafely(readfile, self.RayfieldFolder..'/settings'..self.ConfigurationExtension)
					end
				end

				-- for debug in studio
				if self.useStudio then
					file = [[
			{"General":{"rayfieldOpen":{"Value":"K","Type":"bind","Name":"Rayfield Keybind","Element":{"HoldToInteract":false,"Ext":true,"Name":"Rayfield Keybind","Set":null,"CallOnChange":true,"Callback":null,"CurrentKeybind":"K"}}},"System":{"usageAnalytics":{"Value":false,"Type":"toggle","Name":"Anonymised Analytics","Element":{"Ext":true,"Name":"Anonymised Analytics","Set":null,"CurrentValue":false,"Callback":null}}}}
		]]
				end

				if file then
					local success, decodedFile = pcall(function() return self.HttpService:JSONDecode(file) end)
					if success and type(decodedFile) == "table" then
						file = decodedFile
					else
						file = {}
					end
				else
					file = {}
				end

				if not self.settingsCreated then 
					self.cachedSettings = file
					return
				end

				if type(file) == "table" and next(file) ~= nil then
					for categoryName, settingCategory in pairs(self.settingsTable) do
						if file[categoryName] then
							for settingName, setting in pairs(settingCategory) do
								if file[categoryName][settingName] then
									setting.Value = file[categoryName][settingName].Value
									setting.Element:Set(self.getSetting(categoryName, settingName))
								end
							end
						end
					end
				else
					for settingName, settingValue in self.overriddenSettings do
						local split = string.split(settingName, ".")
						assert(#split == 2, "Rayfield | Invalid overridden setting name: " .. settingName)
						local categoryName = split[1]
						local settingNameOnly = split[2]
						if self.settingsTable[categoryName] and self.settingsTable[categoryName][settingNameOnly] then
							self.settingsTable[categoryName][settingNameOnly].Element:Set(settingValue)
						end
					end
				end
				self.settingsInitialized = true
			end)
		end)
	end


	-- Create settings UI tab
	function self.createSettings(window)
		if not (writefile and isfile and readfile and isfolder and makefolder) and not self.useStudio then
			if self.Topbar['Settings'] then self.Topbar.Settings.Visible = false end
			self.Topbar['Search'].Position = UDim2.new(1, -75, 0.5, 0)
			warn('Can\'t create settings as no file-saving functionality is available.')
			return
		end

		local newTab = window:CreateTab('Rayfield Settings', 0, true)

		if self.TabList['Rayfield Settings'] then
			self.TabList['Rayfield Settings'].LayoutOrder = 1000
		end

		if self.Elements['Rayfield Settings'] then
			self.Elements['Rayfield Settings'].LayoutOrder = 1000
		end

		-- Create sections and elements
		for categoryName, settingCategory in pairs(self.settingsTable) do
			newTab:CreateSection(categoryName)

			for settingName, setting in pairs(settingCategory) do
				if setting.Type == 'input' then
					setting.Element = newTab:CreateInput({
						Name = setting.Name,
						CurrentValue = setting.Value,
						PlaceholderText = setting.Placeholder,
						Ext = true,
						RemoveTextAfterFocusLost = setting.ClearOnFocus,
						Callback = function(Value)
							self.updateSetting(categoryName, settingName, Value)
						end,
					})
				elseif setting.Type == 'toggle' then
					setting.Element = newTab:CreateToggle({
						Name = setting.Name,
						CurrentValue = setting.Value,
						Ext = true,
						Callback = function(Value)
							self.updateSetting(categoryName, settingName, Value)
						end,
					})
				elseif setting.Type == 'bind' then
					setting.Element = newTab:CreateKeybind({
						Name = setting.Name,
						CurrentKeybind = setting.Value,
						HoldToInteract = false,
						Ext = true,
						CallOnChange = true,
						Callback = function(Value)
							self.updateSetting(categoryName, settingName, Value)
						end,
					})
				end
			end
		end

		self.settingsCreated = true
		self.loadSettings()
		self.saveSettings()
	end

	return self
end

return SettingsModule
]=])
put("src/services/theme.lua", [=[--[[
	Rayfield Theme System Module
	Extracted from rayfield-modified.lua
	
	This module handles:
	- Theme definitions (Default, Ocean, AmberGlow, Light, Amethyst, Green, Bloom, DarkBlue, Serenity)
	- Theme switching functionality
	- Icon system integration
]]

local ThemeModule = {}

-- Theme Definitions
ThemeModule.Themes = {
	Default = {
		TextColor = Color3.fromRGB(240, 240, 240),

		Background = Color3.fromRGB(25, 25, 25),
		Topbar = Color3.fromRGB(34, 34, 34),
		Shadow = Color3.fromRGB(20, 20, 20),

		NotificationBackground = Color3.fromRGB(20, 20, 20),
		NotificationActionsBackground = Color3.fromRGB(230, 230, 230),

		TabBackground = Color3.fromRGB(80, 80, 80),
		TabStroke = Color3.fromRGB(85, 85, 85),
		TabBackgroundSelected = Color3.fromRGB(210, 210, 210),
		TabTextColor = Color3.fromRGB(240, 240, 240),
		SelectedTabTextColor = Color3.fromRGB(50, 50, 50),

		ElementBackground = Color3.fromRGB(35, 35, 35),
		ElementBackgroundHover = Color3.fromRGB(40, 40, 40),
		SecondaryElementBackground = Color3.fromRGB(25, 25, 25),
		ElementStroke = Color3.fromRGB(50, 50, 50),
		SecondaryElementStroke = Color3.fromRGB(40, 40, 40),

		SliderBackground = Color3.fromRGB(50, 138, 220),
		SliderProgress = Color3.fromRGB(50, 138, 220),
		SliderStroke = Color3.fromRGB(58, 163, 255),

		ToggleBackground = Color3.fromRGB(30, 30, 30),
		ToggleEnabled = Color3.fromRGB(0, 146, 214),
		ToggleDisabled = Color3.fromRGB(100, 100, 100),
		ToggleEnabledStroke = Color3.fromRGB(0, 170, 255),
		ToggleDisabledStroke = Color3.fromRGB(125, 125, 125),
		ToggleEnabledOuterStroke = Color3.fromRGB(100, 100, 100),
		ToggleDisabledOuterStroke = Color3.fromRGB(65, 65, 65),

		DropdownSelected = Color3.fromRGB(40, 40, 40),
		DropdownUnselected = Color3.fromRGB(30, 30, 30),

		InputBackground = Color3.fromRGB(30, 30, 30),
		InputStroke = Color3.fromRGB(65, 65, 65),
		PlaceholderColor = Color3.fromRGB(178, 178, 178)
	},

	Ocean = {
		TextColor = Color3.fromRGB(230, 240, 240),

		Background = Color3.fromRGB(20, 30, 30),
		Topbar = Color3.fromRGB(25, 40, 40),
		Shadow = Color3.fromRGB(15, 20, 20),

		NotificationBackground = Color3.fromRGB(25, 35, 35),
		NotificationActionsBackground = Color3.fromRGB(230, 240, 240),

		TabBackground = Color3.fromRGB(40, 60, 60),
		TabStroke = Color3.fromRGB(50, 70, 70),
		TabBackgroundSelected = Color3.fromRGB(100, 180, 180),
		TabTextColor = Color3.fromRGB(210, 230, 230),
		SelectedTabTextColor = Color3.fromRGB(20, 50, 50),

		ElementBackground = Color3.fromRGB(30, 50, 50),
		ElementBackgroundHover = Color3.fromRGB(40, 60, 60),
		SecondaryElementBackground = Color3.fromRGB(30, 45, 45),
		ElementStroke = Color3.fromRGB(45, 70, 70),
		SecondaryElementStroke = Color3.fromRGB(40, 65, 65),

		SliderBackground = Color3.fromRGB(0, 110, 110),
		SliderProgress = Color3.fromRGB(0, 140, 140),
		SliderStroke = Color3.fromRGB(0, 160, 160),

		ToggleBackground = Color3.fromRGB(30, 50, 50),
		ToggleEnabled = Color3.fromRGB(0, 130, 130),
		ToggleDisabled = Color3.fromRGB(70, 90, 90),
		ToggleEnabledStroke = Color3.fromRGB(0, 160, 160),
		ToggleDisabledStroke = Color3.fromRGB(85, 105, 105),
		ToggleEnabledOuterStroke = Color3.fromRGB(50, 100, 100),
		ToggleDisabledOuterStroke = Color3.fromRGB(45, 65, 65),

		DropdownSelected = Color3.fromRGB(30, 60, 60),
		DropdownUnselected = Color3.fromRGB(25, 40, 40),

		InputBackground = Color3.fromRGB(30, 50, 50),
		InputStroke = Color3.fromRGB(50, 70, 70),
		PlaceholderColor = Color3.fromRGB(140, 160, 160)
	},

	AmberGlow = {
		TextColor = Color3.fromRGB(255, 245, 230),

		Background = Color3.fromRGB(45, 30, 20),
		Topbar = Color3.fromRGB(55, 40, 25),
		Shadow = Color3.fromRGB(35, 25, 15),

		NotificationBackground = Color3.fromRGB(50, 35, 25),
		NotificationActionsBackground = Color3.fromRGB(245, 230, 215),

		TabBackground = Color3.fromRGB(75, 50, 35),
		TabStroke = Color3.fromRGB(90, 60, 45),
		TabBackgroundSelected = Color3.fromRGB(230, 180, 100),
		TabTextColor = Color3.fromRGB(250, 220, 200),
		SelectedTabTextColor = Color3.fromRGB(50, 30, 10),

		ElementBackground = Color3.fromRGB(60, 45, 35),
		ElementBackgroundHover = Color3.fromRGB(70, 50, 40),
		SecondaryElementBackground = Color3.fromRGB(55, 40, 30),
		ElementStroke = Color3.fromRGB(85, 60, 45),
		SecondaryElementStroke = Color3.fromRGB(75, 50, 35),

		SliderBackground = Color3.fromRGB(220, 130, 60),
		SliderProgress = Color3.fromRGB(250, 150, 75),
		SliderStroke = Color3.fromRGB(255, 170, 85),

		ToggleBackground = Color3.fromRGB(55, 40, 30),
		ToggleEnabled = Color3.fromRGB(240, 130, 30),
		ToggleDisabled = Color3.fromRGB(90, 70, 60),
		ToggleEnabledStroke = Color3.fromRGB(255, 160, 50),
		ToggleDisabledStroke = Color3.fromRGB(110, 85, 75),
		ToggleEnabledOuterStroke = Color3.fromRGB(200, 100, 50),
		ToggleDisabledOuterStroke = Color3.fromRGB(75, 60, 55),

		DropdownSelected = Color3.fromRGB(70, 50, 40),
		DropdownUnselected = Color3.fromRGB(55, 40, 30),

		InputBackground = Color3.fromRGB(60, 45, 35),
		InputStroke = Color3.fromRGB(90, 65, 50),
		PlaceholderColor = Color3.fromRGB(190, 150, 130)
	},
	Light = {
		TextColor = Color3.fromRGB(40, 40, 40),

		Background = Color3.fromRGB(245, 245, 245),
		Topbar = Color3.fromRGB(230, 230, 230),
		Shadow = Color3.fromRGB(200, 200, 200),

		NotificationBackground = Color3.fromRGB(250, 250, 250),
		NotificationActionsBackground = Color3.fromRGB(240, 240, 240),

		TabBackground = Color3.fromRGB(235, 235, 235),
		TabStroke = Color3.fromRGB(215, 215, 215),
		TabBackgroundSelected = Color3.fromRGB(255, 255, 255),
		TabTextColor = Color3.fromRGB(80, 80, 80),
		SelectedTabTextColor = Color3.fromRGB(0, 0, 0),

		ElementBackground = Color3.fromRGB(240, 240, 240),
		ElementBackgroundHover = Color3.fromRGB(225, 225, 225),
		SecondaryElementBackground = Color3.fromRGB(235, 235, 235),
		ElementStroke = Color3.fromRGB(210, 210, 210),
		SecondaryElementStroke = Color3.fromRGB(210, 210, 210),

		SliderBackground = Color3.fromRGB(150, 180, 220),
		SliderProgress = Color3.fromRGB(100, 150, 200),
		SliderStroke = Color3.fromRGB(120, 170, 220),

		ToggleBackground = Color3.fromRGB(220, 220, 220),
		ToggleEnabled = Color3.fromRGB(0, 146, 214),
		ToggleDisabled = Color3.fromRGB(150, 150, 150),
		ToggleEnabledStroke = Color3.fromRGB(0, 170, 255),
		ToggleDisabledStroke = Color3.fromRGB(170, 170, 170),
		ToggleEnabledOuterStroke = Color3.fromRGB(100, 100, 100),
		ToggleDisabledOuterStroke = Color3.fromRGB(180, 180, 180),

		DropdownSelected = Color3.fromRGB(230, 230, 230),
		DropdownUnselected = Color3.fromRGB(220, 220, 220),

		InputBackground = Color3.fromRGB(240, 240, 240),
		InputStroke = Color3.fromRGB(180, 180, 180),
		PlaceholderColor = Color3.fromRGB(140, 140, 140)
	},

	Amethyst = {
		TextColor = Color3.fromRGB(240, 240, 240),

		Background = Color3.fromRGB(30, 20, 40),
		Topbar = Color3.fromRGB(40, 25, 50),
		Shadow = Color3.fromRGB(20, 15, 30),

		NotificationBackground = Color3.fromRGB(35, 20, 40),
		NotificationActionsBackground = Color3.fromRGB(240, 240, 250),

		TabBackground = Color3.fromRGB(60, 40, 80),
		TabStroke = Color3.fromRGB(70, 45, 90),
		TabBackgroundSelected = Color3.fromRGB(180, 140, 200),
		TabTextColor = Color3.fromRGB(230, 230, 240),
		SelectedTabTextColor = Color3.fromRGB(50, 20, 50),

		ElementBackground = Color3.fromRGB(45, 30, 60),
		ElementBackgroundHover = Color3.fromRGB(50, 35, 70),
		SecondaryElementBackground = Color3.fromRGB(40, 30, 55),
		ElementStroke = Color3.fromRGB(70, 50, 85),
		SecondaryElementStroke = Color3.fromRGB(65, 45, 80),

		SliderBackground = Color3.fromRGB(100, 60, 150),
		SliderProgress = Color3.fromRGB(130, 80, 180),
		SliderStroke = Color3.fromRGB(150, 100, 200),

		ToggleBackground = Color3.fromRGB(45, 30, 55),
		ToggleEnabled = Color3.fromRGB(120, 60, 150),
		ToggleDisabled = Color3.fromRGB(94, 47, 117),
		ToggleEnabledStroke = Color3.fromRGB(140, 80, 170),
		ToggleDisabledStroke = Color3.fromRGB(124, 71, 150),
		ToggleEnabledOuterStroke = Color3.fromRGB(90, 40, 120),
		ToggleDisabledOuterStroke = Color3.fromRGB(80, 50, 110),

		DropdownSelected = Color3.fromRGB(50, 35, 70),
		DropdownUnselected = Color3.fromRGB(35, 25, 50),

		InputBackground = Color3.fromRGB(45, 30, 60),
		InputStroke = Color3.fromRGB(80, 50, 110),
		PlaceholderColor = Color3.fromRGB(178, 150, 200)
	},

	Green = {
		TextColor = Color3.fromRGB(30, 60, 30),

		Background = Color3.fromRGB(235, 245, 235),
		Topbar = Color3.fromRGB(210, 230, 210),
		Shadow = Color3.fromRGB(200, 220, 200),

		NotificationBackground = Color3.fromRGB(240, 250, 240),
		NotificationActionsBackground = Color3.fromRGB(220, 235, 220),

		TabBackground = Color3.fromRGB(215, 235, 215),
		TabStroke = Color3.fromRGB(190, 210, 190),
		TabBackgroundSelected = Color3.fromRGB(245, 255, 245),
		TabTextColor = Color3.fromRGB(50, 80, 50),
		SelectedTabTextColor = Color3.fromRGB(20, 60, 20),

		ElementBackground = Color3.fromRGB(225, 240, 225),
		ElementBackgroundHover = Color3.fromRGB(210, 225, 210),
		SecondaryElementBackground = Color3.fromRGB(235, 245, 235),
		ElementStroke = Color3.fromRGB(180, 200, 180),
		SecondaryElementStroke = Color3.fromRGB(180, 200, 180),

		SliderBackground = Color3.fromRGB(90, 160, 90),
		SliderProgress = Color3.fromRGB(70, 130, 70),
		SliderStroke = Color3.fromRGB(100, 180, 100),

		ToggleBackground = Color3.fromRGB(215, 235, 215),
		ToggleEnabled = Color3.fromRGB(60, 130, 60),
		ToggleDisabled = Color3.fromRGB(150, 175, 150),
		ToggleEnabledStroke = Color3.fromRGB(80, 150, 80),
		ToggleDisabledStroke = Color3.fromRGB(130, 150, 130),
		ToggleEnabledOuterStroke = Color3.fromRGB(100, 160, 100),
		ToggleDisabledOuterStroke = Color3.fromRGB(160, 180, 160),

		DropdownSelected = Color3.fromRGB(225, 240, 225),
		DropdownUnselected = Color3.fromRGB(210, 225, 210),

		InputBackground = Color3.fromRGB(235, 245, 235),
		InputStroke = Color3.fromRGB(180, 200, 180),
		PlaceholderColor = Color3.fromRGB(120, 140, 120)
	},

	Bloom = {
		TextColor = Color3.fromRGB(60, 40, 50),

		Background = Color3.fromRGB(255, 240, 245),
		Topbar = Color3.fromRGB(250, 220, 225),
		Shadow = Color3.fromRGB(230, 190, 195),

		NotificationBackground = Color3.fromRGB(255, 235, 240),
		NotificationActionsBackground = Color3.fromRGB(245, 215, 225),

		TabBackground = Color3.fromRGB(240, 210, 220),
		TabStroke = Color3.fromRGB(230, 200, 210),
		TabBackgroundSelected = Color3.fromRGB(255, 225, 235),
		TabTextColor = Color3.fromRGB(80, 40, 60),
		SelectedTabTextColor = Color3.fromRGB(50, 30, 50),

		ElementBackground = Color3.fromRGB(255, 235, 240),
		ElementBackgroundHover = Color3.fromRGB(245, 220, 230),
		SecondaryElementBackground = Color3.fromRGB(255, 235, 240),
		ElementStroke = Color3.fromRGB(230, 200, 210),
		SecondaryElementStroke = Color3.fromRGB(230, 200, 210),

		SliderBackground = Color3.fromRGB(240, 130, 160),
		SliderProgress = Color3.fromRGB(250, 160, 180),
		SliderStroke = Color3.fromRGB(255, 180, 200),

		ToggleBackground = Color3.fromRGB(240, 210, 220),
		ToggleEnabled = Color3.fromRGB(255, 140, 170),
		ToggleDisabled = Color3.fromRGB(200, 180, 185),
		ToggleEnabledStroke = Color3.fromRGB(250, 160, 190),
		ToggleDisabledStroke = Color3.fromRGB(210, 180, 190),
		ToggleEnabledOuterStroke = Color3.fromRGB(220, 160, 180),
		ToggleDisabledOuterStroke = Color3.fromRGB(190, 170, 180),

		DropdownSelected = Color3.fromRGB(250, 220, 225),
		DropdownUnselected = Color3.fromRGB(240, 210, 220),

		InputBackground = Color3.fromRGB(255, 235, 240),
		InputStroke = Color3.fromRGB(220, 190, 200),
		PlaceholderColor = Color3.fromRGB(170, 130, 140)
	},

	DarkBlue = {
		TextColor = Color3.fromRGB(230, 230, 230),

		Background = Color3.fromRGB(20, 25, 30),
		Topbar = Color3.fromRGB(30, 35, 40),
		Shadow = Color3.fromRGB(15, 20, 25),

		NotificationBackground = Color3.fromRGB(25, 30, 35),
		NotificationActionsBackground = Color3.fromRGB(45, 50, 55),

		TabBackground = Color3.fromRGB(35, 40, 45),
		TabStroke = Color3.fromRGB(45, 50, 60),
		TabBackgroundSelected = Color3.fromRGB(40, 70, 100),
		TabTextColor = Color3.fromRGB(200, 200, 200),
		SelectedTabTextColor = Color3.fromRGB(255, 255, 255),

		ElementBackground = Color3.fromRGB(30, 35, 40),
		ElementBackgroundHover = Color3.fromRGB(40, 45, 50),
		SecondaryElementBackground = Color3.fromRGB(35, 40, 45),
		ElementStroke = Color3.fromRGB(45, 50, 60),
		SecondaryElementStroke = Color3.fromRGB(40, 45, 55),

		SliderBackground = Color3.fromRGB(0, 90, 180),
		SliderProgress = Color3.fromRGB(0, 120, 210),
		SliderStroke = Color3.fromRGB(0, 150, 240),

		ToggleBackground = Color3.fromRGB(35, 40, 45),
		ToggleEnabled = Color3.fromRGB(0, 120, 210),
		ToggleDisabled = Color3.fromRGB(70, 70, 80),
		ToggleEnabledStroke = Color3.fromRGB(0, 150, 240),
		ToggleDisabledStroke = Color3.fromRGB(75, 75, 85),
		ToggleEnabledOuterStroke = Color3.fromRGB(20, 100, 180),
		ToggleDisabledOuterStroke = Color3.fromRGB(55, 55, 65),

		DropdownSelected = Color3.fromRGB(30, 70, 90),
		DropdownUnselected = Color3.fromRGB(25, 30, 35),

		InputBackground = Color3.fromRGB(25, 30, 35),
		InputStroke = Color3.fromRGB(45, 50, 60),
		PlaceholderColor = Color3.fromRGB(150, 150, 160)
	},

	Serenity = {
		TextColor = Color3.fromRGB(50, 55, 60),
		Background = Color3.fromRGB(240, 245, 250),
		Topbar = Color3.fromRGB(215, 225, 235),
		Shadow = Color3.fromRGB(200, 210, 220),

		NotificationBackground = Color3.fromRGB(210, 220, 230),
		NotificationActionsBackground = Color3.fromRGB(225, 230, 240),

		TabBackground = Color3.fromRGB(200, 210, 220),
		TabStroke = Color3.fromRGB(180, 190, 200),
		TabBackgroundSelected = Color3.fromRGB(175, 185, 200),
		TabTextColor = Color3.fromRGB(50, 55, 60),
		SelectedTabTextColor = Color3.fromRGB(30, 35, 40),

		ElementBackground = Color3.fromRGB(210, 220, 230),
		ElementBackgroundHover = Color3.fromRGB(220, 230, 240),
		SecondaryElementBackground = Color3.fromRGB(200, 210, 220),
		ElementStroke = Color3.fromRGB(190, 200, 210),
		SecondaryElementStroke = Color3.fromRGB(180, 190, 200),

		SliderBackground = Color3.fromRGB(200, 220, 235),
		SliderProgress = Color3.fromRGB(70, 130, 180),
		SliderStroke = Color3.fromRGB(150, 180, 220),

		ToggleBackground = Color3.fromRGB(210, 220, 230),
		ToggleEnabled = Color3.fromRGB(70, 160, 210),
		ToggleDisabled = Color3.fromRGB(180, 180, 180),
		ToggleEnabledStroke = Color3.fromRGB(60, 150, 200),
		ToggleDisabledStroke = Color3.fromRGB(140, 140, 140),
		ToggleEnabledOuterStroke = Color3.fromRGB(100, 120, 140),
		ToggleDisabledOuterStroke = Color3.fromRGB(120, 120, 130),

		DropdownSelected = Color3.fromRGB(220, 230, 240),
		DropdownUnselected = Color3.fromRGB(200, 210, 220),

		InputBackground = Color3.fromRGB(220, 230, 240),
		InputStroke = Color3.fromRGB(180, 190, 200),
		PlaceholderColor = Color3.fromRGB(150, 150, 150)
	},
}

-- Initialize module with dependencies
function ThemeModule.init(ctx)
	local self = {}

	-- Store dependencies from context
	self.Rayfield = ctx.Rayfield
	self.Main = ctx.Main
	self.Topbar = ctx.Topbar
	self.Elements = ctx.Elements
	self.Notifications = ctx.Notifications
	self.Icons = ctx.Icons

	-- Current selected theme
	self.SelectedTheme = ThemeModule.Themes.Default

	-- Reactive Theme System
	local ThemeValues = Instance.new("Folder")
	ThemeValues.Name = "ThemeValues"
	ThemeValues.Parent = self.Main

	local activeBindings = setmetatable({}, {__mode = "k"}) -- [object] = { [property] = record }
	local objectWatchers = setmetatable({}, {__mode = "k"}) -- [object] = { destroyConn?, ancestryConn? }
	local values = {}

	local function disconnectConnection(connection)
		if connection and typeof(connection) == "RBXScriptConnection" and connection.Connected then
			connection:Disconnect()
		end
	end

	local function cleanupObjectBindings(object)
		local bindingMap = activeBindings[object]
		if bindingMap then
			for _, record in pairs(bindingMap) do
				disconnectConnection(record.connection)
			end
			activeBindings[object] = nil
		end

		local watcher = objectWatchers[object]
		if watcher then
			disconnectConnection(watcher.destroying)
			disconnectConnection(watcher.ancestry)
			objectWatchers[object] = nil
		end
	end

	local function ensureObjectWatcher(object)
		if not object or objectWatchers[object] then
			return
		end

		local watcher = {}
		local okDestroying, destroyingSignal = pcall(function()
			return object.Destroying
		end)
		if okDestroying and destroyingSignal and destroyingSignal.Connect then
			watcher.destroying = destroyingSignal:Connect(function()
				cleanupObjectBindings(object)
			end)
		else
			watcher.ancestry = object.AncestryChanged:Connect(function(_, parent)
				if parent == nil then
					cleanupObjectBindings(object)
				end
			end)
		end

		objectWatchers[object] = watcher
	end

	local function unbindTheme(object, property)
		if not object then
			return
		end

		local bindingMap = activeBindings[object]
		if not bindingMap then
			return
		end

		if property then
			local record = bindingMap[property]
			if record then
				disconnectConnection(record.connection)
				bindingMap[property] = nil
			end
			if next(bindingMap) == nil then
				cleanupObjectBindings(object)
			end
			return
		end

		cleanupObjectBindings(object)
	end

	-- Initialize ValueObjects for all theme properties
	for key, value in pairs(ThemeModule.Themes.Default) do
		local colorValue = Instance.new("Color3Value")
		colorValue.Name = key
		colorValue.Value = value
		colorValue.Parent = ThemeValues
		values[key] = colorValue
	end

	-- Helper to bind an object's property to a theme color
	function self.bindTheme(object, property, themeKey)
		if not object then
			return
		end

		unbindTheme(object, property)

		local valueObj = values[themeKey]
		if not valueObj then
			-- During teardown/reload, values table can be cleared before late bind calls.
			-- Skip noisy warnings when the key itself is valid in theme schema.
			if ThemeModule.Themes.Default and ThemeModule.Themes.Default[themeKey] ~= nil then
				return
			end
			warn("Rayfield | Theme key not found: " .. tostring(themeKey))
			return
		end

		-- Set initial value
		local ok = pcall(function()
			object[property] = valueObj.Value
		end)
		if not ok then
			return
		end

		-- Listen for changes
		local connection = valueObj.Changed:Connect(function(newColor)
			pcall(function()
				object[property] = newColor
			end)
		end)

		activeBindings[object] = activeBindings[object] or {}
		activeBindings[object][property] = {
			connection = connection,
			themeKey = themeKey
		}
		ensureObjectWatcher(object)

		return connection
	end

	function self.unbindTheme(object, property)
		unbindTheme(object, property)
	end

	function self.cleanupObjectBindings(object)
		cleanupObjectBindings(object)
	end

	-- Get icon from Lucide icon library
	function self.getIcon(name)
		if not self.Icons then
			warn("Lucide Icons: Cannot use icons as icons library is not loaded")
			return
		end
		name = string.match(string.lower(name), "^%s*(.*)%s*$")
		local sizedicons = self.Icons['48px']
		local r = sizedicons[name]
		if not r then
			error("Lucide Icons: Failed to find icon by the name of \"" .. name .. "\"", 2)
		end

		local rirs = r[2]
		local riro = r[3]

		return {
			id = r[1],
			imageRectSize = Vector2.new(rirs[1], rirs[2]),
			imageRectOffset = Vector2.new(riro[1], riro[2])
		}
	end

	-- Change theme function
	function self.ChangeTheme(Theme)
		if typeof(Theme) == 'string' then
			self.SelectedTheme = ThemeModule.Themes[Theme]
		elseif typeof(Theme) == 'table' then
			self.SelectedTheme = Theme
		end

		if not self.SelectedTheme then return end

		-- Update all ValueObjects - this triggers listeners in all elements
		for key, value in pairs(self.SelectedTheme) do
			if values[key] then
				values[key].Value = value
			end
		end

		-- Special case for search which isn't fully reactive yet or has complex mapping
		if self.Main:FindFirstChild('Notice') then
			self.Main.Notice.BackgroundColor3 = self.SelectedTheme.Background
		end
	end

	-- Cleanup function to prevent memory leaks on Rayfield:Destroy() + reload
	function self.cleanup()
		for object in pairs(activeBindings) do
			cleanupObjectBindings(object)
		end
		for object, watcher in pairs(objectWatchers) do
			disconnectConnection(watcher.destroying)
			disconnectConnection(watcher.ancestry)
			objectWatchers[object] = nil
		end

		-- Destroy the ThemeValues folder
		if ThemeValues and ThemeValues.Parent then
			ThemeValues:Destroy()
		end
		table.clear(values)
	end

	return self
end

return ThemeModule
]=])
put("src/services/utilities.lua", [[-- Rayfield Utilities & Lifecycle Module
-- Handles utility functions, dragging, visibility, and lifecycle management

local UtilitiesModule = {}

function UtilitiesModule.init(ctx)
	local self = {}
	
	-- Inject dependencies
	self.TweenService = ctx.TweenService
	self.Animation = ctx.Animation or ctx.TweenService
	self.RunService = ctx.RunService
	self.UserInputService = ctx.UserInputService
	self.getService = ctx.getService
	self.Main = ctx.Main
	self.Rayfield = ctx.Rayfield
	self.dragBar = ctx.dragBar
	self.dragBarCosmetic = ctx.dragBarCosmetic
	self.getHidden = ctx.getHidden
	self.useMobileSizing = ctx.useMobileSizing
	self.Hide = ctx.Hide
	self.Unhide = ctx.Unhide
	self.getDebounce = ctx.getDebounce
	self.setRayfieldDestroyed = ctx.setRayfieldDestroyed
	self.keybindConnections = ctx.keybindConnections
	
	-- Utility: Get asset URI from ID or icon name
	local function getAssetUri(id, Icons)
		local assetUri = "rbxassetid://0" -- Default to empty image
		if type(id) == "number" then
			assetUri = "rbxassetid://" .. id
		elseif type(id) == "string" and not Icons then
			warn("Rayfield | Cannot use Lucide icons as icons library is not loaded")
		else
			warn("Rayfield | The icon argument must either be an icon ID (number) or a Lucide icon name (string)")
		end
		return assetUri
	end
	
	-- Make a GUI object draggable
	local function makeDraggable(object, dragObject, enableTaptic, tapticOffset)
		local dragging = false
		local relative = nil
		local activeInput = nil
		local pointerPosition = nil
		
		local offset = Vector2.zero
		local screenGui = object:FindFirstAncestorWhichIsA("ScreenGui")
		if screenGui and screenGui.IgnoreGuiInset then
			offset += self.getService('GuiService'):GetGuiInset()
		end
		
		if dragObject:IsA("GuiObject") then
			dragObject.Active = true
		end
		
		local function updatePointerFromInput(input)
			if input and input.Position then
				pointerPosition = Vector2.new(input.Position.X, input.Position.Y)
			end
		end
		
		local function getPointerPosition()
			if pointerPosition then
				return pointerPosition
			end
			return self.UserInputService:GetMouseLocation()
		end
		
		local function connectFunctions()
			if self.dragBar and enableTaptic then
				self.dragBar.MouseEnter:Connect(function()
					if not dragging and not self.getHidden() then
						self.Animation:Create(self.dragBarCosmetic, TweenInfo.new(0.25, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {BackgroundTransparency = 0.5, Size = UDim2.new(0, 120, 0, 4)}):Play()
					end
				end)
				
				self.dragBar.MouseLeave:Connect(function()
					if not dragging and not self.getHidden() then
						self.Animation:Create(self.dragBarCosmetic, TweenInfo.new(0.25, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {BackgroundTransparency = 0.7, Size = UDim2.new(0, 100, 0, 4)}):Play()
					end
				end)
			end
		end
		
		connectFunctions()
		
		dragObject.InputBegan:Connect(function(input, processed)
			local inputType = input.UserInputType
			
			if inputType == Enum.UserInputType.MouseButton1 or inputType == Enum.UserInputType.Touch then
				dragging = true
				activeInput = input
				updatePointerFromInput(input)
				
				relative = object.AbsolutePosition + object.AbsoluteSize * object.AnchorPoint - getPointerPosition()
				if enableTaptic and not self.getHidden() then
					self.Animation:Create(self.dragBarCosmetic, TweenInfo.new(0.35, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {Size = UDim2.new(0, 110, 0, 4), BackgroundTransparency = 0}):Play()
				end
			end
		end)
		
		local inputChanged = self.UserInputService.InputChanged:Connect(function(input)
			if not dragging then return end
			
			if activeInput and input == activeInput then
				updatePointerFromInput(input)
			elseif activeInput and activeInput.UserInputType == Enum.UserInputType.MouseButton1 and input.UserInputType == Enum.UserInputType.MouseMovement then
				updatePointerFromInput(input)
			end
		end)
		
		local inputEnded = self.UserInputService.InputEnded:Connect(function(input)
			if not dragging then return end
			
			local inputType = input.UserInputType
			local touchEnded = activeInput and activeInput.UserInputType == Enum.UserInputType.Touch and input == activeInput
			if inputType == Enum.UserInputType.MouseButton1 or touchEnded then
				dragging = false
				activeInput = nil
				pointerPosition = nil
				
				connectFunctions()
				
				if enableTaptic and not self.getHidden() then
					self.Animation:Create(self.dragBarCosmetic, TweenInfo.new(0.35, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {Size = UDim2.new(0, 100, 0, 4), BackgroundTransparency = 0.7}):Play()
				end
			end
		end)
		
		local renderStepped = self.RunService.RenderStepped:Connect(function(deltaTime)
			if dragging and not self.getHidden() then
				local position = getPointerPosition() + relative + offset
				if enableTaptic and tapticOffset then
					local tapticY = (self.useMobileSizing and tapticOffset[2]) or tapticOffset[1]
					-- Lerp-based follow instead of creating new tweens every frame
					local objAlpha = math.clamp(1 - math.exp(-deltaTime * 7), 0, 1)
					local objCur = object.Position
					local objNext = objCur:Lerp(UDim2.fromOffset(position.X, position.Y), objAlpha)
					object.Position = objNext
					local barParent = dragObject.Parent
					local barAlpha = math.clamp(1 - math.exp(-deltaTime * 50), 0, 1)
					local barCur = barParent.Position
					barParent.Position = barCur:Lerp(UDim2.fromOffset(position.X, position.Y + tapticY), barAlpha)
				else
					if self.dragBar and tapticOffset then
						self.dragBar.Position = UDim2.fromOffset(position.X, position.Y + ((self.useMobileSizing and tapticOffset[2]) or tapticOffset[1]))
					end
					object.Position = UDim2.fromOffset(position.X, position.Y)
				end
			end
		end)
		
		object.Destroying:Connect(function()
			if inputChanged then inputChanged:Disconnect() end
			if inputEnded then inputEnded:Disconnect() end
			if renderStepped then renderStepped:Disconnect() end
		end)
	end
	
	-- Set visibility with optional notification
	local function setVisibility(visibility, notify)
		if self.getDebounce() then return end
		if visibility then
			self.Unhide()
		else
			self.Hide(notify)
		end
	end
	
	-- Destroy Rayfield and cleanup
	local function destroy(hideHotkeyConnection)
		self.setRayfieldDestroyed(true)
		if hideHotkeyConnection then
			hideHotkeyConnection:Disconnect()
		end
		for _, connection in self.keybindConnections do
			connection:Disconnect()
		end
		self.Rayfield:Destroy()
	end
	
	-- Export functions
	self.getAssetUri = getAssetUri
	self.makeDraggable = makeDraggable
	self.setVisibility = setVisibility
	self.destroy = destroy
	
	return self
end

return UtilitiesModule
]])
put("src/ui/elements/common/destroy.lua", [[local Destroy = {}

function Destroy.execute(element)
	if type(element) == "table" and type(element.Destroy) == "function" then
		return element:Destroy()
	end
end

return Destroy]])
put("src/ui/elements/common/theme-bindings.lua", [[local ThemeBindings = {}

function ThemeBindings.bind(bindThemeFn, target, property, themeKey)
	if type(bindThemeFn) == "function" then
		return bindThemeFn(target, property, themeKey)
	end
end

return ThemeBindings]])
put("src/ui/elements/common/visibility.lua", [[local Visibility = {}

function Visibility.show(element)
	if type(element) == "table" and type(element.Show) == "function" then
		return element:Show()
	end
end

function Visibility.hide(element)
	if type(element) == "table" and type(element.Hide) == "function" then
		return element:Hide()
	end
end

function Visibility.set(element, isVisible)
	if type(element) == "table" and type(element.SetVisible) == "function" then
		return element:SetVisible(isVisible)
	end
end

return Visibility]])
put("src/ui/elements/factory.lua", [[local client = _G and _G.__RayfieldApiClient
if not client then
	error("Rayfield ApiClient is not initialized")
end

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
return client.fetchAndExecute(root .. "src/ui/elements/factory/init.lua")]])
put("src/ui/elements/factory/create-section.lua", [[local CreateSection = {}

function CreateSection.execute(tabObject, ...)
	if type(tabObject) == "table" and type(tabObject.CreateSection) == "function" then
		return tabObject:CreateSection(...)
	end
	error("CreateSection.execute expects a tab object returned from :CreateTab")
end

return CreateSection]])
put("src/ui/elements/factory/create-tab.lua", [[local client = _G and _G.__RayfieldApiClient
if not client then
	error("Rayfield ApiClient is not initialized")
end

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
local FactoryModule = client.fetchAndExecute(root .. "src/ui/elements/factory/init.lua")

local CreateTab = {}

function CreateTab.execute(factoryState, ...)
	if type(factoryState) == "table" and type(factoryState.CreateTab) == "function" then
		return factoryState.CreateTab(...)
	end
	error("CreateTab.execute expects a factory state returned from ElementsModule.init(ctx)")
end

CreateTab.FactoryModule = FactoryModule

return CreateTab]])
put("src/ui/elements/factory/init.lua", [[-- Rayfield Element Factories Module
-- Handles tab creation and all element factories

local ElementsModule = {}

function ElementsModule.init(ctx)
	local self = {}

	-- Inject dependencies
	self.TweenService = ctx.TweenService
	self.Animation = ctx.Animation or ctx.TweenService
	self.RunService = ctx.RunService
	self.UserInputService = ctx.UserInputService
	self.HttpService = ctx.HttpService
	self.Main = ctx.Main
	self.Topbar = ctx.Topbar
	self.TabList = ctx.TabList
	self.Elements = ctx.Elements
	self.Rayfield = ctx.Rayfield
	self.RayfieldLibrary = ctx.RayfieldLibrary
	self.Icons = ctx.Icons
	self.getIcon = ctx.getIcon
	self.getAssetUri = ctx.getAssetUri
	self.getSelectedTheme = ctx.getSelectedTheme
	self.rayfieldDestroyed = ctx.rayfieldDestroyed
	self.getMinimised = ctx.getMinimised or function() return false end
	self.getSetting = ctx.getSetting
	self.bindTheme = ctx.bindTheme
	self.SaveConfiguration = ctx.SaveConfiguration
	self.makeElementDetachable = ctx.makeElementDetachable
	self.ElementSync = ctx.ElementSync
	self.KeybindSequence = ctx.KeybindSequence
	-- Improvement 4: Add safe fallbacks for critical dependencies
	self.keybindConnections = ctx.keybindConnections or {} -- Fallback to empty table
	self.getDebounce = ctx.getDebounce or function() return false end
	self.setDebounce = ctx.setDebounce or function(val) end

	self.useMobileSizing = ctx.useMobileSizing

	-- Window Settings (passed from CreateWindow)
	local Settings = ctx.Settings or {}

	-- Module state
	local FirstTab = false

	-- Extract code starts here

		local function CreateTab(Name, Image, Ext)
			local SDone = false
			local TabButton = self.TabList.Template:Clone()
			TabButton.Name = Name
			TabButton.Title.Text = Name
			TabButton.Parent = self.TabList
			TabButton.Title.TextWrapped = false
			TabButton.Size = UDim2.new(0, TabButton.Title.TextBounds.X + 30, 0, 30)
	
			if Image and Image ~= 0 then
				if typeof(Image) == 'string' and self.Icons then
					local asset = self.getIcon(Image)
	
					TabButton.Image.Image = 'rbxassetid://'..asset.id
					TabButton.Image.ImageRectOffset = asset.imageRectOffset
					TabButton.Image.ImageRectSize = asset.imageRectSize
				else
					TabButton.Image.Image = self.getAssetUri(Image)
				end
	
				TabButton.Title.AnchorPoint = Vector2.new(0, 0.5)
				TabButton.Title.Position = UDim2.new(0, 37, 0.5, 0)
				TabButton.Image.Visible = true
				TabButton.Title.TextXAlignment = Enum.TextXAlignment.Left
				TabButton.Size = UDim2.new(0, TabButton.Title.TextBounds.X + 52, 0, 30)
			end
	
	
	
			TabButton.BackgroundTransparency = 1
			TabButton.Title.TextTransparency = 1
			TabButton.Image.ImageTransparency = 1
			TabButton.UIStroke.Transparency = 1

			local TabHoverGlow = Instance.new("UIStroke")
			TabHoverGlow.Name = "HoverGlow"
			TabHoverGlow.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
			TabHoverGlow.Thickness = 2.8
			TabHoverGlow.Transparency = 1
			TabHoverGlow.Color = Color3.fromRGB(110, 175, 240)
			TabHoverGlow.Parent = TabButton
	
			TabButton.Visible = not Ext or false
	
			-- Create self.Elements Page
			local TabPage = self.Elements.Template:Clone()
			TabPage.Name = Name
			TabPage.Visible = true
	
			TabPage.LayoutOrder = #self.Elements:GetChildren() or Ext and 10000
	
			for _, TemplateElement in ipairs(TabPage:GetChildren()) do
				if TemplateElement.ClassName == "Frame" and TemplateElement.Name ~= "Placeholder" then
					TemplateElement:Destroy()
				end
			end

			TabPage.Parent = self.Elements

			local tabRecord = {
				Name = Name,
				Ext = Ext and true or false,
				TabButton = TabButton,
				TabPage = TabPage,
				DefaultVisible = TabButton.Visible,
				IsSplit = false,
				SplitPanelId = nil,
				SuppressNextClick = false,
				IsSettings = (Name == "Rayfield Settings" and Ext == true)
			}
			local tabHover = false
			
			-- Reactive coloring for TabPage elements
			TabPage.ChildAdded:Connect(function(Element)
				if Element.ClassName == "Frame" and Element.Name ~= "Placeholder" and Element.Name ~= "SectionSpacing" and Element.Name ~= "Divider" and Element.Name ~= "SectionTitle" and Element.Name ~= "SearchTitle-fsefsefesfsefesfesfThanks" then
					self.bindTheme(Element, "BackgroundColor3", "ElementBackground")
					-- Guard: not all frames have a UIStroke child
					if Element:FindFirstChildWhichIsA("UIStroke") then
						self.bindTheme(Element.UIStroke, "Color", "ElementStroke")
					end
				end
			end)
			
			if not FirstTab and not Ext then
				self.Elements.UIPageLayout.Animated = false
				self.Elements.UIPageLayout:JumpTo(TabPage)
				self.Elements.UIPageLayout.Animated = true
			end
	
			self.bindTheme(TabButton.UIStroke, "Color", "TabStroke")
	
			local function UpdateTabColors()
				TabButton.UIStroke.Color = self.getSelectedTheme().TabStroke
				TabHoverGlow.Color = self.getSelectedTheme().SliderProgress or self.getSelectedTheme().TabStroke
				if self.Elements.UIPageLayout.CurrentPage == TabPage then
					tabHover = false
					TabButton.UIStroke.Thickness = 1
					TabHoverGlow.Transparency = 1
					TabButton.BackgroundColor3 = self.getSelectedTheme().TabBackgroundSelected
					TabButton.Image.ImageColor3 = self.getSelectedTheme().SelectedTabTextColor
					TabButton.Title.TextColor3 = self.getSelectedTheme().SelectedTabTextColor
				else
					if not tabHover then
						TabButton.UIStroke.Thickness = 1
						TabHoverGlow.Transparency = 1
					end
					TabButton.BackgroundColor3 = self.getSelectedTheme().TabBackground
					TabButton.Image.ImageColor3 = self.getSelectedTheme().TabTextColor
					TabButton.Title.TextColor3 = self.getSelectedTheme().TabTextColor
				end
			end

			local function applyTabHoverVisual(duration)
				if tabRecord.IsSplit then
					return
				end
				if self.Elements.UIPageLayout.CurrentPage == TabPage then
					return
				end

				local tweenDuration = duration or 0.16
				local theme = self.getSelectedTheme() or {}
				local targetBackgroundTransparency = tabHover and 0.58 or 0.7
				local targetStrokeTransparency = tabHover and 0.32 or 0.5
				local targetStrokeThickness = tabHover and 1.2 or 1
				local targetStrokeColor = tabHover and (theme.SliderProgress or theme.TabStroke) or theme.TabStroke
				local targetGlowTransparency = tabHover and 0.84 or 1
				local targetGlowThickness = tabHover and 3.3 or 2.8
				local targetGlowColor = theme.SliderProgress or theme.TabStroke
				local targetTextTransparency = tabHover and 0.05 or 0.2
				local targetImageTransparency = tabHover and 0.05 or 0.2

				self.Animation:Create(TabButton, TweenInfo.new(tweenDuration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundTransparency = targetBackgroundTransparency}):Play()
				self.Animation:Create(TabButton.UIStroke, TweenInfo.new(tweenDuration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
					Transparency = targetStrokeTransparency,
					Thickness = targetStrokeThickness,
					Color = targetStrokeColor
				}):Play()
				self.Animation:Create(TabHoverGlow, TweenInfo.new(tweenDuration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
					Transparency = targetGlowTransparency,
					Thickness = targetGlowThickness,
					Color = targetGlowColor
				}):Play()
				self.Animation:Create(TabButton.Title, TweenInfo.new(tweenDuration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {TextTransparency = targetTextTransparency}):Play()
				self.Animation:Create(TabButton.Image, TweenInfo.new(tweenDuration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {ImageTransparency = targetImageTransparency}):Play()
			end

			-- Listen for theme changes to update tab colors
			local themeValueFolder = self.Main:FindFirstChild("ThemeValues")
			if themeValueFolder then
				themeValueFolder:FindFirstChild("Background").Changed:Connect(UpdateTabColors)
			end
			
			self.Elements.UIPageLayout:GetPropertyChangedSignal("CurrentPage"):Connect(UpdateTabColors)
	
	
			-- Animate
			task.wait(0.1)
			if FirstTab or Ext then
				TabButton.BackgroundColor3 = self.getSelectedTheme().TabBackground
				TabButton.Image.ImageColor3 = self.getSelectedTheme().TabTextColor
				TabButton.Title.TextColor3 = self.getSelectedTheme().TabTextColor
				self.Animation:Create(TabButton, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0.7}):Play()
				self.Animation:Create(TabButton.Title, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {TextTransparency = 0.2}):Play()
				self.Animation:Create(TabButton.Image, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {ImageTransparency = 0.2}):Play()
				self.Animation:Create(TabButton.UIStroke, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {Transparency = 0.5}):Play()
				TabHoverGlow.Transparency = 1
			elseif not Ext then
				FirstTab = Name
				TabButton.BackgroundColor3 = self.getSelectedTheme().TabBackgroundSelected
				TabButton.Image.ImageColor3 = self.getSelectedTheme().SelectedTabTextColor
				TabButton.Title.TextColor3 = self.getSelectedTheme().SelectedTabTextColor
				self.Animation:Create(TabButton.Image, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {ImageTransparency = 0}):Play()
				self.Animation:Create(TabButton, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0}):Play()
				self.Animation:Create(TabButton.Title, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {TextTransparency = 0}):Play()
				TabHoverGlow.Transparency = 1
			end
	
			local function activateTab(ignoreMinimisedCheck)
				if tabRecord.IsSplit then return false end
				if not ignoreMinimisedCheck and self.getMinimised() then return false end

				tabHover = false
				self.Animation:Create(TabButton, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0}):Play()
				self.Animation:Create(TabButton.UIStroke, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {Transparency = 1}):Play()
				self.Animation:Create(TabButton.Title, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {TextTransparency = 0}):Play()
				self.Animation:Create(TabButton.Image, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {ImageTransparency = 0}):Play()
				self.Animation:Create(TabButton, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().TabBackgroundSelected}):Play()
				self.Animation:Create(TabButton.Title, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {TextColor3 = self.getSelectedTheme().SelectedTabTextColor}):Play()
				self.Animation:Create(TabButton.Image, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {ImageColor3 = self.getSelectedTheme().SelectedTabTextColor}):Play()
				TabButton.UIStroke.Thickness = 1
				TabButton.UIStroke.Color = self.getSelectedTheme().TabStroke
				TabHoverGlow.Transparency = 1

				for _, OtherTabButton in ipairs(self.TabList:GetChildren()) do
					if OtherTabButton.Name ~= "Template" and OtherTabButton.ClassName == "Frame" and OtherTabButton ~= TabButton and OtherTabButton.Name ~= "Placeholder" and OtherTabButton.Visible then
						self.Animation:Create(OtherTabButton, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().TabBackground}):Play()
						self.Animation:Create(OtherTabButton.Title, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {TextColor3 = self.getSelectedTheme().TabTextColor}):Play()
						self.Animation:Create(OtherTabButton.Image, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {ImageColor3 = self.getSelectedTheme().TabTextColor}):Play()
						self.Animation:Create(OtherTabButton, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0.7}):Play()
						self.Animation:Create(OtherTabButton.Title, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {TextTransparency = 0.2}):Play()
						self.Animation:Create(OtherTabButton.Image, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {ImageTransparency = 0.2}):Play()
						self.Animation:Create(OtherTabButton.UIStroke, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {Transparency = 0.5}):Play()
						OtherTabButton.UIStroke.Thickness = 1
						OtherTabButton.UIStroke.Color = self.getSelectedTheme().TabStroke
						local otherGlow = OtherTabButton:FindFirstChild("HoverGlow")
						if otherGlow and otherGlow:IsA("UIStroke") then
							otherGlow.Transparency = 1
						end
					end
				end

				if self.Elements.UIPageLayout.CurrentPage ~= TabPage then
					self.Elements.UIPageLayout:JumpTo(TabPage)
				end

				return true
			end

			tabRecord.Activate = activateTab

			TabButton.Interact.MouseEnter:Connect(function()
				if self.Elements.UIPageLayout.CurrentPage == TabPage then
					return
				end
				tabHover = true
				applyTabHoverVisual(0.14)
			end)

			TabButton.Interact.MouseLeave:Connect(function()
				tabHover = false
				UpdateTabColors()
				applyTabHoverVisual(0.14)
			end)
	
			TabButton.Interact.MouseButton1Click:Connect(function()
				if tabRecord.SuppressNextClick then
					tabRecord.SuppressNextClick = false
					return
				end

				activateTab(false)
			end)
	
			-- Preserve module context for Tab:Create* methods where `self` is Tab.
			local Tab = setmetatable({}, { __index = self })
			Tab.__TabRecord = tabRecord
			function Tab:GetInternalRecord()
				return tabRecord
			end
			tabRecord.Tab = Tab
	
			-- Element tracking system for extended API
			local elementSync = self.ElementSync
			local tabSyncId = tabRecord.Name or tostring(TabPage)
			local tabSyncTokens = {}
			local TabElements = {} -- Stores all elements created in this tab
			local TabSections = {}-- Stores all sections created in this tab
			local hoverBindings = {}
			local hoverSyncConnection = nil
			local hoverSyncAccumulator = 0
			local HOVER_SYNC_INTERVAL = 1 / 30

			local function getPointerLocation()
				local ok, pointer = pcall(function()
					return self.UserInputService:GetMouseLocation()
				end)
				if ok then
					return pointer
				end
				return nil
			end

			local function isPointInsideGui(point, guiObject)
				if not point or not guiObject or not guiObject.Parent then
					return false
				end
				local pos = guiObject.AbsolutePosition
				local size = guiObject.AbsoluteSize
				if size.X <= 0 or size.Y <= 0 then
					return false
				end
				return point.X >= pos.X
					and point.Y >= pos.Y
					and point.X <= (pos.X + size.X)
					and point.Y <= (pos.Y + size.Y)
			end

			local function cleanupHoverBinding(key)
				local binding = hoverBindings[key]
				if not binding then
					return
				end
				if binding.Hovered and binding.OnLeave then
					pcall(binding.OnLeave)
				end
				binding.Hovered = false
				if binding.DestroyingConnection then
					binding.DestroyingConnection:Disconnect()
					binding.DestroyingConnection = nil
				end
				hoverBindings[key] = nil
			end

			local function syncHoverBindingsFromPointer(point, force)
				local pointer = point or getPointerLocation()
				local currentPage = self.Elements.UIPageLayout.CurrentPage
				local isCurrentTab = currentPage == TabPage

				for _, binding in pairs(hoverBindings) do
					local guiObject = binding.GuiObject
					local shouldHover = false
					if isCurrentTab and guiObject and guiObject.Parent and guiObject.Visible and guiObject:IsDescendantOf(TabPage) then
						shouldHover = isPointInsideGui(pointer, guiObject)
					end

					if force or binding.Hovered ~= shouldHover then
						binding.Hovered = shouldHover
						if shouldHover then
							if binding.OnEnter then
								binding.OnEnter()
							end
						else
							if binding.OnLeave then
								binding.OnLeave()
							end
						end
					end
				end
			end

			local function ensureHoverSyncConnection()
				if hoverSyncConnection then
					return
				end

				hoverSyncConnection = self.RunService.RenderStepped:Connect(function(deltaTime)
					if next(hoverBindings) == nil then
						return
					end
					hoverSyncAccumulator += deltaTime
					if hoverSyncAccumulator < HOVER_SYNC_INTERVAL then
						return
					end
					hoverSyncAccumulator = 0
					syncHoverBindingsFromPointer(nil, false)
				end)
			end

			local function cleanupAllHoverBindings()
				for key in pairs(hoverBindings) do
					cleanupHoverBinding(key)
				end
				if hoverSyncConnection then
					hoverSyncConnection:Disconnect()
					hoverSyncConnection = nil
				end
			end

			local function registerHoverBinding(guiObject, onEnter, onLeave, key)
				if not (guiObject and guiObject:IsA("GuiObject")) then
					return nil
				end

				local bindingKey = key or self.HttpService:GenerateGUID(false)
				cleanupHoverBinding(bindingKey)

				local binding = {
					GuiObject = guiObject,
					OnEnter = onEnter,
					OnLeave = onLeave,
					Hovered = false,
					DestroyingConnection = nil
				}
				local destroyingSignal = nil
				local signalOk, signalValue = pcall(function()
					return guiObject.Destroying
				end)
				if signalOk and signalValue and signalValue.Connect then
					destroyingSignal = signalValue
				end
				if destroyingSignal then
					binding.DestroyingConnection = destroyingSignal:Connect(function()
						cleanupHoverBinding(bindingKey)
					end)
				else
					binding.DestroyingConnection = guiObject.AncestryChanged:Connect(function()
						if not guiObject:IsDescendantOf(game) then
							cleanupHoverBinding(bindingKey)
						end
					end)
				end
				hoverBindings[bindingKey] = binding
				ensureHoverSyncConnection()

				task.defer(function()
					if hoverBindings[bindingKey] then
						syncHoverBindingsFromPointer(nil, true)
					end
				end)

				return bindingKey
			end

			local hoverCurrentPageConnection = self.Elements.UIPageLayout:GetPropertyChangedSignal("CurrentPage"):Connect(function()
				syncHoverBindingsFromPointer(nil, true)
				if elementSync and self.Elements.UIPageLayout.CurrentPage == TabPage then
					elementSync.resyncTab(tabSyncId, "tab_page_changed")
				end
			end)
			TabPage.Destroying:Connect(function()
				if hoverCurrentPageConnection then
					hoverCurrentPageConnection:Disconnect()
					hoverCurrentPageConnection = nil
				end
				cleanupAllHoverBindings()
				if elementSync and tabSyncTokens then
					for token in pairs(tabSyncTokens) do
						elementSync.unregister(token)
						tabSyncTokens[token] = nil
					end
				end
			end)

			local function registerElementSync(spec)
				if not elementSync then
					return nil
				end
				spec = spec or {}
				spec.tabId = tabSyncId
				local token = elementSync.register(spec)
				if token then
					tabSyncTokens[token] = true
				end
				return token
			end

			local function unregisterElementSync(token)
				if not token or not elementSync then
					return
				end
				elementSync.unregister(token)
				tabSyncTokens[token] = nil
			end

			local function commitElementSync(token, nextState, options)
				if not token or not elementSync then
					return false, nil
				end
				return elementSync.commit(token, nextState, options)
			end
	
			-- Helper function to add extended API to all elements
			local function addExtendedAPI(elementObject, elementName, elementType, guiObject, hoverBindingKey, syncToken)
				local detachable = self.makeElementDetachable and self.makeElementDetachable(guiObject, elementName, elementType) or nil
				local ancestrySyncConnection = nil
				if guiObject and guiObject.SetAttribute then
					guiObject:SetAttribute("RayfieldElementSyncToken", syncToken)
				end
				if syncToken and elementSync and guiObject and guiObject.AncestryChanged then
					ancestrySyncConnection = guiObject.AncestryChanged:Connect(function()
						task.defer(function()
							if guiObject and guiObject.Parent then
								elementSync.resync(syncToken, "element_reparent")
							end
						end)
					end)
				end
	
				-- Destroy with tracking removal
				local originalDestroy = elementObject.Destroy
				elementObject.Destroy = function(self)
					if hoverBindingKey then
						cleanupHoverBinding(hoverBindingKey)
					end
					if guiObject and guiObject.SetAttribute then
						guiObject:SetAttribute("RayfieldElementSyncToken", nil)
					end
					unregisterElementSync(syncToken)
					if ancestrySyncConnection then
						ancestrySyncConnection:Disconnect()
						ancestrySyncConnection = nil
					end
					if detachable and detachable.Destroy then
						detachable.Destroy()
					end
					if originalDestroy then
						originalDestroy(self)
					end
					-- Remove from tracking
					for i, element in ipairs(TabElements) do
						if element.Object == elementObject then
							table.remove(TabElements, i)
							break
						end
					end
				end
	
				-- Visibility methods
				function elementObject:Show()
					guiObject.Visible = true
					if syncToken and elementSync then
						elementSync.resync(syncToken, "element_show")
					end
				end
	
				function elementObject:Hide()
					guiObject.Visible = false
					if syncToken and elementSync then
						elementSync.resync(syncToken, "element_hide")
					end
				end
	
				function elementObject:SetVisible(visible)
					guiObject.Visible = visible
					if syncToken and elementSync then
						elementSync.resync(syncToken, "element_set_visible")
					end
				end
	
				function elementObject:GetParent()
					return Tab
				end
	
				if detachable then
					function elementObject:Detach(position)
						local result = detachable.Detach(position)
						if syncToken and elementSync then
							elementSync.resync(syncToken, "element_detach")
						end
						return result
					end
	
					function elementObject:Dock()
						local result = detachable.Dock()
						if syncToken and elementSync then
							elementSync.resync(syncToken, "element_dock")
						end
						return result
					end
	
					function elementObject:GetRememberedState()
						return detachable.GetRememberedState()
					end
	
					function elementObject:IsDetached()
						return detachable.IsDetached()
					end
				end
	
				-- Add metadata
				elementObject.Name = elementName
				elementObject.Type = elementType
				elementObject.__ElementSyncToken = syncToken
	
				-- Add to tracking
				table.insert(TabElements, {
					Name = elementName,
					Type = elementType,
					Object = elementObject,
					GuiObject = guiObject,
					HoverBindingKey = hoverBindingKey,
					SyncToken = syncToken
				})
	
				return elementObject
			end
	
			-- Tab utility functions
			function Tab:GetElements()
				return TabElements
			end
	
			function Tab:FindElement(name)
				for _, element in ipairs(TabElements) do
					if element.Name == name then
						return element.Object
					end
				end
				return nil
			end
	
			function Tab:Clear()
				if elementSync then
					for token in pairs(tabSyncTokens) do
						elementSync.unregister(token)
						tabSyncTokens[token] = nil
					end
				end
				-- Snapshot elements and clear tracking first to avoid
				-- concurrent modification (custom Destroy also removes from TabElements)
				local snapshot = {}
				for i, element in ipairs(TabElements) do
					snapshot[i] = element
				end
				-- Clear tracking table before destroying to prevent index corruption
				for i = #TabElements, 1, -1 do
					TabElements[i] = nil
				end
				-- Now safely destroy each element
				for _, element in ipairs(snapshot) do
					if element.Object and element.Object.Destroy then
						element.Object:Destroy()
					end
				end
				cleanupAllHoverBindings()
			end
	
			-- Button
			function Tab:CreateButton(ButtonSettings)
				local ButtonValue = {}
	
				local Button = self.Elements.Template.Button:Clone()
				Button.Name = ButtonSettings.Name
				Button.Title.Text = ButtonSettings.Name
				Button.Visible = true
				Button.Parent = TabPage
	
				Button.BackgroundTransparency = 1
				Button.UIStroke.Transparency = 1
				Button.Title.TextTransparency = 1
	
				self.Animation:Create(Button, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0}):Play()
				self.Animation:Create(Button.UIStroke, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {Transparency = 0}):Play()
				self.Animation:Create(Button.Title, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {TextTransparency = 0}):Play()
	
	
				Button.Interact.MouseButton1Click:Connect(function()
					local Success, Response = pcall(ButtonSettings.Callback)
					-- Prevents animation from trying to play if the button's callback called RayfieldLibrary:Destroy()
					if self.rayfieldDestroyed() then
						return
					end
					if not Success then
						self.Animation:Create(Button, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = Color3.fromRGB(85, 0, 0)}):Play()
						self.Animation:Create(Button.ElementIndicator, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
						self.Animation:Create(Button.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 1}):Play()
						Button.Title.Text = "Callback Error"
						print("Rayfield | "..ButtonSettings.Name.." Callback Error " ..tostring(Response))
						warn('Check docs.sirius.menu for help with Rayfield specific development.')
						task.wait(0.5)
						Button.Title.Text = ButtonSettings.Name
						self.Animation:Create(Button, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackground}):Play()
						self.Animation:Create(Button.ElementIndicator, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {TextTransparency = 0.9}):Play()
						self.Animation:Create(Button.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 0}):Play()
					else
						if not ButtonSettings.Ext then
							self.SaveConfiguration(ButtonSettings.Name..'\n')
						end
						self.Animation:Create(Button, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackgroundHover}):Play()
						self.Animation:Create(Button.ElementIndicator, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
						self.Animation:Create(Button.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 1}):Play()
						task.wait(0.2)
						self.Animation:Create(Button, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackground}):Play()
						self.Animation:Create(Button.ElementIndicator, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {TextTransparency = 0.9}):Play()
						self.Animation:Create(Button.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 0}):Play()
					end
				end)
	
				local buttonHoverBindingKey = registerHoverBinding(Button,
					function()
						self.Animation:Create(Button, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackgroundHover}):Play()
						self.Animation:Create(Button.ElementIndicator, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {TextTransparency = 0.7}):Play()
					end,
					function()
						self.Animation:Create(Button, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackground}):Play()
						self.Animation:Create(Button.ElementIndicator, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {TextTransparency = 0.9}):Play()
					end
				)
	
				function ButtonValue:Set(NewButton)
					Button.Title.Text = NewButton
					Button.Name = NewButton
				end
	
				function ButtonValue:Destroy()
					Button:Destroy()
				end
	
				-- Add extended API
				addExtendedAPI(ButtonValue, ButtonSettings.Name, "Button", Button, buttonHoverBindingKey)
	
				return ButtonValue
			end
	
			-- ColorPicker
			function Tab:CreateColorPicker(ColorPickerSettings) -- by Throit
				ColorPickerSettings.Type = "ColorPicker"
				local ColorPicker = self.Elements.Template.ColorPicker:Clone()
				local Background = ColorPicker.CPBackground
				local Display = Background.Display
				local Main = Background.MainCP
				local Slider = ColorPicker.ColorSlider
				ColorPicker.ClipsDescendants = true
				ColorPicker.Name = ColorPickerSettings.Name
				ColorPicker.Title.Text = ColorPickerSettings.Name
				ColorPicker.Visible = true
				ColorPicker.Parent = TabPage
				ColorPicker.Size = UDim2.new(1, -10, 0, 45)
				Background.Size = UDim2.new(0, 39, 0, 22)
				Display.BackgroundTransparency = 0
				self.Main.MainPoint.ImageTransparency = 1
				ColorPicker.Interact.Size = UDim2.new(1, 0, 1, 0)
				ColorPicker.Interact.Position = UDim2.new(0.5, 0, 0.5, 0)
				ColorPicker.RGB.Position = UDim2.new(0, 17, 0, 70)
				ColorPicker.HexInput.Position = UDim2.new(0, 17, 0, 90)
				self.Main.ImageTransparency = 1
				Background.BackgroundTransparency = 1
	
				for _, rgbinput in ipairs(ColorPicker.RGB:GetChildren()) do
					if rgbinput:IsA("Frame") then
						rgbinput.BackgroundColor3 = self.getSelectedTheme().InputBackground
						rgbinput.UIStroke.Color = self.getSelectedTheme().InputStroke
					end
				end
	
				ColorPicker.HexInput.BackgroundColor3 = self.getSelectedTheme().InputBackground
				ColorPicker.HexInput.UIStroke.Color = self.getSelectedTheme().InputStroke
	
				local opened = false 
				local mouse = Players.LocalPlayer:GetMouse()
				self.Main.Image = "http://www.roblox.com/asset/?id=11415645739"
				local mainDragging = false 
				local sliderDragging = false 
				ColorPicker.Interact.MouseButton1Down:Connect(function()
					task.spawn(function()
						self.Animation:Create(ColorPicker, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackgroundHover}):Play()
						self.Animation:Create(ColorPicker.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 1}):Play()
						task.wait(0.2)
						self.Animation:Create(ColorPicker, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackground}):Play()
						self.Animation:Create(ColorPicker.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 0}):Play()
					end)
	
					if not opened then
						opened = true 
						self.Animation:Create(Background, TweenInfo.new(0.45, Enum.EasingStyle.Exponential), {Size = UDim2.new(0, 18, 0, 15)}):Play()
						task.wait(0.1)
						self.Animation:Create(ColorPicker, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Size = UDim2.new(1, -10, 0, 120)}):Play()
						self.Animation:Create(Background, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Size = UDim2.new(0, 173, 0, 86)}):Play()
						self.Animation:Create(Display, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundTransparency = 1}):Play()
						self.Animation:Create(ColorPicker.Interact, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Position = UDim2.new(0.289, 0, 0.5, 0)}):Play()
						self.Animation:Create(ColorPicker.RGB, TweenInfo.new(0.8, Enum.EasingStyle.Exponential), {Position = UDim2.new(0, 17, 0, 40)}):Play()
						self.Animation:Create(ColorPicker.HexInput, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {Position = UDim2.new(0, 17, 0, 73)}):Play()
						self.Animation:Create(ColorPicker.Interact, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Size = UDim2.new(0.574, 0, 1, 0)}):Play()
						self.Animation:Create(self.Main.MainPoint, TweenInfo.new(0.2, Enum.EasingStyle.Exponential), {ImageTransparency = 0}):Play()
						self.Animation:Create(Main, TweenInfo.new(0.2, Enum.EasingStyle.Exponential), {ImageTransparency = self.getSelectedTheme() ~= self.RayfieldLibrary.Theme.Default and 0.25 or 0.1}):Play()
						self.Animation:Create(Background, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0}):Play()
					else
						opened = false
						self.Animation:Create(ColorPicker, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Size = UDim2.new(1, -10, 0, 45)}):Play()
						self.Animation:Create(Background, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Size = UDim2.new(0, 39, 0, 22)}):Play()
						self.Animation:Create(ColorPicker.Interact, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Size = UDim2.new(1, 0, 1, 0)}):Play()
						self.Animation:Create(ColorPicker.Interact, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Position = UDim2.new(0.5, 0, 0.5, 0)}):Play()
						self.Animation:Create(ColorPicker.RGB, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Position = UDim2.new(0, 17, 0, 70)}):Play()
						self.Animation:Create(ColorPicker.HexInput, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {Position = UDim2.new(0, 17, 0, 90)}):Play()
						self.Animation:Create(Display, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0}):Play()
						self.Animation:Create(self.Main.MainPoint, TweenInfo.new(0.2, Enum.EasingStyle.Exponential), {ImageTransparency = 1}):Play()
						self.Animation:Create(Main, TweenInfo.new(0.2, Enum.EasingStyle.Exponential), {ImageTransparency = 1}):Play()
						self.Animation:Create(Background, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundTransparency = 1}):Play()
					end
	
				end)
	
				self.UserInputService.InputEnded:Connect(function(input, gameProcessed) if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
						local wasDragging = mainDragging or sliderDragging
						mainDragging = false
						sliderDragging = false
						if wasDragging and not ColorPickerSettings.Ext then
							self.SaveConfiguration()
						end
					end end)
				self.Main.MouseButton1Down:Connect(function()
					if opened then
						mainDragging = true 
					end
				end)
				self.Main.MainPoint.MouseButton1Down:Connect(function()
					if opened then
						mainDragging = true 
					end
				end)
				Slider.MouseButton1Down:Connect(function()
					sliderDragging = true 
				end)
				Slider.SliderPoint.MouseButton1Down:Connect(function()
					sliderDragging = true 
				end)
				local h,s,v = ColorPickerSettings.Color:ToHSV()
				local color = Color3.fromHSV(h,s,v) 
				local hex = string.format("#%02X%02X%02X",color.R*0xFF,color.G*0xFF,color.B*0xFF)
				ColorPicker.HexInput.InputBox.Text = hex
				local function setDisplay()
					--Main
					self.Main.MainPoint.Position = UDim2.new(s,-self.Main.MainPoint.AbsoluteSize.X/2,1-v,-self.Main.MainPoint.AbsoluteSize.Y/2)
					self.Main.MainPoint.ImageColor3 = Color3.fromHSV(h,s,v)
					Background.BackgroundColor3 = Color3.fromHSV(h,1,1)
					Display.BackgroundColor3 = Color3.fromHSV(h,s,v)
					--Slider 
					local x = h * Slider.AbsoluteSize.X
					Slider.SliderPoint.Position = UDim2.new(0,x-Slider.SliderPoint.AbsoluteSize.X/2,0.5,0)
					Slider.SliderPoint.ImageColor3 = Color3.fromHSV(h,1,1)
					local color = Color3.fromHSV(h,s,v) 
					local r,g,b = math.floor((color.R*255)+0.5),math.floor((color.G*255)+0.5),math.floor((color.B*255)+0.5)
					ColorPicker.RGB.RInput.InputBox.Text = tostring(r)
					ColorPicker.RGB.GInput.InputBox.Text = tostring(g)
					ColorPicker.RGB.BInput.InputBox.Text = tostring(b)
					hex = string.format("#%02X%02X%02X",color.R*0xFF,color.G*0xFF,color.B*0xFF)
					ColorPicker.HexInput.InputBox.Text = hex
				end
				setDisplay()
				ColorPicker.HexInput.InputBox.FocusLost:Connect(function()
					if not pcall(function()
							local r, g, b = string.match(ColorPicker.HexInput.InputBox.Text, "^#?(%w%w)(%w%w)(%w%w)$")
							local rgbColor = Color3.fromRGB(tonumber(r, 16),tonumber(g, 16), tonumber(b, 16))
							h,s,v = rgbColor:ToHSV()
							hex = ColorPicker.HexInput.InputBox.Text
							setDisplay()
							ColorPickerSettings.Color = rgbColor
						end) 
					then 
						ColorPicker.HexInput.InputBox.Text = hex 
					end
					pcall(function()ColorPickerSettings.Callback(Color3.fromHSV(h,s,v))end)
					local r,g,b = math.floor((h*255)+0.5),math.floor((s*255)+0.5),math.floor((v*255)+0.5)
					ColorPickerSettings.Color = Color3.fromRGB(r,g,b)
					if not ColorPickerSettings.Ext then
						self.SaveConfiguration()
					end
				end)
				--RGB
				local function rgbBoxes(box,toChange)
					local value = tonumber(box.Text) 
					local color = Color3.fromHSV(h,s,v) 
					local oldR,oldG,oldB = math.floor((color.R*255)+0.5),math.floor((color.G*255)+0.5),math.floor((color.B*255)+0.5)
					local save 
					if toChange == "R" then save = oldR;oldR = value elseif toChange == "G" then save = oldG;oldG = value else save = oldB;oldB = value end
					if value then 
						value = math.clamp(value,0,255)
						h,s,v = Color3.fromRGB(oldR,oldG,oldB):ToHSV()
	
						setDisplay()
					else 
						box.Text = tostring(save)
					end
					local r,g,b = math.floor((h*255)+0.5),math.floor((s*255)+0.5),math.floor((v*255)+0.5)
					ColorPickerSettings.Color = Color3.fromRGB(r,g,b)
					if not ColorPickerSettings.Ext then
						self.SaveConfiguration(ColorPickerSettings.Flag..'\n'..tostring(ColorPickerSettings.Color))
					end
				end
				ColorPicker.RGB.RInput.InputBox.FocusLost:connect(function()
					rgbBoxes(ColorPicker.RGB.RInput.InputBox,"R")
					pcall(function()ColorPickerSettings.Callback(Color3.fromHSV(h,s,v))end)
				end)
				ColorPicker.RGB.GInput.InputBox.FocusLost:connect(function()
					rgbBoxes(ColorPicker.RGB.GInput.InputBox,"G")
					pcall(function()ColorPickerSettings.Callback(Color3.fromHSV(h,s,v))end)
				end)
				ColorPicker.RGB.BInput.InputBox.FocusLost:connect(function()
					rgbBoxes(ColorPicker.RGB.BInput.InputBox,"B")
					pcall(function()ColorPickerSettings.Callback(Color3.fromHSV(h,s,v))end)
				end)
	
				local prevH, prevS, prevV = h, s, v
				self.RunService.RenderStepped:connect(function()
					if mainDragging then
						local localX = math.clamp(mouse.X-self.Main.AbsolutePosition.X,0,self.Main.AbsoluteSize.X)
						local localY = math.clamp(mouse.Y-self.Main.AbsolutePosition.Y,0,self.Main.AbsoluteSize.Y)
						self.Main.MainPoint.Position = UDim2.new(0,localX-self.Main.MainPoint.AbsoluteSize.X/2,0,localY-self.Main.MainPoint.AbsoluteSize.Y/2)
						s = localX / self.Main.AbsoluteSize.X
						v = 1 - (localY / self.Main.AbsoluteSize.Y)
						local color = Color3.fromHSV(h,s,v)
						Display.BackgroundColor3 = color
						self.Main.MainPoint.ImageColor3 = color
						Background.BackgroundColor3 = Color3.fromHSV(h,1,1)
						local r,g,b = math.floor((color.R*255)+0.5),math.floor((color.G*255)+0.5),math.floor((color.B*255)+0.5)
						ColorPicker.RGB.RInput.InputBox.Text = tostring(r)
						ColorPicker.RGB.GInput.InputBox.Text = tostring(g)
						ColorPicker.RGB.BInput.InputBox.Text = tostring(b)
						ColorPicker.HexInput.InputBox.Text = string.format("#%02X%02X%02X",color.R*0xFF,color.G*0xFF,color.B*0xFF)
						ColorPickerSettings.Color = Color3.fromRGB(r,g,b)
						if h ~= prevH or s ~= prevS or v ~= prevV then
							prevH, prevS, prevV = h, s, v
							pcall(ColorPickerSettings.Callback, color)
						end
					end
					if sliderDragging then
						local localX = math.clamp(mouse.X-Slider.AbsolutePosition.X,0,Slider.AbsoluteSize.X)
						h = localX / Slider.AbsoluteSize.X
						local color = Color3.fromHSV(h,s,v)
						local hueColor = Color3.fromHSV(h,1,1)
						Display.BackgroundColor3 = color
						Slider.SliderPoint.Position = UDim2.new(0,localX-Slider.SliderPoint.AbsoluteSize.X/2,0.5,0)
						Slider.SliderPoint.ImageColor3 = hueColor
						Background.BackgroundColor3 = hueColor
						self.Main.MainPoint.ImageColor3 = color
						local r,g,b = math.floor((color.R*255)+0.5),math.floor((color.G*255)+0.5),math.floor((color.B*255)+0.5)
						ColorPicker.RGB.RInput.InputBox.Text = tostring(r)
						ColorPicker.RGB.GInput.InputBox.Text = tostring(g)
						ColorPicker.RGB.BInput.InputBox.Text = tostring(b)
						ColorPicker.HexInput.InputBox.Text = string.format("#%02X%02X%02X",color.R*0xFF,color.G*0xFF,color.B*0xFF)
						ColorPickerSettings.Color = Color3.fromRGB(r,g,b)
						if h ~= prevH or s ~= prevS or v ~= prevV then
							prevH, prevS, prevV = h, s, v
							pcall(ColorPickerSettings.Callback, color)
						end
					end
				end)
	
				if Settings.ConfigurationSaving then
					if Settings.ConfigurationSaving.Enabled and ColorPickerSettings.Flag then
						self.RayfieldLibrary.Flags[ColorPickerSettings.Flag] = ColorPickerSettings
					end
				end
	
				function ColorPickerSettings:Set(RGBColor)
					ColorPickerSettings.Color = RGBColor
					h,s,v = ColorPickerSettings.Color:ToHSV()
					color = Color3.fromHSV(h,s,v)
					setDisplay()
				end
	
				local colorPickerHoverBindingKey = registerHoverBinding(ColorPicker,
					function()
						self.Animation:Create(ColorPicker, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackgroundHover}):Play()
					end,
					function()
						self.Animation:Create(ColorPicker, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackground}):Play()
					end
				)
	
				self.Rayfield.Main:GetPropertyChangedSignal('BackgroundColor3'):Connect(function()
					for _, rgbinput in ipairs(ColorPicker.RGB:GetChildren()) do
						if rgbinput:IsA("Frame") then
							rgbinput.BackgroundColor3 = self.getSelectedTheme().InputBackground
							rgbinput.UIStroke.Color = self.getSelectedTheme().InputStroke
						end
					end
	
					ColorPicker.HexInput.BackgroundColor3 = self.getSelectedTheme().InputBackground
					ColorPicker.HexInput.UIStroke.Color = self.getSelectedTheme().InputStroke
				end)
	
				function ColorPickerSettings:Destroy()
					ColorPicker:Destroy()
				end
	
				-- Add extended API
				addExtendedAPI(ColorPickerSettings, ColorPickerSettings.Name, "ColorPicker", ColorPicker, colorPickerHoverBindingKey)
	
				return ColorPickerSettings
			end
	
			-- Section
			function Tab:CreateSection(SectionName)
	
				local SectionValue = {}
	
				if SDone then
					local SectionSpace = self.Elements.Template.SectionSpacing:Clone()
					SectionSpace.Visible = true
					SectionSpace.Parent = TabPage
				end
	
				local Section = self.Elements.Template.SectionTitle:Clone()
				Section.Title.Text = SectionName
				Section.Visible = true
				Section.Parent = TabPage
	
				Section.Title.TextTransparency = 1
				self.Animation:Create(Section.Title, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {TextTransparency = 0.4}):Play()
	
				function SectionValue:Set(NewSection)
					Section.Title.Text = NewSection
				end
	
				function SectionValue:Destroy()
					Section:Destroy()
				end
	
				-- Add extended API
				addExtendedAPI(SectionValue, SectionName, "Section", Section)
	
				SDone = true
	
				return SectionValue
			end
	
			-- Divider
			function Tab:CreateDivider()
				local DividerValue = {}
	
				local Divider = self.Elements.Template.Divider:Clone()
				Divider.Visible = true
				Divider.Parent = TabPage
	
				Divider.Divider.BackgroundTransparency = 1
				self.Animation:Create(Divider.Divider, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0.85}):Play()
	
				function DividerValue:Set(Value)
					Divider.Visible = Value
				end
	
				function DividerValue:Destroy()
					Divider:Destroy()
				end
	
				-- Add extended API
				addExtendedAPI(DividerValue, "Divider", "Divider", Divider)
	
				return DividerValue
			end
	
			-- Label
			function Tab:CreateLabel(LabelText, Icon, Color, IgnoreTheme)
				local LabelValue = {}
	
				local Label = self.Elements.Template.Label:Clone()
				Label.Title.Text = LabelText
				Label.Visible = true
				Label.Parent = TabPage
	
				Label.BackgroundColor3 = Color or self.getSelectedTheme().SecondaryElementBackground
				Label.UIStroke.Color = Color or self.getSelectedTheme().SecondaryElementStroke
	
				if Icon then
					if typeof(Icon) == 'string' and self.Icons then
						local asset = self.getIcon(Icon)
	
						Label.Icon.Image = 'rbxassetid://'..asset.id
						Label.Icon.ImageRectOffset = asset.imageRectOffset
						Label.Icon.ImageRectSize = asset.imageRectSize
					else
						Label.Icon.Image = self.getAssetUri(Icon)
					end
				else
					Label.Icon.Image = "rbxassetid://" .. 0
				end
	
				if Icon and Label:FindFirstChild('Icon') then
					Label.Title.Position = UDim2.new(0, 45, 0.5, 0)
					Label.Title.Size = UDim2.new(1, -100, 0, 14)
	
					if Icon then
						if typeof(Icon) == 'string' and self.Icons then
							local asset = self.getIcon(Icon)
	
							Label.Icon.Image = 'rbxassetid://'..asset.id
							Label.Icon.ImageRectOffset = asset.imageRectOffset
							Label.Icon.ImageRectSize = asset.imageRectSize
						else
							Label.Icon.Image = self.getAssetUri(Icon)
						end
					else
						Label.Icon.Image = "rbxassetid://" .. 0
					end
	
					Label.Icon.Visible = true
				end
	
				Label.Icon.ImageTransparency = 1
				Label.BackgroundTransparency = 1
				Label.UIStroke.Transparency = 1
				Label.Title.TextTransparency = 1
	
				self.Animation:Create(Label, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {BackgroundTransparency = Color and 0.8 or 0}):Play()
				self.Animation:Create(Label.UIStroke, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {Transparency = Color and 0.7 or 0}):Play()
				self.Animation:Create(Label.Icon, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {ImageTransparency = 0.2}):Play()
				self.Animation:Create(Label.Title, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {TextTransparency = Color and 0.2 or 0}):Play()	
	
				function LabelValue:Set(NewLabel, Icon, Color)
					Label.Title.Text = NewLabel
	
					if Color then
						Label.BackgroundColor3 = Color or self.getSelectedTheme().SecondaryElementBackground
						Label.UIStroke.Color = Color or self.getSelectedTheme().SecondaryElementStroke
					end
	
					if Icon and Label:FindFirstChild('Icon') then
						Label.Title.Position = UDim2.new(0, 45, 0.5, 0)
						Label.Title.Size = UDim2.new(1, -100, 0, 14)
	
						if Icon then
							if typeof(Icon) == 'string' and self.Icons then
								local asset = self.getIcon(Icon)
	
								Label.Icon.Image = 'rbxassetid://'..asset.id
								Label.Icon.ImageRectOffset = asset.imageRectOffset
								Label.Icon.ImageRectSize = asset.imageRectSize
							else
								Label.Icon.Image = self.getAssetUri(Icon)
							end
						else
							Label.Icon.Image = "rbxassetid://" .. 0
						end
	
						Label.Icon.Visible = true
					end
				end
	
				self.Rayfield.Main:GetPropertyChangedSignal('BackgroundColor3'):Connect(function()
					Label.BackgroundColor3 = IgnoreTheme and (Color or Label.BackgroundColor3) or self.getSelectedTheme().SecondaryElementBackground
					Label.UIStroke.Color = IgnoreTheme and (Color or Label.BackgroundColor3) or self.getSelectedTheme().SecondaryElementStroke
				end)
	
				function LabelValue:Destroy()
					Label:Destroy()
				end
	
				-- Add extended API
				addExtendedAPI(LabelValue, LabelText, "Label", Label)
	
				return LabelValue
			end
	
			-- Paragraph
			function Tab:CreateParagraph(ParagraphSettings)
				local ParagraphValue = {}
	
				local Paragraph = self.Elements.Template.Paragraph:Clone()
				Paragraph.Title.Text = ParagraphSettings.Title
				Paragraph.Content.Text = ParagraphSettings.Content
				Paragraph.Visible = true
				Paragraph.Parent = TabPage
	
				Paragraph.BackgroundTransparency = 1
				Paragraph.UIStroke.Transparency = 1
				Paragraph.Title.TextTransparency = 1
				Paragraph.Content.TextTransparency = 1
	
				Paragraph.BackgroundColor3 = self.getSelectedTheme().SecondaryElementBackground
				Paragraph.UIStroke.Color = self.getSelectedTheme().SecondaryElementStroke
	
				self.Animation:Create(Paragraph, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0}):Play()
				self.Animation:Create(Paragraph.UIStroke, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {Transparency = 0}):Play()
				self.Animation:Create(Paragraph.Title, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {TextTransparency = 0}):Play()
				self.Animation:Create(Paragraph.Content, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {TextTransparency = 0}):Play()
	
				function ParagraphValue:Set(NewParagraphSettings)
					Paragraph.Title.Text = NewParagraphSettings.Title
					Paragraph.Content.Text = NewParagraphSettings.Content
				end
	
				self.Rayfield.Main:GetPropertyChangedSignal('BackgroundColor3'):Connect(function()
					Paragraph.BackgroundColor3 = self.getSelectedTheme().SecondaryElementBackground
					Paragraph.UIStroke.Color = self.getSelectedTheme().SecondaryElementStroke
				end)
	
				function ParagraphValue:Destroy()
					Paragraph:Destroy()
				end
	
				-- Add extended API
				addExtendedAPI(ParagraphValue, ParagraphSettings.Title, "Paragraph", Paragraph)
	
				return ParagraphValue
			end
	
			-- Input
			function Tab:CreateInput(InputSettings)
				local ctx = self
				InputSettings = InputSettings or {}
				if type(InputSettings.Callback) ~= "function" then
					InputSettings.Callback = function() end
				end
				InputSettings.CurrentValue = tostring(InputSettings.CurrentValue or "")

				local Input = self.Elements.Template.Input:Clone()
				Input.Name = InputSettings.Name
				Input.Title.Text = InputSettings.Name
				Input.Visible = true
				Input.Parent = TabPage
	
				Input.BackgroundTransparency = 1
				Input.UIStroke.Transparency = 1
				Input.Title.TextTransparency = 1

				Input.InputFrame.InputBox.Text = InputSettings.CurrentValue

				self.bindTheme(Input.InputFrame, "BackgroundColor3", "InputBackground")
				self.bindTheme(Input.InputFrame.UIStroke, "Color", "InputStroke")
	
				self.Animation:Create(Input, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0}):Play()
				self.Animation:Create(Input.UIStroke, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {Transparency = 0}):Play()
				self.Animation:Create(Input.Title, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {TextTransparency = 0}):Play()	
	
				Input.InputFrame.InputBox.PlaceholderText = InputSettings.PlaceholderText
				local function resizeInputFrame()
					self.Animation:Create(
						Input.InputFrame,
						TweenInfo.new(0.55, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out),
						{Size = UDim2.new(0, Input.InputFrame.InputBox.TextBounds.X + 24, 0, 30)}
					):Play()
				end
				resizeInputFrame()

				local function handleInputCallbackError(response)
					self.Animation:Create(Input, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = Color3.fromRGB(85, 0, 0)}):Play()
					self.Animation:Create(Input.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 1}):Play()
					Input.Title.Text = "Callback Error"
					print("Rayfield | "..InputSettings.Name.." Callback Error " ..tostring(response))
					warn('Check docs.sirius.menu for help with Rayfield specific development.')
					task.wait(0.5)
					Input.Title.Text = InputSettings.Name
					self.Animation:Create(Input, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackground}):Play()
					self.Animation:Create(Input.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 0}):Play()
				end

				local inputSyncToken = registerElementSync({
					name = InputSettings.Name,
					getState = function()
						return tostring(InputSettings.CurrentValue or "")
					end,
					normalize = function(rawText)
						local normalized = rawText
						if elementSync and elementSync.normalize and elementSync.normalize.text then
							normalized = elementSync.normalize.text(rawText, {
								default = "",
								trim = false
							})
						else
							normalized = tostring(rawText or "")
						end
						return normalized, {
							changed = tostring(InputSettings.CurrentValue or "") ~= normalized
						}
					end,
					applyVisual = function(value)
						InputSettings.CurrentValue = value
						local isFocused = false
						local focusOk, focusState = pcall(function()
							return Input.InputFrame.InputBox:IsFocused()
						end)
						if focusOk and focusState then
							isFocused = true
						end
						if not isFocused then
							Input.InputFrame.InputBox.Text = value
						end
						resizeInputFrame()
					end,
					emitCallback = function(value)
						InputSettings.Callback(value)
					end,
					persist = function()
						ctx.SaveConfiguration()
					end,
					isExt = function()
						return InputSettings.Ext == true
					end,
					isAlive = function()
						return Input ~= nil and Input.Parent ~= nil
					end,
					isVisibleContext = function()
						return Input.Visible and Input:IsDescendantOf(TabPage) and self.Elements.UIPageLayout.CurrentPage == TabPage
					end,
					onCallbackError = handleInputCallbackError
				})

				local function commitInput(rawText, commitOptions)
					local options = commitOptions or {}
					if inputSyncToken then
						return commitElementSync(inputSyncToken, rawText, {
							reason = options.reason or "input_update",
							source = options.source or "unknown",
							emitCallback = options.emitCallback,
							persist = options.persist,
							forceCallback = options.forceCallback
						})
					end

					local normalized = tostring(rawText or "")
					InputSettings.CurrentValue = normalized
					Input.InputFrame.InputBox.Text = normalized
					resizeInputFrame()
					local success, response = pcall(function()
						InputSettings.Callback(normalized)
					end)
					if not success then
						handleInputCallbackError(response)
					elseif not InputSettings.Ext then
						ctx.SaveConfiguration()
					end
					return success, {
						normalized = normalized,
						changed = true,
						fallbackApplied = false,
						callbackOk = success
					}
				end

				Input.InputFrame.InputBox.FocusLost:Connect(function()
					commitInput(Input.InputFrame.InputBox.Text, {
						reason = "focus_lost",
						source = "user_input",
						emitCallback = true,
						persist = true,
						forceCallback = true
					})

					if InputSettings.RemoveTextAfterFocusLost then
						Input.InputFrame.InputBox.Text = ""
						resizeInputFrame()
					end
				end)
	
				local inputHoverBindingKey = registerHoverBinding(Input,
					function()
						self.Animation:Create(Input, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackgroundHover}):Play()
					end,
					function()
						self.Animation:Create(Input, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackground}):Play()
					end
				)
	
				Input.InputFrame.InputBox:GetPropertyChangedSignal("Text"):Connect(function()
					resizeInputFrame()
				end)
	
				function InputSettings:Set(text)
					commitInput(text, {
						reason = "set",
						source = "api_set",
						emitCallback = true,
						persist = true,
						forceCallback = true
					})
				end
	
				if Settings.ConfigurationSaving then
					if Settings.ConfigurationSaving.Enabled and InputSettings.Flag then
						self.RayfieldLibrary.Flags[InputSettings.Flag] = InputSettings
					end
				end
	
				self.Rayfield.Main:GetPropertyChangedSignal('BackgroundColor3'):Connect(function()
					Input.InputFrame.BackgroundColor3 = self.getSelectedTheme().InputBackground
					Input.InputFrame.UIStroke.Color = self.getSelectedTheme().InputStroke
				end)
	
				function InputSettings:Destroy()
					Input:Destroy()
				end

				-- Add extended API
				addExtendedAPI(InputSettings, InputSettings.Name, "Input", Input, inputHoverBindingKey, inputSyncToken)

				return InputSettings
			end
	
			-- Dropdown
			function Tab:CreateDropdown(DropdownSettings)
				local ctx = self
				local Dropdown = self.Elements.Template.Dropdown:Clone()
				local function normalizeDropdownOptions(rawOptions)
					local normalized = {}
					if type(rawOptions) ~= "table" then
						if rawOptions ~= nil then
							table.insert(normalized, tostring(rawOptions))
						end
						return normalized
					end
					if #rawOptions > 0 then
						for _, option in ipairs(rawOptions) do
							if option ~= nil then
								table.insert(normalized, tostring(option))
							end
						end
						return normalized
					end
					for _, option in pairs(rawOptions) do
						if option ~= nil then
							table.insert(normalized, tostring(option))
						end
					end
					return normalized
				end

				DropdownSettings.Options = normalizeDropdownOptions(DropdownSettings.Options)
				DropdownSettings.ClearBehavior = tostring(DropdownSettings.ClearBehavior or DropdownSettings.SelectionFallback or "default"):lower()
				if DropdownSettings.ClearBehavior ~= "default" and DropdownSettings.ClearBehavior ~= "none" then
					DropdownSettings.ClearBehavior = "default"
				end
				if type(DropdownSettings.Callback) ~= "function" then
					DropdownSettings.Callback = function() end
				end

				local function containsDropdownOption(optionName)
					for _, option in ipairs(DropdownSettings.Options) do
						if option == optionName then
							return true
						end
					end
					return false
				end

				local function toSelectionArray(rawSelection)
					local normalized = {}
					if rawSelection == nil then
						return normalized
					end

					if type(rawSelection) == "string" then
						table.insert(normalized, rawSelection)
						return normalized
					end

					if type(rawSelection) ~= "table" then
						table.insert(normalized, tostring(rawSelection))
						return normalized
					end

					if #rawSelection > 0 then
						for _, option in ipairs(rawSelection) do
							if option ~= nil then
								table.insert(normalized, tostring(option))
							end
						end
					else
						for _, option in pairs(rawSelection) do
							if option ~= nil then
								table.insert(normalized, tostring(option))
							end
						end
					end

					return normalized
				end

				local function cloneSelection(selection)
					local cloned = {}
					if type(selection) ~= "table" then
						return cloned
					end
					for _, option in ipairs(selection) do
						table.insert(cloned, option)
					end
					return cloned
				end

				local function selectionEquals(leftSelection, rightSelection)
					if type(leftSelection) ~= "table" or type(rightSelection) ~= "table" then
						return false
					end
					if #leftSelection ~= #rightSelection then
						return false
					end
					for index, value in ipairs(leftSelection) do
						if rightSelection[index] ~= value then
							return false
						end
					end
					return true
				end

				local function getDefaultSelection()
					local defaultRaw = DropdownSettings.DefaultSelection
					if defaultRaw == nil then
						defaultRaw = DropdownSettings.DefaultOption
					end

					local defaults = {}
					for _, optionName in ipairs(toSelectionArray(defaultRaw)) do
						if containsDropdownOption(optionName) then
							table.insert(defaults, optionName)
						end
					end

					if not DropdownSettings.MultipleOptions then
						if defaults[1] then
							return { defaults[1] }
						end
						return {}
					end

					return defaults
				end

				local function normalizeSelection(rawSelection, allowDefaultFallback)
					local normalized = {}
					local dedupe = {}

					for _, optionName in ipairs(toSelectionArray(rawSelection)) do
						if containsDropdownOption(optionName) and not dedupe[optionName] then
							dedupe[optionName] = true
							table.insert(normalized, optionName)
						end
					end

					if not DropdownSettings.MultipleOptions and #normalized > 1 then
						normalized = { normalized[1] }
					end

					local fallbackApplied = false
					if allowDefaultFallback and #normalized == 0 and DropdownSettings.ClearBehavior ~= "none" then
						local fallback = getDefaultSelection()
						if #fallback > 0 then
							normalized = fallback
							fallbackApplied = true
						end
					end

					return normalized, fallbackApplied
				end

				local function updateSelectedText()
					if DropdownSettings.MultipleOptions then
						if #DropdownSettings.CurrentOption == 1 then
							Dropdown.Selected.Text = DropdownSettings.CurrentOption[1]
						elseif #DropdownSettings.CurrentOption == 0 then
							Dropdown.Selected.Text = "None"
						else
							Dropdown.Selected.Text = "Various"
						end
					else
						Dropdown.Selected.Text = DropdownSettings.CurrentOption[1] or "None"
					end
				end

				local function updateOptionVisuals(animated)
					for _, droption in ipairs(Dropdown.List:GetChildren()) do
						if droption.ClassName == "Frame" and droption.Name ~= "Placeholder" and droption.Name ~= "Template" then
							local targetColor = table.find(DropdownSettings.CurrentOption, droption.Name) and self.getSelectedTheme().DropdownSelected or self.getSelectedTheme().DropdownUnselected
							if animated then
								self.Animation:Create(droption, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {BackgroundColor3 = targetColor}):Play()
							else
								droption.BackgroundColor3 = targetColor
							end
						end
					end
				end

				local function handleSelectionCallbackError(response)
					self.Animation:Create(Dropdown, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = Color3.fromRGB(85, 0, 0)}):Play()
					self.Animation:Create(Dropdown.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 1}):Play()
					Dropdown.Title.Text = "Callback Error"
					print("Rayfield | "..DropdownSettings.Name.." Callback Error " ..tostring(response))
					warn('Check docs.sirius.menu for help with Rayfield specific development.')
					task.wait(0.5)
					Dropdown.Title.Text = DropdownSettings.Name
					self.Animation:Create(Dropdown, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackground}):Play()
					self.Animation:Create(Dropdown.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 0}):Play()
				end

				local function emitSelectionNormalized(reason, fallbackApplied, changed)
					if type(DropdownSettings.OnSelectionNormalized) == "function" then
						local okMeta, metaErr = pcall(DropdownSettings.OnSelectionNormalized, DropdownSettings.CurrentOption, {
							reason = reason,
							fallbackApplied = fallbackApplied,
							changed = changed
						})
						if not okMeta then
							warn("Rayfield | Dropdown OnSelectionNormalized Error " .. tostring(metaErr))
						end
					end
				end

				local dropdownSyncToken = registerElementSync({
					name = DropdownSettings.Name,
					getState = function()
						return cloneSelection(DropdownSettings.CurrentOption)
					end,
					normalize = function(rawSelection, syncMeta)
						local options = (syncMeta and syncMeta.options) or {}
						local normalizedSelection, fallbackApplied = normalizeSelection(rawSelection, options.allowDefaultFallback ~= false)
						return normalizedSelection, {
							changed = not selectionEquals(DropdownSettings.CurrentOption, normalizedSelection),
							fallbackApplied = fallbackApplied
						}
					end,
					applyVisual = function(normalizedSelection, syncMeta)
						DropdownSettings.CurrentOption = cloneSelection(normalizedSelection)
						local animated = syncMeta and syncMeta.options and syncMeta.options.animatedVisuals == true
						updateSelectedText()
						updateOptionVisuals(animated)
						emitSelectionNormalized(
							(syncMeta and syncMeta.reason) or "unknown",
							syncMeta and syncMeta.fallbackApplied == true,
							syncMeta and syncMeta.changed == true
						)
					end,
					emitCallback = function(normalizedSelection)
						DropdownSettings.Callback(cloneSelection(normalizedSelection))
					end,
					persist = function()
						self.SaveConfiguration()
					end,
					isExt = function()
						return DropdownSettings.Ext == true
					end,
					isAlive = function()
						return Dropdown ~= nil and Dropdown.Parent ~= nil
					end,
					isVisibleContext = function()
						return Dropdown.Visible and Dropdown:IsDescendantOf(TabPage) and self.Elements.UIPageLayout.CurrentPage == TabPage
					end,
					onCallbackError = handleSelectionCallbackError
				})

				local function commitSelection(rawSelection, commitOptions)
					local options = commitOptions or {}
					if dropdownSyncToken then
						local callbackOk, result = commitElementSync(dropdownSyncToken, rawSelection, {
							reason = options.reason or "selection_update",
							source = options.source or "unknown",
							emitCallback = options.emitCallback,
							persist = options.persist,
							forceCallback = options.forceCallback,
							allowDefaultFallback = options.allowDefaultFallback,
							animatedVisuals = options.animatedVisuals
						})
						if type(result) ~= "table" then
							return false, false, callbackOk
						end
						return result.changed == true, result.fallbackApplied == true, callbackOk
					end

					local previousSelection = cloneSelection(DropdownSettings.CurrentOption)
					local normalizedSelection, fallbackApplied = normalizeSelection(rawSelection, options.allowDefaultFallback ~= false)
					DropdownSettings.CurrentOption = normalizedSelection
					local changed = not selectionEquals(previousSelection, normalizedSelection)
					updateSelectedText()
					updateOptionVisuals(options.animatedVisuals == true)
					emitSelectionNormalized(options.reason or "unknown", fallbackApplied, changed)

					local callbackSuccess, response = pcall(function()
						DropdownSettings.Callback(DropdownSettings.CurrentOption)
					end)
					if not callbackSuccess then
						handleSelectionCallbackError(response)
					elseif not DropdownSettings.Ext and options.persist ~= false then
						self.SaveConfiguration()
					end
					return changed, fallbackApplied, callbackSuccess
				end
				if string.find(DropdownSettings.Name,"closed") then
					Dropdown.Name = "Dropdown"
				else
					Dropdown.Name = DropdownSettings.Name
				end
				Dropdown.Title.Text = DropdownSettings.Name
				Dropdown.Visible = true
				Dropdown.Parent = TabPage
	
				Dropdown.Size = UDim2.new(1, -10, 0, 45)
				Dropdown.List.Visible = false
				Dropdown.List.ScrollBarImageTransparency = 1
				local initialSelection = DropdownSettings.CurrentOption
				DropdownSettings.CurrentOption = {}
				commitSelection(initialSelection, {
					emitCallback = false,
					persist = false,
					forceCallback = false,
					reason = "initial"
				})
	
				self.bindTheme(Dropdown.Toggle, "ImageColor3", "TextColor")
				
				-- Reactive coloring for Dropdown options
				Dropdown.List.ChildAdded:Connect(function(Option)
					if Option.ClassName == "Frame" and Option.Name ~= "Placeholder" then
						if table.find(DropdownSettings.CurrentOption, Option.Name) then
							self.bindTheme(Option, "BackgroundColor3", "DropdownSelected")
						else
							self.bindTheme(Option, "BackgroundColor3", "DropdownUnselected")
						end
						self.bindTheme(Option.UIStroke, "Color", "ElementStroke")
					end
				end)
	
				Dropdown.Toggle.Rotation = 180
	
				Dropdown.Interact.MouseButton1Click:Connect(function()
					self.Animation:Create(Dropdown, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackgroundHover}):Play()
					self.Animation:Create(Dropdown.UIStroke, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {Transparency = 1}):Play()
					task.wait(0.1)
					self.Animation:Create(Dropdown, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackground}):Play()
					self.Animation:Create(Dropdown.UIStroke, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {Transparency = 0}):Play()
					if self.getDebounce() then return end
					if Dropdown.List.Visible then
						self.setDebounce(true)
						self.Animation:Create(Dropdown, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {Size = UDim2.new(1, -10, 0, 45)}):Play()
						for _, DropdownOpt in ipairs(Dropdown.List:GetChildren()) do
							if DropdownOpt.ClassName == "Frame" and DropdownOpt.Name ~= "Placeholder" then
								self.Animation:Create(DropdownOpt, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {BackgroundTransparency = 1}):Play()
								self.Animation:Create(DropdownOpt.UIStroke, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {Transparency = 1}):Play()
								self.Animation:Create(DropdownOpt.Title, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
							end
						end
						self.Animation:Create(Dropdown.List, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {ScrollBarImageTransparency = 1}):Play()
						self.Animation:Create(Dropdown.Toggle, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {Rotation = 180}):Play()
						task.wait(0.35)
						Dropdown.List.Visible = false
						self.setDebounce(false)
					else
						self.Animation:Create(Dropdown, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {Size = UDim2.new(1, -10, 0, 180)}):Play()
						Dropdown.List.Visible = true
						self.Animation:Create(Dropdown.List, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {ScrollBarImageTransparency = 0.7}):Play()
						self.Animation:Create(Dropdown.Toggle, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {Rotation = 0}):Play()	
						for _, DropdownOpt in ipairs(Dropdown.List:GetChildren()) do
							if DropdownOpt.ClassName == "Frame" and DropdownOpt.Name ~= "Placeholder" then
								if DropdownOpt.Name ~= Dropdown.Selected.Text then
									self.Animation:Create(DropdownOpt.UIStroke, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {Transparency = 0}):Play()
								end
								self.Animation:Create(DropdownOpt, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0}):Play()
								self.Animation:Create(DropdownOpt.Title, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {TextTransparency = 0}):Play()
							end
						end
					end
				end)
	
				local dropdownHoverBindingKey = registerHoverBinding(Dropdown,
					function()
						if not Dropdown.List.Visible then
							self.Animation:Create(Dropdown, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackgroundHover}):Play()
						end
					end,
					function()
						self.Animation:Create(Dropdown, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackground}):Play()
					end
				)
	
				local function SetDropdownOptions()
					local listTemplate = Dropdown.List:FindFirstChild("Template")
					if not listTemplate then
						warn("Rayfield | Dropdown template not found for " .. tostring(DropdownSettings.Name))
						return
					end

					for _, optionObject in ipairs(Dropdown.List:GetChildren()) do
						if optionObject.ClassName == "Frame" and optionObject.Name ~= "Placeholder" and optionObject.Name ~= "Template" then
							optionObject:Destroy()
						end
					end

					for _, Option in ipairs(DropdownSettings.Options) do
						local optionName = tostring(Option)
						local DropdownOption = listTemplate:Clone()
						DropdownOption.Name = optionName
						DropdownOption.Title.Text = optionName
						DropdownOption.Parent = Dropdown.List
						DropdownOption.Visible = true
	
						DropdownOption.BackgroundTransparency = 1
						DropdownOption.UIStroke.Transparency = 1
						DropdownOption.Title.TextTransparency = 1
	
						--local Dropdown = Tab:CreateDropdown({
						--	Name = "Dropdown Example",
						--	Options = {"Option 1","Option 2"},
						--	CurrentOption = {"Option 1"},
						--  MultipleOptions = true,
						--	Flag = "Dropdown1",
						--	Callback = function(TableOfOptions)
	
						--	end,
						--})
	
	
						DropdownOption.Interact.ZIndex = 50
						DropdownOption.Interact.MouseButton1Click:Connect(function()
							local nextSelection = cloneSelection(DropdownSettings.CurrentOption)
							local selectedIndex = table.find(nextSelection, optionName)
							local wasSelected = selectedIndex ~= nil

							if not DropdownSettings.MultipleOptions and wasSelected then 
								return
							end

							if selectedIndex then
								table.remove(nextSelection, selectedIndex)
							else
								if not DropdownSettings.MultipleOptions then
									table.clear(nextSelection)
								end
								table.insert(nextSelection, optionName)
								self.Animation:Create(DropdownOption.UIStroke, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {Transparency = 1}):Play()
								self.Animation:Create(DropdownOption, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().DropdownSelected}):Play()
								self.setDebounce(true)
							end

							commitSelection(nextSelection, {
								emitCallback = true,
								persist = true,
								forceCallback = true,
								reason = "option_click",
								animatedVisuals = true
							})

							if not DropdownSettings.MultipleOptions then
								task.wait(0.1)
								self.Animation:Create(Dropdown, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {Size = UDim2.new(1, -10, 0, 45)}):Play()
								for _, DropdownOpt in ipairs(Dropdown.List:GetChildren()) do
									if DropdownOpt.ClassName == "Frame" and DropdownOpt.Name ~= "Placeholder" then
										self.Animation:Create(DropdownOpt, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {BackgroundTransparency = 1}):Play()
										self.Animation:Create(DropdownOpt.UIStroke, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {Transparency = 1}):Play()
										self.Animation:Create(DropdownOpt.Title, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
									end
								end
								self.Animation:Create(Dropdown.List, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {ScrollBarImageTransparency = 1}):Play()
								self.Animation:Create(Dropdown.Toggle, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {Rotation = 180}):Play()
								task.wait(0.35)
								Dropdown.List.Visible = false
							end
							self.setDebounce(false)
						end)
	
						self.Rayfield.Main:GetPropertyChangedSignal('BackgroundColor3'):Connect(function()
							DropdownOption.UIStroke.Color = self.getSelectedTheme().ElementStroke
						end)
					end
				end
				SetDropdownOptions()
	
				for _, droption in ipairs(Dropdown.List:GetChildren()) do
					if droption.ClassName == "Frame" and droption.Name ~= "Placeholder" then
						if not table.find(DropdownSettings.CurrentOption, droption.Name) then
							droption.BackgroundColor3 = self.getSelectedTheme().DropdownUnselected
						else
							droption.BackgroundColor3 = self.getSelectedTheme().DropdownSelected
						end
	
						self.Rayfield.Main:GetPropertyChangedSignal('BackgroundColor3'):Connect(function()
							if not table.find(DropdownSettings.CurrentOption, droption.Name) then
								droption.BackgroundColor3 = self.getSelectedTheme().DropdownUnselected
							else
								droption.BackgroundColor3 = self.getSelectedTheme().DropdownSelected
							end
						end)
					end
				end
	
				function DropdownSettings:Set(NewOption)
					commitSelection(NewOption, {
						emitCallback = true,
						persist = true,
						forceCallback = true,
						reason = "set",
						animatedVisuals = false
					})
				end
	
				function DropdownSettings:Refresh(optionsTable) -- updates a dropdown with new options from optionsTable
					DropdownSettings.Options = normalizeDropdownOptions(optionsTable)
					for _, option in Dropdown.List:GetChildren() do
						if option.ClassName == "Frame" and option.Name ~= "Placeholder" and option.Name ~= "Template" then
							option:Destroy()
						end
					end
					Dropdown.List.Visible = false
					Dropdown.Size = UDim2.new(1, -10, 0, 45)
					Dropdown.Toggle.Rotation = 180
					Dropdown.List.ScrollBarImageTransparency = 1
					SetDropdownOptions()
					commitSelection(DropdownSettings.CurrentOption, {
						emitCallback = true,
						persist = true,
						forceCallback = false,
						reason = "refresh",
						animatedVisuals = false
					})
				end
	
				function DropdownSettings:Clear()
					commitSelection({}, {
						emitCallback = true,
						persist = true,
						forceCallback = true,
						reason = "clear",
						allowDefaultFallback = true,
						animatedVisuals = false
					})
				end
	
				function DropdownSettings:Destroy()
					Dropdown:Destroy()
				end

				-- Add extended API
				addExtendedAPI(DropdownSettings, DropdownSettings.Name, "Dropdown", Dropdown, dropdownHoverBindingKey, dropdownSyncToken)
	
				if Settings.ConfigurationSaving then
					if Settings.ConfigurationSaving.Enabled and DropdownSettings.Flag then
						self.RayfieldLibrary.Flags[DropdownSettings.Flag] = DropdownSettings
					end
				end
	
				self.Rayfield.Main:GetPropertyChangedSignal('BackgroundColor3'):Connect(function()
					Dropdown.Toggle.ImageColor3 = self.getSelectedTheme().TextColor
					self.Animation:Create(Dropdown, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackground}):Play()
				end)
	
				return DropdownSettings
			end

			local SequenceLib = self.KeybindSequence

			local function trim(value)
				if type(value) ~= "string" then
					return ""
				end
				local out = value:gsub("^%s+", "")
				out = out:gsub("%s+$", "")
				return out
			end

			local function resolveSequenceRuntimeOptions(sourceSettings)
				local maxSteps = 4
				local stepTimeoutMs = 800

				if SequenceLib and SequenceLib.DEFAULT_MAX_STEPS then
					maxSteps = SequenceLib.DEFAULT_MAX_STEPS
				end
				if SequenceLib and SequenceLib.DEFAULT_STEP_TIMEOUT_MS then
					stepTimeoutMs = SequenceLib.DEFAULT_STEP_TIMEOUT_MS
				end

				if sourceSettings then
					local customMaxSteps = tonumber(sourceSettings.MaxSteps)
					if customMaxSteps and customMaxSteps > 0 then
						maxSteps = math.floor(customMaxSteps)
					end

					local customTimeout = tonumber(sourceSettings.StepTimeoutMs)
					if customTimeout and customTimeout > 0 then
						stepTimeoutMs = math.floor(customTimeout)
					end
				end

				maxSteps = math.clamp(maxSteps, 1, 4)
				stepTimeoutMs = math.max(1, stepTimeoutMs)
				return maxSteps, stepTimeoutMs
			end

			local function normalizeSequenceBinding(rawBinding, sourceSettings)
				if not SequenceLib then
					if rawBinding == nil or tostring(rawBinding) == "" then
						return nil, nil, "sequence_lib_missing"
					end
					local fallback = tostring(rawBinding)
					local split = string.split(fallback, ">")
					local single = split[1]
					if single and single ~= "" then
						fallback = tostring(single)
					end
					return fallback, nil, nil
				end

				local maxSteps, _ = resolveSequenceRuntimeOptions(sourceSettings)
				return SequenceLib.normalize(rawBinding, {
					maxSteps = maxSteps
				})
			end

			local function parseSequenceInput(rawText, sourceSettings)
				if not SequenceLib then
					return normalizeSequenceBinding(rawText, sourceSettings)
				end

				local maxSteps, _ = resolveSequenceRuntimeOptions(sourceSettings)
				return SequenceLib.parseUserInput(rawText, sourceSettings and sourceSettings.ParseInput, {
					maxSteps = maxSteps,
					fallbackToDefault = true
				})
			end

			local function formatSequenceDisplay(canonical, steps, sourceSettings)
				if not canonical or canonical == "" then
					return ""
				end
				if not SequenceLib then
					return tostring(canonical)
				end

				local displaySource = steps
				if type(displaySource) ~= "table" or displaySource[1] == nil then
					displaySource = canonical
				end

				local display = SequenceLib.formatDisplay(displaySource, sourceSettings and sourceSettings.DisplayFormatter, {
					maxSteps = select(1, resolveSequenceRuntimeOptions(sourceSettings))
				})

				if type(display) ~= "string" or display == "" then
					return tostring(canonical)
				end

				return display
			end
	
			-- Keybind
			function Tab:CreateKeybind(KeybindSettings)
				local ctx = self
				local CheckingForKey = false
				local captureSteps = {}
				local captureToken = 0
				local maxSteps, stepTimeoutMs = resolveSequenceRuntimeOptions(KeybindSettings)
				local sequenceMatcher = SequenceLib and SequenceLib.newMatcher({
					maxSteps = maxSteps,
					stepTimeoutMs = stepTimeoutMs
				}) or nil
				local Keybind = self.Elements.Template.Keybind:Clone()
				Keybind.Name = KeybindSettings.Name
				Keybind.Title.Text = KeybindSettings.Name
				Keybind.Visible = true
				Keybind.Parent = TabPage
	
				Keybind.BackgroundTransparency = 1
				Keybind.UIStroke.Transparency = 1
				Keybind.Title.TextTransparency = 1
	
				Keybind.KeybindFrame.BackgroundColor3 = self.getSelectedTheme().InputBackground
				Keybind.KeybindFrame.UIStroke.Color = self.getSelectedTheme().InputStroke
	
				self.Animation:Create(Keybind, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0}):Play()
				self.Animation:Create(Keybind.UIStroke, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {Transparency = 0}):Play()
				self.Animation:Create(Keybind.Title, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {TextTransparency = 0}):Play()	

				if type(KeybindSettings.Callback) ~= "function" then
					KeybindSettings.Callback = function() end
				end

				KeybindSettings.MaxSteps = maxSteps
				KeybindSettings.StepTimeoutMs = stepTimeoutMs

				local activeSteps = nil
				local activeCanonical, parsedSteps = normalizeSequenceBinding(KeybindSettings.CurrentKeybind or "Q", KeybindSettings)
				if not activeCanonical then
					activeCanonical, parsedSteps = normalizeSequenceBinding("Q", KeybindSettings)
				end
				activeSteps = parsedSteps
				KeybindSettings.CurrentKeybind = activeCanonical or "Q"

				local function resizeKeybindFrameToText()
					self.Animation:Create(Keybind.KeybindFrame, TweenInfo.new(0.55, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out), {
						Size = UDim2.new(0, Keybind.KeybindFrame.KeybindBox.TextBounds.X + 24, 0, 30)
					}):Play()
				end

				local function applyBinding(canonical, steps, callOnChange)
					if not canonical then
						return false
					end

					KeybindSettings.CurrentKeybind = canonical
					activeSteps = steps
					Keybind.KeybindFrame.KeybindBox.Text = formatSequenceDisplay(canonical, steps, KeybindSettings)
					resizeKeybindFrameToText()

					if sequenceMatcher then
						sequenceMatcher:setBinding({
							canonical = canonical,
							steps = activeSteps
						})
					end

					if not KeybindSettings.Ext then
						self.SaveConfiguration()
					end

					if callOnChange and KeybindSettings.CallOnChange then
						KeybindSettings.Callback(canonical)
					end
					return true
				end

				local function finalizeCapture(releaseFocus)
					captureToken += 1
					if #captureSteps <= 0 then
						return false
					end

					local candidateCanonical = table.concat(captureSteps, ">")
					captureSteps = {}

					local canonical, steps = normalizeSequenceBinding(candidateCanonical, KeybindSettings)
					if canonical then
						applyBinding(canonical, steps, true)
					else
						Keybind.KeybindFrame.KeybindBox.Text = formatSequenceDisplay(KeybindSettings.CurrentKeybind, activeSteps, KeybindSettings)
						resizeKeybindFrameToText()
					end

					if releaseFocus and Keybind.KeybindFrame.KeybindBox:IsFocused() then
						Keybind.KeybindFrame.KeybindBox:ReleaseFocus()
					end

					return canonical ~= nil
				end

				local function scheduleCaptureFinalize()
					captureToken += 1
					local token = captureToken
					task.delay(stepTimeoutMs / 1000, function()
						if CheckingForKey and token == captureToken then
							finalizeCapture(true)
						end
					end)
				end

				applyBinding(KeybindSettings.CurrentKeybind, activeSteps, false)

				Keybind.KeybindFrame.KeybindBox.Focused:Connect(function()
					CheckingForKey = true
					Keybind.KeybindFrame.KeybindBox.Text = ""
					captureSteps = {}
					captureToken += 1
				end)
				Keybind.KeybindFrame.KeybindBox.FocusLost:Connect(function()
					local typedText = trim(Keybind.KeybindFrame.KeybindBox.Text or "")
					local captureWasActive = CheckingForKey
					CheckingForKey = false
					captureToken += 1

					if captureWasActive and #captureSteps > 0 then
						finalizeCapture(false)
						return
					end

					if typedText ~= "" then
						local canonical, steps = parseSequenceInput(typedText, KeybindSettings)
						if canonical then
							applyBinding(canonical, steps, true)
							return
						end
					end

					Keybind.KeybindFrame.KeybindBox.Text = formatSequenceDisplay(KeybindSettings.CurrentKeybind, activeSteps, KeybindSettings)
					resizeKeybindFrameToText()
				end)
	
				local keybindHoverBindingKey = registerHoverBinding(Keybind,
					function()
						self.Animation:Create(Keybind, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackgroundHover}):Play()
					end,
					function()
						self.Animation:Create(Keybind, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackground}):Play()
					end
				)
	
				local connection = self.UserInputService.InputBegan:Connect(function(input, processed)
					if CheckingForKey then
						if input.UserInputType ~= Enum.UserInputType.Keyboard then
							return
						end

						if input.KeyCode == Enum.KeyCode.Return or input.KeyCode == Enum.KeyCode.KeypadEnter then
							finalizeCapture(true)
							return
						end

						local capturedStep = nil
						if SequenceLib then
							capturedStep = select(1, SequenceLib.captureStepFromInput(input, self.UserInputService))
						elseif input.KeyCode and input.KeyCode ~= Enum.KeyCode.Unknown then
							capturedStep = input.KeyCode.Name
						end

						if capturedStep then
							if #captureSteps < maxSteps then
								table.insert(captureSteps, capturedStep)
							end

							local previewCanonical = table.concat(captureSteps, ">")
							local previewSteps = select(2, normalizeSequenceBinding(previewCanonical, KeybindSettings))
							Keybind.KeybindFrame.KeybindBox.Text = formatSequenceDisplay(previewCanonical, previewSteps, KeybindSettings)
							resizeKeybindFrameToText()

							if #captureSteps >= maxSteps then
								finalizeCapture(true)
							else
								scheduleCaptureFinalize()
							end
						end
					elseif not KeybindSettings.CallOnChange then
						local matched = false
						if sequenceMatcher then
							matched = sequenceMatcher:consume(input, {
								canonical = KeybindSettings.CurrentKeybind,
								steps = activeSteps
							}, self.UserInputService, processed)
						elseif KeybindSettings.CurrentKeybind and not processed then
							matched = input.KeyCode == Enum.KeyCode[KeybindSettings.CurrentKeybind]
						end

						if not matched then
							return
						end

						local Held = true
						local Connection
						Connection = input.Changed:Connect(function(prop)
							if prop == "UserInputState" then
								Connection:Disconnect()
								Held = false
							end
						end)
	
						if not KeybindSettings.HoldToInteract then
							local Success, Response = pcall(KeybindSettings.Callback)
							if not Success then
								self.Animation:Create(Keybind, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = Color3.fromRGB(85, 0, 0)}):Play()
								self.Animation:Create(Keybind.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 1}):Play()
								Keybind.Title.Text = "Callback Error"
								print("Rayfield | "..KeybindSettings.Name.." Callback Error " ..tostring(Response))
								warn('Check docs.sirius.menu for help with Rayfield specific development.')
								task.wait(0.5)
								Keybind.Title.Text = KeybindSettings.Name
								self.Animation:Create(Keybind, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackground}):Play()
								self.Animation:Create(Keybind.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 0}):Play()
							end
						else
							task.wait(0.25)
							if Held then
								local Loop; Loop = self.RunService.Stepped:Connect(function()
									if not Held then
										KeybindSettings.Callback(false) -- maybe pcall this
										Loop:Disconnect()
									else
										KeybindSettings.Callback(true) -- maybe pcall this
									end
								end)
							end
						end
					end
				end)
				table.insert(self.keybindConnections, connection)

				Keybind.KeybindFrame.KeybindBox:GetPropertyChangedSignal("Text"):Connect(function()
					resizeKeybindFrameToText()
				end)
	
				function KeybindSettings:Set(NewKeybind)
					local canonical, steps = normalizeSequenceBinding(NewKeybind, KeybindSettings)
					if not canonical then
						canonical, steps = parseSequenceInput(tostring(NewKeybind or ""), KeybindSettings)
					end

					if canonical then
						applyBinding(canonical, steps, true)
					else
						Keybind.KeybindFrame.KeybindBox.Text = formatSequenceDisplay(KeybindSettings.CurrentKeybind, activeSteps, KeybindSettings)
						resizeKeybindFrameToText()
					end
				end
	
				if Settings.ConfigurationSaving then
					if Settings.ConfigurationSaving.Enabled and KeybindSettings.Flag then
						self.RayfieldLibrary.Flags[KeybindSettings.Flag] = KeybindSettings
					end
				end
	
				self.Rayfield.Main:GetPropertyChangedSignal('BackgroundColor3'):Connect(function()
					Keybind.KeybindFrame.BackgroundColor3 = self.getSelectedTheme().InputBackground
					Keybind.KeybindFrame.UIStroke.Color = self.getSelectedTheme().InputStroke
				end)
	
				function KeybindSettings:Destroy()
					Keybind:Destroy()
				end
	
				-- Add extended API
				addExtendedAPI(KeybindSettings, KeybindSettings.Name, "Keybind", Keybind, keybindHoverBindingKey)
	
				return KeybindSettings
			end
	
			-- Toggle
			function Tab:CreateToggle(ToggleSettings)
				local ctx = self
				ToggleSettings = ToggleSettings or {}
				ToggleSettings.Name = ToggleSettings.Name or "Toggle"
				if type(ToggleSettings.Callback) ~= "function" then
					ToggleSettings.Callback = function() end
				end
				ToggleSettings.CurrentValue = ToggleSettings.CurrentValue == true

				local toggleKeybindSettings = ToggleSettings.Keybind
				if type(toggleKeybindSettings) ~= "table" then
					toggleKeybindSettings = {}
				end
				if ToggleSettings.EnableKeybind ~= nil and toggleKeybindSettings.Enabled == nil then
					toggleKeybindSettings.Enabled = ToggleSettings.EnableKeybind
				end
				if ToggleSettings.CurrentKeybind and toggleKeybindSettings.CurrentKeybind == nil then
					toggleKeybindSettings.CurrentKeybind = ToggleSettings.CurrentKeybind
				end
				if ToggleSettings.KeybindDisplayFormatter and toggleKeybindSettings.DisplayFormatter == nil then
					toggleKeybindSettings.DisplayFormatter = ToggleSettings.KeybindDisplayFormatter
				end
				if ToggleSettings.KeybindParseInput and toggleKeybindSettings.ParseInput == nil then
					toggleKeybindSettings.ParseInput = ToggleSettings.KeybindParseInput
				end
				if ToggleSettings.KeybindMaxSteps and toggleKeybindSettings.MaxSteps == nil then
					toggleKeybindSettings.MaxSteps = ToggleSettings.KeybindMaxSteps
				end
				if ToggleSettings.KeybindStepTimeoutMs and toggleKeybindSettings.StepTimeoutMs == nil then
					toggleKeybindSettings.StepTimeoutMs = ToggleSettings.KeybindStepTimeoutMs
				end
				ToggleSettings.Keybind = toggleKeybindSettings

				local keybindEnabled = toggleKeybindSettings.Enabled == true
				local toggleKeybindMaxSteps, toggleKeybindTimeoutMs = resolveSequenceRuntimeOptions(toggleKeybindSettings)
				toggleKeybindSettings.MaxSteps = toggleKeybindMaxSteps
				toggleKeybindSettings.StepTimeoutMs = toggleKeybindTimeoutMs
				toggleKeybindSettings.CurrentKeybind = toggleKeybindSettings.CurrentKeybind or "Q"
				ToggleSettings.CurrentKeybind = toggleKeybindSettings.CurrentKeybind

				local toggleKeybindConnection = nil
				local toggleKeybindMatcher = nil
				local toggleKeybindActiveSteps = nil
				local keybindCapturing = false
				local keybindCaptureSteps = {}
				local keybindCaptureToken = 0
				local suppressNextToggleClick = false
				local toggleKeybindFrame = nil
				local toggleKeybindBox = nil
				local toggleKeybindFlagProxy = nil
	
				local Toggle = self.Elements.Template.Toggle:Clone()
				Toggle.Name = ToggleSettings.Name
				Toggle.Title.Text = ToggleSettings.Name
				Toggle.Visible = true
				Toggle.Parent = TabPage
	
				Toggle.BackgroundTransparency = 1
				Toggle.UIStroke.Transparency = 1
				Toggle.Title.TextTransparency = 1
				self.bindTheme(Toggle.Switch, "BackgroundColor3", "ToggleBackground")
	
				if self.getSelectedTheme() ~= self.RayfieldLibrary.Theme.Default then
					local toggleShadow = Toggle.Switch:FindFirstChild("Shadow")
					if toggleShadow then
						toggleShadow.Visible = false
					end
				end
	
				self.Animation:Create(Toggle, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0}):Play()
				self.Animation:Create(Toggle.UIStroke, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {Transparency = 0}):Play()
				self.Animation:Create(Toggle.Title, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {TextTransparency = 0}):Play()	
	
				local function UpdateToggleColors()
					if ToggleSettings.CurrentValue == true then
						Toggle.Switch.Indicator.UIStroke.Color = self.getSelectedTheme().ToggleEnabledStroke
						Toggle.Switch.Indicator.BackgroundColor3 = self.getSelectedTheme().ToggleEnabled
						Toggle.Switch.UIStroke.Color = self.getSelectedTheme().ToggleEnabledOuterStroke
					else
						Toggle.Switch.Indicator.UIStroke.Color = self.getSelectedTheme().ToggleDisabledStroke
						Toggle.Switch.Indicator.BackgroundColor3 = self.getSelectedTheme().ToggleDisabled
						Toggle.Switch.UIStroke.Color = self.getSelectedTheme().ToggleDisabledOuterStroke
					end
				end

				local function handleToggleCallbackError(response)
					self.Animation:Create(Toggle, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = Color3.fromRGB(85, 0, 0)}):Play()
					self.Animation:Create(Toggle.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 1}):Play()
					Toggle.Title.Text = "Callback Error"
					print("Rayfield | "..ToggleSettings.Name.." Callback Error " ..tostring(response))
					warn('Check docs.sirius.menu for help with Rayfield specific development.')
					task.wait(0.5)
					Toggle.Title.Text = ToggleSettings.Name
					self.Animation:Create(Toggle, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackground}):Play()
					self.Animation:Create(Toggle.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 0}):Play()
				end

				local function applyToggleVisual(nextValue)
					if nextValue == true then
						ToggleSettings.CurrentValue = true
						self.Animation:Create(Toggle, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackgroundHover}):Play()
						self.Animation:Create(Toggle.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 1}):Play()
						self.Animation:Create(Toggle.Switch.Indicator, TweenInfo.new(0.5, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {Position = UDim2.new(1, -20, 0.5, 0)}):Play()
						self.Animation:Create(Toggle.Switch.Indicator, TweenInfo.new(0.4, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {Size = UDim2.new(0,12,0,12)}):Play()
						self.Animation:Create(Toggle.Switch.Indicator.UIStroke, TweenInfo.new(0.55, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out), {Color = self.getSelectedTheme().ToggleEnabledStroke}):Play()
						self.Animation:Create(Toggle.Switch.Indicator, TweenInfo.new(0.8, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out), {BackgroundColor3 = self.getSelectedTheme().ToggleEnabled}):Play()
						self.Animation:Create(Toggle.Switch.UIStroke, TweenInfo.new(0.55, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out), {Color = self.getSelectedTheme().ToggleEnabledOuterStroke}):Play()
						self.Animation:Create(Toggle.Switch.Indicator, TweenInfo.new(0.45, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {Size = UDim2.new(0,17,0,17)}):Play()
						self.Animation:Create(Toggle, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackground}):Play()
						self.Animation:Create(Toggle.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 0}):Play()
					else
						ToggleSettings.CurrentValue = false
						self.Animation:Create(Toggle, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackgroundHover}):Play()
						self.Animation:Create(Toggle.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 1}):Play()
						self.Animation:Create(Toggle.Switch.Indicator, TweenInfo.new(0.45, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {Position = UDim2.new(1, -40, 0.5, 0)}):Play()
						self.Animation:Create(Toggle.Switch.Indicator, TweenInfo.new(0.4, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {Size = UDim2.new(0,12,0,12)}):Play()
						self.Animation:Create(Toggle.Switch.Indicator.UIStroke, TweenInfo.new(0.55, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out), {Color = self.getSelectedTheme().ToggleDisabledStroke}):Play()
						self.Animation:Create(Toggle.Switch.Indicator, TweenInfo.new(0.8, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out), {BackgroundColor3 = self.getSelectedTheme().ToggleDisabled}):Play()
						self.Animation:Create(Toggle.Switch.UIStroke, TweenInfo.new(0.55, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out), {Color = self.getSelectedTheme().ToggleDisabledOuterStroke}):Play()
						self.Animation:Create(Toggle.Switch.Indicator, TweenInfo.new(0.4, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {Size = UDim2.new(0,17,0,17)}):Play()
						self.Animation:Create(Toggle, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackground}):Play()
						self.Animation:Create(Toggle.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 0}):Play()
					end
				end

				local toggleSyncToken = registerElementSync({
					name = ToggleSettings.Name,
					getState = function()
						return ToggleSettings.CurrentValue == true
					end,
					normalize = function(rawValue)
						local normalized = rawValue == true
						if elementSync and elementSync.normalize and elementSync.normalize.boolean then
							normalized = elementSync.normalize.boolean(rawValue)
						end
						return normalized, {
							changed = (ToggleSettings.CurrentValue == true) ~= normalized
						}
					end,
					applyVisual = function(normalized)
						applyToggleVisual(normalized == true)
					end,
					emitCallback = function(normalized)
						if debugX then warn('Running toggle \''..ToggleSettings.Name..'\' (sync commit)') end
						ToggleSettings.Callback(normalized == true)
					end,
					persist = function()
						ctx.SaveConfiguration()
					end,
					isExt = function()
						return ToggleSettings.Ext == true
					end,
					isAlive = function()
						return Toggle ~= nil and Toggle.Parent ~= nil
					end,
					isVisibleContext = function()
						return Toggle.Visible and Toggle:IsDescendantOf(TabPage) and self.Elements.UIPageLayout.CurrentPage == TabPage
					end,
					onCallbackError = handleToggleCallbackError
				})

				local function commitToggleState(rawValue, commitOptions)
					local options = commitOptions or {}
					if toggleSyncToken then
						local callbackOk = commitElementSync(toggleSyncToken, rawValue, {
							reason = options.reason or "toggle_update",
							source = options.source or "unknown",
							emitCallback = options.emitCallback,
							persist = options.persist,
							forceCallback = options.forceCallback
						})
						return callbackOk
					end

					local normalized = rawValue == true
					applyToggleVisual(normalized)
					local success, response = pcall(function()
						ToggleSettings.Callback(ToggleSettings.CurrentValue)
					end)
					if not success then
						handleToggleCallbackError(response)
					elseif not ToggleSettings.Ext then
						ctx.SaveConfiguration()
					end
					return success
				end

				local function formatToggleKeybindDisplay(canonical, steps)
					return formatSequenceDisplay(canonical, steps, toggleKeybindSettings)
				end

				local function resizeToggleKeybindFrame()
					if not (toggleKeybindFrame and toggleKeybindBox) then
						return
					end
					local targetWidth = math.clamp(toggleKeybindBox.TextBounds.X + 24, 56, 190)
					self.Animation:Create(toggleKeybindFrame, TweenInfo.new(0.55, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out), {
						Size = UDim2.new(0, targetWidth, 0, 30)
					}):Play()
				end

				local function applyToggleKeybindBinding(canonical, steps, callOnChange)
					if not canonical then
						return false
					end

					toggleKeybindSettings.CurrentKeybind = canonical
					ToggleSettings.CurrentKeybind = canonical
					toggleKeybindActiveSteps = steps
					if toggleKeybindFlagProxy then
						toggleKeybindFlagProxy.CurrentKeybind = canonical
					end
					if toggleKeybindMatcher then
						toggleKeybindMatcher:setBinding({
							canonical = canonical,
							steps = steps
						})
					end

					if toggleKeybindBox then
						toggleKeybindBox.Text = formatToggleKeybindDisplay(canonical, steps)
						resizeToggleKeybindFrame()
					end

					if callOnChange and toggleKeybindSettings.CallOnChange and type(toggleKeybindSettings.Callback) == "function" then
						pcall(toggleKeybindSettings.Callback, canonical)
					end

					return true
				end

				local function finalizeToggleKeybindCapture(releaseFocus)
					keybindCaptureToken += 1
					if #keybindCaptureSteps <= 0 then
						return false
					end

					local candidateCanonical = table.concat(keybindCaptureSteps, ">")
					keybindCaptureSteps = {}
					local canonical, steps = normalizeSequenceBinding(candidateCanonical, toggleKeybindSettings)
					if canonical then
						applyToggleKeybindBinding(canonical, steps, true)
					elseif toggleKeybindBox then
						toggleKeybindBox.Text = formatToggleKeybindDisplay(toggleKeybindSettings.CurrentKeybind, toggleKeybindActiveSteps)
						resizeToggleKeybindFrame()
					end

					if releaseFocus and toggleKeybindBox and toggleKeybindBox:IsFocused() then
						toggleKeybindBox:ReleaseFocus()
					end

					return canonical ~= nil
				end

				local function scheduleToggleKeybindCaptureFinalize()
					keybindCaptureToken += 1
					local token = keybindCaptureToken
					task.delay(toggleKeybindTimeoutMs / 1000, function()
						if keybindCapturing and token == keybindCaptureToken then
							finalizeToggleKeybindCapture(true)
						end
					end)
				end

				if keybindEnabled then
					local switchWidth = Toggle.Switch.Size.X.Offset
					if switchWidth <= 0 then
						switchWidth = Toggle.Switch.AbsoluteSize.X
					end
					if switchWidth <= 0 then
						switchWidth = 56
					end

					local keybindFrameTemplate = self.Elements.Template.Keybind and self.Elements.Template.Keybind:FindFirstChild("KeybindFrame")
					if keybindFrameTemplate and keybindFrameTemplate:IsA("Frame") then
						toggleKeybindFrame = keybindFrameTemplate:Clone()
					else
						toggleKeybindFrame = Instance.new("Frame")
						toggleKeybindFrame.Name = "ToggleKeybindFrame"
						toggleKeybindFrame.BackgroundTransparency = 0
						local fallbackStroke = Instance.new("UIStroke")
						fallbackStroke.Parent = toggleKeybindFrame
						local fallbackBox = Instance.new("TextBox")
						fallbackBox.Name = "KeybindBox"
						fallbackBox.BackgroundTransparency = 1
						fallbackBox.Size = UDim2.new(1, 0, 1, 0)
						fallbackBox.Parent = toggleKeybindFrame
					end

					toggleKeybindFrame.Name = "ToggleKeybindFrame"
					toggleKeybindFrame.Visible = true
					toggleKeybindFrame.Active = true
					toggleKeybindFrame.Parent = Toggle
					toggleKeybindFrame.AnchorPoint = Vector2.new(1, 0.5)
					toggleKeybindFrame.Position = UDim2.new(1, -(switchWidth + 18), 0.5, 0)
					toggleKeybindFrame.ZIndex = math.max(Toggle.Switch.ZIndex, Toggle.Interact.ZIndex, Toggle.ZIndex) + 2
					self.bindTheme(toggleKeybindFrame, "BackgroundColor3", "InputBackground")

					toggleKeybindBox = toggleKeybindFrame:FindFirstChild("KeybindBox")
					if not (toggleKeybindBox and toggleKeybindBox:IsA("TextBox")) then
						toggleKeybindBox = Instance.new("TextBox")
						toggleKeybindBox.Name = "KeybindBox"
						toggleKeybindBox.BackgroundTransparency = 1
						toggleKeybindBox.Size = UDim2.new(1, 0, 1, 0)
						toggleKeybindBox.Parent = toggleKeybindFrame
					end

					toggleKeybindBox.ClearTextOnFocus = false
					toggleKeybindBox.TextWrapped = false
					toggleKeybindBox.TextXAlignment = Enum.TextXAlignment.Center
					toggleKeybindBox.TextYAlignment = Enum.TextYAlignment.Center
					toggleKeybindBox.ZIndex = toggleKeybindFrame.ZIndex + 1

					local keybindFrameStroke = toggleKeybindFrame:FindFirstChildWhichIsA("UIStroke")
					if keybindFrameStroke then
						self.bindTheme(keybindFrameStroke, "Color", "InputStroke")
					end

					if SequenceLib then
						toggleKeybindMatcher = SequenceLib.newMatcher({
							maxSteps = toggleKeybindMaxSteps,
							stepTimeoutMs = toggleKeybindTimeoutMs
						})
					end

					local initialCanonical, initialSteps = normalizeSequenceBinding(toggleKeybindSettings.CurrentKeybind, toggleKeybindSettings)
					if not initialCanonical then
						initialCanonical, initialSteps = normalizeSequenceBinding("Q", toggleKeybindSettings)
					end
					applyToggleKeybindBinding(initialCanonical, initialSteps, false)

					toggleKeybindFrame.InputBegan:Connect(function(input)
						if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
							suppressNextToggleClick = true
							task.delay(0.2, function()
								suppressNextToggleClick = false
							end)
						end
					end)

					toggleKeybindBox.Focused:Connect(function()
						keybindCapturing = true
						keybindCaptureSteps = {}
						keybindCaptureToken += 1
						toggleKeybindBox.Text = ""
					end)

					toggleKeybindBox.FocusLost:Connect(function()
						local typedText = trim(toggleKeybindBox.Text or "")
						local wasCapturing = keybindCapturing
						keybindCapturing = false
						keybindCaptureToken += 1

						if wasCapturing and #keybindCaptureSteps > 0 then
							finalizeToggleKeybindCapture(false)
							return
						end

						if typedText ~= "" then
							local canonical, steps = parseSequenceInput(typedText, toggleKeybindSettings)
							if canonical then
								applyToggleKeybindBinding(canonical, steps, true)
								return
							end
						end

						toggleKeybindBox.Text = formatToggleKeybindDisplay(toggleKeybindSettings.CurrentKeybind, toggleKeybindActiveSteps)
						resizeToggleKeybindFrame()
					end)

					toggleKeybindBox:GetPropertyChangedSignal("Text"):Connect(function()
						resizeToggleKeybindFrame()
					end)
				end

				-- Reactive Toggle Colors
				local themeValueFolder = self.Main:FindFirstChild("ThemeValues")
				if themeValueFolder then
					local backgroundValue = themeValueFolder:FindFirstChild("Background")
					if backgroundValue then
						backgroundValue.Changed:Connect(UpdateToggleColors)
					end
				end
				
				UpdateToggleColors()
	
				local toggleHoverBindingKey = registerHoverBinding(Toggle,
					function()
						self.Animation:Create(Toggle, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackgroundHover}):Play()
					end,
					function()
						self.Animation:Create(Toggle, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackground}):Play()
					end
				)

				if keybindEnabled then
					toggleKeybindConnection = self.UserInputService.InputBegan:Connect(function(input, processed)
						if keybindCapturing then
							if input.UserInputType ~= Enum.UserInputType.Keyboard then
								return
							end

							if input.KeyCode == Enum.KeyCode.Return or input.KeyCode == Enum.KeyCode.KeypadEnter then
								finalizeToggleKeybindCapture(true)
								return
							end

							local capturedStep = nil
							if SequenceLib then
								capturedStep = select(1, SequenceLib.captureStepFromInput(input, self.UserInputService))
							elseif input.KeyCode and input.KeyCode ~= Enum.KeyCode.Unknown then
								capturedStep = input.KeyCode.Name
							end

							if capturedStep then
								if #keybindCaptureSteps < toggleKeybindMaxSteps then
									table.insert(keybindCaptureSteps, capturedStep)
								end

								local previewCanonical = table.concat(keybindCaptureSteps, ">")
								local previewSteps = select(2, normalizeSequenceBinding(previewCanonical, toggleKeybindSettings))
								if toggleKeybindBox then
									toggleKeybindBox.Text = formatToggleKeybindDisplay(previewCanonical, previewSteps)
									resizeToggleKeybindFrame()
								end

								if #keybindCaptureSteps >= toggleKeybindMaxSteps then
									finalizeToggleKeybindCapture(true)
								else
									scheduleToggleKeybindCaptureFinalize()
								end
							end

							return
						end

						if processed then
							return
						end

						local matched = false
						if toggleKeybindMatcher then
							matched = toggleKeybindMatcher:consume(input, {
								canonical = toggleKeybindSettings.CurrentKeybind,
								steps = toggleKeybindActiveSteps
							}, self.UserInputService, processed)
						elseif toggleKeybindSettings.CurrentKeybind and input.KeyCode then
							matched = input.KeyCode == Enum.KeyCode[toggleKeybindSettings.CurrentKeybind]
						end

						if matched then
							ToggleSettings:Set(not ToggleSettings.CurrentValue)
						end
					end)
					table.insert(self.keybindConnections, toggleKeybindConnection)
				end
	
				Toggle.Interact.MouseButton1Click:Connect(function()
					if suppressNextToggleClick then
						suppressNextToggleClick = false
						return
					end
					commitToggleState(not ToggleSettings.CurrentValue, {
						reason = "interact_click",
						source = "ui_click",
						emitCallback = true,
						persist = true,
						forceCallback = true
					})
				end)
	
				function ToggleSettings:Set(NewToggleValue)
					if keybindEnabled and (type(NewToggleValue) == "string" or typeof(NewToggleValue) == "EnumItem") then
						local canonical, steps = normalizeSequenceBinding(NewToggleValue, toggleKeybindSettings)
						if not canonical then
							canonical, steps = parseSequenceInput(tostring(NewToggleValue), toggleKeybindSettings)
						end

						if canonical then
							applyToggleKeybindBinding(canonical, steps, true)
							if not ToggleSettings.Ext then
								ctx.SaveConfiguration()
							end
						elseif toggleKeybindBox then
							toggleKeybindBox.Text = formatToggleKeybindDisplay(toggleKeybindSettings.CurrentKeybind, toggleKeybindActiveSteps)
							resizeToggleKeybindFrame()
						end
						return
					end
					commitToggleState(NewToggleValue == true, {
						reason = "set",
						source = "api_set",
						emitCallback = true,
						persist = true,
						forceCallback = true
					})
				end

				function ToggleSettings:Get()
					return ToggleSettings.CurrentValue
				end

				function ToggleSettings:SetKeybind(NewKeybind)
					if not keybindEnabled then
						return false
					end

					local canonical, steps = normalizeSequenceBinding(NewKeybind, toggleKeybindSettings)
					if not canonical then
						canonical, steps = parseSequenceInput(tostring(NewKeybind or ""), toggleKeybindSettings)
					end

					if canonical then
						local applied = applyToggleKeybindBinding(canonical, steps, true)
						if applied and not ToggleSettings.Ext then
							ctx.SaveConfiguration()
						end
						return applied
					end

					if toggleKeybindBox then
						toggleKeybindBox.Text = formatToggleKeybindDisplay(toggleKeybindSettings.CurrentKeybind, toggleKeybindActiveSteps)
						resizeToggleKeybindFrame()
					end
					return false
				end

				function ToggleSettings:GetKeybind()
					return toggleKeybindSettings.CurrentKeybind
				end

				if keybindEnabled and Settings.ConfigurationSaving and Settings.ConfigurationSaving.Enabled and toggleKeybindSettings.Flag then
					toggleKeybindFlagProxy = {
						Type = "Keybind",
						CurrentKeybind = toggleKeybindSettings.CurrentKeybind,
						Set = function(_, newBinding)
							local canonical, steps = normalizeSequenceBinding(newBinding, toggleKeybindSettings)
							if not canonical then
								canonical, steps = parseSequenceInput(tostring(newBinding or ""), toggleKeybindSettings)
							end
							if canonical then
								applyToggleKeybindBinding(canonical, steps, false)
							end
						end
					}
					self.RayfieldLibrary.Flags[toggleKeybindSettings.Flag] = toggleKeybindFlagProxy
				end
	
				if not ToggleSettings.Ext then
					if Settings.ConfigurationSaving then
						if Settings.ConfigurationSaving.Enabled and ToggleSettings.Flag then
							self.RayfieldLibrary.Flags[ToggleSettings.Flag] = ToggleSettings
						end
					end
				end
	
	
				self.Rayfield.Main:GetPropertyChangedSignal('BackgroundColor3'):Connect(function()
					Toggle.Switch.BackgroundColor3 = self.getSelectedTheme().ToggleBackground

					if toggleKeybindFrame then
						toggleKeybindFrame.BackgroundColor3 = self.getSelectedTheme().InputBackground
						local frameStroke = toggleKeybindFrame:FindFirstChildWhichIsA("UIStroke")
						if frameStroke then
							frameStroke.Color = self.getSelectedTheme().InputStroke
						end
					end
	
					if self.getSelectedTheme() ~= self.RayfieldLibrary.Theme.Default then
						local toggleShadow = Toggle.Switch:FindFirstChild("Shadow")
						if toggleShadow then
							toggleShadow.Visible = false
						end
					end
	
					task.wait()
	
					if not ToggleSettings.CurrentValue then
						Toggle.Switch.Indicator.UIStroke.Color = self.getSelectedTheme().ToggleDisabledStroke
						Toggle.Switch.Indicator.BackgroundColor3 = self.getSelectedTheme().ToggleDisabled
						Toggle.Switch.UIStroke.Color = self.getSelectedTheme().ToggleDisabledOuterStroke
					else
						Toggle.Switch.Indicator.UIStroke.Color = self.getSelectedTheme().ToggleEnabledStroke
						Toggle.Switch.Indicator.BackgroundColor3 = self.getSelectedTheme().ToggleEnabled
						Toggle.Switch.UIStroke.Color = self.getSelectedTheme().ToggleEnabledOuterStroke
					end
				end)
	
				function ToggleSettings:Destroy()
					if toggleKeybindConnection then
						toggleKeybindConnection:Disconnect()
						toggleKeybindConnection = nil
					end
					if toggleKeybindSettings.Flag and ctx.RayfieldLibrary and ctx.RayfieldLibrary.Flags then
						if ctx.RayfieldLibrary.Flags[toggleKeybindSettings.Flag] == toggleKeybindFlagProxy then
							ctx.RayfieldLibrary.Flags[toggleKeybindSettings.Flag] = nil
						end
					end
					Toggle:Destroy()
				end
	
				-- Add extended API
				addExtendedAPI(ToggleSettings, ToggleSettings.Name, "Toggle", Toggle, toggleHoverBindingKey, toggleSyncToken)
	
				return ToggleSettings
			end

			function Tab:CreateToggleBind(ToggleSettings)
				ToggleSettings = ToggleSettings or {}
				local keybindSettings = ToggleSettings.Keybind
				if type(keybindSettings) ~= "table" then
					keybindSettings = {}
				end
				keybindSettings.Enabled = true
				ToggleSettings.Keybind = keybindSettings
				return self:CreateToggle(ToggleSettings)
			end

			function Tab:CreateHotToggle(ToggleSettings)
				return self:CreateToggleBind(ToggleSettings)
			end
	
			-- Slider
			function Tab:CreateSlider(SliderSettings)
				local ctx = self
				local SLDragging = false
				SliderSettings = SliderSettings or {}
				if type(SliderSettings.Callback) ~= "function" then
					SliderSettings.Callback = function() end
				end
				SliderSettings.Range = SliderSettings.Range or {0, 100}
				local sliderMin = tonumber(SliderSettings.Range[1]) or 0
				local sliderMax = tonumber(SliderSettings.Range[2]) or 100
				if sliderMax <= sliderMin then
					sliderMax = sliderMin + 1
				end
				SliderSettings.Range = {sliderMin, sliderMax}
				SliderSettings.Increment = tonumber(SliderSettings.Increment) or 1
				if SliderSettings.Increment <= 0 then
					SliderSettings.Increment = 1
				end
				SliderSettings.CurrentValue = math.clamp(tonumber(SliderSettings.CurrentValue) or sliderMin, sliderMin, sliderMax)

				local Slider = self.Elements.Template.Slider:Clone()
				Slider.Name = SliderSettings.Name
				Slider.Title.Text = SliderSettings.Name
				Slider.Visible = true
				Slider.Parent = TabPage
	
				Slider.BackgroundTransparency = 1
				Slider.UIStroke.Transparency = 1
				Slider.Title.TextTransparency = 1
	
				if self.getSelectedTheme() ~= self.RayfieldLibrary.Theme.Default then
					Slider.Main.Shadow.Visible = false
				end
	
				self.bindTheme(Slider.Main, "BackgroundColor3", "SliderBackground")
				self.bindTheme(Slider.Main.UIStroke, "Color", "SliderStroke")
				self.bindTheme(Slider.Main.Progress.UIStroke, "Color", "SliderStroke")
				self.bindTheme(Slider.Main.Progress, "BackgroundColor3", "SliderProgress")
	
				self.Animation:Create(Slider, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0}):Play()
				self.Animation:Create(Slider.UIStroke, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {Transparency = 0}):Play()
				self.Animation:Create(Slider.Title, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {TextTransparency = 0}):Play()	

				local function normalizeSliderValue(rawValue)
					local normalized = tonumber(rawValue)
					if normalized == nil then
						normalized = sliderMin
					end
					if elementSync and elementSync.normalize and elementSync.normalize.numberRange then
						normalized = elementSync.normalize.numberRange(normalized, {
							min = sliderMin,
							max = sliderMax,
							increment = SliderSettings.Increment,
							default = sliderMin
						})
					else
						normalized = math.clamp(normalized, sliderMin, sliderMax)
						normalized = math.floor((normalized / SliderSettings.Increment) + 0.5) * SliderSettings.Increment
						normalized = math.floor((normalized * 10000000) + 0.5) / 10000000
						normalized = math.clamp(normalized, sliderMin, sliderMax)
					end
					return normalized
				end

				local function sliderValueToWidth(value)
					local width = Slider.Main.AbsoluteSize.X
					if width <= 0 then
						return 5
					end
					local ratio = math.clamp((value - sliderMin) / (sliderMax - sliderMin), 0, 1)
					local target = width * ratio
					if ratio > 0 and target < 5 then
						target = 5
					end
					return target
				end

				local function formatSliderValue(value)
					if not SliderSettings.Suffix then
						return tostring(value)
					end
					return tostring(value) .. " " .. SliderSettings.Suffix
				end

				local function handleSliderCallbackError(response)
					self.Animation:Create(Slider, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = Color3.fromRGB(85, 0, 0)}):Play()
					self.Animation:Create(Slider.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 1}):Play()
					Slider.Title.Text = "Callback Error"
					print("Rayfield | "..SliderSettings.Name.." Callback Error " ..tostring(response))
					warn('Check docs.sirius.menu for help with Rayfield specific development.')
					task.wait(0.5)
					Slider.Title.Text = SliderSettings.Name
					self.Animation:Create(Slider, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackground}):Play()
					self.Animation:Create(Slider.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 0}):Play()
				end

				local function applySliderVisual(value, animate)
					local targetWidth = sliderValueToWidth(value)
					if animate then
						self.Animation:Create(Slider.Main.Progress, TweenInfo.new(0.45, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out), {Size = UDim2.new(0, targetWidth, 1, 0)}):Play()
					else
						Slider.Main.Progress.Size = UDim2.new(0, targetWidth, 1, 0)
					end
					Slider.Main.Information.Text = formatSliderValue(value)
					SliderSettings.CurrentValue = value
				end

				local sliderSyncToken = registerElementSync({
					name = SliderSettings.Name,
					getState = function()
						return SliderSettings.CurrentValue
					end,
					normalize = function(rawValue)
						local normalized = normalizeSliderValue(rawValue)
						return normalized, {
							changed = SliderSettings.CurrentValue ~= normalized
						}
					end,
					applyVisual = function(normalized, syncMeta)
						local animate = true
						if syncMeta and syncMeta.options and syncMeta.options.animate == false then
							animate = false
						end
						applySliderVisual(normalized, animate)
					end,
					emitCallback = function(normalized)
						SliderSettings.Callback(normalized)
					end,
					persist = function()
						ctx.SaveConfiguration()
					end,
					isExt = function()
						return SliderSettings.Ext == true
					end,
					isAlive = function()
						return Slider ~= nil and Slider.Parent ~= nil
					end,
					isVisibleContext = function()
						return Slider.Visible and Slider:IsDescendantOf(TabPage) and self.Elements.UIPageLayout.CurrentPage == TabPage
					end,
					onCallbackError = handleSliderCallbackError
				})

				local function commitSliderValue(rawValue, commitOptions)
					local options = commitOptions or {}
					if sliderSyncToken then
						return commitElementSync(sliderSyncToken, rawValue, {
							reason = options.reason or "slider_update",
							source = options.source or "unknown",
							emitCallback = options.emitCallback,
							persist = options.persist,
							forceCallback = options.forceCallback,
							animate = options.animate
						})
					end

					local normalized = normalizeSliderValue(rawValue)
					applySliderVisual(normalized, options.animate ~= false)
					local success, response = pcall(function()
						SliderSettings.Callback(normalized)
					end)
					if not success then
						handleSliderCallbackError(response)
					elseif not SliderSettings.Ext then
						ctx.SaveConfiguration()
					end
					return success
				end

				applySliderVisual(SliderSettings.CurrentValue, false)
	
				local sliderHoverBindingKey = registerHoverBinding(Slider,
					function()
						self.Animation:Create(Slider, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackgroundHover}):Play()
					end,
					function()
						self.Animation:Create(Slider, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackground}):Play()
					end
				)
	
				Slider.Main.Interact.InputBegan:Connect(function(Input)
					if Input.UserInputType == Enum.UserInputType.MouseButton1 or Input.UserInputType == Enum.UserInputType.Touch then 
						self.Animation:Create(Slider.Main.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 1}):Play()
						self.Animation:Create(Slider.Main.Progress.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 1}):Play()
						SLDragging = true 
					end 
				end)
	
				Slider.Main.Interact.InputEnded:Connect(function(Input) 
					if Input.UserInputType == Enum.UserInputType.MouseButton1 or Input.UserInputType == Enum.UserInputType.Touch then 
						self.Animation:Create(Slider.Main.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 0.4}):Play()
						self.Animation:Create(Slider.Main.Progress.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 0.3}):Play()
						SLDragging = false 
					end 
				end)
	
				Slider.Main.Interact.MouseButton1Down:Connect(function(X)
					local Current = Slider.Main.Progress.AbsolutePosition.X + Slider.Main.Progress.AbsoluteSize.X
					local Start = Current
					local Location = X
					local sliderProgressTween = nil
					local sliderProgressTweenInfo = TweenInfo.new(0.45, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out)
					local Loop; Loop = self.RunService.Stepped:Connect(function()
						if SLDragging then
							Location = self.UserInputService:GetMouseLocation().X
							Current = Current + 0.025 * (Location - Start)
	
							if Location < Slider.Main.AbsolutePosition.X then
								Location = Slider.Main.AbsolutePosition.X
							elseif Location > Slider.Main.AbsolutePosition.X + Slider.Main.AbsoluteSize.X then
								Location = Slider.Main.AbsolutePosition.X + Slider.Main.AbsoluteSize.X
							end
	
							if Current < Slider.Main.AbsolutePosition.X + 5 then
								Current = Slider.Main.AbsolutePosition.X + 5
							elseif Current > Slider.Main.AbsolutePosition.X + Slider.Main.AbsoluteSize.X then
								Current = Slider.Main.AbsolutePosition.X + Slider.Main.AbsoluteSize.X
							end
	
							if Current <= Location and (Location - Start) < 0 then
								Start = Location
							elseif Current >= Location and (Location - Start) > 0 then
								Start = Location
							end
							if sliderProgressTween then
								sliderProgressTween:Cancel()
							end
							sliderProgressTween = self.Animation:Create(Slider.Main.Progress, sliderProgressTweenInfo, {Size = UDim2.new(0, Current - Slider.Main.AbsolutePosition.X, 1, 0)})
							sliderProgressTween:Play()
							local NewValue = SliderSettings.Range[1] + (Location - Slider.Main.AbsolutePosition.X) / Slider.Main.AbsoluteSize.X * (SliderSettings.Range[2] - SliderSettings.Range[1])
							NewValue = normalizeSliderValue(NewValue)
							commitSliderValue(NewValue, {
								reason = "drag",
								source = "ui_drag",
								emitCallback = true,
								persist = true,
								forceCallback = false,
								animate = false
							})
						else
							self.Animation:Create(Slider.Main.Progress, TweenInfo.new(0.3, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out), {Size = UDim2.new(0, Location - Slider.Main.AbsolutePosition.X > 5 and Location - Slider.Main.AbsolutePosition.X or 5, 1, 0)}):Play()
							Loop:Disconnect()
						end
					end)
				end)
	
				function SliderSettings:Set(NewVal)
					commitSliderValue(NewVal, {
						reason = "set",
						source = "api_set",
						emitCallback = true,
						persist = true,
						forceCallback = true,
						animate = true
					})
				end
	
				if Settings.ConfigurationSaving then
					if Settings.ConfigurationSaving.Enabled and SliderSettings.Flag then
						self.RayfieldLibrary.Flags[SliderSettings.Flag] = SliderSettings
					end
				end
	
				self.Rayfield.Main:GetPropertyChangedSignal('BackgroundColor3'):Connect(function()
					if self.getSelectedTheme() ~= self.RayfieldLibrary.Theme.Default then
						Slider.Main.Shadow.Visible = false
					end
	
					Slider.Main.BackgroundColor3 = self.getSelectedTheme().SliderBackground
					Slider.Main.UIStroke.Color = self.getSelectedTheme().SliderStroke
					Slider.Main.Progress.UIStroke.Color = self.getSelectedTheme().SliderStroke
					Slider.Main.Progress.BackgroundColor3 = self.getSelectedTheme().SliderProgress
				end)
	
				function SliderSettings:Destroy()
					Slider:Destroy()
				end

				-- Add extended API
				addExtendedAPI(SliderSettings, SliderSettings.Name, "Slider", Slider, sliderHoverBindingKey, sliderSyncToken)

				return SliderSettings
			end

			local function normalizeBarSettings(rawSettings, defaults)
				local settings = rawSettings or {}
				settings.Name = settings.Name or defaults.name
				settings.Range = settings.Range or {0, 100}

				local rangeMin = tonumber(settings.Range[1]) or 0
				local rangeMax = tonumber(settings.Range[2]) or 100
				if rangeMax <= rangeMin then
					rangeMax = rangeMin + 1
				end
				settings.Range = {rangeMin, rangeMax}

				settings.Increment = tonumber(settings.Increment) or 1
				if settings.Increment <= 0 then
					settings.Increment = 1
				end

				local currentValue = tonumber(settings.CurrentValue)
				if currentValue == nil then
					currentValue = rangeMin
				end
				settings.CurrentValue = math.clamp(currentValue, rangeMin, rangeMax)

				if type(settings.Callback) ~= "function" then
					settings.Callback = function() end
				end

				if settings.Draggable == nil then
					settings.Draggable = defaults.draggable
				end

				settings.Type = defaults.typeName
				return settings
			end

			local function createCustomBar(rawSettings, customOptions)
				local ctx = self
				customOptions = customOptions or {}
				local barSettings = normalizeBarSettings(rawSettings, {
					name = customOptions.defaultName or "Bar",
					draggable = customOptions.defaultDraggable ~= false,
					typeName = customOptions.typeName or "Bar"
				})
				local showText = customOptions.showText == true
				local statusMode = customOptions.statusMode == true
				local barMin = barSettings.Range[1]
				local barMax = barSettings.Range[2]
				local barDragging = false

				local Bar = self.Elements.Template.Slider:Clone()
				Bar.Name = barSettings.Name
				Bar.Title.Text = barSettings.Name
				Bar.Visible = true
				Bar.Parent = TabPage

				Bar.BackgroundTransparency = 1
				Bar.UIStroke.Transparency = 1
				Bar.Title.TextTransparency = 1

				local BarMain = Bar.Main
				local BarProgress = BarMain.Progress
				local BarValueLabel = BarMain.Information

				if self.getSelectedTheme() ~= self.RayfieldLibrary.Theme.Default then
					BarMain.Shadow.Visible = false
				end

				self.bindTheme(BarMain, "BackgroundColor3", "SliderBackground")
				self.bindTheme(BarMain.UIStroke, "Color", "SliderStroke")
				self.bindTheme(BarProgress.UIStroke, "Color", "SliderStroke")
				self.bindTheme(BarProgress, "BackgroundColor3", "SliderProgress")

				self.Animation:Create(Bar, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0}):Play()
				self.Animation:Create(Bar.UIStroke, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {Transparency = 0}):Play()
				self.Animation:Create(Bar.Title, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {TextTransparency = 0}):Play()

				if showText then
					BarValueLabel.Visible = true
					if statusMode then
						BarValueLabel.AnchorPoint = Vector2.new(0.5, 0.5)
						BarValueLabel.Position = UDim2.new(0.5, 0, 0.5, 0)
						BarValueLabel.Size = UDim2.new(1, -8, 1, 0)
						BarValueLabel.TextXAlignment = Enum.TextXAlignment.Center
						BarValueLabel.TextYAlignment = Enum.TextYAlignment.Center
						BarValueLabel.ZIndex = BarProgress.ZIndex + 2
						BarValueLabel.TextStrokeTransparency = 0.7
						if barSettings.TextSize then
							BarValueLabel.TextSize = barSettings.TextSize
						end
					end
				else
					BarValueLabel.Visible = false
					BarValueLabel.TextTransparency = 1
				end

				local function ensureCorner(target, radiusPx)
					local corner = target:FindFirstChildWhichIsA("UICorner")
					if not corner then
						corner = Instance.new("UICorner")
						corner.Parent = target
					end
					corner.CornerRadius = UDim.new(0, radiusPx)
				end

				local function applyBarGeometry()
					local desiredHeight = tonumber(barSettings.Height) or tonumber(barSettings.BarHeight)
					if statusMode and not desiredHeight and barSettings.AutoHeight ~= false then
						local textSize = tonumber(barSettings.TextSize) or (BarValueLabel and BarValueLabel.TextSize or 14)
						desiredHeight = math.clamp(math.floor(textSize + 12), 26, 44)
					end

					if desiredHeight then
						desiredHeight = math.max(12, math.floor(desiredHeight))
						local baseYOffset = BarMain.Position.Y.Offset
						if baseYOffset <= 0 then
							baseYOffset = 24
						end
						BarMain.Size = UDim2.new(BarMain.Size.X.Scale, BarMain.Size.X.Offset, 0, desiredHeight)
						Bar.Size = UDim2.new(1, -10, 0, baseYOffset + desiredHeight + 10)
					end

					if statusMode or barSettings.Roundness then
						local roundness = tonumber(barSettings.Roundness)
						if not roundness then
							local sourceHeight = BarMain.Size.Y.Offset
							roundness = math.max(6, math.floor(sourceHeight / 2))
						end
						ensureCorner(BarMain, roundness)
						ensureCorner(BarProgress, roundness)
					end
				end

				applyBarGeometry()

				local function formatBarText(value)
					if not showText then
						return ""
					end

					local percent = ((value - barMin) / (barMax - barMin)) * 100
					if type(barSettings.TextFormatter) == "function" then
						local ok, custom = pcall(barSettings.TextFormatter, value, barMax, percent)
						if ok and custom ~= nil then
							return tostring(custom)
						end
					end

					local defaultText = tostring(value) .. "/" .. tostring(barMax)
					if barSettings.Suffix and tostring(barSettings.Suffix) ~= "" then
						defaultText = defaultText .. " " .. tostring(barSettings.Suffix)
					end
					return defaultText
				end

				local function valueToWidth(value)
					local width = BarMain.AbsoluteSize.X
					if width <= 0 then
						return 0
					end
					local ratio = math.clamp((value - barMin) / (barMax - barMin), 0, 1)
					local result = width * ratio
					if ratio > 0 and result < 5 then
						result = 5
					end
					return result
				end

				local function applyVisualValue(value, animate)
					local targetWidth = valueToWidth(value)
					if animate then
						self.Animation:Create(BarProgress, TweenInfo.new(0.3, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out), {Size = UDim2.new(0, targetWidth, 1, 0)}):Play()
					else
						BarProgress.Size = UDim2.new(0, targetWidth, 1, 0)
					end

					if showText and BarValueLabel then
						BarValueLabel.Text = formatBarText(value)
					end
				end

				local function handleBarCallbackError(response)
					self.Animation:Create(Bar, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = Color3.fromRGB(85, 0, 0)}):Play()
					self.Animation:Create(Bar.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 1}):Play()
					Bar.Title.Text = "Callback Error"
					print("Rayfield | " .. barSettings.Name .. " Callback Error " .. tostring(response))
					warn('Check docs.sirius.menu for help with Rayfield specific development.')
					task.wait(0.5)
					Bar.Title.Text = barSettings.Name
					self.Animation:Create(Bar, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackground}):Play()
					self.Animation:Create(Bar.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 0}):Play()
				end

				local function triggerCallback(nextValue)
					local Success, Response = pcall(function()
						barSettings.Callback(nextValue)
					end)
					if not Success then
						handleBarCallbackError(Response)
					end
					return Success
				end

				local function normalizeValue(rawValue)
					local value = math.clamp(tonumber(rawValue) or barMin, barMin, barMax)
					value = math.floor((value / barSettings.Increment) + 0.5) * barSettings.Increment
					value = math.floor((value * 10000000) + 0.5) / 10000000
					return math.clamp(value, barMin, barMax)
				end

				local barSyncToken = nil
				local function applyBarValue(rawValue, opts)
					opts = opts or {}
					if barSyncToken then
						return commitElementSync(barSyncToken, rawValue, {
							reason = opts.reason or "bar_update",
							source = opts.source or "unknown",
							emitCallback = opts.emitCallback,
							persist = opts.persist,
							forceCallback = opts.forceCallback,
							animate = opts.animate
						})
					end

					local nextValue = normalizeValue(rawValue)
					applyVisualValue(nextValue, opts.animate ~= false)
					local callbackSuccess = triggerCallback(nextValue)
					barSettings.CurrentValue = nextValue
					if callbackSuccess and opts.persist and not barSettings.Ext then
						self.SaveConfiguration()
					end
					return callbackSuccess
				end

				barSyncToken = registerElementSync({
					name = barSettings.Name,
					getState = function()
						return barSettings.CurrentValue
					end,
					normalize = function(rawValue)
						local nextValue = normalizeValue(rawValue)
						return nextValue, {
							changed = barSettings.CurrentValue ~= nextValue
						}
					end,
					applyVisual = function(value, syncMeta)
						local animate = true
						if syncMeta and syncMeta.options and syncMeta.options.animate == false then
							animate = false
						end
						applyVisualValue(value, animate)
						barSettings.CurrentValue = value
					end,
					emitCallback = function(value)
						barSettings.Callback(value)
					end,
					persist = function()
						self.SaveConfiguration()
					end,
					isExt = function()
						return barSettings.Ext == true
					end,
					isAlive = function()
						return Bar ~= nil and Bar.Parent ~= nil
					end,
					isVisibleContext = function()
						return Bar.Visible and Bar:IsDescendantOf(TabPage) and self.Elements.UIPageLayout.CurrentPage == TabPage
					end,
					onCallbackError = handleBarCallbackError
				})

				applyVisualValue(barSettings.CurrentValue, false)
				task.defer(function()
					if Bar and Bar.Parent then
						applyVisualValue(barSettings.CurrentValue, false)
					end
				end)

				local barHoverBindingKey = registerHoverBinding(Bar,
					function()
						self.Animation:Create(Bar, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackgroundHover}):Play()
					end,
					function()
						self.Animation:Create(Bar, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackground}):Play()
					end
				)

				BarMain.Interact.InputBegan:Connect(function(Input)
					if not barSettings.Draggable then
						return
					end
					if Input.UserInputType == Enum.UserInputType.MouseButton1 or Input.UserInputType == Enum.UserInputType.Touch then
						self.Animation:Create(BarMain.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 1}):Play()
						self.Animation:Create(BarProgress.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 1}):Play()
						barDragging = true
					end
				end)

				BarMain.Interact.InputEnded:Connect(function(Input)
					if not barSettings.Draggable then
						return
					end
					if Input.UserInputType == Enum.UserInputType.MouseButton1 or Input.UserInputType == Enum.UserInputType.Touch then
						self.Animation:Create(BarMain.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 0.4}):Play()
						self.Animation:Create(BarProgress.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 0.3}):Play()
						barDragging = false
					end
				end)

				BarMain.Interact.MouseButton1Down:Connect(function(mouseX)
					if not barSettings.Draggable then
						return
					end

					local currentX = BarProgress.AbsolutePosition.X + BarProgress.AbsoluteSize.X
					local startX = currentX
					local locationX = mouseX
					local progressTween = nil
					local tweenInfo = TweenInfo.new(0.45, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out)

					local loopConn
					loopConn = self.RunService.Stepped:Connect(function()
						if barDragging then
							locationX = self.UserInputService:GetMouseLocation().X
							currentX = currentX + 0.025 * (locationX - startX)

							local minX = BarMain.AbsolutePosition.X
							local maxX = BarMain.AbsolutePosition.X + BarMain.AbsoluteSize.X

							if locationX < minX then
								locationX = minX
							elseif locationX > maxX then
								locationX = maxX
							end

							if currentX < minX + 5 then
								currentX = minX + 5
							elseif currentX > maxX then
								currentX = maxX
							end

							if (currentX <= locationX and (locationX - startX) < 0) or (currentX >= locationX and (locationX - startX) > 0) then
								startX = locationX
							end

							if progressTween then
								progressTween:Cancel()
							end
							progressTween = self.Animation:Create(BarProgress, tweenInfo, {Size = UDim2.new(0, currentX - minX, 1, 0)})
							progressTween:Play()

							local nextValue = barMin + ((locationX - minX) / math.max(1, BarMain.AbsoluteSize.X)) * (barMax - barMin)
							if barSettings.CurrentValue ~= normalizeValue(nextValue) then
								applyBarValue(nextValue, {animate = false, persist = true})
							end
						else
							self.Animation:Create(BarProgress, TweenInfo.new(0.3, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out), {
								Size = UDim2.new(0, locationX - BarMain.AbsolutePosition.X > 5 and locationX - BarMain.AbsolutePosition.X or 5, 1, 0)
							}):Play()

							if loopConn then
								loopConn:Disconnect()
							end
						end
					end)
				end)

				function barSettings:Set(NewVal)
					applyBarValue(NewVal, {animate = true, persist = true, forceCallback = true})
				end

				function barSettings:Get()
					return barSettings.CurrentValue
				end

				if Settings.ConfigurationSaving then
					if Settings.ConfigurationSaving.Enabled and barSettings.Flag then
						self.RayfieldLibrary.Flags[barSettings.Flag] = barSettings
					end
				end

				self.Rayfield.Main:GetPropertyChangedSignal('BackgroundColor3'):Connect(function()
					if self.getSelectedTheme() ~= self.RayfieldLibrary.Theme.Default then
						BarMain.Shadow.Visible = false
					end

					BarMain.BackgroundColor3 = self.getSelectedTheme().SliderBackground
					BarMain.UIStroke.Color = self.getSelectedTheme().SliderStroke
					BarProgress.UIStroke.Color = self.getSelectedTheme().SliderStroke
					BarProgress.BackgroundColor3 = self.getSelectedTheme().SliderProgress
					if showText and BarValueLabel then
						BarValueLabel.TextColor3 = self.getSelectedTheme().TextColor
					end
				end)

				function barSettings:Destroy()
					Bar:Destroy()
				end

				addExtendedAPI(barSettings, barSettings.Name, customOptions.typeName or "Bar", Bar, barHoverBindingKey, barSyncToken)
				return barSettings
			end

			function Tab:CreateTrackBar(TrackBarSettings)
				return createCustomBar(TrackBarSettings, {
					defaultName = "Track Bar",
					defaultDraggable = true,
					showText = false,
					statusMode = false,
					typeName = "TrackBar"
				})
			end

			function Tab:CreateStatusBar(StatusBarSettings)
				return createCustomBar(StatusBarSettings, {
					defaultName = "Status Bar",
					defaultDraggable = false,
					showText = true,
					statusMode = true,
					typeName = "StatusBar"
				})
			end

			function Tab:CreateDragBar(settings)
				return self:CreateTrackBar(settings)
			end

			function Tab:CreateSliderLite(settings)
				return self:CreateTrackBar(settings)
			end

			function Tab:CreateInfoBar(settings)
				return self:CreateStatusBar(settings)
			end

			function Tab:CreateSliderDisplay(settings)
				return self:CreateStatusBar(settings)
			end
	
			self.Rayfield.Main:GetPropertyChangedSignal('BackgroundColor3'):Connect(function()
				TabButton.UIStroke.Color = self.getSelectedTheme().TabStroke
	
				if self.Elements.UIPageLayout.CurrentPage == TabPage then
					TabButton.BackgroundColor3 = self.getSelectedTheme().TabBackgroundSelected
					TabButton.Image.ImageColor3 = self.getSelectedTheme().SelectedTabTextColor
					TabButton.Title.TextColor3 = self.getSelectedTheme().SelectedTabTextColor
				else
					TabButton.BackgroundColor3 = self.getSelectedTheme().TabBackground
					TabButton.Image.ImageColor3 = self.getSelectedTheme().TabTextColor
					TabButton.Title.TextColor3 = self.getSelectedTheme().TabTextColor
				end
			end)
	
			return Tab
		end

	
	-- Export function
	self.CreateTab = CreateTab
	self.getFirstTab = function() return FirstTab end
	
	return self
end

return ElementsModule
]])
put("src/ui/elements/widgets/bootstrap.lua", [[local WidgetBootstrap = {}

local DEFAULT_ROOT = "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
local TRACE_FLAG_KEY = "__RAYFIELD_WIDGET_TRACE"
local TRACE_PREFIX = "[RAYFIELD][WIDGET_BOOTSTRAP]"

local function trim(value)
	if type(value) ~= "string" then
		return ""
	end
	local out = value:gsub("^%s+", "")
	out = out:gsub("%s+$", "")
	return out
end

local function shouldTrace(level)
	if level == "error" then
		return true
	end
	return type(_G) == "table" and _G[TRACE_FLAG_KEY] == true
end

function WidgetBootstrap.trace(branchId, level, data)
	local payload = data or {}
	local branch = tostring(branchId or "unknown")
	local stage = tostring(payload.stage or "widgets.bootstrap")
	local moduleName = tostring(payload.module or "unknown")
	local reason = tostring(payload.reason or "n/a")
	local nextAction = tostring(payload.next_action or "n/a")
	local traceLevel = tostring(level or "info")
	local message = string.format(
		"%s branch_id=%s level=%s stage=%s module=%s reason=%s next_action=%s",
		TRACE_PREFIX,
		branch,
		traceLevel,
		stage,
		moduleName,
		reason,
		nextAction
	)

	if shouldTrace(traceLevel) then
		if traceLevel == "error" then
			warn(message)
		else
			print(message)
		end
	end
end

function WidgetBootstrap.fail(code, message, data)
	local payload = data or {}
	local moduleName = tostring(payload.module or "unknown")
	local stage = tostring(payload.stage or "widgets.bootstrap")
	local branch = tostring(payload.branch_id or code or "unknown")
	local reason = tostring(message or "unknown_error")
	local errorCode = tostring(code or "E_UNKNOWN")

	WidgetBootstrap.trace(branch, "error", {
		stage = stage,
		module = moduleName,
		reason = reason,
		next_action = payload.next_action or "stop"
	})

	error(string.format("[%s] %s (module=%s, stage=%s, branch_id=%s)", errorCode, reason, moduleName, stage, branch))
end

local function normalizeRoot(rawRoot)
	local root = trim(rawRoot)
	if root == "" then
		return nil, "root_empty"
	end
	if root:find("%s") then
		return nil, "root_contains_whitespace"
	end
	if not root:match("^https?://") then
		return nil, "root_not_http_url"
	end
	if root:sub(-1) ~= "/" then
		root = root .. "/"
	end
	return root, nil
end

local function normalizeTargetPath(rawTargetPath)
	if type(rawTargetPath) ~= "string" then
		return nil, "target_not_string"
	end
	local path = trim(rawTargetPath)
	path = path:gsub("^/+", "")
	if path == "" then
		return nil, "target_empty"
	end
	return path, nil
end

function WidgetBootstrap.bootstrapWidget(widgetName, targetPath, exportAdapter, options)
	local opts = options or {}
	local moduleName = tostring(widgetName or "unknown_widget")
	local stage = "widgets.bootstrap"
	local expectedType = opts.expectedType or "table"

	WidgetBootstrap.trace("B01_CLIENT_PRESENT", "debug", {
		stage = stage,
		module = moduleName,
		reason = "checking _G.__RayfieldApiClient",
		next_action = "validate_client_contract"
	})
	local client = _G and _G.__RayfieldApiClient
	if not client then
		WidgetBootstrap.fail("E_CLIENT_MISSING", "Rayfield ApiClient is not initialized", {
			branch_id = "B01_CLIENT_PRESENT",
			stage = stage,
			module = moduleName,
			next_action = "stop"
		})
	end

	WidgetBootstrap.trace("B02_CLIENT_CONTRACT", "debug", {
		stage = stage,
		module = moduleName,
		reason = "checking client.fetchAndExecute contract",
		next_action = "resolve_root"
	})
	if type(client.fetchAndExecute) ~= "function" then
		WidgetBootstrap.fail("E_CLIENT_INVALID", "ApiClient.fetchAndExecute must be a function", {
			branch_id = "B02_CLIENT_CONTRACT",
			stage = stage,
			module = moduleName,
			next_action = "stop"
		})
	end

	WidgetBootstrap.trace("B03_ROOT_RESOLVE", "debug", {
		stage = stage,
		module = moduleName,
		reason = "resolving runtime root URL",
		next_action = "build_target_path"
	})
	local rawRoot = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or DEFAULT_ROOT
	local root, rootErr = normalizeRoot(rawRoot)
	if not root then
		WidgetBootstrap.fail("E_ROOT_INVALID", "Invalid runtime root URL: " .. tostring(rootErr), {
			branch_id = "B03_ROOT_RESOLVE",
			stage = stage,
			module = moduleName,
			next_action = "stop"
		})
	end

	WidgetBootstrap.trace("B04_TARGET_BUILD", "debug", {
		stage = stage,
		module = moduleName,
		reason = "building target module URL",
		next_action = "fetch_execute"
	})
	local normalizedTarget, targetErr = normalizeTargetPath(targetPath)
	if not normalizedTarget then
		WidgetBootstrap.fail("E_TARGET_INVALID", "Invalid target module path: " .. tostring(targetErr), {
			branch_id = "B04_TARGET_BUILD",
			stage = stage,
			module = moduleName,
			next_action = "stop"
		})
	end
	local fullPath = root .. normalizedTarget

	WidgetBootstrap.trace("B05_FETCH_EXEC", "debug", {
		stage = stage,
		module = moduleName,
		reason = "fetchAndExecute module",
		next_action = "validate_export"
	})
	local ok, exported = pcall(client.fetchAndExecute, fullPath)
	if not ok then
		WidgetBootstrap.fail("E_FETCH_FAILED", tostring(exported), {
			branch_id = "B05_FETCH_EXEC",
			stage = stage,
			module = moduleName,
			next_action = "stop"
		})
	end

	if type(exportAdapter) ~= "nil" and type(exportAdapter) ~= "function" then
		WidgetBootstrap.fail("E_EXPORT_INVALID", "exportAdapter must be a function when provided", {
			branch_id = "B06_EXPORT_VALIDATE",
			stage = stage,
			module = moduleName,
			next_action = "stop"
		})
	end

	WidgetBootstrap.trace("B06_EXPORT_VALIDATE", "debug", {
		stage = stage,
		module = moduleName,
		reason = "validating exported module",
		next_action = "return_export"
	})
	if type(exportAdapter) == "function" then
		local adaptOk, adapted = pcall(exportAdapter, exported)
		if not adaptOk then
			WidgetBootstrap.fail("E_EXPORT_INVALID", "exportAdapter failed: " .. tostring(adapted), {
				branch_id = "B06_EXPORT_VALIDATE",
				stage = stage,
				module = moduleName,
				next_action = "stop"
			})
		end
		exported = adapted
	end

	if exported == nil then
		WidgetBootstrap.fail("E_EXPORT_INVALID", "module export is nil", {
			branch_id = "B06_EXPORT_VALIDATE",
			stage = stage,
			module = moduleName,
			next_action = "stop"
		})
	end

	if expectedType ~= "any" and type(exported) ~= expectedType then
		WidgetBootstrap.fail("E_EXPORT_INVALID", "Expected export type '" .. tostring(expectedType) .. "', got '" .. type(exported) .. "'", {
			branch_id = "B06_EXPORT_VALIDATE",
			stage = stage,
			module = moduleName,
			next_action = "stop"
		})
	end

	WidgetBootstrap.trace("B07_RETURN", "info", {
		stage = stage,
		module = moduleName,
		reason = "bootstrap completed successfully",
		next_action = "return"
	})
	return exported
end

if _G then
	_G.__RayfieldWidgetBootstrap = WidgetBootstrap
end

return WidgetBootstrap
]])
put("src/ui/elements/widgets/button.lua", [[local bootstrap = _G and _G.__RayfieldWidgetBootstrap
if not bootstrap then
	error("[E_BOOTSTRAP_MISSING] Rayfield widget bootstrap is not initialized")
end
if type(bootstrap) ~= "table" or type(bootstrap.bootstrapWidget) ~= "function" then
	error("[E_BOOTSTRAP_INVALID] Rayfield widget bootstrap contract is invalid")
end

return bootstrap.bootstrapWidget(
	"button",
	"src/ui/elements/widgets/index.lua",
	function(widgetsIndex)
		return {
			name = "button",
			index = widgetsIndex
		}
	end,
	{ expectedType = "table" }
)
]])
put("src/ui/elements/widgets/dropdown.lua", [[local bootstrap = _G and _G.__RayfieldWidgetBootstrap
if not bootstrap then
	error("[E_BOOTSTRAP_MISSING] Rayfield widget bootstrap is not initialized")
end
if type(bootstrap) ~= "table" or type(bootstrap.bootstrapWidget) ~= "function" then
	error("[E_BOOTSTRAP_INVALID] Rayfield widget bootstrap contract is invalid")
end

return bootstrap.bootstrapWidget(
	"dropdown",
	"src/ui/elements/widgets/index.lua",
	function(widgetsIndex)
		return {
			name = "dropdown",
			index = widgetsIndex
		}
	end,
	{ expectedType = "table" }
)
]])
put("src/ui/elements/widgets/extracted.lua", [[local bootstrap = _G and _G.__RayfieldWidgetBootstrap
if not bootstrap then
	error("[E_BOOTSTRAP_MISSING] Rayfield widget bootstrap is not initialized")
end
if type(bootstrap) ~= "table" or type(bootstrap.bootstrapWidget) ~= "function" then
	error("[E_BOOTSTRAP_INVALID] Rayfield widget bootstrap contract is invalid")
end

return bootstrap.bootstrapWidget(
	"extracted",
	"src/ui/elements/widgets/index.lua",
	nil,
	{ expectedType = "table" }
)
]])
put("src/ui/elements/widgets/index.lua", [[local bootstrap = _G and _G.__RayfieldWidgetBootstrap
if not bootstrap then
	error("[E_BOOTSTRAP_MISSING] Rayfield widget bootstrap is not initialized")
end
if type(bootstrap) ~= "table" or type(bootstrap.bootstrapWidget) ~= "function" then
	error("[E_BOOTSTRAP_INVALID] Rayfield widget bootstrap contract is invalid")
end

return bootstrap.bootstrapWidget(
	"widgets.index",
	"src/ui/elements/factory/init.lua",
	nil,
	{ expectedType = "table" }
)
]])
put("src/ui/elements/widgets/input.lua", [[local bootstrap = _G and _G.__RayfieldWidgetBootstrap
if not bootstrap then
	error("[E_BOOTSTRAP_MISSING] Rayfield widget bootstrap is not initialized")
end
if type(bootstrap) ~= "table" or type(bootstrap.bootstrapWidget) ~= "function" then
	error("[E_BOOTSTRAP_INVALID] Rayfield widget bootstrap contract is invalid")
end

return bootstrap.bootstrapWidget(
	"input",
	"src/ui/elements/widgets/index.lua",
	function(widgetsIndex)
		return {
			name = "input",
			index = widgetsIndex
		}
	end,
	{ expectedType = "table" }
)
]])
put("src/ui/elements/widgets/keybind.lua", [[local bootstrap = _G and _G.__RayfieldWidgetBootstrap
if not bootstrap then
	error("[E_BOOTSTRAP_MISSING] Rayfield widget bootstrap is not initialized")
end
if type(bootstrap) ~= "table" or type(bootstrap.bootstrapWidget) ~= "function" then
	error("[E_BOOTSTRAP_INVALID] Rayfield widget bootstrap contract is invalid")
end

return bootstrap.bootstrapWidget(
	"keybind",
	"src/ui/elements/widgets/index.lua",
	function(widgetsIndex)
		return {
			name = "keybind",
			index = widgetsIndex
		}
	end,
	{ expectedType = "table" }
)
]])
put("src/ui/elements/widgets/slider.lua", [[local bootstrap = _G and _G.__RayfieldWidgetBootstrap
if not bootstrap then
	error("[E_BOOTSTRAP_MISSING] Rayfield widget bootstrap is not initialized")
end
if type(bootstrap) ~= "table" or type(bootstrap.bootstrapWidget) ~= "function" then
	error("[E_BOOTSTRAP_INVALID] Rayfield widget bootstrap contract is invalid")
end

return bootstrap.bootstrapWidget(
	"slider",
	"src/ui/elements/widgets/index.lua",
	function(widgetsIndex)
		return {
			name = "slider",
			index = widgetsIndex
		}
	end,
	{ expectedType = "table" }
)
]])
put("src/ui/elements/widgets/toggle.lua", [[local bootstrap = _G and _G.__RayfieldWidgetBootstrap
if not bootstrap then
	error("[E_BOOTSTRAP_MISSING] Rayfield widget bootstrap is not initialized")
end
if type(bootstrap) ~= "table" or type(bootstrap.bootstrapWidget) ~= "function" then
	error("[E_BOOTSTRAP_INVALID] Rayfield widget bootstrap contract is invalid")
end

return bootstrap.bootstrapWidget(
	"toggle",
	"src/ui/elements/widgets/index.lua",
	function(widgetsIndex)
		return {
			name = "toggle",
			index = widgetsIndex
		}
	end,
	{ expectedType = "table" }
)
]])
put("src/ui/notifications.lua", [[local client = _G and _G.__RayfieldApiClient
if not client then
	error("Rayfield ApiClient is not initialized")
end

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
return client.fetchAndExecute(root .. "src/ui/notifications/init.lua")]])
put("src/ui/notifications/init.lua", [[local NotificationsUi = {}

function NotificationsUi.init(ctx)
	return {
		ctx = ctx
	}
end

return NotificationsUi]])
put("src/ui/tabs.lua", [[local client = _G and _G.__RayfieldApiClient
if not client then
	error("Rayfield ApiClient is not initialized")
end

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
return client.fetchAndExecute(root .. "src/ui/tabs/init.lua")]])
put("src/ui/tabs/init.lua", [[local TabsUi = {}

function TabsUi.init(ctx)
	return {
		ctx = ctx
	}
end

return TabsUi]])
put("src/ui/topbar.lua", [[local client = _G and _G.__RayfieldApiClient
if not client then
	error("Rayfield ApiClient is not initialized")
end

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
return client.fetchAndExecute(root .. "src/ui/topbar/init.lua")]])
put("src/ui/topbar/init.lua", [[local TopbarUi = {}

function TopbarUi.init(ctx)
	return {
		ctx = ctx
	}
end

return TopbarUi]])
put("src/ui/window/init.lua", [[local WindowUi = {}

function WindowUi.init(ctx)
	return {
		ctx = ctx
	}
end

return WindowUi]])
put("src/ui/window-shell.lua", [[local client = _G and _G.__RayfieldApiClient
if not client then
	error("Rayfield ApiClient is not initialized")
end

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
return client.fetchAndExecute(root .. "src/ui/window/init.lua")]])

return {
    name = BUNDLE_NAME,
    count = 64,
    bundle = bundle
}
