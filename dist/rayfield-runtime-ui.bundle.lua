-- AUTO-GENERATED by scripts/build-bundle.lua
local bundle = _G.__RAYFIELD_BUNDLE_SOURCES or {}
_G.__RAYFIELD_BUNDLE_SOURCES = bundle
_G.__RAYFIELD_BUNDLE_MODE = "bundle_first"

local function put(path, source)
	bundle[path] = source
end

local BUNDLE_NAME = "rayfield-runtime-ui"

put("Main loader/rayfield-all-in-one.lua", [[local compileString = loadstring or load
if not compileString then
	error("No Lua compiler function available (loadstring/load)")
end

local function compileChunk(source, label)
	if type(source) ~= "string" then
		error("Invalid Lua source for " .. tostring(label) .. ": " .. type(source))
	end
	source = source:gsub("^\239\187\191", "")
	source = source:gsub("^\0+", "")
	local chunk, err = compileString(source)
	if not chunk then
		error("Failed to compile " .. tostring(label) .. ": " .. tostring(err))
	end
	return chunk
end
	
local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
local forwardSource = game:HttpGet(root .. "src/legacy/forward.lua")
if type(forwardSource) == "string" then
	forwardSource = forwardSource:gsub("^\239\187\191", "")
	forwardSource = forwardSource:gsub("^\0+", "")
end
local Forward = compileChunk(forwardSource, "src/legacy/forward.lua")()
return Forward.module("allInOne")
]])
put("Main loader/rayfield-modified.lua", [[local compileString = loadstring or load
if not compileString then
	error("No Lua compiler function available (loadstring/load)")
end

local function formatBootstrapError(code, message)
	return string.format("Rayfield Mod: [%s] %s", tostring(code or "E_BOOTSTRAP"), tostring(message or "Unknown bootstrap error"))
end

local function compileChunk(source, label)
	if type(source) ~= "string" then
		error("Invalid Lua source for " .. tostring(label) .. ": " .. type(source))
	end
	source = source:gsub("^\239\187\191", "")
	source = source:gsub("^\0+", "")
	local chunk, err = compileString(source)
	if not chunk then
		error("Failed to compile " .. tostring(label) .. ": " .. tostring(err))
	end
	return chunk
end

local function fetchSource(url, label)
	local ok, body = pcall(game.HttpGet, game, url)
	if not ok then
		error(formatBootstrapError("E_BOOTSTRAP_FETCH", "Failed to fetch " .. tostring(label) .. ": " .. tostring(body)))
	end
	if type(body) ~= "string" or #body == 0 then
		error(formatBootstrapError("E_BOOTSTRAP_EMPTY", "Empty response for " .. tostring(label)))
	end
	return body
end

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"

local forwardOk, forwardResult = pcall(function()
	local forwardSource = fetchSource(root .. "src/legacy/forward.lua", "src/legacy/forward.lua")
	local Forward = compileChunk(forwardSource, "src/legacy/forward.lua")()
	if type(Forward) ~= "table" or type(Forward.module) ~= "function" then
		error(formatBootstrapError("E_BOOTSTRAP_FORWARD", "Invalid legacy forward contract"))
	end
	return Forward.module("modifiedEntry")
end)

if forwardOk then
	return forwardResult
end

warn(formatBootstrapError("W_BOOTSTRAP_FORWARD_FALLBACK", "Legacy forward failed, trying direct entry fallback."))
warn(formatBootstrapError("W_BOOTSTRAP_FORWARD_REASON", tostring(forwardResult)))

local fallbackSource = fetchSource(root .. "src/entry/rayfield-modified.entry.lua", "src/entry/rayfield-modified.entry.lua")
local fallback = compileChunk(fallbackSource, "src/entry/rayfield-modified.entry.lua")()
return fallback
]])
put("feature/mini-window-system.lua", [[local compileString = loadstring or load
if not compileString then
	error("No Lua compiler function available (loadstring/load)")
end

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
local Forward = compileString(game:HttpGet(root .. "src/legacy/forward.lua"))()
return Forward.module("miniWindow")
]])
put("feature/rayfield-advanced-features.lua", [[local compileString = loadstring or load
if not compileString then
	error("No Lua compiler function available (loadstring/load)")
end

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
local Forward = compileString(game:HttpGet(root .. "src/legacy/forward.lua"))()
return Forward.module("advanced")
]])
put("feature/rayfield-all-in-one.lua", [[local compileString = loadstring or load
if not compileString then
	error("No Lua compiler function available (loadstring/load)")
end

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
local Forward = compileString(game:HttpGet(root .. "src/legacy/forward.lua"))()
return Forward.module("allInOne")
]])
put("feature/rayfield-config.lua", [[local compileString = loadstring or load
if not compileString then
	error("No Lua compiler function available (loadstring/load)")
end

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
local Forward = compileString(game:HttpGet(root .. "src/legacy/forward.lua"))()
return Forward.module("config")
]])
put("feature/rayfield-drag.lua", [[local compileString = loadstring or load
if not compileString then
	error("No Lua compiler function available (loadstring/load)")
end

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
local Forward = compileString(game:HttpGet(root .. "src/legacy/forward.lua"))()
return Forward.module("drag")
]])
put("feature/rayfield-elements-extracted.lua", [[local compileString = loadstring or load
if not compileString then
	error("No Lua compiler function available (loadstring/load)")
end

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
local Forward = compileString(game:HttpGet(root .. "src/legacy/forward.lua"))()
return Forward.module("elementsExtracted")
]])
put("feature/rayfield-elements.lua", [[local compileString = loadstring or load
if not compileString then
	error("No Lua compiler function available (loadstring/load)")
end

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
local Forward = compileString(game:HttpGet(root .. "src/legacy/forward.lua"))()
return Forward.module("elements")
]])
put("feature/rayfield-enhanced.lua", [[local compileString = loadstring or load
if not compileString then
	error("No Lua compiler function available (loadstring/load)")
end

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
local Forward = compileString(game:HttpGet(root .. "src/legacy/forward.lua"))()
return Forward.module("enhanced")
]])
put("feature/rayfield-settings.lua", [[local compileString = loadstring or load
if not compileString then
	error("No Lua compiler function available (loadstring/load)")
end

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
local Forward = compileString(game:HttpGet(root .. "src/legacy/forward.lua"))()
return Forward.module("settings")
]])
put("feature/rayfield-tab-split.lua", [[local compileString = loadstring or load
if not compileString then
	error("No Lua compiler function available (loadstring/load)")
end

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
local Forward = compileString(game:HttpGet(root .. "src/legacy/forward.lua"))()
return Forward.module("tabSplit")
]])
put("feature/rayfield-theme.lua", [[local compileString = loadstring or load
if not compileString then
	error("No Lua compiler function available (loadstring/load)")
end

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
local Forward = compileString(game:HttpGet(root .. "src/legacy/forward.lua"))()
return Forward.module("theme")
]])
put("feature/rayfield-ui-state.lua", [[local compileString = loadstring or load
if not compileString then
	error("No Lua compiler function available (loadstring/load)")
end

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
local Forward = compileString(game:HttpGet(root .. "src/legacy/forward.lua"))()
return Forward.module("uiState")
]])
put("feature/rayfield-utilities.lua", [[local compileString = loadstring or load
if not compileString then
	error("No Lua compiler function available (loadstring/load)")
end

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
local Forward = compileString(game:HttpGet(root .. "src/legacy/forward.lua"))()
return Forward.module("utilities")
]])
put("src/feature/drag/cleanup.lua", [[local Cleanup = {}

function Cleanup.disconnectAll(connections)
	if type(connections) ~= "table" then
		return
	end
	for i = #connections, 1, -1 do
		local conn = connections[i]
		if conn then
			pcall(function()
				conn:Disconnect()
			end)
		end
		connections[i] = nil
	end
end

return Cleanup]])
put("src/feature/drag/controller.lua", [[-- Rayfield Drag/Detach System Module
-- Handles element detachment, mini windows, drag preview, and dock/undock logic

local DragModule = {}
local compileString = loadstring or load
if not compileString then
	error("No Lua compiler function available (loadstring/load)")
end

local MODULE_ROOT_URL = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"

local function loadSubmodule(localName, relativePath)
	local useStudio = false
	local okRun, runService = pcall(function()
		return game:GetService("RunService")
	end)
	if okRun and runService then
		local okStudio, studio = pcall(function()
			return runService:IsStudio()
		end)
		useStudio = okStudio and studio or false
	end

	if useStudio then
		local okRequire, module = pcall(function()
			return require(script.Parent[localName])
		end)
		if okRequire and module then
			return module
		end
	end

	return compileString(game:HttpGet(MODULE_ROOT_URL .. relativePath))()
end

local DragInputLib = loadSubmodule("input", "src/feature/drag/input.lua")
local DragWindowLib = loadSubmodule("window", "src/feature/drag/window.lua")
local DragDockLib = loadSubmodule("dock", "src/feature/drag/dock.lua")
local DragDetacherLib = loadSubmodule("detacher", "src/feature/drag/detacher.lua")
local DragReorderMainUiLib = loadSubmodule("reorder_main_ui", "src/feature/drag/reorder_main_ui.lua")
local DragReorderFloatingWindowsLib = loadSubmodule("reorder_floating_windows", "src/feature/drag/reorder_floating_windows.lua")

-- Initialize module with dependencies
function DragModule.init(ctx)
	local self = {}

	-- Inject dependencies
	self.UserInputService = ctx.UserInputService
	self.TweenService = ctx.TweenService
	self.Animation = ctx.Animation or ctx.TweenService
	self.RunService = ctx.RunService
	self.HttpService = ctx.HttpService
	self.Main = ctx.Main
	self.Topbar = ctx.Topbar
	self.Elements = ctx.Elements
	self.Rayfield = ctx.Rayfield
	self.Icons = ctx.Icons
	self.getIcon = ctx.getIcon
	self.getAssetUri = ctx.getAssetUri
	self.getSelectedTheme = ctx.getSelectedTheme
	self.rayfieldDestroyed = ctx.rayfieldDestroyed
	self.ElementSync = ctx.ElementSync
	self.getSetting = ctx.getSetting
	self.useMobileSizing = ctx.useMobileSizing
	self.getViewportVirtualization = ctx.getViewportVirtualization
	self.getDetachEnabled = ctx.getDetachEnabled
	self.enableDetach = ctx.enableDetach

	-- Extract code starts here

	local DETACH_HOLD_DURATION = 3
	local DETACH_HEADER_HEIGHT = 28
	local DETACH_MIN_WIDTH = 250
	local DETACH_MIN_HEIGHT = 90
	local DETACH_GHOST_FOLLOW_SPEED = 0.22
	local DETACH_WINDOW_DRAG_FOLLOW_SPEED = 0.28
	local DETACH_POP_IN_DURATION = 0.2
	local DETACH_POP_OUT_DURATION = 0.14
	local DETACH_CUE_HOVER_TRANSPARENCY = 0.52
	local DETACH_CUE_HOLD_TRANSPARENCY = 0.34
	local DETACH_CUE_READY_TRANSPARENCY = 0.24
	local DETACH_CUE_IDLE_THICKNESS = 1
	local DETACH_CUE_HOVER_THICKNESS = 1.35
	local DETACH_CUE_HOLD_THICKNESS = 1.9
	local DETACH_CUE_READY_THICKNESS = 2.2
	local DETACH_MERGE_DETECT_PADDING = 56
	local MERGE_INDICATOR_HEIGHT = 3
	local MERGE_INDICATOR_MARGIN = 8
	local MERGE_INDICATOR_TWEEN_DURATION = 0.12
	local DETACH_MOD_BUILD = "overlay-indicator-v1"
	_G.__RAYFIELD_MOD_BUILD = DETACH_MOD_BUILD
	local layoutDirtyCallback = type(ctx.onLayoutDirty) == "function" and ctx.onLayoutDirty or nil
	local detacherRegistry = {}

	local function isDetachEnabled()
		if type(self.getDetachEnabled) == "function" then
			local ok, enabled = pcall(self.getDetachEnabled)
			if ok then
				return enabled ~= false
			end
			return true
		end
		if self.enableDetach ~= nil then
			return self.enableDetach ~= false
		end
		return true
	end

	local function getViewportVirtualization()
		if type(self.getViewportVirtualization) == "function" then
			local ok, service = pcall(self.getViewportVirtualization)
			if ok then
				return service
			end
			return nil
		end
		return ctx.ViewportVirtualization
	end

	local function virtualRegisterHost(hostId, hostObject, options)
		local service = getViewportVirtualization()
		if service and type(service.registerHost) == "function" then
			pcall(service.registerHost, hostId, hostObject, options)
		end
	end

	local function virtualUnregisterHost(hostId)
		local service = getViewportVirtualization()
		if service and type(service.unregisterHost) == "function" then
			pcall(service.unregisterHost, hostId)
		end
	end

	local function virtualRefreshHost(hostId, reason)
		local service = getViewportVirtualization()
		if service and type(service.refreshHost) == "function" then
			pcall(service.refreshHost, hostId, reason)
		end
	end

	local function virtualMoveElement(guiObject, hostId, reason)
		local service = getViewportVirtualization()
		if service and type(service.moveElementToHost) == "function" then
			pcall(service.moveElementToHost, guiObject, hostId, reason)
		end
	end

	local function virtualSetElementBusy(guiObject, busy)
		local service = getViewportVirtualization()
		if service and type(service.setElementBusy) == "function" then
			pcall(service.setElementBusy, guiObject, busy)
		end
	end

	local function notifyLayoutDirty(reason)
		if type(layoutDirtyCallback) ~= "function" then
			return
		end
		pcall(layoutDirtyCallback, "floating", reason or "drag_layout_changed")
	end
	
	local inputManager = DragInputLib.create(self.UserInputService)
	local windowManager = DragWindowLib.create({
		UserInputService = self.UserInputService,
		RunService = self.RunService,
		HttpService = self.HttpService,
		Rayfield = self.Rayfield,
		Main = self.Main,
		rayfieldDestroyed = self.rayfieldDestroyed,
		mergeDetectPadding = DETACH_MERGE_DETECT_PADDING,
		followSpeed = DETACH_WINDOW_DRAG_FOLLOW_SPEED,
		getInputPosition = function(input)
			return inputManager.getInputPosition(input)
		end,
		registerSharedInput = function(id, onChanged, onEnded)
			inputManager.register(id, onChanged, onEnded)
		end,
		unregisterSharedInput = function(id)
			inputManager.unregister(id)
		end,
		onDestroyInput = function()
			inputManager.disconnect()
		end
	})

	local function ensureSharedInputConnections()
		inputManager.ensure()
	end

	local function registerSharedInput(id, onChanged, onEnded)
		inputManager.register(id, onChanged, onEnded)
	end

	local function unregisterSharedInput(id)
		inputManager.unregister(id)
	end

	local function registerDetachedWindow(record)
		windowManager.registerDetachedWindow(record)
	end

	local function unregisterDetachedWindow(record)
		windowManager.unregisterDetachedWindow(record)
	end

	local function isPointNearFrame(point, frame, padding)
		return windowManager.isPointNearFrame(point, frame, padding)
	end

	local function findMergeTargetWindow(point, excludeRecord)
		return windowManager.findMergeTargetWindow(point, excludeRecord)
	end

	local function ensureDetachedLayer()
		return windowManager.ensureDetachedLayer()
	end

	windowManager.prewarmDetachedLayer()

	local function getInputPosition(input)
		return inputManager.getInputPosition(input)
	end

	local function clampDetachedPosition(desiredPosition, windowSize)
		return windowManager.clampDetachedPosition(desiredPosition, windowSize)
	end

	local function isOutsideMain(point)
		return windowManager.isOutsideMain(point)
	end

	local function isInsideMain(point)
		return windowManager.isInsideMain(point)
	end

	local function makeFloatingDraggable(frame, dragHandle, onDragEnd)
		return windowManager.makeFloatingDraggable(frame, dragHandle, onDragEnd)
	end
	
	local createElementDetacher = DragDetacherLib.create({
		self = self,
		DragDockLib = DragDockLib,
		registerSharedInput = registerSharedInput,
		unregisterSharedInput = unregisterSharedInput,
		registerDetachedWindow = registerDetachedWindow,
		unregisterDetachedWindow = unregisterDetachedWindow,
		isPointNearFrame = isPointNearFrame,
		findMergeTargetWindow = findMergeTargetWindow,
		ensureDetachedLayer = ensureDetachedLayer,
		getInputPosition = getInputPosition,
		clampDetachedPosition = clampDetachedPosition,
		isOutsideMain = isOutsideMain,
		isInsideMain = isInsideMain,
		makeFloatingDraggable = makeFloatingDraggable,
		notifyLayoutDirty = notifyLayoutDirty,
		onVirtualHostCreate = virtualRegisterHost,
		onVirtualHostDestroy = virtualUnregisterHost,
		onVirtualHostRefresh = virtualRefreshHost,
		onVirtualElementMove = virtualMoveElement,
		onVirtualElementBusy = virtualSetElementBusy,
		ReorderMainUILib = DragReorderMainUiLib,
		ReorderFloatingWindowsLib = DragReorderFloatingWindowsLib,
		detacherRegistry = detacherRegistry,
		constants = {
			DETACH_HOLD_DURATION = DETACH_HOLD_DURATION,
			DETACH_HEADER_HEIGHT = DETACH_HEADER_HEIGHT,
			DETACH_MIN_WIDTH = DETACH_MIN_WIDTH,
			DETACH_MIN_HEIGHT = DETACH_MIN_HEIGHT,
			DETACH_GHOST_FOLLOW_SPEED = DETACH_GHOST_FOLLOW_SPEED,
			DETACH_WINDOW_DRAG_FOLLOW_SPEED = DETACH_WINDOW_DRAG_FOLLOW_SPEED,
			DETACH_POP_IN_DURATION = DETACH_POP_IN_DURATION,
			DETACH_POP_OUT_DURATION = DETACH_POP_OUT_DURATION,
			DETACH_CUE_HOVER_TRANSPARENCY = DETACH_CUE_HOVER_TRANSPARENCY,
			DETACH_CUE_HOLD_TRANSPARENCY = DETACH_CUE_HOLD_TRANSPARENCY,
			DETACH_CUE_READY_TRANSPARENCY = DETACH_CUE_READY_TRANSPARENCY,
			DETACH_CUE_IDLE_THICKNESS = DETACH_CUE_IDLE_THICKNESS,
			DETACH_CUE_HOVER_THICKNESS = DETACH_CUE_HOVER_THICKNESS,
			DETACH_CUE_HOLD_THICKNESS = DETACH_CUE_HOLD_THICKNESS,
			DETACH_CUE_READY_THICKNESS = DETACH_CUE_READY_THICKNESS,
			DETACH_MERGE_DETECT_PADDING = DETACH_MERGE_DETECT_PADDING,
			MERGE_INDICATOR_HEIGHT = MERGE_INDICATOR_HEIGHT,
			MERGE_INDICATOR_MARGIN = MERGE_INDICATOR_MARGIN,
			MERGE_INDICATOR_TWEEN_DURATION = MERGE_INDICATOR_TWEEN_DURATION
		}
	})
	-- Export main function
	self.makeElementDetachable = function(guiObject, elementName, elementType)
		if not isDetachEnabled() then
			return nil
		end
		return createElementDetacher(guiObject, elementName, elementType)
	end
	self.setLayoutDirtyCallback = function(callback)
		layoutDirtyCallback = type(callback) == "function" and callback or nil
	end
	self.getLayoutSnapshot = function()
		if not isDetachEnabled() then
			return {}
		end
		local snapshot = {}
		for _, entry in pairs(detacherRegistry) do
			if entry and entry.meta and type(entry.meta.flag) == "string" and entry.meta.flag ~= "" then
				local api = entry.api
				if api and type(api.GetLayoutSnapshot) == "function" then
					local okSnapshot, value = pcall(api.GetLayoutSnapshot)
					if okSnapshot and type(value) == "table" and value.detached == true then
						snapshot[entry.meta.flag] = value
					end
				end
			end
		end
		return snapshot
	end
	self.applyLayoutSnapshot = function(snapshot)
		if not isDetachEnabled() then
			return false
		end
		if type(snapshot) ~= "table" then
			return false
		end

		local byFlag = {}
		for _, entry in pairs(detacherRegistry) do
			if entry and entry.meta and type(entry.meta.flag) == "string" and entry.meta.flag ~= "" then
				byFlag[entry.meta.flag] = entry
			end
		end

		for flag, layout in pairs(snapshot) do
			local entry = byFlag[flag]
			if entry and entry.api and type(entry.api.ApplyLayoutSnapshot) == "function" then
				pcall(entry.api.ApplyLayoutSnapshot, layout)
			end
		end

		for flag, entry in pairs(byFlag) do
			if snapshot[flag] == nil and entry.api and type(entry.api.IsDetached) == "function" and entry.api.IsDetached() then
				pcall(entry.api.Dock)
			end
		end
		return true
	end
	
	return self
end

return DragModule
]])
put("src/feature/drag/detach-gesture.lua", [[local DetachGesture = {}

function DetachGesture.shouldStartHold(startTick, nowTick, holdDuration)
	holdDuration = holdDuration or 3
	return (nowTick - startTick) >= holdDuration
end

function DetachGesture.isDragThresholdExceeded(startPosition, currentPosition, threshold)
	threshold = threshold or 4
	if not startPosition or not currentPosition then
		return false
	end
	return (currentPosition - startPosition).Magnitude >= threshold
end

return DetachGesture]])
put("src/feature/drag/detacher.lua", [[-- Rayfield Drag Detacher Module

local DetacherModule = {}

function DetacherModule.create(ctx)
	local self = ctx.self
	local DragDockLib = ctx.DragDockLib
	local registerSharedInput = ctx.registerSharedInput
	local unregisterSharedInput = ctx.unregisterSharedInput
	local registerDetachedWindow = ctx.registerDetachedWindow
	local unregisterDetachedWindow = ctx.unregisterDetachedWindow
	local isPointNearFrame = ctx.isPointNearFrame
	local findMergeTargetWindow = ctx.findMergeTargetWindow
	local ensureDetachedLayer = ctx.ensureDetachedLayer
	local getInputPosition = ctx.getInputPosition
	local clampDetachedPosition = ctx.clampDetachedPosition
	local isOutsideMain = ctx.isOutsideMain
	local isInsideMain = ctx.isInsideMain
	local makeFloatingDraggable = ctx.makeFloatingDraggable
	local notifyLayoutDirty = ctx.notifyLayoutDirty or function() end
	local onVirtualHostCreate = type(ctx.onVirtualHostCreate) == "function" and ctx.onVirtualHostCreate or function() end
	local onVirtualHostDestroy = type(ctx.onVirtualHostDestroy) == "function" and ctx.onVirtualHostDestroy or function() end
	local onVirtualHostRefresh = type(ctx.onVirtualHostRefresh) == "function" and ctx.onVirtualHostRefresh or function() end
	local onVirtualElementMove = type(ctx.onVirtualElementMove) == "function" and ctx.onVirtualElementMove or function() end
	local onVirtualElementBusy = type(ctx.onVirtualElementBusy) == "function" and ctx.onVirtualElementBusy or function() end
	local ReorderMainUILib = ctx.ReorderMainUILib
	local ReorderFloatingWindowsLib = ctx.ReorderFloatingWindowsLib
	local detacherRegistry = ctx.detacherRegistry or {}

	if type(self) ~= "table" then
		error("DetacherModule.create: missing 'self' context")
	end
	if type(DragDockLib) ~= "table" or type(DragDockLib.create) ~= "function" then
		error("DetacherModule.create: missing DragDockLib.create")
	end

	local constants = ctx.constants or {}
	local DETACH_HOLD_DURATION = constants.DETACH_HOLD_DURATION or 3
	local DETACH_HEADER_HEIGHT = constants.DETACH_HEADER_HEIGHT or 28
	local DETACH_MIN_WIDTH = constants.DETACH_MIN_WIDTH or 250
	local DETACH_MIN_HEIGHT = constants.DETACH_MIN_HEIGHT or 90
	local DETACH_GHOST_FOLLOW_SPEED = constants.DETACH_GHOST_FOLLOW_SPEED or 0.22
	local DETACH_WINDOW_DRAG_FOLLOW_SPEED = constants.DETACH_WINDOW_DRAG_FOLLOW_SPEED or 0.28
	local DETACH_POP_IN_DURATION = constants.DETACH_POP_IN_DURATION or 0.2
	local DETACH_POP_OUT_DURATION = constants.DETACH_POP_OUT_DURATION or 0.14
	local DETACH_CUE_HOVER_TRANSPARENCY = constants.DETACH_CUE_HOVER_TRANSPARENCY or 0.52
	local DETACH_CUE_HOLD_TRANSPARENCY = constants.DETACH_CUE_HOLD_TRANSPARENCY or 0.34
	local DETACH_CUE_READY_TRANSPARENCY = constants.DETACH_CUE_READY_TRANSPARENCY or 0.24
	local DETACH_CUE_IDLE_THICKNESS = constants.DETACH_CUE_IDLE_THICKNESS or 1
	local DETACH_CUE_HOVER_THICKNESS = constants.DETACH_CUE_HOVER_THICKNESS or 1.35
	local DETACH_CUE_HOLD_THICKNESS = constants.DETACH_CUE_HOLD_THICKNESS or 1.9
	local DETACH_CUE_READY_THICKNESS = constants.DETACH_CUE_READY_THICKNESS or 2.2
	local DETACH_MERGE_DETECT_PADDING = constants.DETACH_MERGE_DETECT_PADDING or 56
	local MERGE_INDICATOR_HEIGHT = constants.MERGE_INDICATOR_HEIGHT or 3
	local MERGE_INDICATOR_MARGIN = constants.MERGE_INDICATOR_MARGIN or 8
	local MERGE_INDICATOR_TWEEN_DURATION = constants.MERGE_INDICATOR_TWEEN_DURATION or 0.12

	local function resolveReducedEffects()
		if self.useMobileSizing then
			return true
		end
		if type(self.getSetting) == "function" then
			local okReduced, reduced = pcall(self.getSetting, "System", "reducedEffects")
			if okReduced and reduced == true then
				return true
			end
			local okPerf, performanceMode = pcall(self.getSetting, "System", "performanceMode")
			if okPerf and performanceMode == true then
				return true
			end
		end
		return false
	end

	local REDUCED_EFFECTS = resolveReducedEffects()

	local function createElementDetacher(guiObject, elementName, elementType)
		if not guiObject or not guiObject:IsA("GuiObject") then
			return nil
		end
	
		if elementType == "Section" or elementType == "Divider" then
			return nil
		end
	
		local dragInputSources = {}
		local adaptiveHoldDuration = DETACH_HOLD_DURATION
		local hoverCounter = 0
	
		local function addDragInputSource(source)
			if not (source and source:IsA("GuiObject")) then
				return
			end
			if table.find(dragInputSources, source) then
				return
			end
			source.Active = true
			table.insert(dragInputSources, source)
		end
	
		if elementType == "Button" then
			adaptiveHoldDuration = 2.2
		elseif elementType == "Dropdown" then
			adaptiveHoldDuration = 1.85
		elseif elementType == "Input" then
			adaptiveHoldDuration = 1.7
		end
	
		-- Prefer Interact for elements like Button/Toggle, then Title, then fallback to full element.
		addDragInputSource(guiObject:FindFirstChild("Interact"))
		addDragInputSource(guiObject:FindFirstChild("Title"))
		if elementType == "Dropdown" then
			addDragInputSource(guiObject:FindFirstChild("Selected"))
		end
		if elementType == "Input" then
			local inputFrame = guiObject:FindFirstChild("InputFrame")
			addDragInputSource(inputFrame)
			if inputFrame then
				addDragInputSource(inputFrame:FindFirstChild("InputBox"))
			end
		end
		if elementType ~= "Input" and elementType ~= "Dropdown" then
			addDragInputSource(guiObject)
		end
		if #dragInputSources == 0 then
			addDragInputSource(guiObject)
		end
	
		local detached = false
		local floatingWindow = nil
		local floatingContent = nil
		local floatingWindowWidth = nil
		local floatingDragCleanup = nil
		local floatingTitleBar = nil
		local floatingStroke = nil
		local floatingTitleLabel = nil
		local floatingDockButton = nil

		local function resyncElement(reason)
			if not (guiObject and guiObject.GetAttribute and self.ElementSync and type(self.ElementSync.resync) == "function") then
				return
			end
			local syncToken = guiObject:GetAttribute("RayfieldElementSyncToken")
			if type(syncToken) ~= "string" or syncToken == "" then
				return
			end
			pcall(self.ElementSync.resync, syncToken, reason or "drag_update")
		end
		local detachedPlaceholder = nil
		local windowRecord = nil
		local windowConnections = {}
		local eventConnections = {}
		local originalState = nil
		local rememberedState = nil
		local detacherId = self.HttpService:GenerateGUID(false)
		local persistenceMeta = {
			flag = nil,
			tabId = nil,
			virtualHostId = nil,
			elementName = elementName,
			elementType = elementType
		}
	
		local pressInput = nil
		local pressToken = 0
		local pressing = false
		local dragArmed = false
		local pointerPosition = nil
		local dragGhost = nil
		local ghostTargetPosition = nil
		local ghostFollowConnection = nil
		local hoverActive = false
		local cueFrame = nil
		local cueStroke = nil
		local cueGlowStroke = nil
		local cueBlurStroke = nil
		local cueThemeConnection = nil
		local mergePreviewRecord = nil
		local clearMergePreview = nil
		local destroyDragGhost
		local mergeIndicator = nil
		local mergeIndicatorRecord = nil
		local mergeIndicatorTween = nil
		local lastMergeUpdateTime = 0
		local lastMergeInsertIndex = nil
		local mainDropIndicator = nil
		local mainDropIndicatorTween = nil
		local lastMainDropInsertIndex = nil
		local MERGE_UPDATE_INTERVAL = REDUCED_EFFECTS and 0.08 or 0.05 -- ~20fps default, lower update cost in reduced-effects mode
		local getOrderedMainDockChildren
		local calculateMainInsertIndex
		local reorderInMainAt
		local isGuiActiveInCurrentPage
		local isPointInsideGui
		local syncCueHoverFromPointer
		local resetDragState

		local function resolveTabVirtualHostId()
			if type(persistenceMeta.virtualHostId) == "string" and persistenceMeta.virtualHostId ~= "" then
				return persistenceMeta.virtualHostId
			end
			if type(persistenceMeta.tabId) == "string" and persistenceMeta.tabId ~= "" then
				return "tab:" .. tostring(persistenceMeta.tabId)
			end
			return nil
		end

		local function setInteractionBusy(busy)
			local nextBusy = busy == true
			if guiObject and guiObject.SetAttribute then
				pcall(guiObject.SetAttribute, guiObject, "RayfieldInteractionBusy", nextBusy)
			end
			onVirtualElementBusy(guiObject, nextBusy)
		end
	
		local function getDetachCueColor()
			return self.getSelectedTheme().SliderProgress or self.getSelectedTheme().TextColor or Color3.fromRGB(120, 170, 255)
		end
	
		local function ensureDetachCue()
			if self.rayfieldDestroyed() or not (guiObject and guiObject.Parent) or not (self.Main and self.Main.Parent) then
				if cueThemeConnection then
					cueThemeConnection:Disconnect()
					cueThemeConnection = nil
				end
				if cueFrame then
					cueFrame:Destroy()
					cueFrame = nil
					cueStroke = nil
					cueGlowStroke = nil
					cueBlurStroke = nil
				end
				return false
			end
	
			if cueFrame
				and cueFrame.Parent
				and cueStroke
				and cueStroke.Parent
				and cueGlowStroke
				and cueGlowStroke.Parent
				and (REDUCED_EFFECTS or (cueBlurStroke and cueBlurStroke.Parent))
			then
				return true
			end
	
			if cueThemeConnection then
				cueThemeConnection:Disconnect()
				cueThemeConnection = nil
			end
	
			cueFrame = Instance.new("Frame")
			cueFrame.Name = "DetachCue"
			cueFrame.BackgroundTransparency = 1
			cueFrame.BorderSizePixel = 0
			cueFrame.Size = UDim2.fromScale(1, 1)
			cueFrame.Position = UDim2.fromOffset(0, 0)
			cueFrame.ZIndex = (guiObject.ZIndex or 1) + 6
			cueFrame.Active = false
			cueFrame.Parent = guiObject
	
			local sourceCorner = guiObject:FindFirstChildOfClass("UICorner")
			if sourceCorner then
				local cueCorner = Instance.new("UICorner")
				cueCorner.CornerRadius = sourceCorner.CornerRadius
				cueCorner.Parent = cueFrame
			end
	
			cueStroke = Instance.new("UIStroke")
			cueStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
			cueStroke.Color = getDetachCueColor()
			cueStroke.Thickness = DETACH_CUE_IDLE_THICKNESS
			cueStroke.Transparency = 1
			cueStroke.Parent = cueFrame

			cueGlowStroke = Instance.new("UIStroke")
			cueGlowStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
			cueGlowStroke.Color = getDetachCueColor()
			cueGlowStroke.Thickness = DETACH_CUE_IDLE_THICKNESS + 1.4
			cueGlowStroke.Transparency = 1
			cueGlowStroke.Parent = cueFrame

			if not REDUCED_EFFECTS then
				cueBlurStroke = Instance.new("UIStroke")
				cueBlurStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
				cueBlurStroke.Color = getDetachCueColor()
				cueBlurStroke.Thickness = DETACH_CUE_IDLE_THICKNESS + 3.2
				cueBlurStroke.Transparency = 1
				cueBlurStroke.Parent = cueFrame
			else
				cueBlurStroke = nil
			end
	
			cueThemeConnection = self.Main:GetPropertyChangedSignal("BackgroundColor3"):Connect(function()
				if cueStroke and cueStroke.Parent then
					cueStroke.Color = getDetachCueColor()
				end
				if cueGlowStroke and cueGlowStroke.Parent then
					cueGlowStroke.Color = getDetachCueColor()
				end
				if cueBlurStroke and cueBlurStroke.Parent then
					cueBlurStroke.Color = getDetachCueColor()
				end
			end)
	
			return true
		end
	
		local function setDetachCue(transparency, thickness, duration)
			if not cueStroke or not cueStroke.Parent then
				return
			end
			local glowTransparency = (transparency >= 0.99)
				and 1
				or math.clamp(transparency + 0.34, 0.45, 0.98)
			local glowThickness = thickness + 1.4
			local blurTransparency = (transparency >= 0.99)
				and 1
				or math.clamp(transparency + 0.52, 0.7, 0.995)
			local blurThickness = thickness + 3.2
	
			if not duration or duration <= 0 then
				cueStroke.Transparency = transparency
				cueStroke.Thickness = thickness
				if cueGlowStroke and cueGlowStroke.Parent then
					cueGlowStroke.Transparency = glowTransparency
					cueGlowStroke.Thickness = glowThickness
				end
				if (not REDUCED_EFFECTS) and cueBlurStroke and cueBlurStroke.Parent then
					cueBlurStroke.Transparency = blurTransparency
					cueBlurStroke.Thickness = blurThickness
				end
				return
			end
	
			self.Animation:Create(cueStroke, TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
				Transparency = transparency,
				Thickness = thickness
			}):Play()
			if cueGlowStroke and cueGlowStroke.Parent then
				self.Animation:Create(cueGlowStroke, TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
					Transparency = glowTransparency,
					Thickness = glowThickness
				}):Play()
			end
			if (not REDUCED_EFFECTS) and cueBlurStroke and cueBlurStroke.Parent then
				self.Animation:Create(cueBlurStroke, TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
					Transparency = blurTransparency,
					Thickness = blurThickness
				}):Play()
			end
		end
	
		local function refreshDetachCue()
			if not ensureDetachCue() then
				return
			end
			if detached then
				setDetachCue(1, DETACH_CUE_IDLE_THICKNESS, 0.1)
				return
			end
	
			if dragArmed then
				setDetachCue(DETACH_CUE_READY_TRANSPARENCY, DETACH_CUE_READY_THICKNESS, 0.08)
				return
			end
	
			if pressing then
				setDetachCue(DETACH_CUE_HOLD_TRANSPARENCY, DETACH_CUE_HOLD_THICKNESS, 0.08)
				return
			end
	
			if hoverActive then
				setDetachCue(DETACH_CUE_HOVER_TRANSPARENCY, DETACH_CUE_HOVER_THICKNESS, 0.12)
			else
				setDetachCue(1, DETACH_CUE_IDLE_THICKNESS, 0.12)
			end
		end

		isGuiActiveInCurrentPage = function(targetGui)
			if not targetGui or not targetGui.Parent then
				return false
			end
			if detached then
				return false
			end
			if not targetGui.Visible then
				return false
			end
			local currentPage = self.Elements and self.Elements.UIPageLayout and self.Elements.UIPageLayout.CurrentPage
			if not currentPage or not currentPage.Parent then
				return false
			end
			return targetGui:IsDescendantOf(currentPage)
		end

		isPointInsideGui = function(point, targetGui)
			if not point or not targetGui or not targetGui.Parent then
				return false
			end
			if targetGui.AbsoluteSize.X <= 0 or targetGui.AbsoluteSize.Y <= 0 then
				return false
			end
			local pos = targetGui.AbsolutePosition
			local size = targetGui.AbsoluteSize
			return point.X >= pos.X
				and point.Y >= pos.Y
				and point.X <= (pos.X + size.X)
				and point.Y <= (pos.Y + size.Y)
		end

		syncCueHoverFromPointer = function(point, force)
			local pointer = point
			if not pointer then
				pointer = self.UserInputService:GetMouseLocation()
			end

			local shouldHover = false
			local currentPage = self.Elements and self.Elements.UIPageLayout and self.Elements.UIPageLayout.CurrentPage
			if currentPage and isGuiActiveInCurrentPage(guiObject) then
				for _, source in ipairs(dragInputSources) do
					if source and source.Parent and source.Visible and source:IsDescendantOf(guiObject) and source:IsDescendantOf(currentPage) then
						if isPointInsideGui(pointer, source) then
							shouldHover = true
							break
						end
					end
				end
			end

			if force or hoverActive ~= shouldHover then
				hoverCounter = shouldHover and 1 or 0
				hoverActive = shouldHover
				if not pressing and not dragArmed then
					refreshDetachCue()
				end
			end
		end

		resetDragState = function(reason)
			if reason then
				-- No-op hook kept for lightweight diagnostics if needed later.
			end
			setInteractionBusy(false)
			pressing = false
			pressInput = nil
			dragArmed = false
			pressToken += 1
			if clearMergePreview then
				clearMergePreview(false)
			end
			if destroyDragGhost then
				destroyDragGhost(true)
			end
			hoverCounter = 0
			hoverActive = false
			refreshDetachCue()
		end
	
		local function runHoldCueProgress(token)
			local started = os.clock()
			while pressing and pressToken == token and not dragArmed and not detached do
				local progress = math.clamp((os.clock() - started) / adaptiveHoldDuration, 0, 1)
				local transparency = DETACH_CUE_HOVER_TRANSPARENCY + ((DETACH_CUE_HOLD_TRANSPARENCY - DETACH_CUE_HOVER_TRANSPARENCY) * progress)
				local thickness = DETACH_CUE_HOVER_THICKNESS + ((DETACH_CUE_HOLD_THICKNESS - DETACH_CUE_HOVER_THICKNESS) * progress)
				setDetachCue(transparency, thickness, 0)
				task.wait()
			end
		end
	
		local function cleanupDetachCue()
			if cueThemeConnection then
				cueThemeConnection:Disconnect()
				cueThemeConnection = nil
			end
			if cueFrame then
				cueFrame:Destroy()
				cueFrame = nil
				cueStroke = nil
				cueGlowStroke = nil
				cueBlurStroke = nil
			end
		end
	
		local function cleanupWindowConnections()
			for _, connection in ipairs(windowConnections) do
				if connection then
					connection:Disconnect()
				end
			end
			table.clear(windowConnections)
		end

		local dockManager = DragDockLib.create()
	
		local function getOrderedGuiChildren(parent, excludeA, excludeB)
			return dockManager.getOrderedGuiChildren(parent, excludeA, excludeB)
		end
	
		local function normalizeOrderedGuiLayout(ordered)
			dockManager.normalizeOrderedGuiLayout(ordered)
		end
	
		local function parentUsesLayoutOrder(parent)
			return dockManager.parentUsesLayoutOrder(parent)
		end
	
		local function resolveInsertIndexFromState(parent, state, ordered)
			return dockManager.resolveInsertIndexFromState(parent, state, ordered)
		end
	
		local function captureCurrentElementState()
			local parent = guiObject.Parent
			local siblingIndex = nil
			local previousSibling = nil
			local nextSibling = nil
	
			if parent and parentUsesLayoutOrder(parent) then
				local ordered = getOrderedGuiChildren(parent)
				for index, child in ipairs(ordered) do
					if child == guiObject then
						siblingIndex = index
						previousSibling = ordered[index - 1]
						nextSibling = ordered[index + 1]
						break
					end
				end
			end
	
			return {
				Parent = parent,
				AnchorPoint = guiObject.AnchorPoint,
				Position = guiObject.Position,
				Size = guiObject.Size,
				LayoutOrder = guiObject.LayoutOrder,
				SiblingIndex = siblingIndex,
				PreviousSibling = previousSibling,
				NextSibling = nextSibling
			}
		end
	
		local function updateDetachedPlaceholder()
			if not detachedPlaceholder then
				return
			end
	
			local height = math.max(guiObject.AbsoluteSize.Y, 36)
			detachedPlaceholder.Size = UDim2.new(1, 0, 0, height)
		end
	
		local function destroyDetachedPlaceholder()
			if detachedPlaceholder then
				detachedPlaceholder:Destroy()
				detachedPlaceholder = nil
			end
		end
	
		local function createDetachedPlaceholder()
			if detachedPlaceholder or not originalState or not originalState.Parent then
				return
			end
	
			detachedPlaceholder = Instance.new("Frame")
			detachedPlaceholder.Name = "DetachPlaceholder"
			detachedPlaceholder.BackgroundColor3 = self.getSelectedTheme().SecondaryElementBackground
			detachedPlaceholder.BackgroundTransparency = 0.82
			detachedPlaceholder.BorderSizePixel = 0
			detachedPlaceholder.LayoutOrder = originalState.LayoutOrder
			detachedPlaceholder.Parent = originalState.Parent
	
			if parentUsesLayoutOrder(originalState.Parent) then
				local ordered = getOrderedGuiChildren(originalState.Parent, detachedPlaceholder)
				local insertIndex = resolveInsertIndexFromState(originalState.Parent, originalState, ordered)
				if type(insertIndex) ~= "number" then
					insertIndex = #ordered + 1
				end
				insertIndex = math.clamp(insertIndex, 1, #ordered + 1)
				table.insert(ordered, insertIndex, detachedPlaceholder)
				normalizeOrderedGuiLayout(ordered)
				detachedPlaceholder:SetAttribute("DetachSlotIndex", insertIndex)
			else
				detachedPlaceholder:SetAttribute("DetachSlotIndex", nil)
			end
	
			local sourceCorner = guiObject:FindFirstChildOfClass("UICorner")
			if sourceCorner then
				local placeholderCorner = Instance.new("UICorner")
				placeholderCorner.CornerRadius = sourceCorner.CornerRadius
				placeholderCorner.Parent = detachedPlaceholder
			end
	
			local placeholderStroke = Instance.new("UIStroke")
			placeholderStroke.Color = self.getSelectedTheme().SliderProgress or self.getSelectedTheme().ElementStroke
			placeholderStroke.Thickness = 1.2
			placeholderStroke.Transparency = 0.35
			placeholderStroke.Parent = detachedPlaceholder
	
			local placeholderLabel = Instance.new("TextLabel")
			placeholderLabel.Name = "Hint"
			placeholderLabel.BackgroundTransparency = 1
			placeholderLabel.Size = UDim2.new(1, -12, 1, 0)
			placeholderLabel.Position = UDim2.new(0, 6, 0, 0)
			placeholderLabel.Text = "Detached slot (origin): " .. tostring(elementName)
			placeholderLabel.TextColor3 = self.getSelectedTheme().TextColor
			placeholderLabel.TextTransparency = 0.35
			placeholderLabel.TextSize = 11
			placeholderLabel.Font = Enum.Font.Gotham
			placeholderLabel.TextXAlignment = Enum.TextXAlignment.Left
			placeholderLabel.Parent = detachedPlaceholder
	
			updateDetachedPlaceholder()
		end
	
		destroyDragGhost = function(instant)
			if clearMergePreview then
				clearMergePreview(true)
			end
	
			if ghostFollowConnection then
				ghostFollowConnection:Disconnect()
				ghostFollowConnection = nil
			end
	
			if not dragGhost then
				ghostTargetPosition = nil
				return
			end
	
			local ghost = dragGhost
			dragGhost = nil
			ghostTargetPosition = nil
	
			if instant then
				ghost:Destroy()
				return
			end
	
			local shrinkWidth = math.max(math.floor(ghost.AbsoluteSize.X * 0.9), 120)
			local shrinkHeight = math.max(math.floor(ghost.AbsoluteSize.Y * 0.88), 26)
			self.Animation:Create(ghost, TweenInfo.new(DETACH_POP_OUT_DURATION, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
				BackgroundTransparency = 1,
				Size = UDim2.fromOffset(shrinkWidth, shrinkHeight)
			}):Play()
	
			for _, child in ipairs(ghost:GetChildren()) do
				if child:IsA("TextLabel") then
					self.Animation:Create(child, TweenInfo.new(DETACH_POP_OUT_DURATION, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {TextTransparency = 1}):Play()
				elseif child:IsA("UIStroke") then
					self.Animation:Create(child, TweenInfo.new(DETACH_POP_OUT_DURATION, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {Transparency = 1}):Play()
				end
			end
	
			task.delay(DETACH_POP_OUT_DURATION + 0.03, function()
				if ghost and ghost.Parent then
					ghost:Destroy()
				end
			end)
		end
	
		local function updateGhostPosition()
			if not dragGhost or not pointerPosition then
				return
			end
	
			local size = dragGhost.AbsoluteSize
			ghostTargetPosition = Vector2.new(
				pointerPosition.X - (size.X / 2),
				pointerPosition.Y - (size.Y / 2)
			)
		end
	
		local function createDragGhost()
			if dragGhost then
				return
			end
	
			local layer = ensureDetachedLayer()
			local targetSize = Vector2.new(
				math.max(guiObject.AbsoluteSize.X, 160),
				math.max(guiObject.AbsoluteSize.Y, 34)
			)
			local startSize = Vector2.new(
				math.max(math.floor(targetSize.X * 0.9), 120),
				math.max(math.floor(targetSize.Y * 0.88), 26)
			)
	
			dragGhost = Instance.new("Frame")
			dragGhost.Name = "DetachGhost"
			dragGhost.Size = UDim2.fromOffset(startSize.X, startSize.Y)
			dragGhost.BorderSizePixel = 0
			dragGhost.BackgroundColor3 = self.getSelectedTheme().SecondaryElementBackground
			dragGhost.BackgroundTransparency = 1
			dragGhost.ZIndex = 250
			dragGhost.Parent = layer
	
			local ghostCorner = Instance.new("UICorner")
			ghostCorner.CornerRadius = UDim.new(0, 8)
			ghostCorner.Parent = dragGhost
	
			local ghostStroke = Instance.new("UIStroke")
			ghostStroke.Thickness = 1.5
			ghostStroke.Color = self.getSelectedTheme().ElementStroke
			ghostStroke.Transparency = 1
			ghostStroke.Parent = dragGhost
	
			local ghostLabel = Instance.new("TextLabel")
			ghostLabel.BackgroundTransparency = 1
			ghostLabel.Size = UDim2.new(1, -14, 1, 0)
			ghostLabel.Position = UDim2.new(0, 7, 0, 0)
			ghostLabel.Text = "Detach: " .. tostring(elementName)
			ghostLabel.TextSize = 12
			ghostLabel.Font = Enum.Font.Gotham
			ghostLabel.TextColor3 = self.getSelectedTheme().TextColor
			ghostLabel.TextTransparency = 1
			ghostLabel.TextXAlignment = Enum.TextXAlignment.Left
			ghostLabel.ZIndex = 251
			ghostLabel.Parent = dragGhost
	
			updateGhostPosition()
			if ghostTargetPosition then
				dragGhost.Position = UDim2.fromOffset(ghostTargetPosition.X, ghostTargetPosition.Y)
			end
	
			ghostFollowConnection = self.RunService.RenderStepped:Connect(function(deltaTime)
				if not dragGhost or not ghostTargetPosition then
					return
				end
	
				local current = Vector2.new(dragGhost.Position.X.Offset, dragGhost.Position.Y.Offset)
				local alpha = math.clamp(deltaTime * (DETACH_GHOST_FOLLOW_SPEED * 60), 0, 1)
				local nextPosition = current:Lerp(ghostTargetPosition, alpha)
				dragGhost.Position = UDim2.fromOffset(math.floor(nextPosition.X + 0.5), math.floor(nextPosition.Y + 0.5))
			end)
	
			self.Animation:Create(dragGhost, TweenInfo.new(DETACH_POP_IN_DURATION, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
				Size = UDim2.fromOffset(targetSize.X, targetSize.Y),
				BackgroundTransparency = 0.25
			}):Play()
			self.Animation:Create(ghostStroke, TweenInfo.new(DETACH_POP_IN_DURATION * 0.85, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Transparency = 0}):Play()
			self.Animation:Create(ghostLabel, TweenInfo.new(DETACH_POP_IN_DURATION * 0.85, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {TextTransparency = 0}):Play()
		end
	
		local function clearMergeIndicator(instant)
			if mergeIndicatorTween then
				pcall(function() mergeIndicatorTween:Cancel() end)
				mergeIndicatorTween = nil
			end
	
			if mergeIndicator then
				local indicator = mergeIndicator
				mergeIndicator = nil
				mergeIndicatorRecord = nil
	
				if instant then
					indicator:Destroy()
					return
				end
	
				self.Animation:Create(indicator, TweenInfo.new(0.08, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
					BackgroundTransparency = 1
				}):Play()
				for _, child in ipairs(indicator:GetChildren()) do
					if child:IsA("TextLabel") then
						self.Animation:Create(child, TweenInfo.new(0.08, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
							TextTransparency = 1,
							BackgroundTransparency = 1
						}):Play()
					end
				end
				task.delay(0.09, function()
					if indicator and indicator.Parent then
						indicator:Destroy()
					end
				end)
			else
				mergeIndicatorRecord = nil
			end
		end
	
		local function calculateRecordInsertIndex(record, point)
			if type(ReorderFloatingWindowsLib) == "table" and type(ReorderFloatingWindowsLib.calculateInsertIndex) == "function" then
				local ok, insertIndex, ordered = pcall(
					ReorderFloatingWindowsLib.calculateInsertIndex,
					record,
					point,
					getOrderedGuiChildren
				)
				if ok then
					return insertIndex, ordered
				end
			end

			if not (record and record.content and record.content.Parent and point) then
				return nil
			end
	
			local ordered = getOrderedGuiChildren(record.content)
			local insertIndex = #ordered + 1
	
			for index, child in ipairs(ordered) do
				local childCenterY = child.AbsolutePosition.Y + (child.AbsoluteSize.Y * 0.5)
				if point.Y <= childCenterY then
					insertIndex = index
					break
				end
			end
	
			return insertIndex, ordered
		end
	
		local function getMergeSiblingNameForPreview(child)
			if not (child and child:IsA("GuiObject")) then
				return nil
			end
	
			local title = child:FindFirstChild("Title")
			if title and title:IsA("TextLabel") then
				local text = tostring(title.Text or ""):gsub("^%s+", ""):gsub("%s+$", "")
				if text ~= "" then
					return text
				end
			end
	
			return tostring(child.Name or "")
		end
	
		local function computeIndicatorY(record, insertIndex, ordered)
			local content = record.content
			if not ordered or #ordered == 0 then
				return content.AbsolutePosition.Y + 4
			end
	
			if insertIndex <= 1 then
				local first = ordered[1]
				return first.AbsolutePosition.Y - 2
			end
	
			if insertIndex > #ordered then
				local last = ordered[#ordered]
				return last.AbsolutePosition.Y + last.AbsoluteSize.Y + 2
			end
	
			local before = ordered[insertIndex - 1]
			local after = ordered[insertIndex]
			local beforeBottom = before.AbsolutePosition.Y + before.AbsoluteSize.Y
			local afterTop = after.AbsolutePosition.Y
			return (beforeBottom + afterTop) / 2
		end
	
		local function ensureMergeIndicator(record, insertIndex, ordered)
			if not (record and record.content and record.content.Parent) then
				clearMergeIndicator(true)
				return
			end
	
			-- Recycle: just update record reference, no destroy/recreate needed
			mergeIndicatorRecord = record
	
			local layer = ensureDetachedLayer()
			-- Convert screen-space AbsolutePosition to layer-local coordinates
			-- This handles IgnoreGuiInset correctly regardless of setting
			local layerOffset = layer.AbsolutePosition
			local contentX = record.content.AbsolutePosition.X - layerOffset.X
			local contentW = record.content.AbsoluteSize.X
			local indicatorW = math.max(contentW - (MERGE_INDICATOR_MARGIN * 2), 20)
			local indicatorX = contentX + MERGE_INDICATOR_MARGIN
			local indicatorY = computeIndicatorY(record, insertIndex, ordered) - layerOffset.Y - math.floor(MERGE_INDICATOR_HEIGHT / 2)
	
			if not mergeIndicator then
				mergeIndicator = Instance.new("Frame")
				mergeIndicator.Name = "MergeIndicator"
				mergeIndicator.BackgroundColor3 = getDetachCueColor()
				mergeIndicator.BackgroundTransparency = 0.05
				mergeIndicator.BorderSizePixel = 0
				mergeIndicator.Size = UDim2.fromOffset(indicatorW, MERGE_INDICATOR_HEIGHT)
				mergeIndicator.Position = UDim2.fromOffset(indicatorX, indicatorY)
				mergeIndicator.ZIndex = 210
				mergeIndicator.Parent = layer
	
				local corner = Instance.new("UICorner")
				corner.CornerRadius = UDim.new(0, 2)
				corner.Parent = mergeIndicator
	
				local label = Instance.new("TextLabel")
				label.Name = "ReviewLabel"
				label.BackgroundColor3 = getDetachCueColor()
				label.BackgroundTransparency = 0.08
				label.BorderSizePixel = 0
				label.Size = UDim2.fromOffset(0, 16)
				label.AutomaticSize = Enum.AutomaticSize.X
				label.Position = UDim2.fromOffset(0, -18)
				label.Font = Enum.Font.GothamBold
				label.TextSize = 10
				label.TextColor3 = self.getSelectedTheme().TextColor
				label.TextTransparency = 0.05
				label.Text = ""
				label.Parent = mergeIndicator
	
				local labelPadding = Instance.new("UIPadding")
				labelPadding.PaddingLeft = UDim.new(0, 5)
				labelPadding.PaddingRight = UDim.new(0, 5)
				labelPadding.Parent = label
	
				local labelCorner = Instance.new("UICorner")
				labelCorner.CornerRadius = UDim.new(0, 4)
				labelCorner.Parent = label
			end
	
			-- Update label text
			local orderedCount = ordered and #ordered or 0
			local indexNumber = math.clamp(math.floor(tonumber(insertIndex) or 1), 1, orderedCount + 1)
			local hint = "at end"
			local targetSibling = type(ordered) == "table" and ordered[indexNumber] or nil
			if targetSibling then
				local siblingName = getMergeSiblingNameForPreview(targetSibling)
				if siblingName and siblingName ~= "" then
					hint = "before " .. siblingName
				else
					hint = "before next"
				end
			end
	
			local reviewLabel = mergeIndicator:FindFirstChild("ReviewLabel")
			if reviewLabel and reviewLabel:IsA("TextLabel") then
				reviewLabel.Text = string.format("#%d  %s", indexNumber, hint)
				reviewLabel.BackgroundColor3 = getDetachCueColor()
			end
	
			-- Update indicator color/size in case theme changed
			mergeIndicator.BackgroundColor3 = getDetachCueColor()
			mergeIndicator.Size = UDim2.fromOffset(indicatorW, MERGE_INDICATOR_HEIGHT)
	
			-- Tween to new position
			local targetPos = UDim2.fromOffset(indicatorX, indicatorY)
	
			if mergeIndicatorTween then
				pcall(function() mergeIndicatorTween:Cancel() end)
				mergeIndicatorTween = nil
			end
	
			local tween = self.Animation:Create(mergeIndicator, TweenInfo.new(
				MERGE_INDICATOR_TWEEN_DURATION, Enum.EasingStyle.Quad, Enum.EasingDirection.Out
			), { Position = targetPos })
			mergeIndicatorTween = tween
			tween.Completed:Connect(function()
				if mergeIndicatorTween == tween then
					mergeIndicatorTween = nil
				end
			end)
			tween:Play()
		end
	
		getOrderedMainDockChildren = function(tabPage, excludeA, excludeB)
			if not (tabPage and tabPage.Parent) then
				return {}
			end

			local rawChildren = tabPage:GetChildren()
			local insertionOrder = {}
			for index, child in ipairs(rawChildren) do
				insertionOrder[child] = index
			end

			local function isDockCandidate(child)
				if not (child and child:IsA("GuiObject")) then
					return false
				end
				if child == excludeA or child == excludeB then
					return false
				end
				if not child.Visible then
					return false
				end

				local childName = tostring(child.Name)
				if childName == "Placeholder"
					or childName == "DetachPlaceholder"
					or childName == "SearchTitle-fsefsefesfsefesfesfThanks" then
					return false
				end

				return true
			end

			local ordered = {}
			for _, child in ipairs(rawChildren) do
				if isDockCandidate(child) then
					table.insert(ordered, child)
				end
			end

			table.sort(ordered, function(a, b)
				if a.LayoutOrder ~= b.LayoutOrder then
					return a.LayoutOrder < b.LayoutOrder
				end
				return (insertionOrder[a] or 0) < (insertionOrder[b] or 0)
			end)

			return ordered
		end

		calculateMainInsertIndex = function(tabPage, point, excludeA, excludeB)
			if not (tabPage and tabPage.Parent and point) then
				return nil, {}
			end

			local ordered = getOrderedMainDockChildren(tabPage, excludeA, excludeB)
			local insertIndex = #ordered + 1
			for index, child in ipairs(ordered) do
				local childCenterY = child.AbsolutePosition.Y + (child.AbsoluteSize.Y * 0.5)
				if point.Y <= childCenterY then
					insertIndex = index
					break
				end
			end
			return insertIndex, ordered
		end
	
		local function computeMainIndicatorY(tabPage, insertIndex, ordered)
			if not ordered or #ordered == 0 then
				return tabPage.AbsolutePosition.Y + 4
			end
			if insertIndex <= 1 then
				return ordered[1].AbsolutePosition.Y - 2
			end
			if insertIndex > #ordered then
				local last = ordered[#ordered]
				return last.AbsolutePosition.Y + last.AbsoluteSize.Y + 2
			end
			local before = ordered[insertIndex - 1]
			local after = ordered[insertIndex]
			return (before.AbsolutePosition.Y + before.AbsoluteSize.Y + after.AbsolutePosition.Y) / 2
		end
	
		local function clearMainDropPreview(instant)
			if mainDropIndicatorTween then
				pcall(function() mainDropIndicatorTween:Cancel() end)
				mainDropIndicatorTween = nil
			end
			lastMainDropInsertIndex = nil
			if mainDropIndicator then
				local indicator = mainDropIndicator
				mainDropIndicator = nil
				if instant then
					indicator:Destroy()
					return
				end
				self.Animation:Create(indicator, TweenInfo.new(0.08, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
					BackgroundTransparency = 1
				}):Play()
				for _, child in ipairs(indicator:GetChildren()) do
					if child:IsA("TextLabel") then
						self.Animation:Create(child, TweenInfo.new(0.08, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
							TextTransparency = 1,
							BackgroundTransparency = 1
						}):Play()
					end
				end
				task.delay(0.09, function()
					if indicator and indicator.Parent then
						indicator:Destroy()
					end
				end)
			end
		end
	
		local function showMainDropPreview(point)
			local currentTabPage = self.Elements.UIPageLayout.CurrentPage
			if not (currentTabPage and currentTabPage.Parent) then
				clearMainDropPreview(false)
				return
			end
			local targetState = originalState or rememberedState
			if targetState and targetState.Parent and currentTabPage ~= targetState.Parent then
				clearMainDropPreview(false)
				return
			end
			local excludeSelf = (not detached) and guiObject or nil
			local insertIndex, ordered = calculateMainInsertIndex(currentTabPage, point, excludeSelf)
			if not insertIndex then
				clearMainDropPreview(false)
				return
			end
			lastMainDropInsertIndex = insertIndex
	
			local layer = ensureDetachedLayer()
			local layerOffset = layer.AbsolutePosition
			local contentX = currentTabPage.AbsolutePosition.X - layerOffset.X
			local contentW = currentTabPage.AbsoluteSize.X
			local indicatorW = math.max(contentW - (MERGE_INDICATOR_MARGIN * 2), 20)
			local indicatorX = contentX + MERGE_INDICATOR_MARGIN
			local indicatorY = computeMainIndicatorY(currentTabPage, insertIndex, ordered) - layerOffset.Y - math.floor(MERGE_INDICATOR_HEIGHT / 2)
	
			if not mainDropIndicator then
				mainDropIndicator = Instance.new("Frame")
				mainDropIndicator.Name = "MainDropIndicator"
				mainDropIndicator.BackgroundColor3 = getDetachCueColor()
				mainDropIndicator.BackgroundTransparency = 0.05
				mainDropIndicator.BorderSizePixel = 0
				mainDropIndicator.Size = UDim2.fromOffset(indicatorW, MERGE_INDICATOR_HEIGHT)
				mainDropIndicator.Position = UDim2.fromOffset(indicatorX, indicatorY)
				mainDropIndicator.ZIndex = 210
				mainDropIndicator.Parent = layer
	
				local corner = Instance.new("UICorner")
				corner.CornerRadius = UDim.new(0, 2)
				corner.Parent = mainDropIndicator
	
				local label = Instance.new("TextLabel")
				label.Name = "ReviewLabel"
				label.BackgroundColor3 = getDetachCueColor()
				label.BackgroundTransparency = 0.08
				label.BorderSizePixel = 0
				label.Size = UDim2.fromOffset(0, 16)
				label.AutomaticSize = Enum.AutomaticSize.X
				label.Position = UDim2.fromOffset(0, -18)
				label.Font = Enum.Font.GothamBold
				label.TextSize = 10
				label.TextColor3 = self.getSelectedTheme().TextColor
				label.TextTransparency = 0.05
				label.Text = ""
				label.Parent = mainDropIndicator
	
				local labelPadding = Instance.new("UIPadding")
				labelPadding.PaddingLeft = UDim.new(0, 5)
				labelPadding.PaddingRight = UDim.new(0, 5)
				labelPadding.Parent = label
	
				local labelCorner = Instance.new("UICorner")
				labelCorner.CornerRadius = UDim.new(0, 4)
				labelCorner.Parent = label
			end
	
			local orderedCount = #ordered
			local indexNumber = math.clamp(insertIndex, 1, orderedCount + 1)
			local hint = "at end"
			local targetSibling = ordered[indexNumber]
			if targetSibling then
				local siblingName = getMergeSiblingNameForPreview(targetSibling)
				if siblingName and siblingName ~= "" then
					hint = "before " .. siblingName
				else
					hint = "before next"
				end
			end
	
			local reviewLabel = mainDropIndicator:FindFirstChild("ReviewLabel")
			if reviewLabel and reviewLabel:IsA("TextLabel") then
				reviewLabel.Text = string.format("Dock #%d  %s", indexNumber, hint)
				reviewLabel.BackgroundColor3 = getDetachCueColor()
			end
	
			mainDropIndicator.BackgroundColor3 = getDetachCueColor()
			mainDropIndicator.Size = UDim2.fromOffset(indicatorW, MERGE_INDICATOR_HEIGHT)
	
			local targetPos = UDim2.fromOffset(indicatorX, indicatorY)
			if mainDropIndicatorTween then
				pcall(function() mainDropIndicatorTween:Cancel() end)
				mainDropIndicatorTween = nil
			end
			local tween = self.Animation:Create(mainDropIndicator, TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), { Position = targetPos })
			mainDropIndicatorTween = tween
			tween.Completed:Connect(function()
				if mainDropIndicatorTween == tween then
					mainDropIndicatorTween = nil
				end
			end)
			tween:Play()
		end
	
		clearMergePreview = function(instant)
			local previous = mergePreviewRecord
			mergePreviewRecord = nil
			lastMergeInsertIndex = nil
			clearMergeIndicator(instant)
			clearMainDropPreview(instant)
	
			if not previous or not previous.stroke or not previous.stroke.Parent then
				return
			end
	
			local targetThickness = 1.5
			local targetColor = self.getSelectedTheme().ElementStroke
			if instant then
				previous.stroke.Thickness = targetThickness
				previous.stroke.Color = targetColor
				return
			end
	
			self.Animation:Create(previous.stroke, TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
				Thickness = targetThickness,
				Color = targetColor
			}):Play()
		end
	
		local function updateMergePreview(point)
			if not dragArmed or not point then
				clearMergePreview(false)
				return
			end
	
			-- Throttle: cap at ~20 updates/sec to avoid per-pixel recalculation
			local now = os.clock()
			if now - lastMergeUpdateTime < MERGE_UPDATE_INTERVAL then
				return
			end
			lastMergeUpdateTime = now
	
			local excludeRecord = detached and windowRecord or nil
			local targetRecord = findMergeTargetWindow(point, excludeRecord)
			if targetRecord ~= mergePreviewRecord then
				local previous = mergePreviewRecord
				mergePreviewRecord = nil
				lastMergeInsertIndex = nil
	
				if previous and previous.stroke and previous.stroke.Parent then
					self.Animation:Create(previous.stroke, TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
						Thickness = 1.5,
						Color = self.getSelectedTheme().ElementStroke
					}):Play()
				end
	
				if targetRecord and targetRecord.stroke and targetRecord.stroke.Parent then
					mergePreviewRecord = targetRecord
					self.Animation:Create(targetRecord.stroke, TweenInfo.new(0.08, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
						Thickness = 2.35,
						Color = self.getSelectedTheme().SliderProgress or self.getSelectedTheme().TextColor
					}):Play()
				end
			end
	
			if targetRecord then
				clearMainDropPreview(false)
				local insertIndex, ordered = calculateRecordInsertIndex(targetRecord, point)
				lastMergeInsertIndex = insertIndex
				ensureMergeIndicator(targetRecord, insertIndex, ordered)
			elseif isInsideMain(point) and (detached or isGuiActiveInCurrentPage(guiObject)) then
				clearMergeIndicator(false)
				lastMergeInsertIndex = nil
				showMainDropPreview(point)
			else
				clearMergeIndicator(false)
				clearMainDropPreview(false)
				lastMergeInsertIndex = nil
			end
		end
	
		local function getWindowElementCount(record)
			if not (record and record.elements) then
				return 0
			end
			local count = 0
			for _ in pairs(record.elements) do
				count += 1
			end
			return count
		end
	
		local function updateWindowRecordLayout(record)
			if not (record and record.frame and record.frame.Parent) then
				return
			end
	
			local count = getWindowElementCount(record)
			if count <= 0 then
				return
			end
	
			local contentHeight = ((record.layout and record.layout.AbsoluteContentSize.Y) or 0) + 8
			local windowHeight = math.max(contentHeight + DETACH_HEADER_HEIGHT + 12, DETACH_MIN_HEIGHT)
			record.frame.Size = UDim2.fromOffset(record.width or DETACH_MIN_WIDTH, windowHeight)
			record.content.Size = UDim2.new(1, -10, 1, -(DETACH_HEADER_HEIGHT + 10))
	
			if record.titleLabel then
				if count == 1 then
					for _, entry in pairs(record.elements) do
						record.titleLabel.Text = tostring(entry.name or elementName)
						break
					end
				else
					record.titleLabel.Text = string.format("Merged (%d)", count)
				end
			end
	
			if record.dockButton then
				if count > 1 then
					record.dockButton.Size = UDim2.fromOffset(64, 20)
					record.dockButton.Position = UDim2.new(1, -70, 0.5, -10)
					record.dockButton.Text = "DockAll"
				else
					record.dockButton.Size = UDim2.fromOffset(48, 20)
					record.dockButton.Position = UDim2.new(1, -54, 0.5, -10)
					record.dockButton.Text = "Dock"
				end
			end
		end
	
		local function destroyWindowRecord(record)
			if not record then
				return
			end
	
			if record.dragCleanup then
				record.dragCleanup()
				record.dragCleanup = nil
			end
	
			if record.connections then
				for _, connection in ipairs(record.connections) do
					if connection then
						connection:Disconnect()
					end
				end
				table.clear(record.connections)
			end
	
			unregisterDetachedWindow(record)
			onVirtualHostDestroy("floating:" .. tostring(record.id))

			if record.frame then
				record.frame:Destroy()
			end
	
			if windowRecord == record then
				windowRecord = nil
			end
		end
	
		local function cleanupFloatingWindow()
			if floatingDragCleanup then
				floatingDragCleanup()
				floatingDragCleanup = nil
			end
	
			cleanupWindowConnections()
	
			local record = windowRecord
			if record and record.elements then
				record.elements[detacherId] = nil
				if getWindowElementCount(record) <= 0 then
					destroyWindowRecord(record)
				else
					updateWindowRecordLayout(record)
				end
			end
	
			windowRecord = nil
			destroyDetachedPlaceholder()
			floatingWindow = nil
			floatingContent = nil
			floatingWindowWidth = nil
			floatingTitleBar = nil
			floatingStroke = nil
			floatingTitleLabel = nil
			floatingDockButton = nil
		end
	
		local dockBack
		local dockBackToPosition
		local moveToWindowRecord
		local moveDetachedAt

		reorderInMainAt = function(point, requestedInsertIndex)
			if type(ReorderMainUILib) == "table" and type(ReorderMainUILib.apply) == "function" then
				local ok, reordered, nextRememberedState = pcall(ReorderMainUILib.apply, {
					detached = detached,
					guiObject = guiObject,
					point = point,
					requestedInsertIndex = requestedInsertIndex,
					currentTabPage = self.Elements.UIPageLayout.CurrentPage,
					parentUsesLayoutOrder = parentUsesLayoutOrder,
					getOrderedMainDockChildren = getOrderedMainDockChildren,
					calculateMainInsertIndex = calculateMainInsertIndex,
					normalizeOrderedGuiLayout = normalizeOrderedGuiLayout,
					captureCurrentElementState = captureCurrentElementState,
					resyncElement = resyncElement,
					rememberedState = rememberedState
				})
				if ok then
					if reordered and nextRememberedState then
						rememberedState = nextRememberedState
					end
					return reordered == true
				end
			end

			if detached then
				return false
			end
			if not (guiObject and guiObject.Parent) then
				return false
			end

			local currentTabPage = self.Elements.UIPageLayout.CurrentPage
			if not currentTabPage or currentTabPage ~= guiObject.Parent then
				return false
			end
			if not parentUsesLayoutOrder(currentTabPage) then
				return false
			end

			local ordered = getOrderedMainDockChildren(currentTabPage, guiObject)
			local insertIndex = tonumber(requestedInsertIndex)
			if type(insertIndex) == "number" then
				insertIndex = math.floor(insertIndex)
			else
				insertIndex = nil
			end
			if type(insertIndex) ~= "number" then
				local calculated
				calculated, ordered = calculateMainInsertIndex(currentTabPage, point, guiObject)
				insertIndex = calculated
			end
			if type(insertIndex) ~= "number" then
				return false
			end

			insertIndex = math.clamp(insertIndex, 1, #ordered + 1)
			table.insert(ordered, insertIndex, guiObject)
			normalizeOrderedGuiLayout(ordered)

			local latestState = captureCurrentElementState()
			rememberedState = {
				Parent = latestState.Parent,
				AnchorPoint = latestState.AnchorPoint,
				Position = latestState.Position,
				Size = latestState.Size,
				LayoutOrder = latestState.LayoutOrder,
				SiblingIndex = latestState.SiblingIndex,
				PreviousSibling = latestState.PreviousSibling,
				NextSibling = latestState.NextSibling
			}
			resyncElement("reorder_main")
			return true
		end
	
		local function reorderElementInRecord(record, requestedInsertIndex)
			if type(ReorderFloatingWindowsLib) == "table" and type(ReorderFloatingWindowsLib.apply) == "function" then
				local ok, reordered = pcall(ReorderFloatingWindowsLib.apply, {
					record = record,
					guiObject = guiObject,
					requestedInsertIndex = requestedInsertIndex,
					getOrderedGuiChildren = getOrderedGuiChildren,
					normalizeOrderedGuiLayout = normalizeOrderedGuiLayout,
					updateWindowRecordLayout = updateWindowRecordLayout,
					resyncElement = resyncElement,
					notifyLayoutDirty = notifyLayoutDirty
				})
				if ok then
					return reordered == true
				end
			end

			if not (record and record.content and record.content.Parent) then
				return false
			end
	
			local ordered = getOrderedGuiChildren(record.content)
			local currentIndex = nil
			for index, child in ipairs(ordered) do
				if child == guiObject then
					currentIndex = index
					break
				end
			end
			if not currentIndex then
				return false
			end
	
			local insertIndex = tonumber(requestedInsertIndex)
			if type(insertIndex) == "number" then
				insertIndex = math.floor(insertIndex)
			else
				insertIndex = currentIndex
			end
	
			table.remove(ordered, currentIndex)
			insertIndex = math.clamp(insertIndex, 1, #ordered + 1)
			table.insert(ordered, insertIndex, guiObject)
			normalizeOrderedGuiLayout(ordered)
			record.nextOrder = (#ordered + 1) * 10
			updateWindowRecordLayout(record)
			resyncElement("reorder_detached")
			notifyLayoutDirty("floating_reorder")
			return true
		end
	
		local function attachToWindowRecord(record, requestedInsertIndex)
			if not (record and record.content and record.content.Parent) then
				return false
			end
	
			windowRecord = record
			floatingWindow = record.frame
			floatingContent = record.content
			floatingWindowWidth = record.width
			floatingTitleBar = record.titleBar
			floatingStroke = record.stroke
			floatingTitleLabel = record.titleLabel
			floatingDockButton = record.dockButton
			floatingDragCleanup = nil
	
			local elementHeight = math.max(guiObject.AbsoluteSize.Y, 36)
	
			guiObject.Parent = record.content
			guiObject.AnchorPoint = Vector2.zero
			guiObject.Position = UDim2.new(0, 0, 0, 0)
			guiObject.Size = UDim2.new(1, 0, 0, elementHeight)
			onVirtualElementMove(guiObject, "floating:" .. tostring(record.id), "detach_attach")

			local ordered = getOrderedGuiChildren(record.content, guiObject)
			local insertIndex = tonumber(requestedInsertIndex)
			if type(insertIndex) == "number" then
				insertIndex = math.clamp(math.floor(insertIndex), 1, #ordered + 1)
			else
				insertIndex = #ordered + 1
			end
			table.insert(ordered, insertIndex, guiObject)
			normalizeOrderedGuiLayout(ordered)
			record.nextOrder = (#ordered + 1) * 10
	
			record.elements[detacherId] = {
				name = elementName,
				dock = function(skipAnimation)
					return dockBack(skipAnimation)
				end,
				mergeTo = function(targetRecord)
					return moveToWindowRecord(targetRecord)
				end
			}
	
			createDetachedPlaceholder()
	
			cleanupWindowConnections()
			table.insert(windowConnections, guiObject:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
				updateWindowRecordLayout(record)
				updateDetachedPlaceholder()
			end))
	
			detached = true
			updateWindowRecordLayout(record)
			updateDetachedPlaceholder()
			onVirtualHostRefresh("floating:" .. tostring(record.id), "detach_attach")
			resyncElement("detach_attach")
			notifyLayoutDirty("floating_attach")
			return true
		end
	
		moveToWindowRecord = function(targetRecord, requestedInsertIndex)
			if not detached then
				return false
			end
			if not (targetRecord and targetRecord.content and targetRecord.content.Parent) then
				return false
			end
			if targetRecord == windowRecord then
				return reorderElementInRecord(targetRecord, requestedInsertIndex)
			end
	
			local previousRecord = windowRecord
			cleanupWindowConnections()
	
			if previousRecord and previousRecord.elements then
				previousRecord.elements[detacherId] = nil
			end
	
			local attached = attachToWindowRecord(targetRecord, requestedInsertIndex)
			if not attached then
				if previousRecord and previousRecord.content and previousRecord.content.Parent then
					attachToWindowRecord(previousRecord)
				end
				return false
			end
	
			if previousRecord then
				if getWindowElementCount(previousRecord) <= 0 then
					destroyWindowRecord(previousRecord)
				else
					updateWindowRecordLayout(previousRecord)
				end
			end

			notifyLayoutDirty("floating_merge")

			return true
		end
	
		moveDetachedAt = function(point)
			if not detached then
				return false
			end
	
			local currentRecord = windowRecord
			if not (currentRecord and currentRecord.content and currentRecord.content.Parent) then
				return false
			end
	
			local targetRecord = findMergeTargetWindow(point, currentRecord)
	
			-- Float  Float: merge into another floating window (takes priority over self.Main)
			if targetRecord then
				local targetInsertIndex = nil
				if mergeIndicatorRecord == targetRecord and lastMergeInsertIndex then
					targetInsertIndex = lastMergeInsertIndex
				end
				if type(targetInsertIndex) ~= "number" then
					targetInsertIndex = calculateRecordInsertIndex(targetRecord, point)
				end
				return moveToWindowRecord(targetRecord, targetInsertIndex)
			end
	
			-- Float  self.Main: dock back to a specific position in the self.Main UI
			if isInsideMain(point) then
				local targetInsertIndex = lastMainDropInsertIndex
				local targetState = originalState or rememberedState
				if type(targetInsertIndex) ~= "number" then
					local currentTabPage = self.Elements.UIPageLayout.CurrentPage
					if targetState and targetState.Parent and currentTabPage == targetState.Parent then
						targetInsertIndex = calculateMainInsertIndex(currentTabPage, point)
					end
				end
				if type(targetInsertIndex) == "number" then
					return dockBackToPosition(targetInsertIndex)
				end
				return dockBack()
			end
	
			-- Float  same window: reorder within current window
			if not isPointNearFrame(point, currentRecord.frame, DETACH_MERGE_DETECT_PADDING) then
				return false
			end
			local targetInsertIndex = nil
			if mergeIndicatorRecord == currentRecord and lastMergeInsertIndex then
				targetInsertIndex = lastMergeInsertIndex
			end
			if type(targetInsertIndex) ~= "number" then
				targetInsertIndex = calculateRecordInsertIndex(currentRecord, point)
			end
	
			return moveToWindowRecord(currentRecord, targetInsertIndex)
		end
	
		local function createWindowRecord(point, windowWidth, windowHeight)
			local layer = ensureDetachedLayer()
			local desiredPosition = Vector2.new(point.X - (windowWidth / 2), point.Y - (DETACH_HEADER_HEIGHT / 2))
			local clampedPosition = clampDetachedPosition(desiredPosition, Vector2.new(windowWidth, windowHeight))
			local finalPosition = Vector2.new(clampedPosition.X, clampedPosition.Y)
	
			local startSize = Vector2.new(
				math.max(math.floor(windowWidth * 0.92), 140),
				math.max(math.floor(windowHeight * 0.9), 70)
			)
			local startPosition = Vector2.new(
				finalPosition.X + math.floor((windowWidth - startSize.X) / 2),
				finalPosition.Y + 8
			)
	
			local record = {
				id = self.HttpService:GenerateGUID(false),
				frame = nil,
				titleBar = nil,
				content = nil,
				layout = nil,
				stroke = nil,
				titleLabel = nil,
				dockButton = nil,
				width = windowWidth,
				elements = {},
				nextOrder = 1,
				connections = {},
				dragCleanup = nil
			}
	
			record.frame = Instance.new("Frame")
			record.frame.Name = "Detached-" .. guiObject.Name
			record.frame.Size = UDim2.fromOffset(startSize.X, startSize.Y)
			record.frame.Position = UDim2.fromOffset(startPosition.X, startPosition.Y)
			record.frame.BackgroundColor3 = self.getSelectedTheme().SecondaryElementBackground
			record.frame.BackgroundTransparency = 1
			record.frame.BorderSizePixel = 0
			record.frame.ZIndex = 200
			record.frame.Parent = layer
	
			local floatingCorner = Instance.new("UICorner")
			floatingCorner.CornerRadius = UDim.new(0, 9)
			floatingCorner.Parent = record.frame
	
			record.stroke = Instance.new("UIStroke")
			record.stroke.Color = self.getSelectedTheme().ElementStroke
			record.stroke.Thickness = 1.5
			record.stroke.Transparency = 1
			record.stroke.Parent = record.frame
	
			record.titleBar = Instance.new("Frame")
			record.titleBar.Name = "TitleBar"
			record.titleBar.Size = UDim2.new(1, 0, 0, DETACH_HEADER_HEIGHT)
			record.titleBar.BackgroundColor3 = self.getSelectedTheme().ElementBackground
			record.titleBar.BackgroundTransparency = 1
			record.titleBar.BorderSizePixel = 0
			record.titleBar.ZIndex = 201
			record.titleBar.Parent = record.frame
	
			record.titleLabel = Instance.new("TextLabel")
			record.titleLabel.Name = "Title"
			record.titleLabel.BackgroundTransparency = 1
			record.titleLabel.Size = UDim2.new(1, -72, 1, 0)
			record.titleLabel.Position = UDim2.new(0, 10, 0, 0)
			record.titleLabel.Text = tostring(elementName)
			record.titleLabel.TextColor3 = self.getSelectedTheme().TextColor
			record.titleLabel.TextSize = 12
			record.titleLabel.TextTransparency = 1
			record.titleLabel.Font = Enum.Font.GothamSemibold
			record.titleLabel.TextXAlignment = Enum.TextXAlignment.Left
			record.titleLabel.ZIndex = 202
			record.titleLabel.Parent = record.titleBar
	
			record.dockButton = Instance.new("TextButton")
			record.dockButton.Name = "DockButton"
			record.dockButton.Size = UDim2.fromOffset(48, 20)
			record.dockButton.Position = UDim2.new(1, -54, 0.5, -10)
			record.dockButton.BackgroundColor3 = self.getSelectedTheme().ElementBackgroundHover
			record.dockButton.BackgroundTransparency = 1
			record.dockButton.BorderSizePixel = 0
			record.dockButton.Text = "Dock"
			record.dockButton.TextColor3 = self.getSelectedTheme().TextColor
			record.dockButton.TextSize = 10
			record.dockButton.TextTransparency = 1
			record.dockButton.Font = Enum.Font.GothamBold
			record.dockButton.ZIndex = 202
			record.dockButton.Parent = record.titleBar
	
			local dockCorner = Instance.new("UICorner")
			dockCorner.CornerRadius = UDim.new(0, 6)
			dockCorner.Parent = record.dockButton
	
			record.content = Instance.new("Frame")
			record.content.Name = "Content"
			record.content.BackgroundTransparency = 1
			record.content.BorderSizePixel = 0
			record.content.Size = UDim2.new(1, -10, 1, -(DETACH_HEADER_HEIGHT + 10))
			record.content.Position = UDim2.fromOffset(5, DETACH_HEADER_HEIGHT + 5)
			record.content.ClipsDescendants = true
			record.content.ZIndex = 201
			record.content.Parent = record.frame
	
			record.layout = Instance.new("UIListLayout")
			record.layout.Padding = UDim.new(0, 6)
			record.layout.SortOrder = Enum.SortOrder.LayoutOrder
			record.layout.Parent = record.content

			onVirtualHostCreate("floating:" .. tostring(record.id), record.content, {
				mode = "clipped"
			})

			record.dragCleanup = makeFloatingDraggable(record.frame, record.titleBar, function(releasePoint)
				if not (record.frame and record.frame.Parent) then
					return
				end
				notifyLayoutDirty("floating_move")
	
				local point = releasePoint
				if not point then
					local absPos = record.frame.AbsolutePosition
					local absSize = record.frame.AbsoluteSize
					point = Vector2.new(absPos.X + (absSize.X * 0.5), absPos.Y + (absSize.Y * 0.5))
				end
	
				local targetRecord = findMergeTargetWindow(point, record)
				if not targetRecord then
					return
				end
	
				local mergeHandlers = {}
				for _, entry in pairs(record.elements) do
					if entry and entry.mergeTo then
						table.insert(mergeHandlers, entry.mergeTo)
					end
				end
	
				for _, mergeFn in ipairs(mergeHandlers) do
					pcall(function()
						mergeFn(targetRecord)
					end)
				end
			end)
	
			table.insert(record.connections, record.dockButton.MouseButton1Click:Connect(function()
				local docks = {}
				for _, entry in pairs(record.elements) do
					if entry and entry.dock then
						table.insert(docks, entry.dock)
					end
				end
				for _, dockFn in ipairs(docks) do
					pcall(function()
						dockFn(true)
					end)
				end
			end))
	
			registerDetachedWindow(record)
	
			self.Animation:Create(record.frame, TweenInfo.new(DETACH_POP_IN_DURATION, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
				Size = UDim2.fromOffset(windowWidth, windowHeight),
				Position = UDim2.fromOffset(finalPosition.X, finalPosition.Y),
				BackgroundTransparency = 0
			}):Play()
			self.Animation:Create(record.stroke, TweenInfo.new(DETACH_POP_IN_DURATION * 0.85, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Transparency = 0}):Play()
			self.Animation:Create(record.titleBar, TweenInfo.new(DETACH_POP_IN_DURATION * 0.85, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundTransparency = 0}):Play()
			self.Animation:Create(record.titleLabel, TweenInfo.new(DETACH_POP_IN_DURATION * 0.85, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {TextTransparency = 0}):Play()
			self.Animation:Create(record.dockButton, TweenInfo.new(DETACH_POP_IN_DURATION * 0.85, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
				BackgroundTransparency = 0,
				TextTransparency = 0
			}):Play()
	
			return record
		end
	
		dockBack = function(skipWindowAnimation)
			if not detached then
				return false
			end
	
			local targetState = originalState or rememberedState
			local targetParent = targetState and targetState.Parent
			if not targetParent or not targetParent.Parent then
				cleanupFloatingWindow()
				detached = false
				originalState = nil
				return false
			end
	
			local record = windowRecord
			local recordCountBefore = getWindowElementCount(record)
			local shouldCollapse = (not skipWindowAnimation) and record and record.frame and record.frame.Parent and recordCountBefore <= 1
	
			if shouldCollapse then
				local collapseWidth = math.max(math.floor(record.frame.Size.X.Offset * 0.94), 120)
				local collapseHeight = math.max(math.floor(record.frame.Size.Y.Offset * 0.92), 70)
				self.Animation:Create(record.frame, TweenInfo.new(DETACH_POP_OUT_DURATION, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
					BackgroundTransparency = 1,
					Size = UDim2.fromOffset(collapseWidth, collapseHeight)
				}):Play()
				if record.stroke then
					self.Animation:Create(record.stroke, TweenInfo.new(DETACH_POP_OUT_DURATION, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {Transparency = 1}):Play()
				end
				if record.titleBar then
					self.Animation:Create(record.titleBar, TweenInfo.new(DETACH_POP_OUT_DURATION, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {BackgroundTransparency = 1}):Play()
				end
				if record.titleLabel then
					self.Animation:Create(record.titleLabel, TweenInfo.new(DETACH_POP_OUT_DURATION, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {TextTransparency = 1}):Play()
				end
				if record.dockButton then
					self.Animation:Create(record.dockButton, TweenInfo.new(DETACH_POP_OUT_DURATION, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
						BackgroundTransparency = 1,
						TextTransparency = 1
					}):Play()
				end
				task.wait(DETACH_POP_OUT_DURATION)
			end
	
			local placeholder = detachedPlaceholder
			guiObject.Parent = targetParent
			guiObject.AnchorPoint = targetState.AnchorPoint
			guiObject.Position = targetState.Position
			guiObject.Size = targetState.Size
			local tabVirtualHostId = resolveTabVirtualHostId()
			if tabVirtualHostId then
				onVirtualElementMove(guiObject, tabVirtualHostId, "dock_back")
				onVirtualHostRefresh(tabVirtualHostId, "dock_back")
			end
	
			if parentUsesLayoutOrder(targetParent) then
				local ordered = getOrderedGuiChildren(targetParent, guiObject, placeholder)
				local slotIndex = nil
	
				if placeholder and placeholder.Parent == targetParent then
					slotIndex = placeholder:GetAttribute("DetachSlotIndex")
				end
				if type(slotIndex) ~= "number" then
					slotIndex = resolveInsertIndexFromState(targetParent, targetState, ordered)
				end
	
				if type(slotIndex) == "number" then
					slotIndex = math.clamp(slotIndex, 1, #ordered + 1)
					table.insert(ordered, slotIndex, guiObject)
					normalizeOrderedGuiLayout(ordered)
				else
					guiObject.LayoutOrder = targetState.LayoutOrder
				end
			else
				guiObject.LayoutOrder = targetState.LayoutOrder
			end
	
			destroyDetachedPlaceholder()
	
			if record and record.elements then
				record.elements[detacherId] = nil
				if getWindowElementCount(record) <= 0 then
					destroyWindowRecord(record)
				else
					updateWindowRecordLayout(record)
				end
			end
	
			windowRecord = nil
			floatingWindow = nil
			floatingContent = nil
			floatingWindowWidth = nil
			floatingTitleBar = nil
			floatingStroke = nil
			floatingTitleLabel = nil
			floatingDockButton = nil
			cleanupWindowConnections()
	
			detached = false
			originalState = nil
			hoverCounter = 0
			hoverActive = false
			refreshDetachCue()
			resyncElement("dock_back")
			notifyLayoutDirty("element_docked")
			return true
		end
	
		dockBackToPosition = function(insertIndex)
			if not detached then
				return false
			end
	
			local targetState = originalState or rememberedState
			if not targetState then
				return dockBack()
			end
	
			local currentTabPage = self.Elements.UIPageLayout.CurrentPage
			if not (currentTabPage and currentTabPage.Parent) then
				return dockBack()
			end
	
			-- Only allow position-aware dock to the original parent tab page
			local targetParent = targetState.Parent
			if targetParent ~= currentTabPage then
				return dockBack()
			end
	
			local record = windowRecord
			local recordCountBefore = getWindowElementCount(record)
			local shouldCollapse = record and record.frame and record.frame.Parent and recordCountBefore <= 1
	
			if shouldCollapse then
				local collapseWidth = math.max(math.floor(record.frame.Size.X.Offset * 0.94), 120)
				local collapseHeight = math.max(math.floor(record.frame.Size.Y.Offset * 0.92), 70)
				self.Animation:Create(record.frame, TweenInfo.new(DETACH_POP_OUT_DURATION, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
					BackgroundTransparency = 1,
					Size = UDim2.fromOffset(collapseWidth, collapseHeight)
				}):Play()
				if record.stroke then
					self.Animation:Create(record.stroke, TweenInfo.new(DETACH_POP_OUT_DURATION, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {Transparency = 1}):Play()
				end
				if record.titleBar then
					self.Animation:Create(record.titleBar, TweenInfo.new(DETACH_POP_OUT_DURATION, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {BackgroundTransparency = 1}):Play()
				end
				if record.titleLabel then
					self.Animation:Create(record.titleLabel, TweenInfo.new(DETACH_POP_OUT_DURATION, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {TextTransparency = 1}):Play()
				end
				if record.dockButton then
					self.Animation:Create(record.dockButton, TweenInfo.new(DETACH_POP_OUT_DURATION, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
						BackgroundTransparency = 1,
						TextTransparency = 1
					}):Play()
				end
				task.wait(DETACH_POP_OUT_DURATION)
			end
	
			local placeholder = detachedPlaceholder
			guiObject.Parent = targetParent
			guiObject.AnchorPoint = targetState.AnchorPoint
			guiObject.Position = targetState.Position
			guiObject.Size = targetState.Size
			local tabVirtualHostId = resolveTabVirtualHostId()
			if tabVirtualHostId then
				onVirtualElementMove(guiObject, tabVirtualHostId, "dock_back_to_position")
				onVirtualHostRefresh(tabVirtualHostId, "dock_back_to_position")
			end
	
			if parentUsesLayoutOrder(targetParent) then
				local ordered
				if targetParent == currentTabPage then
					ordered = getOrderedMainDockChildren(targetParent, guiObject, placeholder)
				else
					ordered = getOrderedGuiChildren(targetParent, guiObject, placeholder)
				end
				local clampedIndex = math.clamp(insertIndex, 1, #ordered + 1)
				table.insert(ordered, clampedIndex, guiObject)
				normalizeOrderedGuiLayout(ordered)
			else
				guiObject.LayoutOrder = targetState.LayoutOrder
			end
	
			destroyDetachedPlaceholder()
	
			if record and record.elements then
				record.elements[detacherId] = nil
				if getWindowElementCount(record) <= 0 then
					destroyWindowRecord(record)
				else
					updateWindowRecordLayout(record)
				end
			end
	
			windowRecord = nil
			floatingWindow = nil
			floatingContent = nil
			floatingWindowWidth = nil
			floatingTitleBar = nil
			floatingStroke = nil
			floatingTitleLabel = nil
			floatingDockButton = nil
			cleanupWindowConnections()
	
			detached = false
			originalState = nil
			hoverCounter = 0
			hoverActive = false
			refreshDetachCue()
			resyncElement("dock_back_to_position")
			notifyLayoutDirty("element_docked_positioned")
			return true
		end
	
		local function detachAt(point)
			if detached or not guiObject.Parent then
				return false
			end
	
			originalState = captureCurrentElementState()
			rememberedState = {
				Parent = originalState.Parent,
				AnchorPoint = originalState.AnchorPoint,
				Position = originalState.Position,
				Size = originalState.Size,
				LayoutOrder = originalState.LayoutOrder,
				SiblingIndex = originalState.SiblingIndex,
				PreviousSibling = originalState.PreviousSibling,
				NextSibling = originalState.NextSibling
			}
	
			if not originalState.Parent then
				return false
			end
	
			local elementHeight = math.max(guiObject.AbsoluteSize.Y, 36)
			local windowWidth = math.max(guiObject.AbsoluteSize.X + 20, DETACH_MIN_WIDTH)
			local windowHeight = math.max(elementHeight + DETACH_HEADER_HEIGHT + 12, DETACH_MIN_HEIGHT)
	
			local targetRecord = findMergeTargetWindow(point, nil)
			local targetInsertIndex = nil
			if targetRecord then
				if mergeIndicatorRecord == targetRecord and lastMergeInsertIndex then
					targetInsertIndex = lastMergeInsertIndex
				end
				if type(targetInsertIndex) ~= "number" then
					targetInsertIndex = calculateRecordInsertIndex(targetRecord, point)
				end
			end
			if not targetRecord then
				targetRecord = createWindowRecord(point, windowWidth, windowHeight)
			end
			if not targetRecord then
				return false
			end
	
			local attached = attachToWindowRecord(targetRecord, targetInsertIndex)
			if not attached then
				return false
			end
	
			if targetRecord.stroke then
				local baseThickness = targetRecord.stroke.Thickness
				targetRecord.stroke.Thickness = baseThickness + 0.9
				self.Animation:Create(targetRecord.stroke, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
					Thickness = baseThickness
				}):Play()
			end

			refreshDetachCue()
			local tabVirtualHostId = resolveTabVirtualHostId()
			if tabVirtualHostId then
				onVirtualHostRefresh(tabVirtualHostId, "element_detached")
			end
			resyncElement("detach")
			notifyLayoutDirty("element_detached")
			return true
		end

		local function getDetachedLayoutSnapshot()
			if not detached then
				return nil
			end
			if not (windowRecord and windowRecord.frame and windowRecord.frame.Parent) then
				return nil
			end

			local frame = windowRecord.frame
			local position = frame.Position
			local size = frame.Size
			return {
				detached = true,
				position = {
					x = position.X.Offset,
					y = position.Y.Offset
				},
				size = {
					x = size.X.Offset,
					y = size.Y.Offset
				},
				tabId = persistenceMeta.tabId,
				elementType = persistenceMeta.elementType
			}
		end

		local function applyDetachedLayout(layout)
			if type(layout) ~= "table" then
				return false
			end
			if not (windowRecord and windowRecord.frame and windowRecord.frame.Parent) then
				return false
			end

			local frame = windowRecord.frame
			local sizeSpec = layout.size
			local width = sizeSpec and tonumber(sizeSpec.x)
			local height = sizeSpec and tonumber(sizeSpec.y)
			if not width then
				width = frame.Size.X.Offset
			end
			if not height then
				height = frame.Size.Y.Offset
			end
			width = math.max(math.floor(width), DETACH_MIN_WIDTH)
			height = math.max(math.floor(height), DETACH_MIN_HEIGHT)

			local positionSpec = layout.position
			local posX = positionSpec and tonumber(positionSpec.x)
			local posY = positionSpec and tonumber(positionSpec.y)
			if not posX then
				posX = frame.Position.X.Offset
			end
			if not posY then
				posY = frame.Position.Y.Offset
			end

			local clamped = clampDetachedPosition(Vector2.new(posX, posY), Vector2.new(width, height))
			frame.Size = UDim2.fromOffset(width, height)
			frame.Position = UDim2.fromOffset(clamped.X, clamped.Y)
			windowRecord.width = width
			updateWindowRecordLayout(windowRecord)
			notifyLayoutDirty("floating_layout_applied")
			return true
		end
	
		local function handleDetachHoverEnter()
			if detached then
				return
			end
			hoverCounter = 1
			hoverActive = true
			syncCueHoverFromPointer(self.UserInputService:GetMouseLocation(), true)
		end
	
		local function handleDetachHoverLeave()
			hoverCounter = 0
			hoverActive = false
			syncCueHoverFromPointer(self.UserInputService:GetMouseLocation(), true)
		end
	
		local function handleDetachInputBegan(input)
			local inputType = input.UserInputType
			if inputType ~= Enum.UserInputType.MouseButton1 and inputType ~= Enum.UserInputType.Touch then
				return
			end
			if elementType == "Input" and self.UserInputService:GetFocusedTextBox() then
				return
			end
			if pressing or dragArmed then
				return
			end
	
			ensureDetachCue()
			pressing = true
			pressInput = input
			pressToken += 1
			dragArmed = false
			setInteractionBusy(true)
			pointerPosition = getInputPosition(input)
			local token = pressToken
			refreshDetachCue()
			task.spawn(runHoldCueProgress, token)
	
			task.delay(adaptiveHoldDuration, function()
				if pressToken ~= token or not pressing then
					return
				end
				dragArmed = true
				refreshDetachCue()
				createDragGhost()
			end)
		end
	
		for _, source in ipairs(dragInputSources) do
			table.insert(eventConnections, source.MouseEnter:Connect(handleDetachHoverEnter))
			table.insert(eventConnections, source.MouseLeave:Connect(handleDetachHoverLeave))
			table.insert(eventConnections, source.InputBegan:Connect(handleDetachInputBegan))
		end

		local currentPageSignal = self.Elements and self.Elements.UIPageLayout and self.Elements.UIPageLayout:GetPropertyChangedSignal("CurrentPage")
		if currentPageSignal then
			table.insert(eventConnections, currentPageSignal:Connect(function()
				local pointer = self.UserInputService:GetMouseLocation()
				syncCueHoverFromPointer(pointer, true)
				if pressing and not isGuiActiveInCurrentPage(guiObject) then
					resetDragState("page_changed")
				end
			end))
		end

		table.insert(eventConnections, guiObject:GetPropertyChangedSignal("Visible"):Connect(function()
			syncCueHoverFromPointer(self.UserInputService:GetMouseLocation(), true)
		end))
	
		-- Use shared global dispatcher instead of per-element InputChanged/InputEnded
		registerSharedInput(detacherId, function(input) -- InputChanged
			if input.UserInputType == Enum.UserInputType.MouseMovement then
				pointerPosition = getInputPosition(input)
				if not pressing then
					syncCueHoverFromPointer(pointerPosition, false)
				end
			end

			if not pressing or not pressInput then
				return
			end
	
			local matchesTouch = input == pressInput
			local matchesMouse = pressInput.UserInputType == Enum.UserInputType.MouseButton1 and input.UserInputType == Enum.UserInputType.MouseMovement
			if not matchesTouch and not matchesMouse then
				return
			end
	
			pointerPosition = getInputPosition(input)
			if dragArmed then
				updateGhostPosition()
				updateMergePreview(pointerPosition)
			end
		end, function(input) -- InputEnded
			if not pressInput then
				return
			end
	
			local sameTouch = input == pressInput
			local mouseEnded = pressInput.UserInputType == Enum.UserInputType.MouseButton1 and input.UserInputType == Enum.UserInputType.MouseButton1
			if not sameTouch and not mouseEnded then
				return
			end
	
			pressing = false
			pressInput = nil
			pressToken += 1
			setInteractionBusy(false)
	
			-- Snapshot cached insert indices before clearMergePreview wipes them
			local cachedMainDropIndex = lastMainDropInsertIndex
			local cachedMergeInsertIndex = lastMergeInsertIndex
			clearMergePreview(false)
	
			local dropPoint = pointerPosition or self.UserInputService:GetMouseLocation()
			if dragArmed then
				dragArmed = false
				destroyDragGhost()
				if detached then
					if dropPoint then
						-- Restore cached index so moveDetachedAt can use the indicator's value
						lastMainDropInsertIndex = cachedMainDropIndex
						lastMergeInsertIndex = cachedMergeInsertIndex
						if not moveDetachedAt(dropPoint) then
							refreshDetachCue()
						end
						lastMainDropInsertIndex = nil
						lastMergeInsertIndex = nil
					else
						refreshDetachCue()
					end
				else
					local hasMergeTarget = dropPoint and findMergeTargetWindow(dropPoint, nil) ~= nil
					local canReorderInMain = dropPoint and isInsideMain(dropPoint) and isGuiActiveInCurrentPage(guiObject)
					if canReorderInMain then
						lastMainDropInsertIndex = cachedMainDropIndex
						local reordered = reorderInMainAt(dropPoint, lastMainDropInsertIndex)
						lastMainDropInsertIndex = nil
						if not reordered then
							if dropPoint and (isOutsideMain(dropPoint) or hasMergeTarget) then
								if not detachAt(dropPoint) then
									refreshDetachCue()
								end
							else
								refreshDetachCue()
							end
						else
							syncCueHoverFromPointer(dropPoint, true)
						end
					elseif dropPoint and (isOutsideMain(dropPoint) or hasMergeTarget) then
						if not detachAt(dropPoint) then
							refreshDetachCue()
						end
					else
						refreshDetachCue()
					end
				end
			else
				destroyDragGhost()
				refreshDetachCue()
			end
		end)
	
		local function fullCleanup()
			setInteractionBusy(false)
			detacherRegistry[detacherId] = nil
			unregisterSharedInput(detacherId)
			destroyDragGhost(true)
			cleanupFloatingWindow()
			cleanupDetachCue()
			for _, connection in ipairs(eventConnections) do
				if connection then
					connection:Disconnect()
				end
			end
			table.clear(eventConnections)
		end
	
		local function connectIfAvailable(signalName, callback)
			local ok, signal = pcall(function()
				return guiObject[signalName]
			end)
			if ok and signal and signal.Connect then
				table.insert(eventConnections, signal:Connect(callback))
			end
		end

		-- Cleanup when guiObject is destroyed
		connectIfAvailable("Destroying", fullCleanup)
	
		-- Safety net: cleanup if element leaves the DataModel without being destroyed
		-- (e.g. parent set to nil, or ancestor removed)
		connectIfAvailable("AncestryChanged", function()
			if not guiObject:IsDescendantOf(game) then
				task.defer(function()
					-- Re-check after defer in case of rapid reparent
					if not guiObject:IsDescendantOf(game) then
						fullCleanup()
					end
				end)
			else
				task.defer(function()
					if guiObject and guiObject.Parent then
						syncCueHoverFromPointer(self.UserInputService:GetMouseLocation(), true)
						if pressing and not isGuiActiveInCurrentPage(guiObject) then
							resetDragState("reparent")
						end
					end
				end)
			end
		end)

		task.defer(function()
			if guiObject and guiObject.Parent then
				syncCueHoverFromPointer(self.UserInputService:GetMouseLocation(), true)
			end
		end)
	
		local detacherApi = {
			Detach = function(position)
				local pos = position or self.UserInputService:GetMouseLocation()
				return detachAt(pos)
			end,
			Dock = function()
				return dockBack()
			end,
			GetRememberedState = function()
				if not rememberedState then
					return nil
				end
				return {
					Parent = rememberedState.Parent,
					AnchorPoint = rememberedState.AnchorPoint,
					Position = rememberedState.Position,
					Size = rememberedState.Size,
					LayoutOrder = rememberedState.LayoutOrder,
					SiblingIndex = rememberedState.SiblingIndex,
					PreviousSibling = rememberedState.PreviousSibling,
					NextSibling = rememberedState.NextSibling
				}
			end,
			IsDetached = function()
				return detached
			end,
			SetPersistenceMetadata = function(metadata)
				if type(metadata) ~= "table" then
					return
				end
				if type(metadata.flag) == "string" and metadata.flag ~= "" then
					persistenceMeta.flag = metadata.flag
				end
				if type(metadata.tabId) == "string" and metadata.tabId ~= "" then
					persistenceMeta.tabId = metadata.tabId
				end
				if type(metadata.virtualHostId) == "string" and metadata.virtualHostId ~= "" then
					persistenceMeta.virtualHostId = metadata.virtualHostId
				end
				if type(metadata.elementName) == "string" and metadata.elementName ~= "" then
					persistenceMeta.elementName = metadata.elementName
				end
				if type(metadata.elementType) == "string" and metadata.elementType ~= "" then
					persistenceMeta.elementType = metadata.elementType
				end
			end,
			GetLayoutSnapshot = function()
				return getDetachedLayoutSnapshot()
			end,
			ApplyLayoutSnapshot = function(layout)
				if type(layout) ~= "table" then
					return false
				end
				if layout.detached ~= true then
					if detached then
						return dockBack()
					end
					return true
				end
				local position = layout.position
				local targetX = position and tonumber(position.x)
				local targetY = position and tonumber(position.y)
				local size = layout.size
				local targetWidth = size and tonumber(size.x)
				local targetHeight = size and tonumber(size.y)
				local detachPoint = Vector2.new(
					(targetX or 0) + math.floor((targetWidth or DETACH_MIN_WIDTH) / 2),
					(targetY or 0) + math.floor((targetHeight or DETACH_MIN_HEIGHT) / 2)
				)
				if not detached then
					local detachedNow = detachAt(detachPoint)
					if not detachedNow then
						return false
					end
				end
				return applyDetachedLayout(layout)
			end,
			Destroy = fullCleanup
		}

		detacherRegistry[detacherId] = {
			id = detacherId,
			meta = persistenceMeta,
			api = detacherApi
		}
		return detacherApi
	end


	return createElementDetacher
end

return DetacherModule
]])
put("src/feature/drag/dock.lua", [[local DragDock = {}

local function getOrderedGuiChildren(parent, excludeA, excludeB)
	if not parent then
		return {}
	end

	local rawChildren = parent:GetChildren()
	local insertionOrder = {}
	for index, child in ipairs(rawChildren) do
		insertionOrder[child] = index
	end

	local ordered = {}
	for _, child in ipairs(rawChildren) do
		if child:IsA("GuiObject") and child ~= excludeA and child ~= excludeB then
			table.insert(ordered, child)
		end
	end

	table.sort(ordered, function(a, b)
		if a.LayoutOrder ~= b.LayoutOrder then
			return a.LayoutOrder < b.LayoutOrder
		end
		return (insertionOrder[a] or 0) < (insertionOrder[b] or 0)
	end)

	return ordered
end

local function normalizeOrderedGuiLayout(ordered)
	for index, child in ipairs(ordered) do
		child.LayoutOrder = index * 10
	end
end

local function parentUsesLayoutOrder(parent)
	if not parent then
		return false
	end
	local listLayout = parent:FindFirstChildOfClass("UIListLayout")
	if not listLayout then
		return false
	end
	if listLayout.SortOrder ~= Enum.SortOrder.LayoutOrder then
		listLayout.SortOrder = Enum.SortOrder.LayoutOrder
	end
	return true
end

local function resolveInsertIndexFromState(parent, state, ordered)
	if not (parent and state) then
		return nil
	end

	local candidates = ordered or getOrderedGuiChildren(parent)

	if state.NextSibling and state.NextSibling.Parent == parent then
		for index, child in ipairs(candidates) do
			if child == state.NextSibling then
				return index
			end
		end
	end

	if state.PreviousSibling and state.PreviousSibling.Parent == parent then
		for index, child in ipairs(candidates) do
			if child == state.PreviousSibling then
				return index + 1
			end
		end
	end

	if type(state.SiblingIndex) == "number" then
		return math.floor(state.SiblingIndex)
	end

	return nil
end

function DragDock.create()
	return {
		getOrderedGuiChildren = getOrderedGuiChildren,
		normalizeOrderedGuiLayout = normalizeOrderedGuiLayout,
		parentUsesLayoutOrder = parentUsesLayoutOrder,
		resolveInsertIndexFromState = resolveInsertIndexFromState
	}
end

return DragDock
]])
put("src/feature/drag/init.lua", [[local client = _G and _G.__RayfieldApiClient
if not client then
	error("Rayfield ApiClient is not initialized")
end

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
return client.fetchAndExecute(root .. "src/feature/drag/controller.lua")]])
put("src/feature/drag/input.lua", [[local DragInput = {}

function DragInput.create(UserInputService)
	local sharedInputChanged = {}
	local sharedInputEnded = {}
	local sharedInputConnections = nil

	local function ensureSharedInputConnections()
		if sharedInputConnections then
			return
		end
		sharedInputConnections = {
			UserInputService.InputChanged:Connect(function(input)
				for _, cb in pairs(sharedInputChanged) do
					cb(input)
				end
			end),
			UserInputService.InputEnded:Connect(function(input)
				for _, cb in pairs(sharedInputEnded) do
					cb(input)
				end
			end)
		}
	end

	local function registerSharedInput(id, onChanged, onEnded)
		ensureSharedInputConnections()
		if onChanged then
			sharedInputChanged[id] = onChanged
		end
		if onEnded then
			sharedInputEnded[id] = onEnded
		end
	end

	local function unregisterSharedInput(id)
		sharedInputChanged[id] = nil
		sharedInputEnded[id] = nil
	end

	local function disconnectSharedInput()
		table.clear(sharedInputChanged)
		table.clear(sharedInputEnded)
		if sharedInputConnections then
			for _, connection in ipairs(sharedInputConnections) do
				if connection then
					connection:Disconnect()
				end
			end
			sharedInputConnections = nil
		end
	end

	local function getInputPosition(input)
		if input and input.Position then
			return Vector2.new(input.Position.X, input.Position.Y)
		end
		return UserInputService:GetMouseLocation()
	end

	return {
		ensure = ensureSharedInputConnections,
		register = registerSharedInput,
		unregister = unregisterSharedInput,
		disconnect = disconnectSharedInput,
		getInputPosition = getInputPosition
	}
end

return DragInput
]])
put("src/feature/drag/merge-indicator.lua", [[local MergeIndicator = {}

function MergeIndicator.computeInsertIndex(slotPositions, pointerX)
	local index = #slotPositions + 1
	for i, x in ipairs(slotPositions) do
		if pointerX < x then
			index = i
			break
		end
	end
	return index
end

return MergeIndicator]])
put("src/feature/drag/reorder_floating_windows.lua", [[local FloatingWindowReorder = {}

function FloatingWindowReorder.calculateInsertIndex(record, point, getOrderedGuiChildren)
	if not (record and record.content and record.content.Parent and point) then
		return nil, {}
	end
	if type(getOrderedGuiChildren) ~= "function" then
		return nil, {}
	end

	local ordered = getOrderedGuiChildren(record.content)
	local insertIndex = #ordered + 1

	for index, child in ipairs(ordered) do
		local childCenterY = child.AbsolutePosition.Y + (child.AbsoluteSize.Y * 0.5)
		if point.Y <= childCenterY then
			insertIndex = index
			break
		end
	end

	return insertIndex, ordered
end

function FloatingWindowReorder.apply(params)
	if type(params) ~= "table" then
		return false
	end

	local record = params.record
	local guiObject = params.guiObject
	local requestedInsertIndex = params.requestedInsertIndex
	local getOrderedGuiChildren = params.getOrderedGuiChildren
	local normalizeOrderedGuiLayout = params.normalizeOrderedGuiLayout
	local updateWindowRecordLayout = params.updateWindowRecordLayout
	local resyncElement = params.resyncElement
	local notifyLayoutDirty = params.notifyLayoutDirty

	if not (record and record.content and record.content.Parent) then
		return false
	end
	if type(getOrderedGuiChildren) ~= "function" or type(normalizeOrderedGuiLayout) ~= "function" then
		return false
	end

	local ordered = getOrderedGuiChildren(record.content)
	local currentIndex = nil
	for index, child in ipairs(ordered) do
		if child == guiObject then
			currentIndex = index
			break
		end
	end

	if not currentIndex then
		return false
	end

	local insertIndex = tonumber(requestedInsertIndex)
	if type(insertIndex) == "number" then
		insertIndex = math.floor(insertIndex)
	else
		insertIndex = currentIndex
	end

	table.remove(ordered, currentIndex)
	insertIndex = math.clamp(insertIndex, 1, #ordered + 1)
	table.insert(ordered, insertIndex, guiObject)
	normalizeOrderedGuiLayout(ordered)

	record.nextOrder = (#ordered + 1) * 10

	if type(updateWindowRecordLayout) == "function" then
		updateWindowRecordLayout(record)
	end
	if type(resyncElement) == "function" then
		resyncElement("reorder_detached")
	end
	if type(notifyLayoutDirty) == "function" then
		notifyLayoutDirty("floating_reorder")
	end

	return true
end

return FloatingWindowReorder
]])
put("src/feature/drag/reorder_main_ui.lua", [[local MainUiReorder = {}

local function cloneStateSnapshot(state)
	if type(state) ~= "table" then
		return nil
	end

	return {
		Parent = state.Parent,
		AnchorPoint = state.AnchorPoint,
		Position = state.Position,
		Size = state.Size,
		LayoutOrder = state.LayoutOrder,
		SiblingIndex = state.SiblingIndex,
		PreviousSibling = state.PreviousSibling,
		NextSibling = state.NextSibling
	}
end

function MainUiReorder.apply(params)
	if type(params) ~= "table" then
		return false, nil
	end

	local detached = params.detached == true
	local guiObject = params.guiObject
	local point = params.point
	local requestedInsertIndex = params.requestedInsertIndex
	local currentTabPage = params.currentTabPage
	local parentUsesLayoutOrder = params.parentUsesLayoutOrder
	local getOrderedMainDockChildren = params.getOrderedMainDockChildren
	local calculateMainInsertIndex = params.calculateMainInsertIndex
	local normalizeOrderedGuiLayout = params.normalizeOrderedGuiLayout
	local captureCurrentElementState = params.captureCurrentElementState
	local resyncElement = params.resyncElement
	local rememberedState = params.rememberedState

	if detached then
		return false, rememberedState
	end
	if not (guiObject and guiObject.Parent) then
		return false, rememberedState
	end
	if not (currentTabPage and currentTabPage.Parent) then
		return false, rememberedState
	end
	if currentTabPage ~= guiObject.Parent then
		return false, rememberedState
	end
	if type(parentUsesLayoutOrder) ~= "function" or not parentUsesLayoutOrder(currentTabPage) then
		return false, rememberedState
	end
	if type(getOrderedMainDockChildren) ~= "function"
		or type(calculateMainInsertIndex) ~= "function"
		or type(normalizeOrderedGuiLayout) ~= "function"
	then
		return false, rememberedState
	end

	local ordered = getOrderedMainDockChildren(currentTabPage, guiObject)
	local insertIndex = tonumber(requestedInsertIndex)
	if type(insertIndex) == "number" then
		insertIndex = math.floor(insertIndex)
	else
		insertIndex = nil
	end

	if type(insertIndex) ~= "number" then
		local calculated, calculatedOrdered = calculateMainInsertIndex(currentTabPage, point, guiObject)
		insertIndex = calculated
		if type(calculatedOrdered) == "table" then
			ordered = calculatedOrdered
		end
	end

	if type(insertIndex) ~= "number" then
		return false, rememberedState
	end

	insertIndex = math.clamp(insertIndex, 1, #ordered + 1)
	table.insert(ordered, insertIndex, guiObject)
	normalizeOrderedGuiLayout(ordered)

	local nextRememberedState = rememberedState
	if type(captureCurrentElementState) == "function" then
		nextRememberedState = cloneStateSnapshot(captureCurrentElementState())
	end

	if type(resyncElement) == "function" then
		resyncElement("reorder_main")
	end

	return true, nextRememberedState
end

return MainUiReorder
]])
put("src/feature/drag/window.lua", [[local DragWindow = {}

function DragWindow.create(ctx)
	local detachedScreenGui = nil
	local detachedLayer = nil
	local detachedCleanupBound = false
	local detachedWindowsRegistry = {}

	local function getInputPosition(input)
		if type(ctx.getInputPosition) == "function" then
			return ctx.getInputPosition(input)
		end
		if input and input.Position then
			return Vector2.new(input.Position.X, input.Position.Y)
		end
		return ctx.UserInputService:GetMouseLocation()
	end

	local function registerDetachedWindow(record)
		if not record then
			return
		end
		table.insert(detachedWindowsRegistry, record)
	end

	local function unregisterDetachedWindow(record)
		for i = #detachedWindowsRegistry, 1, -1 do
			if detachedWindowsRegistry[i] == record then
				table.remove(detachedWindowsRegistry, i)
				break
			end
		end
	end

	local function isPointNearFrame(point, frame, padding)
		if not (point and frame and frame.Parent) then
			return false
		end

		local pad = padding or 0
		local framePosition = frame.AbsolutePosition
		local frameSize = frame.AbsoluteSize
		local minX = framePosition.X - pad
		local minY = framePosition.Y - pad
		local maxX = framePosition.X + frameSize.X + pad
		local maxY = framePosition.Y + frameSize.Y + pad
		return point.X >= minX and point.X <= maxX and point.Y >= minY and point.Y <= maxY
	end

	local function findMergeTargetWindow(point, excludeRecord)
		for _, record in ipairs(detachedWindowsRegistry) do
			if record ~= excludeRecord and record.frame and record.frame.Parent and isPointNearFrame(point, record.frame, ctx.mergeDetectPadding) then
				return record
			end
		end
		return nil
	end

	local function ensureDetachedLayer()
		if detachedLayer and detachedLayer.Parent then
			return detachedLayer
		end

		if detachedScreenGui and not detachedScreenGui.Parent then
			detachedScreenGui = nil
			detachedLayer = nil
		end

		if not detachedScreenGui then
			local existing = ctx.Rayfield.Parent and ctx.Rayfield.Parent:FindFirstChild("self.Rayfield-DetachedWindows")
			if existing and existing:IsA("ScreenGui") then
				detachedScreenGui = existing
			else
				detachedScreenGui = Instance.new("ScreenGui")
				detachedScreenGui.Name = "self.Rayfield-DetachedWindows"
				detachedScreenGui.ResetOnSpawn = false
				detachedScreenGui.IgnoreGuiInset = ctx.Rayfield.IgnoreGuiInset
				detachedScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
				detachedScreenGui.DisplayOrder = math.max((ctx.Rayfield.DisplayOrder or 100) + 1, 101)
				detachedScreenGui.Parent = ctx.Rayfield.Parent
			end
		end

		detachedLayer = detachedScreenGui:FindFirstChild("WindowLayer")
		if not detachedLayer then
			detachedLayer = Instance.new("Frame")
			detachedLayer.Name = "WindowLayer"
			detachedLayer.BackgroundTransparency = 1
			detachedLayer.BorderSizePixel = 0
			detachedLayer.Size = UDim2.fromScale(1, 1)
			detachedLayer.Parent = detachedScreenGui
		end

		if not detachedCleanupBound then
			detachedCleanupBound = true
			ctx.Rayfield.Destroying:Connect(function()
				if detachedScreenGui then
					detachedScreenGui:Destroy()
					detachedScreenGui = nil
					detachedLayer = nil
				end
				table.clear(detachedWindowsRegistry)
				if type(ctx.onDestroyInput) == "function" then
					ctx.onDestroyInput()
				end
			end)
		end

		return detachedLayer
	end

	local function prewarmDetachedLayer()
		task.defer(function()
			if ctx.rayfieldDestroyed and ctx.rayfieldDestroyed() then
				return
			end
			pcall(ensureDetachedLayer)
		end)
	end

	local function clampDetachedPosition(desiredPosition, windowSize)
		local layer = ensureDetachedLayer()
		local layerSize = layer.AbsoluteSize
		local maxX = math.max(layerSize.X - windowSize.X, 0)
		local maxY = math.max(layerSize.Y - windowSize.Y, 0)
		return Vector2.new(
			math.clamp(desiredPosition.X, 0, maxX),
			math.clamp(desiredPosition.Y, 0, maxY)
		)
	end

	local function isOutsideMain(point)
		local mainPosition = ctx.Main.AbsolutePosition
		local mainSize = ctx.Main.AbsoluteSize
		return point.X < mainPosition.X
			or point.Y < mainPosition.Y
			or point.X > (mainPosition.X + mainSize.X)
			or point.Y > (mainPosition.Y + mainSize.Y)
	end

	local function isInsideMain(point)
		return not isOutsideMain(point)
	end

	local function makeFloatingDraggable(frame, dragHandle, onDragEnd)
		local dragging = false
		local dragInput = nil
		local dragStartPointer = nil
		local dragStartFramePosition = nil
		local targetPosition = Vector2.new(frame.Position.X.Offset, frame.Position.Y.Offset)
		local connections = {}
		local dragId = ctx.HttpService and ctx.HttpService:GenerateGUID(false) or tostring(math.random())

		dragHandle.Active = true

		table.insert(connections, dragHandle.InputBegan:Connect(function(input)
			local inputType = input.UserInputType
			if inputType ~= Enum.UserInputType.MouseButton1 and inputType ~= Enum.UserInputType.Touch then
				return
			end

			dragging = true
			dragInput = input
			dragStartPointer = getInputPosition(input)
			dragStartFramePosition = targetPosition
		end))

		ctx.registerSharedInput(dragId, function(input)
			if not dragging or not dragInput then
				return
			end

			local matchesTouch = input == dragInput
			local matchesMouse = dragInput.UserInputType == Enum.UserInputType.MouseButton1 and input.UserInputType == Enum.UserInputType.MouseMovement
			if not matchesTouch and not matchesMouse then
				return
			end

			local currentPointer = getInputPosition(input)
			local delta = currentPointer - dragStartPointer
			local desired = dragStartFramePosition + delta
			targetPosition = clampDetachedPosition(desired, frame.AbsoluteSize)
		end, function(input)
			if not dragging or not dragInput then
				return
			end

			local mouseEnded = dragInput.UserInputType == Enum.UserInputType.MouseButton1 and input.UserInputType == Enum.UserInputType.MouseButton1
			if input == dragInput or mouseEnded then
				local releasePoint = getInputPosition(input)
				dragging = false
				dragInput = nil
				if typeof(onDragEnd) == "function" then
					task.defer(onDragEnd, releasePoint, frame)
				end
			end
		end)

		table.insert(connections, ctx.RunService.RenderStepped:Connect(function(deltaTime)
			if not dragging then
				targetPosition = Vector2.new(frame.Position.X.Offset, frame.Position.Y.Offset)
				return
			end

			local current = Vector2.new(frame.Position.X.Offset, frame.Position.Y.Offset)
			local alpha = math.clamp(deltaTime * ((ctx.followSpeed or 0.28) * 60), 0, 1)
			local nextPosition = current:Lerp(targetPosition, alpha)
			frame.Position = UDim2.fromOffset(math.floor(nextPosition.X + 0.5), math.floor(nextPosition.Y + 0.5))
		end))

		return function()
			ctx.unregisterSharedInput(dragId)
			for _, connection in ipairs(connections) do
				if connection then
					connection:Disconnect()
				end
			end
			table.clear(connections)
		end
	end

	return {
		registerDetachedWindow = registerDetachedWindow,
		unregisterDetachedWindow = unregisterDetachedWindow,
		isPointNearFrame = isPointNearFrame,
		findMergeTargetWindow = findMergeTargetWindow,
		ensureDetachedLayer = ensureDetachedLayer,
		prewarmDetachedLayer = prewarmDetachedLayer,
		clampDetachedPosition = clampDetachedPosition,
		isOutsideMain = isOutsideMain,
		isInsideMain = isInsideMain,
		makeFloatingDraggable = makeFloatingDraggable
	}
end

return DragWindow
]])
put("src/feature/enhanced/advanced.lua", [=[--[[
	Rayfield Advanced Features - Complete Module

	Tnh nng:
	 Animation API - Animate bt k property no
	 Drag & Drop - Ko th elements (gi 3 giy)
	 Detachable Windows - Tch element thnh ca s ring
	 State Persistence - Lu trng thi elements
	 Performance Monitor - Theo di hiu sut
	 Default Templates - Main & Settings tabs mc nh

]]

local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")

local function buildFallbackAnimateFacade()
	local engine = (_G and _G.__RayfieldSharedAnimationEngine) or nil
	if not engine then
		local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
		local okEngineLib, engineLib = pcall(function()
			if _G and _G.__RayfieldApiClient then
				return _G.__RayfieldApiClient.fetchAndExecute(root .. "src/core/animation/engine.lua")
			end
			return nil
		end)
		if okEngineLib and engineLib and type(engineLib.new) == "function" then
			local okEngine, createdEngine = pcall(function()
				return engineLib.new({
					TweenService = TweenService,
					RunService = RunService,
					mode = "raw"
				})
			end)
			if okEngine then
				engine = createdEngine
			end
		end
	end

	if not engine then
		return {
			Create = function(_, guiObject, tweenInfo, goals)
				local creator = TweenService["Create"]
				if type(creator) == "function" then
					return creator(TweenService, guiObject, tweenInfo, goals)
				end
				return nil
			end,
			UI = function()
				return nil
			end,
			Text = function()
				return nil
			end,
			GetEngine = function()
				return nil
			end
		}
	end

	return {
		Create = function(_, guiObject, tweenInfo, goals)
			return engine:Create(guiObject, tweenInfo, goals)
		end,
		UI = function()
			return nil
		end,
		Text = function()
			return nil
		end,
		GetEngine = function()
			return engine
		end
	}
end

local Animation = (_G and _G.__RayfieldSharedAnimateFacade) or buildFallbackAnimateFacade()

local RayfieldAdvanced = {Version = "1.1.0"}

-- ============================================
-- 1. SHARED ANIMATION LAYER
-- ============================================
-- Legacy standalone AnimationAPI bridge removed.
-- Enhanced module now relies on shared `Rayfield.Animate` runtime layer.

-- ============================================
-- 2. STATE PERSISTENCE
-- ============================================

local StatePersistence = {}
StatePersistence.__index = StatePersistence

function StatePersistence.new(configFolder)
	local self = setmetatable({}, StatePersistence)
	self.configFolder = configFolder or "RayfieldAdvanced"
	self.stateFile = self.configFolder .. "/element_states.json"
	self.states = {}

	if makefolder and not isfolder(self.configFolder) then
		pcall(makefolder, self.configFolder)
	end

	self:Load()
	return self
end

function StatePersistence:SaveState(elementId, state)
	self.states[elementId] = {
		visible = state.visible,
		position = state.position,
		size = state.size,
		detached = state.detached or false,
		timestamp = tick()
	}
	self:Save()
end

function StatePersistence:GetState(elementId)
	return self.states[elementId]
end

function StatePersistence:Save()
	if not writefile then return end
	local success, encoded = pcall(function()
		return HttpService:JSONEncode(self.states)
	end)
	if success then
		pcall(writefile, self.stateFile, encoded)
	end
end

function StatePersistence:Load()
	if not readfile or not isfile then return end
	local success, content = pcall(readfile, self.stateFile)
	if not success then return end

	local decoded
	success, decoded = pcall(function()
		return HttpService:JSONDecode(content)
	end)
	if success and decoded then
		self.states = decoded
	end
end

-- Export modules
RayfieldAdvanced.StatePersistence = StatePersistence




-- ============================================
-- 3. PERFORMANCE MONITOR
-- ============================================

local PerformanceMonitor = {}
PerformanceMonitor.__index = PerformanceMonitor

function PerformanceMonitor.new()
	local self = setmetatable({}, PerformanceMonitor)

	self.elementCount = 0
	self.detachedWindowCount = 0
	self.activeAnimations = 0
	self.memoryUsage = 0
	self.fps = 0
	self.startTime = tick()

	self:StartMonitoring()
	return self
end

function PerformanceMonitor:StartMonitoring()
	local lastUpdate = tick()
	local frames = 0

	RunService.RenderStepped:Connect(function()
		frames = frames + 1
		if tick() - lastUpdate >= 1 then
			self.fps = frames
			frames = 0
			lastUpdate = tick()
		end
	end)

	task.spawn(function()
		while true do
			task.wait(5)
			local stats = game:GetService("Stats")
			self.memoryUsage = stats:GetTotalMemoryUsageMb()
		end
	end)
end

function PerformanceMonitor:GetStats()
	return {
		elementCount = self.elementCount,
		detachedWindows = self.detachedWindowCount,
		activeAnimations = self.activeAnimations,
		memoryUsage = self.memoryUsage,
		fps = self.fps,
		uptime = tick() - self.startTime
	}
end

function PerformanceMonitor:PrintStats()
	local stats = self:GetStats()
	print("")
	print(" Rayfield Performance Stats")
	print("")
	print(string.format("Elements: %d", stats.elementCount))
	print(string.format("Detached Windows: %d", stats.detachedWindows))
	print(string.format("Active Animations: %d", stats.activeAnimations))
	print(string.format("Memory: %.2f MB", stats.memoryUsage))
	print(string.format("FPS: %d", stats.fps))
	print(string.format("Uptime: %.1f seconds", stats.uptime))
	print("")
end

-- ============================================
-- 4. DRAG & DROP MANAGER
-- ============================================

local DragDropManager = {}
DragDropManager.__index = DragDropManager

function DragDropManager.new(performanceMonitor)
	local self = setmetatable({}, DragDropManager)

	self.performanceMonitor = performanceMonitor
	self.draggingElement = nil
	self.isDragging = false
	self.dragThreshold = 3
	self.detachedWindows = {}

	return self
end

function DragDropManager:EnableDrag(element, guiObject)
	local holding = false
	local holdIndicator = nil
	local holdThemeConnection = nil

	local function getHoldIndicatorColor()
		local fallback = Color3.fromRGB(100, 200, 255)
		if not guiObject then
			return fallback
		end

		local cursor = guiObject
		while cursor do
			local themeValues = cursor:FindFirstChild("ThemeValues")
			if themeValues and themeValues:IsA("Folder") then
				local sliderProgress = themeValues:FindFirstChild("SliderProgress")
				if sliderProgress and sliderProgress:IsA("Color3Value") then
					return sliderProgress.Value
				end
			end
			cursor = cursor.Parent
		end

		return fallback
	end

	local function cleanupHoldThemeSync()
		if holdThemeConnection then
			holdThemeConnection:Disconnect()
			holdThemeConnection = nil
		end
	end

	local function bindHoldThemeSync()
		cleanupHoldThemeSync()
		if not guiObject then
			return
		end

		local cursor = guiObject
		while cursor do
			local themeValues = cursor:FindFirstChild("ThemeValues")
			if themeValues and themeValues:IsA("Folder") then
				local sliderProgress = themeValues:FindFirstChild("SliderProgress")
				if sliderProgress and sliderProgress:IsA("Color3Value") then
					holdThemeConnection = sliderProgress:GetPropertyChangedSignal("Value"):Connect(function()
						if holdIndicator and holdIndicator.Parent then
							holdIndicator.BackgroundColor3 = sliderProgress.Value
						end
					end)
					break
				end
			end
			cursor = cursor.Parent
		end
	end

	guiObject.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or
		   input.UserInputType == Enum.UserInputType.Touch then
			holding = true

			holdIndicator = Instance.new("Frame")
			holdIndicator.Name = "HoldIndicator"
			holdIndicator.Size = UDim2.new(0, 0, 0, 3)
			holdIndicator.Position = UDim2.new(0, 0, 1, -3)
			holdIndicator.BackgroundColor3 = getHoldIndicatorColor()
			holdIndicator.BorderSizePixel = 0
			holdIndicator.ZIndex = 1000
			holdIndicator.Parent = guiObject
			bindHoldThemeSync()

			local progressTween = Animation:Create(
				holdIndicator,
				TweenInfo.new(self.dragThreshold, Enum.EasingStyle.Linear),
				{Size = UDim2.new(1, 0, 0, 3)}
			)
			progressTween:Play()

			local holdStartTime = tick()
			task.spawn(function()
				while holding and tick() - holdStartTime < self.dragThreshold do
					task.wait(0.1)
				end

				if holding and tick() - holdStartTime >= self.dragThreshold then
					self:StartDragging(element, guiObject)
				end

				if holdIndicator then
					Animation:Create(holdIndicator, TweenInfo.new(0.2, Enum.EasingStyle.Exponential),
						{BackgroundTransparency = 1}):Play()
					task.wait(0.2)
					if holdIndicator then
						holdIndicator:Destroy()
						holdIndicator = nil
					end
					cleanupHoldThemeSync()
				end
			end)
		end
	end)

	guiObject.InputEnded:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or
		   input.UserInputType == Enum.UserInputType.Touch then
			holding = false
			cleanupHoldThemeSync()
		end
	end)
end

function DragDropManager:StartDragging(element, guiObject)
	self.isDragging = true
	self.draggingElement = {
		element = element,
		guiObject = guiObject,
		originalParent = guiObject.Parent,
		originalPosition = guiObject.Position,
		originalSize = guiObject.Size,
		originalTransparency = guiObject.BackgroundTransparency
	}

	guiObject.BackgroundTransparency = 0.5
	guiObject.ZIndex = 1000

	print(" Drag mode! Ko ra ngoi  tch ca s")
	self:TrackDragMovement(guiObject)
end

return RayfieldAdvanced
]=])
put("src/feature/enhanced/create-enhanced-rayfield-fn.lua", [[local client = _G and _G.__RayfieldApiClient
if not client then
	error("Rayfield ApiClient is not initialized")
end

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
local Enhanced = client.fetchAndExecute(root .. "src/feature/enhanced/create-enhanced-rayfield.lua")
return Enhanced.createEnhancedRayfield]])
put("src/feature/enhanced/create-enhanced-rayfield.lua", [=[--[[

	Rayfield Interface Suite - Enhanced Version 2.0
	
	Tnh nng mi:
	 Memory Leak Detection t ng
	 Performance Profiler
	 Hybrid Mode (fast + protected callbacks)
	 Priority Queue cho Remote Calls
	 Exception System vi auto-disable
	 Audit Log cho security
	 API Reference y 
	 Migration helpers

	Tc gi: Enhanced by Community
	Version: 2.0.0

]]

local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")

-- ============================================
-- PHN 1: MEMORY LEAK DETECTOR
-- ============================================

local MemoryLeakDetector = {}
MemoryLeakDetector.__index = MemoryLeakDetector

local function resolveCompatibility()
	if type(_G) == "table" and type(_G.__RayfieldCompatibility) == "table" then
		return _G.__RayfieldCompatibility
	end
	return nil
end

local function getService(name)
	local compatibility = resolveCompatibility()
	if compatibility and type(compatibility.getService) == "function" then
		local service = compatibility.getService(name)
		if service then
			return service
		end
	end
	return game:GetService(name)
end

local function safeGetChildren(instance)
	local ok, children = pcall(function()
		return instance:GetChildren()
	end)
	if ok and type(children) == "table" then
		return children
	end
	return {}
end

local function safeGetDescendants(instance)
	local ok, descendants = pcall(function()
		return instance:GetDescendants()
	end)
	if ok and type(descendants) == "table" then
		return descendants
	end
	return {}
end

local UI_HEAVY_CLASSES = {
	Frame = true,
	TextLabel = true,
	ImageLabel = true,
	UIStroke = true,
	UICorner = true,
	ScrollingFrame = true,
	TextButton = true,
	ImageButton = true,
}

local function clamp(value, minValue, maxValue)
	value = tonumber(value) or 0
	if value < minValue then
		return minValue
	end
	if value > maxValue then
		return maxValue
	end
	return value
end

function MemoryLeakDetector.new()
	local self = setmetatable({}, MemoryLeakDetector)
	
	-- Tracking
	self.snapshots = {}
	self.maxSnapshots = 10
	self.checkInterval = 120 -- seconds (increased from 30 for performance)
	self.leakThreshold = 10 * 1024 * 1024 -- 10MB growth
	self.suspectedLeaks = {}
	self.enabled = true -- Toggle to disable in production
	
	-- Object tracking
	self.objectCounts = {}
	self.lastObjectCounts = {}
	
	-- Scan behavior
	self.scanMode = "ui" -- "ui", "mixed", "game"
	self.scanTargets = {"Workspace", "Players"} -- legacy targets for "game" mode
	self.customScanRoots = nil
	self.maxScanDescendants = 50000
	self.scanBudgetWarning = 20000
	self.lastScanMeta = nil
	
	-- Callbacks
	self.onLeakDetected = nil
	self.onUnknownCause = nil
	self.running = false
	self.monitorThread = nil

	self.runtimeDiagnosticsProvider = nil
	self.attributionPolicy = {
		mode = "weighted",
		triggerScore = 70,
		confirmCycles = 2,
		unknownNotifyOncePerSession = true
	}
	self.attributionState = {
		lastScore = 0,
		lastClassification = "unknown",
		confirmStreak = 0,
		lastEvidence = {},
		unknownNotified = false
	}
	
	self:startMonitoring()
	
	return self
end

function MemoryLeakDetector:setRuntimeDiagnosticsProvider(provider)
	if provider ~= nil and type(provider) ~= "function" then
		warn("[Memory Leak Detector] setRuntimeDiagnosticsProvider expects function or nil")
		return false
	end
	self.runtimeDiagnosticsProvider = provider
	return true
end

function MemoryLeakDetector:setAttributionPolicy(policy)
	if type(policy) ~= "table" then
		warn("[Memory Leak Detector] setAttributionPolicy expects table")
		return false
	end

	local updated = {
		mode = tostring(policy.mode or self.attributionPolicy.mode):lower(),
		triggerScore = tonumber(policy.triggerScore) or self.attributionPolicy.triggerScore,
		confirmCycles = tonumber(policy.confirmCycles) or self.attributionPolicy.confirmCycles,
		unknownNotifyOncePerSession = policy.unknownNotifyOncePerSession
	}

	if updated.mode ~= "weighted" then
		warn("[Memory Leak Detector] Unsupported attribution mode: " .. tostring(updated.mode))
		return false
	end

	if updated.unknownNotifyOncePerSession == nil then
		updated.unknownNotifyOncePerSession = self.attributionPolicy.unknownNotifyOncePerSession
	end

	self.attributionPolicy = {
		mode = updated.mode,
		triggerScore = clamp(updated.triggerScore, 1, 100),
		confirmCycles = math.max(1, math.floor(updated.confirmCycles)),
		unknownNotifyOncePerSession = updated.unknownNotifyOncePerSession == true
	}

	return true
end

function MemoryLeakDetector:getAttributionReport()
	return {
		lastScore = self.attributionState.lastScore,
		lastClassification = self.attributionState.lastClassification,
		confirmStreak = self.attributionState.confirmStreak,
		lastEvidence = self.attributionState.lastEvidence
	}
end

function MemoryLeakDetector:_collectRuntimeDiagnostics()
	local diagnostics = {
		activeTweens = 0,
		activeTextHandles = 0,
		themeBindings = {
			objectsBound = 0,
			propertiesBound = 0
		},
		gcTrackedObjects = 0,
		rayfieldVisible = false,
		rayfieldMinimized = false,
		rayfieldDestroyed = false
	}

	if type(self.runtimeDiagnosticsProvider) == "function" then
		local ok, provided = pcall(self.runtimeDiagnosticsProvider)
		if ok and type(provided) == "table" then
			diagnostics.activeTweens = tonumber(provided.activeTweens) or diagnostics.activeTweens
			diagnostics.activeTextHandles = tonumber(provided.activeTextHandles) or diagnostics.activeTextHandles
			diagnostics.gcTrackedObjects = tonumber(provided.gcTrackedObjects) or diagnostics.gcTrackedObjects
			diagnostics.rayfieldVisible = provided.rayfieldVisible == true
			diagnostics.rayfieldMinimized = provided.rayfieldMinimized == true
			diagnostics.rayfieldDestroyed = provided.rayfieldDestroyed == true
			if type(provided.themeBindings) == "table" then
				diagnostics.themeBindings = {
					objectsBound = tonumber(provided.themeBindings.objectsBound) or 0,
					propertiesBound = tonumber(provided.themeBindings.propertiesBound) or 0
				}
			end
		end
	end

	return diagnostics
end

function MemoryLeakDetector:setScanMode(mode)
	local normalized = tostring(mode or ""):lower()
	if normalized ~= "ui" and normalized ~= "mixed" and normalized ~= "game" then
		warn("[Memory Leak Detector] Invalid scan mode: " .. tostring(mode) .. " (use 'ui', 'mixed', or 'game')")
		return false
	end
	self.scanMode = normalized
	return true
end

function MemoryLeakDetector:setScanRoots(roots)
	if roots == nil then
		self.customScanRoots = nil
		return true
	end
	if type(roots) ~= "table" then
		warn("[Memory Leak Detector] setScanRoots expects table or nil")
		return false
	end

	local sanitized = {}
	local seen = {}
	for _, root in ipairs(roots) do
		if typeof(root) == "Instance" and not seen[root] then
			seen[root] = true
			table.insert(sanitized, root)
		end
	end
	self.customScanRoots = sanitized
	return true
end

function MemoryLeakDetector:_resolveUiRoots()
	if type(self.customScanRoots) == "table" and #self.customScanRoots > 0 then
		return self.customScanRoots
	end

	local roots = {}
	local seen = {}
	local function addRoot(root)
		if typeof(root) ~= "Instance" then
			return
		end
		if seen[root] then
			return
		end
		seen[root] = true
		table.insert(roots, root)
	end

	local compatibility = resolveCompatibility()
	local coreGui = getService("CoreGui")
	local players = getService("Players")
	local localPlayer = players and players.LocalPlayer or nil

	if type(_G) == "table" then
		addRoot(_G.Rayfield)
		local rayfieldUi = _G.RayfieldUI
		if type(rayfieldUi) == "table" and typeof(rayfieldUi.ScreenGui) == "Instance" then
			addRoot(rayfieldUi.ScreenGui)
		end
	end

	if compatibility and type(compatibility.tryGetHui) == "function" then
		local hui = compatibility.tryGetHui()
		if hui then
			for _, child in ipairs(safeGetChildren(hui)) do
				if child.Name == "Rayfield" or child.Name == "Key" then
					addRoot(child)
				end
			end
		end
	end

	if coreGui then
		for _, child in ipairs(safeGetChildren(coreGui)) do
			if child.Name == "Rayfield" or child.Name == "Key" then
				addRoot(child)
			end
		end
	end

	local playerGui = nil
	if localPlayer then
		playerGui = localPlayer:FindFirstChildOfClass("PlayerGui")
	end
	if playerGui then
		for _, child in ipairs(safeGetChildren(playerGui)) do
			if child.Name == "Rayfield" or child.Name == "Key" then
				addRoot(child)
			end
		end
	end

	return roots
end

function MemoryLeakDetector:_resolveGameRoots()
	local roots = {}
	for _, targetName in ipairs(self.scanTargets) do
		local target = game:FindFirstChild(targetName)
		if target then
			table.insert(roots, target)
		end
	end
	return roots
end

function MemoryLeakDetector:_resolveScanRoots()
	if self.scanMode == "game" then
		return self:_resolveGameRoots()
	end
	return self:_resolveUiRoots()
end

function MemoryLeakDetector:_scanRoots(collectBreakdown)
	local objectBreakdown = collectBreakdown and {} or nil
	local totalCount = 0
	local totalDescendantsVisited = 0
	local truncated = false
	local roots = self:_resolveScanRoots()

	for _, root in ipairs(roots) do
		local descendants = safeGetDescendants(root)
		totalDescendantsVisited += #descendants
		local allowed = #descendants
		local remainingBudget = self.maxScanDescendants - totalCount
		if remainingBudget <= 0 then
			truncated = true
			break
		end
		if allowed > remainingBudget then
			allowed = remainingBudget
			truncated = true
		end

		for index = 1, allowed do
			local obj = descendants[index]
			totalCount += 1
			if objectBreakdown then
				local className = obj.ClassName
				objectBreakdown[className] = (objectBreakdown[className] or 0) + 1
			end
		end
	end

	if totalDescendantsVisited > self.scanBudgetWarning then
		warn(string.format(
			"[Memory Leak Detector] Scan budget warning: visited=%d mode=%s roots=%d",
			totalDescendantsVisited,
			tostring(self.scanMode),
			#roots
		))
	end

	self.lastScanMeta = {
		mode = self.scanMode,
		rootCount = #roots,
		visited = totalDescendantsVisited,
		counted = totalCount,
		truncated = truncated
	}

	return totalCount, objectBreakdown
end

function MemoryLeakDetector:getTargetedInstanceCount()
	local count = self:_scanRoots(false)
	return count
end

function MemoryLeakDetector:_getMixedLightweightStats()
	local workspace = getService("Workspace")
	local players = getService("Players")
	local stats = {
		workspaceChildren = workspace and #safeGetChildren(workspace) or 0,
		playersChildren = players and #safeGetChildren(players) or 0
	}
	return stats
end

function MemoryLeakDetector:takeSnapshot()
	local statsService = getService("Stats")
	local instanceCount, objectBreakdown = self:_scanRoots(true)
	local runtimeDiagnostics = self:_collectRuntimeDiagnostics()
	local snapshot = {
		timestamp = tick(),
		totalMemory = statsService and statsService:GetTotalMemoryUsageMb() or 0,
		instanceCount = instanceCount,
		objectBreakdown = objectBreakdown or {},
		scanMode = self.scanMode,
		runtimeDiagnostics = runtimeDiagnostics
	}
	
	if self.scanMode == "mixed" then
		snapshot.mixedStats = self:_getMixedLightweightStats()
	end
	if self.lastScanMeta then
		snapshot.scanMeta = self.lastScanMeta
	end
	
	table.insert(self.snapshots, snapshot)
	
	-- Keep only recent snapshots
	if #self.snapshots > self.maxSnapshots then
		table.remove(self.snapshots, 1)
	end
	
	return snapshot
end

function MemoryLeakDetector:_evaluateAttribution()
	local snapshots = self.snapshots
	local newest = snapshots[#snapshots]
	local previous = snapshots[#snapshots - 1]
	if not newest or not previous then
		self.attributionState.lastScore = 0
		self.attributionState.lastClassification = "unknown"
		self.attributionState.confirmStreak = 0
		self.attributionState.lastEvidence = {
			reason = "insufficient_snapshots"
		}
		return {
			score = 0,
			classification = "unknown",
			confirmed = false,
			evidence = self.attributionState.lastEvidence
		}
	end

	local latestDiag = newest.runtimeDiagnostics or {}
	local prevDiag = previous.runtimeDiagnostics or {}
	local latestTheme = latestDiag.themeBindings or {}
	local prevTheme = prevDiag.themeBindings or {}

	local uiInstanceGrowth = math.max(0, (newest.instanceCount or 0) - (previous.instanceCount or 0))
	local uiClassGrowth = 0
	for className in pairs(UI_HEAVY_CLASSES) do
		local newestCount = tonumber(newest.objectBreakdown and newest.objectBreakdown[className]) or 0
		local previousCount = tonumber(previous.objectBreakdown and previous.objectBreakdown[className]) or 0
		uiClassGrowth += math.max(0, newestCount - previousCount)
	end

	local tweenGrowth = math.max(0, (tonumber(latestDiag.activeTweens) or 0) - (tonumber(prevDiag.activeTweens) or 0))
	local textHandleGrowth = math.max(0, (tonumber(latestDiag.activeTextHandles) or 0) - (tonumber(prevDiag.activeTextHandles) or 0))
	local themeBindingGrowth = math.max(0, (tonumber(latestTheme.propertiesBound) or 0) - (tonumber(prevTheme.propertiesBound) or 0))
	local gcTrackedGrowth = math.max(0, (tonumber(latestDiag.gcTrackedObjects) or 0) - (tonumber(prevDiag.gcTrackedObjects) or 0))

	local subsystemGrowth = tweenGrowth + textHandleGrowth + themeBindingGrowth + gcTrackedGrowth
	local rayfieldGuiAlive = false
	if type(_G) == "table" and typeof(_G.Rayfield) == "Instance" then
		local ok, parent = pcall(function()
			return _G.Rayfield.Parent
		end)
		rayfieldGuiAlive = ok and parent ~= nil
	end

	local scoreS1 = clamp((uiInstanceGrowth / 300) * 40, 0, 40)
	local scoreS2 = clamp((uiClassGrowth / 160) * 20, 0, 20)
	local scoreS3 = clamp((subsystemGrowth / 60) * 30, 0, 30)
	local scoreS4 = rayfieldGuiAlive and 10 or 0
	local totalScore = clamp(scoreS1 + scoreS2 + scoreS3 + scoreS4, 0, 100)

	local classification = totalScore >= self.attributionPolicy.triggerScore and "rayfield_ui" or "unknown"
	if classification == "rayfield_ui" then
		self.attributionState.confirmStreak = self.attributionState.confirmStreak + 1
	else
		self.attributionState.confirmStreak = 0
	end

	local evidence = {
		uiInstanceGrowth = uiInstanceGrowth,
		uiClassGrowth = uiClassGrowth,
		subsystemGrowth = subsystemGrowth,
		tweenGrowth = tweenGrowth,
		textHandleGrowth = textHandleGrowth,
		themeBindingGrowth = themeBindingGrowth,
		gcTrackedGrowth = gcTrackedGrowth,
		rayfieldGuiAlive = rayfieldGuiAlive,
		scoreBreakdown = {
			S1 = scoreS1,
			S2 = scoreS2,
			S3 = scoreS3,
			S4 = scoreS4
		}
	}

	self.attributionState.lastScore = totalScore
	self.attributionState.lastClassification = classification
	self.attributionState.lastEvidence = evidence

	return {
		score = totalScore,
		classification = classification,
		confirmed = classification == "rayfield_ui" and self.attributionState.confirmStreak >= self.attributionPolicy.confirmCycles,
		evidence = evidence
	}
end

function MemoryLeakDetector:_shouldNotifyUnknownCause()
	if not self.attributionPolicy.unknownNotifyOncePerSession then
		return true
	end
	if self.attributionState.unknownNotified then
		return false
	end
	self.attributionState.unknownNotified = true
	return true
end

function MemoryLeakDetector:detectLeaks()
	if #self.snapshots < 3 then
		return nil -- Need at least 3 snapshots
	end
	
	local leaks = {}
	local oldest = self.snapshots[1]
	local newest = self.snapshots[#self.snapshots]
	
	-- Check total memory growth
	local memoryGrowth = (newest.totalMemory - oldest.totalMemory) * 1024 * 1024
	local timeSpan = newest.timestamp - oldest.timestamp
	local growthRate = memoryGrowth / timeSpan -- bytes per second
	
	if memoryGrowth > self.leakThreshold then
		table.insert(leaks, {
			type = "memory",
			severity = "high",
			growth = memoryGrowth,
			rate = growthRate,
			message = string.format(
				"Memory leak detected: %.2f MB growth in %.1f seconds (%.2f KB/s)",
				memoryGrowth / 1024 / 1024,
				timeSpan,
				growthRate / 1024
			)
		})
	end
	
	-- Check object count growth
	for className, newCount in pairs(newest.objectBreakdown) do
		local oldCount = oldest.objectBreakdown[className] or 0
		local growth = newCount - oldCount
		
		if growth > 100 then -- More than 100 new objects
			table.insert(leaks, {
				type = "object",
				severity = "medium",
				className = className,
				growth = growth,
				message = string.format(
					"Object leak detected: %s increased by %d instances",
					className,
					growth
				)
			})
		end
	end
	
	return #leaks > 0 and leaks or nil
end

function MemoryLeakDetector:setEnabled(enabled)
	self.enabled = enabled
	if enabled then
		print("[Memory Leak Detector] Enabled")
	else
		print("[Memory Leak Detector] Disabled")
	end
end

function MemoryLeakDetector:startMonitoring()
	if self.monitorThread then
		return
	end
	self.running = true
	self.monitorThread = task.spawn(function()
		while self.running do
			task.wait(self.checkInterval)
			if not self.running then
				break
			end
			
			if not self.enabled then continue end
			
			-- Take snapshot
			self:takeSnapshot()
			local attribution = self:_evaluateAttribution()
			
			-- Detect leaks
			local leaks = self:detectLeaks()
			
			if leaks then
				local unknownNotificationSent = false
				for _, leak in ipairs(leaks) do
					leak.sourceClassification = attribution.classification
					leak.attributionScore = attribution.score
					leak.attributionEvidence = attribution.evidence
					leak.attributionConfirmed = attribution.confirmed
					
					-- Track suspected leaks
					table.insert(self.suspectedLeaks, {
						leak = leak,
						timestamp = tick()
					})
					
					if leak.sourceClassification == "rayfield_ui" then
						warn("[Memory Leak Detector] " .. leak.message)
						if self.onLeakDetected then
							pcall(self.onLeakDetected, leak)
						end
					elseif not unknownNotificationSent and self:_shouldNotifyUnknownCause() then
						unknownNotificationSent = true
						if self.onUnknownCause then
							pcall(self.onUnknownCause, {
								message = leak.message,
								attributionScore = attribution.score,
								attributionEvidence = attribution.evidence
							})
						end
					end
				end
			end
		end
		self.monitorThread = nil
	end)
end

function MemoryLeakDetector:stopMonitoring()
	self.running = false
	if self.monitorThread then
		pcall(task.cancel, self.monitorThread)
		self.monitorThread = nil
	end
end

function MemoryLeakDetector:destroy()
	self:setEnabled(false)
	self:stopMonitoring()
	self.onLeakDetected = nil
	self.onUnknownCause = nil
end

function MemoryLeakDetector:getReport()
	local report = {
		snapshots = #self.snapshots,
		suspectedLeaks = #self.suspectedLeaks,
		currentMemory = 0,
		details = {},
		scanMode = self.scanMode,
		attribution = self:getAttributionReport()
	}
	
	if #self.snapshots > 0 then
		local latest = self.snapshots[#self.snapshots]
		report.currentMemory = latest.totalMemory
		report.instanceCount = latest.instanceCount
		report.scanMeta = latest.scanMeta
		if latest.mixedStats then
			report.mixedStats = latest.mixedStats
		end
		
		-- Top 10 object types
		local sorted = {}
		for className, count in pairs(latest.objectBreakdown) do
			table.insert(sorted, {className = className, count = count})
		end
		table.sort(sorted, function(a, b) return a.count > b.count end)
		
		for i = 1, math.min(10, #sorted) do
			table.insert(report.details, sorted[i])
		end
	end
	
	return report
end

-- ============================================
-- PHN 2: PERFORMANCE PROFILER
-- ============================================

local PerformanceProfiler = {}
PerformanceProfiler.__index = PerformanceProfiler

function PerformanceProfiler.new()
	local self = setmetatable({}, PerformanceProfiler)
	
	self.profiles = {}
	self.activeProfiles = {}
	self.maxProfiles = 1000
	
	return self
end

function PerformanceProfiler:startProfile(identifier)
	self.activeProfiles[identifier] = {
		startTime = tick(),
		startMemory = collectgarbage("count")
	}
end

function PerformanceProfiler:endProfile(identifier)
	local active = self.activeProfiles[identifier]
	if not active then return nil end
	
	local duration = tick() - active.startTime
	local memoryDelta = collectgarbage("count") - active.startMemory
	
	-- Store profile
	if not self.profiles[identifier] then
		self.profiles[identifier] = {
			calls = 0,
			totalTime = 0,
			minTime = math.huge,
			maxTime = 0,
			avgTime = 0,
			totalMemory = 0
		}
	end
	
	local profile = self.profiles[identifier]
	profile.calls = profile.calls + 1
	profile.totalTime = profile.totalTime + duration
	profile.minTime = math.min(profile.minTime, duration)
	profile.maxTime = math.max(profile.maxTime, duration)
	profile.avgTime = profile.totalTime / profile.calls
	profile.totalMemory = profile.totalMemory + memoryDelta
	
	self.activeProfiles[identifier] = nil
	
	return {
		duration = duration,
		memory = memoryDelta
	}
end

function PerformanceProfiler:getProfile(identifier)
	return self.profiles[identifier]
end

function PerformanceProfiler:getAllProfiles()
	return self.profiles
end

function PerformanceProfiler:printReport()
	print("\n")
	print(" Performance Profile Report")
	print("")
	
	-- Sort by total time
	local sorted = {}
	for identifier, profile in pairs(self.profiles) do
		table.insert(sorted, {
			identifier = identifier,
			profile = profile
		})
	end
	table.sort(sorted, function(a, b)
		return a.profile.totalTime > b.profile.totalTime
	end)
	
	for i, data in ipairs(sorted) do
		if i > 20 then break end -- Top 20
		
		local p = data.profile
		print(string.format(
			"%d. %s\n   Calls: %d | Avg: %.3fms | Max: %.3fms | Total: %.2fs",
			i,
			data.identifier,
			p.calls,
			p.avgTime * 1000,
			p.maxTime * 1000,
			p.totalTime
		))
	end
	
	print("\n")
end

-- ============================================
-- PHN 3: ENHANCED ERROR MANAGER (V2)
-- ============================================

local ErrorManager = {}
ErrorManager.__index = ErrorManager

function ErrorManager.new()
	local self = setmetatable({}, ErrorManager)
	
	-- Circuit Breaker
	self.errorThreshold = 5
	self.resetTimeout = 30
	self.errorCount = {}
	self.circuitState = {}
	self.lastErrorTime = {}
	
	-- Rate Limiting
	self.rateLimits = {}
	self.callHistory = {}
	
	-- Error logging
	self.errorLog = {}
	self.maxLogSize = 100
	
	-- Fatal error
	self.fatalErrorOccurred = false
	self.shutdownCallbacks = {}
	
	-- Exception System V2
	self.exceptionList = {}
	self.exceptionMode = false
	self.exceptionModeTimer = nil
	self.auditLog = {} -- NEW: Security audit log
	
	return self
end

function ErrorManager:formatError(identifier, errorMessage)
	local id = tostring(identifier or "Unknown")
	local detail = tostring(errorMessage or "Unknown error")
	local lowerId = string.lower(id)
	local component = id

	if string.find(lowerId, "split") then
		component = "Tab Splitter"
	elseif string.find(lowerId, "drag") or string.find(lowerId, "dock") then
		component = "Drag & Dock"
	elseif string.find(lowerId, "remote") then
		component = "Remote Protection"
	elseif string.find(lowerId, "config") then
		component = "Configuration"
	elseif string.find(lowerId, "theme") then
		component = "Theme"
	end

	return string.format("Rayfield Mod: %s | %s", component, detail)
end

function ErrorManager:isCircuitOpen(identifier)
	if self.exceptionMode or self.exceptionList[identifier] then
		return false
	end
	
	if not self.circuitState[identifier] then
		self.circuitState[identifier] = "closed"
		self.errorCount[identifier] = 0
		return false
	end
	
	local state = self.circuitState[identifier]
	
	if state == "open" then
		local timeSinceError = tick() - (self.lastErrorTime[identifier] or 0)
		if timeSinceError >= self.resetTimeout then
			self.circuitState[identifier] = "half-open"
			return false
		end
		return true
	end
	
	return false
end

function ErrorManager:recordError(identifier, errorMessage)
	self.errorCount[identifier] = (self.errorCount[identifier] or 0) + 1
	self.lastErrorTime[identifier] = tick()
	local formatted = self:formatError(identifier, errorMessage)
	
	table.insert(self.errorLog, {
		identifier = identifier,
		message = formatted,
		timestamp = tick(),
		count = self.errorCount[identifier]
	})
	
	if #self.errorLog > self.maxLogSize then
		table.remove(self.errorLog, 1)
	end
	
	if self.errorCount[identifier] >= self.errorThreshold then
		self.circuitState[identifier] = "open"
		warn(string.format(
			"Rayfield Mod: Circuit breaker opened for '%s' after %d errors",
			identifier,
			self.errorCount[identifier]
		))
		return true
	end
	
	return false
end

function ErrorManager:recordSuccess(identifier)
	if self.circuitState[identifier] == "half-open" then
		self.circuitState[identifier] = "closed"
	end
	self.errorCount[identifier] = 0
end

function ErrorManager:checkRateLimit(identifier, maxCallsPerSecond)
	if self.exceptionMode or self.exceptionList[identifier] then
		return true, nil
	end
	
	maxCallsPerSecond = maxCallsPerSecond or 10
	
	if not self.callHistory[identifier] then
		self.callHistory[identifier] = {}
	end
	
	local now = tick()
	local history = self.callHistory[identifier]
	
	for i = #history, 1, -1 do
		if now - history[i] > 1 then
			table.remove(history, i)
		end
	end
	
	if #history >= maxCallsPerSecond then
		return false, "Rate limit exceeded"
	end
	
	table.insert(history, now)
	return true, nil
end

-- NEW: Exception with auto-disable
function ErrorManager:addException(identifier, duration)
	self.exceptionList[identifier] = true
	
	-- Audit log
	table.insert(self.auditLog, {
		action = "add_exception",
		identifier = identifier,
		duration = duration,
		timestamp = tick()
	})
	
	print(string.format(
		" [Exception] '%s' bypassed protection%s",
		identifier,
		duration and string.format(" for %ds", duration) or ""
	))
	
	-- Auto-disable after duration
	if duration then
		task.delay(duration, function()
			if self.exceptionList[identifier] then
				self:removeException(identifier)
				print(string.format(" [Exception] '%s' protection restored", identifier))
			end
		end)
	end
end

function ErrorManager:removeException(identifier)
	self.exceptionList[identifier] = nil
	
	table.insert(self.auditLog, {
		action = "remove_exception",
		identifier = identifier,
		timestamp = tick()
	})
end

-- NEW: Global exception with confirmation
function ErrorManager:setExceptionMode(enabled, duration, confirmed)
	if enabled and not confirmed then
		warn(" [SECURITY WARNING] ")
		warn("You are about to DISABLE ALL PROTECTION!")
		warn("Call again with confirmed=true to proceed")
		return false
	end
	
	self.exceptionMode = enabled
	
	-- Audit log
	table.insert(self.auditLog, {
		action = enabled and "enable_global_exception" or "disable_global_exception",
		duration = duration,
		timestamp = tick()
	})
	
	if enabled then
		warn(" [Exception Mode] ALL PROTECTION DISABLED!")
		
		-- Auto-disable
		if duration then
			if self.exceptionModeTimer then
				task.cancel(self.exceptionModeTimer)
			end
			
			self.exceptionModeTimer = task.delay(duration, function()
				self:setExceptionMode(false, nil, true)
				print(" [Exception Mode] Protection restored automatically")
			end)
		end
	else
		print(" [Exception Mode] Protection enabled")
		if self.exceptionModeTimer then
			task.cancel(self.exceptionModeTimer)
			self.exceptionModeTimer = nil
		end
	end
	
	return true
end

function ErrorManager:isException(identifier)
	return self.exceptionMode or self.exceptionList[identifier] == true
end

function ErrorManager:getAuditLog()
	return self.auditLog
end

function ErrorManager:printAuditLog()
	print("\n")
	print(" Security Audit Log")
	print("")
	
	for i, entry in ipairs(self.auditLog) do
		print(string.format(
			"[%d] %s: %s (%.1fs ago)",
			i,
			entry.action,
			entry.identifier or "global",
			tick() - entry.timestamp
		))
	end
	
	print("\n")
end

function ErrorManager:onShutdown(callback)
	table.insert(self.shutdownCallbacks, callback)
end

function ErrorManager:triggerFatalError(reason)
	if self.fatalErrorOccurred then return end
	
	self.fatalErrorOccurred = true
	warn("[Rayfield Fatal Error] " .. reason)
	
	for _, callback in ipairs(self.shutdownCallbacks) do
		pcall(callback)
	end
end

-- ============================================
-- PHN 4: ENHANCED GARBAGE COLLECTOR
-- ============================================

local GarbageCollector = {}
GarbageCollector.__index = GarbageCollector

function GarbageCollector.new()
	local self = setmetatable({}, GarbageCollector)
	
	self.trackedObjects = {}
	self.weakReferences = setmetatable({}, {__mode = "v"})
	self.connections = {}
	self.timers = {}
	
	self.autoCleanupInterval = 60
	self.maxTrackedObjects = 1000
	
	self:startAutoCleanup()
	
	return self
end

function GarbageCollector:track(object, identifier, cleanupFunc)
	if #self.trackedObjects >= self.maxTrackedObjects then
		self:cleanup()
	end
	
	table.insert(self.trackedObjects, {
		object = object,
		identifier = identifier,
		cleanupFunc = cleanupFunc,
		createdAt = tick()
	})
	
	self.weakReferences[identifier] = object
end

function GarbageCollector:trackConnection(connection, identifier)
	self.connections[identifier] = connection
end

function GarbageCollector:trackTimer(thread, identifier)
	self.timers[identifier] = thread
end

function GarbageCollector:cleanup()
	local cleaned = 0
	
	for i = #self.trackedObjects, 1, -1 do
		local tracked = self.trackedObjects[i]
		local obj = tracked.object
		
		local exists = pcall(function()
			return obj.Parent ~= nil
		end)
		
		if not exists or (obj.Parent == nil) then
			if tracked.cleanupFunc then
				pcall(tracked.cleanupFunc)
			end
			table.remove(self.trackedObjects, i)
			cleaned = cleaned + 1
		end
	end
	
	for identifier, connection in pairs(self.connections) do
		if not connection.Connected then
			self.connections[identifier] = nil
			cleaned = cleaned + 1
		end
	end
	
	if cleaned > 0 then
		print(string.format("[GC] Cleaned %d objects", cleaned))
	end
	
	return cleaned
end

function GarbageCollector:cleanupAll()
	for identifier, connection in pairs(self.connections) do
		pcall(function()
			connection:Disconnect()
		end)
	end
	self.connections = {}
	
	for identifier, thread in pairs(self.timers) do
		pcall(function()
			task.cancel(thread)
		end)
	end
	self.timers = {}
	
	for _, tracked in ipairs(self.trackedObjects) do
		if tracked.cleanupFunc then
			pcall(tracked.cleanupFunc)
		end
	end
	self.trackedObjects = {}
	
	print("[GC] Full cleanup completed")
end

function GarbageCollector:startAutoCleanup()
	local thread = task.spawn(function()
		while true do
			task.wait(self.autoCleanupInterval)
			self:cleanup()
		end
	end)
	
	self.timers["autoCleanup"] = thread
end

-- ============================================
-- PHN 5: PRIORITY REMOTE PROTECTION
-- ============================================

local RemoteProtection = {}
RemoteProtection.__index = RemoteProtection

function RemoteProtection.new(errorManager)
	local self = setmetatable({}, RemoteProtection)
	
	self.errorManager = errorManager
	
	-- Priority queues
	self.queues = {
		critical = {},
		high = {},
		normal = {},
		low = {}
	}
	
	self.maxQueueSize = {
		critical = 100,
		high = 75,
		normal = 50,
		low = 25
	}
	
	self.processingQueue = false
	self.timeout = 10 -- Increased from 5
	
	return self
end

function RemoteProtection:safeRemoteCall(remoteObject, method, priority, ...)
	priority = priority or "normal"
	local args = {...}
	
	if self.errorManager.fatalErrorOccurred then
		return false, "Fatal error occurred"
	end
	
	local queue = self.queues[priority]
	local maxSize = self.maxQueueSize[priority]
	
	if #queue >= maxSize then
		warn(string.format("[Remote] %s queue full", priority))
		return false, "Queue full"
	end
	
	table.insert(queue, {
		remote = remoteObject,
		method = method,
		args = args,
		timestamp = tick(),
		priority = priority
	})
	
	if not self.processingQueue then
		self:processQueue()
	end
	
	return true, "Queued"
end

function RemoteProtection:processQueue()
	self.processingQueue = true
	
	task.spawn(function()
		local priorities = {"critical", "high", "normal", "low"}
		
		while true do
			local hasWork = false
			
			-- Process in priority order
			for _, priority in ipairs(priorities) do
				local queue = self.queues[priority]
				
				if #queue > 0 then
					hasWork = true
					local callData = table.remove(queue, 1)
					
					-- Check timeout
					if tick() - callData.timestamp > self.timeout then
						warn(string.format("[Remote] Timeout: %s", priority))
					else
						local success, result = pcall(function()
							return callData.remote[callData.method](callData.remote, unpack(callData.args))
						end)
						
						if not success then
							warn("[Remote Error] " .. tostring(result))
							self.errorManager:recordError("RemoteCall", tostring(result))
						end
					end
					
					-- Delay based on priority
					local delays = {
						critical = 0.05,
						high = 0.1,
						normal = 0.15,
						low = 0.2
					}
					task.wait(delays[priority])
					break -- Process one at a time
				end
			end
			
			if not hasWork then
				break
			end
		end
		
		self.processingQueue = false
	end)
end

function RemoteProtection:getQueueStatus()
	local status = {}
	for priority, queue in pairs(self.queues) do
		status[priority] = {
			count = #queue,
			max = self.maxQueueSize[priority]
		}
	end
	return status
end

-- ============================================
-- PHN 6: HYBRID CALLBACK SYSTEM
-- ============================================

local function createHybridCallback(callback, identifier, errorManager, profiler, options)
	options = options or {}
	
	local mode = options.mode or "protected" -- "protected" or "fast"
	local rateLimit = options.rateLimit or 10
	local circuitBreaker = options.circuitBreaker ~= false
	local profile = options.profile ~= false
	
	if mode == "fast" then
		-- Fast path: minimal overhead
		return function(...)
			if profile and profiler then
				profiler:startProfile(identifier)
			end
			
			local success, result = pcall(callback, ...)
			
			if profile and profiler then
				profiler:endProfile(identifier)
			end
			
			if not success then
				warn(errorManager:formatError(identifier, tostring(result)))
			end
			
			return result
		end
	else
		-- Protected path: full protection
		return function(...)
			-- Fatal error check
			if errorManager.fatalErrorOccurred then
				return nil
			end
			
			-- Exception check
			if errorManager:isException(identifier) then
				if profile and profiler then
					profiler:startProfile(identifier)
				end
				
				local success, result = pcall(callback, ...)
				
				if profile and profiler then
					profiler:endProfile(identifier)
				end
				
				return result
			end
			
			-- Circuit breaker
			if circuitBreaker and errorManager:isCircuitOpen(identifier) then
				return nil
			end
			
			-- Rate limit
			local allowed, rateLimitError = errorManager:checkRateLimit(identifier, rateLimit)
			if not allowed then
				return nil
			end
			
			-- Profile start
			if profile and profiler then
				profiler:startProfile(identifier)
			end
			
			-- Execute
			local success, result = pcall(callback, ...)
			
			-- Profile end
			if profile and profiler then
				profiler:endProfile(identifier)
			end
			
			-- Handle result
			if success then
				errorManager:recordSuccess(identifier)
				return result
			else
				local circuitOpened = errorManager:recordError(identifier, tostring(result))
				
				if circuitOpened then
					errorManager:triggerFatalError(
						errorManager:formatError(identifier, "Circuit breaker opened")
					)
				end
				
				return nil
			end
		end
	end
end

-- ============================================
-- PHN 7: ENHANCED WRAPPER
-- ============================================

local function createEnhancedRayfield(originalRayfield)
	local errorManager = ErrorManager.new()
	local garbageCollector = GarbageCollector.new()
	local remoteProtection = RemoteProtection.new(errorManager)
	local memoryLeakDetector = MemoryLeakDetector.new()
	local profiler = PerformanceProfiler.new()

	memoryLeakDetector:setRuntimeDiagnosticsProvider(function()
		local diagnostics = {}
		if type(originalRayfield.GetRuntimeDiagnostics) == "function" then
			local ok, value = pcall(function()
				return originalRayfield:GetRuntimeDiagnostics()
			end)
			if ok and type(value) == "table" then
				diagnostics = value
			end
		end

		diagnostics.gcTrackedObjects = type(garbageCollector.trackedObjects) == "table" and #garbageCollector.trackedObjects or 0
		return diagnostics
	end)
	
	-- Shutdown callback
	errorManager:onShutdown(function()
		memoryLeakDetector:destroy()
		garbageCollector:cleanupAll()
	end)
	
	-- Leak detection callback
	memoryLeakDetector.onLeakDetected = function(leak)
		if leak.severity == "high" and leak.sourceClassification == "rayfield_ui" and leak.attributionConfirmed == true then
			warn("[Memory Leak] Triggering emergency cleanup")
			garbageCollector:cleanup()
		end
	end

	memoryLeakDetector.onUnknownCause = function()
		if type(originalRayfield.Notify) == "function" then
			pcall(function()
				originalRayfield:Notify({
					Title = "Memory Monitor",
					Content = "RAM tng cao nhng cha  bng chng do Rayfield; cha kch hot emergency.",
					Duration = 8
				})
			end)
		end
	end
	
	-- Wrap CreateWindow
	local originalCreateWindow = originalRayfield.CreateWindow
	originalRayfield.CreateWindow = function(selfOrSettings, maybeSettings)
		-- Support both call styles:
		-- 1) Rayfield:CreateWindow(settings)  -> selfOrSettings = Rayfield, maybeSettings = settings
		-- 2) Rayfield.CreateWindow(settings)  -> selfOrSettings = settings, maybeSettings = nil
		local self = originalRayfield
		local settings = maybeSettings

		if selfOrSettings == originalRayfield then
			self = selfOrSettings
		elseif maybeSettings == nil then
			settings = selfOrSettings
		end

		if type(settings) ~= "table" then
			settings = {}
		end

		local window = originalCreateWindow(self, settings)
		
		garbageCollector:track(window, "MainWindow", function()
			if window.Destroy then
				pcall(window.Destroy, window)
			end
		end)
		
		return window
	end

	-- Ensure background workers are stopped on explicit destroy
	local originalDestroy = originalRayfield.Destroy
	if type(originalDestroy) == "function" then
		originalRayfield.Destroy = function(self, ...)
			memoryLeakDetector:destroy()
			garbageCollector:cleanupAll()
			return originalDestroy(self, ...)
		end
	end
	
	-- New APIs
	originalRayfield.GetErrorManager = function()
		return errorManager
	end
	
	originalRayfield.GetGarbageCollector = function()
		return garbageCollector
	end
	
	originalRayfield.GetRemoteProtection = function()
		return remoteProtection
	end
	
	originalRayfield.GetMemoryLeakDetector = function()
		return memoryLeakDetector
	end
	
	originalRayfield.GetProfiler = function()
		return profiler
	end

	originalRayfield.IsHealthy = function()
		return not errorManager.fatalErrorOccurred
	end
	
	originalRayfield.GetErrorLog = function()
		return errorManager.errorLog
	end
	
	originalRayfield.ForceCleanup = function()
		return garbageCollector:cleanup()
	end
	
	originalRayfield.GetMemoryReport = function()
		return memoryLeakDetector:getReport()
	end

	originalRayfield.GetAttributionReport = function()
		return memoryLeakDetector:getAttributionReport()
	end
	
	originalRayfield.GetPerformanceReport = function()
		profiler:printReport()
	end
	
	originalRayfield.GetAuditLog = function()
		return errorManager:getAuditLog()
	end
	
	return originalRayfield, errorManager, garbageCollector, remoteProtection, memoryLeakDetector, profiler
end

-- ============================================
-- EXPORT
-- ============================================

return {
	ErrorManager = ErrorManager,
	GarbageCollector = GarbageCollector,
	RemoteProtection = RemoteProtection,
	MemoryLeakDetector = MemoryLeakDetector,
	PerformanceProfiler = PerformanceProfiler,
	createHybridCallback = createHybridCallback,
	createEnhancedRayfield = createEnhancedRayfield,
	Version = "2.0.0"
}
]=])
put("src/feature/enhanced/error-manager.lua", [[local client = _G and _G.__RayfieldApiClient
if not client then
	error("Rayfield ApiClient is not initialized")
end

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
local Enhanced = client.fetchAndExecute(root .. "src/feature/enhanced/create-enhanced-rayfield.lua")
return Enhanced.ErrorManager]])
put("src/feature/enhanced/garbage-collector.lua", [[local client = _G and _G.__RayfieldApiClient
if not client then
	error("Rayfield ApiClient is not initialized")
end

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
local Enhanced = client.fetchAndExecute(root .. "src/feature/enhanced/create-enhanced-rayfield.lua")
return Enhanced.GarbageCollector]])
put("src/feature/enhanced/init.lua", [[local client = _G and _G.__RayfieldApiClient
if not client then
	error("Rayfield ApiClient is not initialized")
end

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
return client.fetchAndExecute(root .. "src/feature/enhanced/create-enhanced-rayfield.lua")]])
put("src/feature/enhanced/memory-leak-detector.lua", [[local client = _G and _G.__RayfieldApiClient
if not client then
	error("Rayfield ApiClient is not initialized")
end

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
local Enhanced = client.fetchAndExecute(root .. "src/feature/enhanced/create-enhanced-rayfield.lua")
return Enhanced.MemoryLeakDetector]])
put("src/feature/enhanced/profiler.lua", [[local client = _G and _G.__RayfieldApiClient
if not client then
	error("Rayfield ApiClient is not initialized")
end

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
local Enhanced = client.fetchAndExecute(root .. "src/feature/enhanced/create-enhanced-rayfield.lua")
return Enhanced.PerformanceProfiler]])
put("src/feature/enhanced/remote-protection.lua", [[local client = _G and _G.__RayfieldApiClient
if not client then
	error("Rayfield ApiClient is not initialized")
end

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
local Enhanced = client.fetchAndExecute(root .. "src/feature/enhanced/create-enhanced-rayfield.lua")
return Enhanced.RemoteProtection]])
put("src/feature/mini-window/controller.lua", [[-- Custom Mini Window System
-- Creates a small floating widget separate from Rayfield

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local HttpService = game:GetService("HttpService")

local function buildFallbackAnimateFacade()
	local engine = (_G and _G.__RayfieldSharedAnimationEngine) or nil
	if not engine then
		local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
		local okEngineLib, engineLib = pcall(function()
			if _G and _G.__RayfieldApiClient then
				return _G.__RayfieldApiClient.fetchAndExecute(root .. "src/core/animation/engine.lua")
			end
			return nil
		end)
		if okEngineLib and engineLib and type(engineLib.new) == "function" then
			local okEngine, createdEngine = pcall(function()
				return engineLib.new({
					TweenService = TweenService,
					RunService = game:GetService("RunService"),
					mode = "raw"
				})
			end)
			if okEngine then
				engine = createdEngine
			end
		end
	end

	if not engine then
		return {
			Create = function(_, object, tweenInfo, goals)
				local creator = TweenService["Create"]
				if type(creator) == "function" then
					return creator(TweenService, object, tweenInfo, goals)
				end
				return nil
			end
		}
	end

	return {
		Create = function(_, object, tweenInfo, goals)
			return engine:Create(object, tweenInfo, goals)
		end
	}
end

local Animation = (_G and _G.__RayfieldSharedAnimateFacade) or buildFallbackAnimateFacade()

local MiniWindow = {}
MiniWindow.__index = MiniWindow

local function getViewportVirtualization()
	local service = _G and _G.__RayfieldViewportVirtualization
	if type(service) == "table" then
		return service
	end
	return nil
end

function MiniWindow.new(config)
    local self = setmetatable({}, MiniWindow)
    
    config = config or {}
    self.Title = config.Title or "Mini Window"
    self.Size = config.Size or UDim2.new(0, 200, 0, 300)
    self.Position = config.Position or UDim2.new(1, -220, 0.5, -150)
    self.Buttons = {}
    self.Labels = {}
    self.Animation = Animation
    self.Connections = {}
    self.ViewportVirtualization = getViewportVirtualization()
    self.VirtualHostId = "mini:" .. tostring(HttpService:GenerateGUID(false))
    self.VirtualTokens = setmetatable({}, { __mode = "k" })
    
    self:CreateUI()
    
    return self
end

function MiniWindow:_trackConnection(connection)
	if connection then
		table.insert(self.Connections, connection)
	end
	return connection
end

function MiniWindow:_registerVirtualHost()
	local viewport = self.ViewportVirtualization
	if not (viewport and type(viewport.registerHost) == "function") then
		return false
	end
	return pcall(viewport.registerHost, self.VirtualHostId, self.Content, {
		mode = "scrolling"
	})
end

function MiniWindow:_refreshVirtualHost(reason)
	local viewport = self.ViewportVirtualization
	if viewport and type(viewport.refreshHost) == "function" then
		pcall(viewport.refreshHost, self.VirtualHostId, reason or "mini_window_update")
	end
end

function MiniWindow:_registerVirtualElement(guiObject, elementType)
	if not guiObject then
		return nil
	end
	local viewport = self.ViewportVirtualization
	if not (viewport and type(viewport.registerElement) == "function") then
		return nil
	end
	local okToken, token = pcall(viewport.registerElement, self.VirtualHostId, guiObject, {
		meta = {
			elementType = elementType or guiObject.ClassName or "GuiObject",
			miniWindow = true,
			title = self.Title
		}
	})
	if okToken and type(token) == "string" then
		self.VirtualTokens[guiObject] = token
		if guiObject.SetAttribute then
			pcall(guiObject.SetAttribute, guiObject, "RayfieldVirtualToken", token)
		end
		return token
	end
	return nil
end

function MiniWindow:_unregisterVirtualElement(guiObject)
	if not guiObject then
		return
	end
	local viewport = self.ViewportVirtualization
	if not (viewport and type(viewport.unregisterElement) == "function") then
		return
	end
	local token = self.VirtualTokens[guiObject]
	if token then
		pcall(viewport.unregisterElement, token)
		self.VirtualTokens[guiObject] = nil
	else
		pcall(viewport.unregisterElement, guiObject)
	end
	if guiObject.SetAttribute then
		pcall(guiObject.SetAttribute, guiObject, "RayfieldVirtualToken", nil)
	end
end

function MiniWindow:CreateUI()
    -- Create ScreenGui
    self.ScreenGui = Instance.new("ScreenGui")
    self.ScreenGui.Name = "MiniWindow"
    self.ScreenGui.ResetOnSpawn = false
    self.ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    
    -- Main Frame
    self.Frame = Instance.new("Frame")
    self.Frame.Name = "MainFrame"
    self.Frame.Size = self.Size
    self.Frame.Position = self.Position
    self.Frame.BackgroundColor3 = Color3.fromRGB(25, 25, 35)
    self.Frame.BorderSizePixel = 0
    self.Frame.Parent = self.ScreenGui
    
    -- Corner
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 8)
    corner.Parent = self.Frame
    
    -- Stroke
    local stroke = Instance.new("UIStroke")
    stroke.Color = Color3.fromRGB(60, 60, 80)
    stroke.Thickness = 2
    stroke.Parent = self.Frame
    
    -- Title Bar
    self.TitleBar = Instance.new("Frame")
    self.TitleBar.Name = "TitleBar"
    self.TitleBar.Size = UDim2.new(1, 0, 0, 30)
    self.TitleBar.BackgroundColor3 = Color3.fromRGB(35, 35, 50)
    self.TitleBar.BorderSizePixel = 0
    self.TitleBar.Parent = self.Frame
    
    local titleCorner = Instance.new("UICorner")
    titleCorner.CornerRadius = UDim.new(0, 8)
    titleCorner.Parent = self.TitleBar
    
    -- Title Text
    self.TitleLabel = Instance.new("TextLabel")
    self.TitleLabel.Name = "Title"
    self.TitleLabel.Size = UDim2.new(1, -40, 1, 0)
    self.TitleLabel.Position = UDim2.new(0, 10, 0, 0)
    self.TitleLabel.BackgroundTransparency = 1
    self.TitleLabel.Text = self.Title
    self.TitleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    self.TitleLabel.TextSize = 14
    self.TitleLabel.Font = Enum.Font.GothamBold
    self.TitleLabel.TextXAlignment = Enum.TextXAlignment.Left
    self.TitleLabel.Parent = self.TitleBar
    
    -- Close Button
    self.CloseButton = Instance.new("TextButton")
    self.CloseButton.Name = "Close"
    self.CloseButton.Size = UDim2.new(0, 20, 0, 20)
    self.CloseButton.Position = UDim2.new(1, -25, 0.5, -10)
    self.CloseButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
    self.CloseButton.Text = ""
    self.CloseButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    self.CloseButton.TextSize = 16
    self.CloseButton.Font = Enum.Font.GothamBold
    self.CloseButton.BorderSizePixel = 0
    self.CloseButton.Parent = self.TitleBar
    
    local closeCorner = Instance.new("UICorner")
    closeCorner.CornerRadius = UDim.new(1, 0)
    closeCorner.Parent = self.CloseButton
    
    self:_trackConnection(self.CloseButton.MouseButton1Click:Connect(function()
        self:Toggle()
    end))
    
    -- Content Frame
    self.Content = Instance.new("ScrollingFrame")
    self.Content.Name = "Content"
    self.Content.Size = UDim2.new(1, -10, 1, -40)
    self.Content.Position = UDim2.new(0, 5, 0, 35)
    self.Content.BackgroundTransparency = 1
    self.Content.BorderSizePixel = 0
    self.Content.ScrollBarThickness = 4
    self.Content.ScrollBarImageColor3 = Color3.fromRGB(100, 100, 120)
    self.Content.Parent = self.Frame
    
    -- Layout
    self.Layout = Instance.new("UIListLayout")
    self.Layout.Padding = UDim.new(0, 5)
    self.Layout.SortOrder = Enum.SortOrder.LayoutOrder
    self.Layout.Parent = self.Content
    
    -- Make draggable
    self:MakeDraggable()
    
    -- Parent to PlayerGui
    self.ScreenGui.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")
    self:_registerVirtualHost()
    self:_trackConnection(self.Frame:GetPropertyChangedSignal("Visible"):Connect(function()
        if self.ViewportVirtualization and type(self.ViewportVirtualization.setHostSuppressed) == "function" then
            pcall(self.ViewportVirtualization.setHostSuppressed, self.VirtualHostId, not self.Frame.Visible)
        end
        self:_refreshVirtualHost("mini_visibility")
    end))
    self:_refreshVirtualHost("mini_window_created")
end

function MiniWindow:MakeDraggable()
    local dragging = false
    local dragInput, mousePos, framePos
    
    self:_trackConnection(self.TitleBar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            mousePos = input.Position
            framePos = self.Frame.Position
            
            self:_trackConnection(input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end))
        end
    end))
    
    self:_trackConnection(UserInputService.InputChanged:Connect(function(input)
        if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
            local delta = input.Position - mousePos
            self.Frame.Position = UDim2.new(
                framePos.X.Scale,
                framePos.X.Offset + delta.X,
                framePos.Y.Scale,
                framePos.Y.Offset + delta.Y
            )
        end
    end))
end

function MiniWindow:AddButton(name, callback)
    local button = Instance.new("TextButton")
    button.Name = name
    button.Size = UDim2.new(1, -10, 0, 30)
    button.BackgroundColor3 = Color3.fromRGB(45, 45, 60)
    button.Text = name
    button.TextColor3 = Color3.fromRGB(255, 255, 255)
    button.TextSize = 12
    button.Font = Enum.Font.Gotham
    button.BorderSizePixel = 0
    button.Parent = self.Content
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 6)
    corner.Parent = button
    
    self:_trackConnection(button.MouseButton1Click:Connect(callback))
    
    self:_trackConnection(button.MouseEnter:Connect(function()
        Animation:Create(button, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(60, 60, 80)}):Play()
    end))
    
    self:_trackConnection(button.MouseLeave:Connect(function()
        Animation:Create(button, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(45, 45, 60)}):Play()
    end))
    
    table.insert(self.Buttons, button)
    self:_registerVirtualElement(button, "Button")
    self:UpdateContentSize()
    
    return button
end

function MiniWindow:AddLabel(text)
    local label = Instance.new("TextLabel")
    label.Name = "Label"
    label.Size = UDim2.new(1, -10, 0, 25)
    label.BackgroundTransparency = 1
    label.Text = text
    label.TextColor3 = Color3.fromRGB(200, 200, 200)
    label.TextSize = 11
    label.Font = Enum.Font.Gotham
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.Parent = self.Content
    
    table.insert(self.Labels, label)
    self:_registerVirtualElement(label, "Label")
    self:UpdateContentSize()
    
    return label
end

function MiniWindow:UpdateContentSize()
    local contentSize = self.Layout.AbsoluteContentSize
    self.Content.CanvasSize = UDim2.new(0, 0, 0, contentSize.Y + 10)
    self:_refreshVirtualHost("content_size")
end

function MiniWindow:Toggle()
    self.Frame.Visible = not self.Frame.Visible
    if self.ViewportVirtualization and type(self.ViewportVirtualization.setHostSuppressed) == "function" then
        pcall(self.ViewportVirtualization.setHostSuppressed, self.VirtualHostId, not self.Frame.Visible)
    end
    self:_refreshVirtualHost("mini_toggle")
end

function MiniWindow:Show()
    self.Frame.Visible = true
    if self.ViewportVirtualization and type(self.ViewportVirtualization.setHostSuppressed) == "function" then
        pcall(self.ViewportVirtualization.setHostSuppressed, self.VirtualHostId, false)
    end
    self:_refreshVirtualHost("mini_show")
end

function MiniWindow:Hide()
    self.Frame.Visible = false
    if self.ViewportVirtualization and type(self.ViewportVirtualization.setHostSuppressed) == "function" then
        pcall(self.ViewportVirtualization.setHostSuppressed, self.VirtualHostId, true)
    end
    self:_refreshVirtualHost("mini_hide")
end

function MiniWindow:AddToggle(name, defaultValue, callback)
    local container = Instance.new("Frame")
    container.Name = name
    container.Size = UDim2.new(1, -10, 0, 30)
    container.BackgroundColor3 = Color3.fromRGB(45, 45, 60)
    container.BorderSizePixel = 0
    container.Parent = self.Content

    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 6)
    corner.Parent = container

    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1, -40, 1, 0)
    label.Position = UDim2.new(0, 10, 0, 0)
    label.BackgroundTransparency = 1
    label.Text = name
    label.TextColor3 = Color3.fromRGB(255, 255, 255)
    label.TextSize = 12
    label.Font = Enum.Font.Gotham
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.Parent = container

    local toggle = Instance.new("TextButton")
    toggle.Size = UDim2.new(0, 40, 0, 20)
    toggle.Position = UDim2.new(1, -45, 0.5, -10)
    toggle.BackgroundColor3 = defaultValue and Color3.fromRGB(100, 255, 100) or Color3.fromRGB(80, 80, 90)
    toggle.Text = defaultValue and "ON" or "OFF"
    toggle.TextColor3 = Color3.fromRGB(255, 255, 255)
    toggle.TextSize = 10
    toggle.Font = Enum.Font.GothamBold
    toggle.BorderSizePixel = 0
    toggle.Parent = container

    local toggleCorner = Instance.new("UICorner")
    toggleCorner.CornerRadius = UDim.new(0, 10)
    toggleCorner.Parent = toggle

    local state = defaultValue

    self:_trackConnection(toggle.MouseButton1Click:Connect(function()
        state = not state
        toggle.Text = state and "ON" or "OFF"
        Animation:Create(toggle, TweenInfo.new(0.2), {
            BackgroundColor3 = state and Color3.fromRGB(100, 255, 100) or Color3.fromRGB(80, 80, 90)
        }):Play()
        callback(state)
    end))

    self:_registerVirtualElement(container, "Toggle")
    self:UpdateContentSize()

    return {
        Container = container,
        Toggle = toggle,
        SetValue = function(value)
            state = value
            toggle.Text = state and "ON" or "OFF"
            toggle.BackgroundColor3 = state and Color3.fromRGB(100, 255, 100) or Color3.fromRGB(80, 80, 90)
        end,
        GetValue = function()
            return state
        end
    }
end

function MiniWindow:AddSlider(name, min, max, defaultValue, callback)
    local container = Instance.new("Frame")
    container.Name = name
    container.Size = UDim2.new(1, -10, 0, 50)
    container.BackgroundColor3 = Color3.fromRGB(45, 45, 60)
    container.BorderSizePixel = 0
    container.Parent = self.Content

    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 6)
    corner.Parent = container

    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1, -20, 0, 20)
    label.Position = UDim2.new(0, 10, 0, 5)
    label.BackgroundTransparency = 1
    label.Text = name .. ": " .. defaultValue
    label.TextColor3 = Color3.fromRGB(255, 255, 255)
    label.TextSize = 11
    label.Font = Enum.Font.Gotham
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.Parent = container

    local sliderBg = Instance.new("Frame")
    sliderBg.Size = UDim2.new(1, -20, 0, 6)
    sliderBg.Position = UDim2.new(0, 10, 1, -15)
    sliderBg.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
    sliderBg.BorderSizePixel = 0
    sliderBg.Parent = container

    local sliderBgCorner = Instance.new("UICorner")
    sliderBgCorner.CornerRadius = UDim.new(1, 0)
    sliderBgCorner.Parent = sliderBg

    local sliderFill = Instance.new("Frame")
    sliderFill.Size = UDim2.new((defaultValue - min) / (max - min), 0, 1, 0)
    sliderFill.BackgroundColor3 = Color3.fromRGB(100, 150, 255)
    sliderFill.BorderSizePixel = 0
    sliderFill.Parent = sliderBg

    local sliderFillCorner = Instance.new("UICorner")
    sliderFillCorner.CornerRadius = UDim.new(1, 0)
    sliderFillCorner.Parent = sliderFill

    local currentValue = defaultValue
    local dragging = false

    local function updateSlider(input)
        local pos = (input.Position.X - sliderBg.AbsolutePosition.X) / sliderBg.AbsoluteSize.X
        pos = math.clamp(pos, 0, 1)
        currentValue = math.floor(min + (max - min) * pos)
        sliderFill.Size = UDim2.new(pos, 0, 1, 0)
        label.Text = name .. ": " .. currentValue
        callback(currentValue)
    end

    self:_trackConnection(sliderBg.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            updateSlider(input)
        end
    end))

    self:_trackConnection(sliderBg.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = false
        end
    end))

    self:_trackConnection(UserInputService.InputChanged:Connect(function(input)
        if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
            updateSlider(input)
        end
    end))

    self:_registerVirtualElement(container, "Slider")
    self:UpdateContentSize()

    return {
        Container = container,
        SetValue = function(value)
            currentValue = math.clamp(value, min, max)
            local pos = (currentValue - min) / (max - min)
            sliderFill.Size = UDim2.new(pos, 0, 1, 0)
            label.Text = name .. ": " .. currentValue
        end,
        GetValue = function()
            return currentValue
        end
    }
end

function MiniWindow:Destroy()
    local tokenObjects = {}
    for guiObject in pairs(self.VirtualTokens) do
        table.insert(tokenObjects, guiObject)
    end
    for _, guiObject in ipairs(tokenObjects) do
        self:_unregisterVirtualElement(guiObject)
    end
    local viewport = self.ViewportVirtualization
    if viewport and type(viewport.unregisterHost) == "function" then
        pcall(viewport.unregisterHost, self.VirtualHostId)
    end
    for _, connection in ipairs(self.Connections) do
        pcall(function()
            connection:Disconnect()
        end)
    end
    self.Connections = {}
    self.ScreenGui:Destroy()
end

return MiniWindow

]])
put("src/feature/mini-window/dock.lua", [[local MiniWindowDock = {}

function MiniWindowDock.shouldDock(dropPosition, dockBounds)
	if not dropPosition or not dockBounds then
		return false
	end
	return dropPosition.X >= dockBounds.X and dropPosition.X <= (dockBounds.X + dockBounds.Width)
		and dropPosition.Y >= dockBounds.Y and dropPosition.Y <= (dockBounds.Y + dockBounds.Height)
end

return MiniWindowDock]])
put("src/feature/mini-window/drag.lua", [[local MiniWindowDrag = {}

function MiniWindowDrag.clamp(position, viewport, size)
	local x = math.clamp(position.X, 0, math.max(0, viewport.X - size.X))
	local y = math.clamp(position.Y, 0, math.max(0, viewport.Y - size.Y))
	return Vector2.new(x, y)
end

return MiniWindowDrag]])
put("src/feature/mini-window/init.lua", [[local client = _G and _G.__RayfieldApiClient
if not client then
	error("Rayfield ApiClient is not initialized")
end

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
return client.fetchAndExecute(root .. "src/feature/mini-window/controller.lua")]])
put("src/feature/mini-window/layout.lua", [[local MiniWindowController = {}

function MiniWindowController.new(runtime)
	return {
		runtime = runtime
	}
end

return MiniWindowController]])
put("src/feature/reorder/engine.lua", [[local ReorderEngine = {}

local function getOrderedGuiChildren(parent, excludes)
	excludes = excludes or {}
	local deny = {}
	for _, obj in ipairs(excludes) do
		deny[obj] = true
	end

	local rawChildren = parent and parent:GetChildren() or {}
	local insertionOrder = {}
	for index, child in ipairs(rawChildren) do
		insertionOrder[child] = index
	end

	local ordered = {}
	for _, child in ipairs(rawChildren) do
		if child:IsA("GuiObject") and not deny[child] then
			table.insert(ordered, child)
		end
	end

	table.sort(ordered, function(a, b)
		if a.LayoutOrder ~= b.LayoutOrder then
			return a.LayoutOrder < b.LayoutOrder
		end
		return (insertionOrder[a] or 0) < (insertionOrder[b] or 0)
	end)

	return ordered
end

local function normalizeOrderedGuiLayout(ordered, step)
	step = step or 10
	for index, child in ipairs(ordered) do
		child.LayoutOrder = index * step
	end
end

local function calculateInsertIndex(ordered, point)
	if not point then
		return #ordered + 1
	end
	local insertIndex = #ordered + 1
	for index, child in ipairs(ordered) do
		local centerY = child.AbsolutePosition.Y + (child.AbsoluteSize.Y * 0.5)
		if point.Y <= centerY then
			insertIndex = index
			break
		end
	end
	return insertIndex
end

function ReorderEngine.init()
	return {
		getOrderedGuiChildren = getOrderedGuiChildren,
		normalizeOrderedGuiLayout = normalizeOrderedGuiLayout,
		calculateInsertIndex = calculateInsertIndex
	}
end

return ReorderEngine
]])
put("src/feature/reorder/preview.lua", [[local ReorderPreview = {}

function ReorderPreview.init(ctx)
	local tweenService = ctx and ctx.TweenService
	local indicator = nil
	local indicatorTween = nil

	local function clear(instant)
		if indicatorTween then
			pcall(function() indicatorTween:Cancel() end)
			indicatorTween = nil
		end
		if indicator then
			local target = indicator
			indicator = nil
			if instant or not tweenService then
				target:Destroy()
				return
			end
			indicatorTween = tweenService:Create(target, TweenInfo.new(0.08, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
				BackgroundTransparency = 1
			})
			indicatorTween:Play()
			task.delay(0.09, function()
				if target and target.Parent then
					target:Destroy()
				end
			end)
		end
	end

	local function show(parent, x, y, width, color)
		if not parent then
			return
		end
		if not indicator then
			indicator = Instance.new("Frame")
			indicator.Name = "ReorderIndicator"
			indicator.BorderSizePixel = 0
			indicator.Size = UDim2.fromOffset(width, 3)
			indicator.ZIndex = 210
			indicator.Parent = parent
		end
		indicator.BackgroundColor3 = color
		indicator.BackgroundTransparency = 0.08
		indicator.Size = UDim2.fromOffset(width, 3)
		indicator.Position = UDim2.fromOffset(x, y)
		indicator.Visible = true
	end

	return {
		show = show,
		clear = clear
	}
end

return ReorderPreview
]])
put("src/feature/tabsplit/controller.lua", [[-- Rayfield Tab Split Module
-- Handles long-hold tab split into secondary panels (non-float detached windows)

local TabSplitModule = {}
local compileString = loadstring or load
if not compileString then
	error("No Lua compiler function available (loadstring/load)")
end

local MODULE_ROOT_URL = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"

local function loadSubmodule(localName, relativePath)
	local useStudio = false
	local okRun, runService = pcall(function()
		return game:GetService("RunService")
	end)
	if okRun and runService then
		local okStudio, studio = pcall(function()
			return runService:IsStudio()
		end)
		useStudio = okStudio and studio or false
	end

	if useStudio then
		local okRequire, module = pcall(function()
			return require(script.Parent[localName])
		end)
		if okRequire and module then
			return module
		end
	end

	return compileString(game:HttpGet(MODULE_ROOT_URL .. relativePath))()
end

local TabSplitStateLib = loadSubmodule("state", "src/feature/tabsplit/state.lua")
local TabSplitPanelLib = loadSubmodule("panel", "src/feature/tabsplit/panel.lua")
local TabSplitDragDockLib = loadSubmodule("dragdock", "src/feature/tabsplit/dragdock.lua")
local TabSplitReorderLib = loadSubmodule("reorder_tab_split", "src/feature/tabsplit/reorder_tab_split.lua")

function TabSplitModule.init(ctx)
	local self = {}

	self.UserInputService = ctx.UserInputService
	self.RunService = ctx.RunService
	self.TweenService = ctx.TweenService
	self.Animation = ctx.Animation or ctx.TweenService
	self.HttpService = ctx.HttpService
	self.Rayfield = ctx.Rayfield
	self.Main = ctx.Main
	self.Topbar = ctx.Topbar
	self.TabList = ctx.TabList
	self.Elements = ctx.Elements
	self.getSelectedTheme = ctx.getSelectedTheme
	self.rayfieldDestroyed = ctx.rayfieldDestroyed
	self.useMobileSizing = ctx.useMobileSizing
	self.Notify = ctx.Notify
	self.getBlockedState = ctx.getBlockedState

	local enabled = ctx.enabled ~= false
	local holdDuration = tonumber(ctx.holdDuration) or 3
	if holdDuration < 0.5 then
		holdDuration = 0.5
	end

	local allowSettingsSplit = ctx.allowSettingsSplit == true
	local maxSplitTabs = tonumber(ctx.maxSplitTabs)
	if maxSplitTabs and maxSplitTabs < 1 then
		maxSplitTabs = nil
	end

	local splitRoot = nil
	local splitPanels = {}
	local tabToPanel = {}
	local panelOrder = {}
	local tabRecords = {}
	local tabGestureCleanup = {}
	local splitHidden = false
	local splitMinimized = false
	local splitIndex = 0
	local layoutDirtyCallback = type(ctx.onLayoutDirty) == "function" and ctx.onLayoutDirty or nil
	local viewportVirtualization = ctx.ViewportVirtualization

	local rootConnections = {}
	local tabZIndexState = setmetatable({}, { __mode = "k" })

	local DRAG_THRESHOLD = 4
	local PANEL_MARGIN = 8
	local TAB_GHOST_FOLLOW_SPEED = 0.24
	local TAB_CUE_HOVER_TRANSPARENCY = 0.52
	local TAB_CUE_HOLD_TRANSPARENCY = 0.34
	local TAB_CUE_READY_TRANSPARENCY = 0.24
	local TAB_CUE_IDLE_THICKNESS = 1
	local TAB_CUE_HOVER_THICKNESS = 1.35
	local TAB_CUE_HOLD_THICKNESS = 1.9
	local TAB_CUE_READY_THICKNESS = 2.2
	local REDUCED_EFFECTS = self.useMobileSizing == true

	local function notifyLayoutDirty(reason)
		if type(layoutDirtyCallback) ~= "function" then
			return
		end
		pcall(layoutDirtyCallback, "tabsplit", reason or "tabsplit_layout_changed")
	end

	local stateManager = TabSplitStateLib.create({
		UserInputService = self.UserInputService,
		Main = self.Main,
		TabList = self.TabList
	})

	local function isDestroyed()
		return self.rayfieldDestroyed and self.rayfieldDestroyed()
	end

	local function isBlocked()
		if isDestroyed() then
			return true
		end
		if type(self.getBlockedState) == "function" then
			local ok, result = pcall(self.getBlockedState)
			if ok and result then
				return true
			end
		end
		return false
	end

	local function safeNotify(data)
		if type(self.Notify) == "function" then
			pcall(self.Notify, data)
		end
	end

	local function ensureSharedInput()
		stateManager.ensureSharedInput()
	end

	local function registerSharedInput(id, onChanged, onEnded)
		stateManager.registerSharedInput(id, onChanged, onEnded)
	end

	local function unregisterSharedInput(id)
		stateManager.unregisterSharedInput(id)
	end

	local function disconnectSharedInput()
		stateManager.disconnectSharedInput()
	end

	local function getInputPosition(input)
		return stateManager.getInputPosition(input)
	end

	local function isPointInside(guiObject, point, padding)
		return stateManager.isPointInside(guiObject, point, padding)
	end

	local function isPointInsideMain(point)
		return stateManager.isPointInsideMain(point)
	end

	local function isPointInsideTabList(point)
		return stateManager.isPointInsideTabList(point)
	end

	local function clampPositionToViewport(root, desiredPosition, panelSize)
		return stateManager.clampPositionToViewport(root, desiredPosition, panelSize, PANEL_MARGIN)
	end

	local function hasZIndex(guiObject)
		return stateManager.hasZIndex(guiObject)
	end

	local function getOriginalZState(tabRecord)
		local state = tabZIndexState[tabRecord]
		if state then
			return state
		end

		state = {
			Original = setmetatable({}, { __mode = "k" }),
			DescendantConn = nil,
			LastBaseZ = 200,
			LastAppliedBase = nil
		}
		tabZIndexState[tabRecord] = state
		return state
	end

	local function captureOriginalZIndex(tabRecord)
		if not (tabRecord and tabRecord.TabPage) then
			return
		end

		local state = getOriginalZState(tabRecord)
		local objects = { tabRecord.TabPage }
		for _, descendant in ipairs(tabRecord.TabPage:GetDescendants()) do
			table.insert(objects, descendant)
		end

		for _, object in ipairs(objects) do
			if hasZIndex(object) and state.Original[object] == nil then
				state.Original[object] = object.ZIndex
			end
		end
	end

	local function applySplitZIndex(tabRecord, zBase)
		if not (tabRecord and tabRecord.TabPage) then
			return
		end

		local state = getOriginalZState(tabRecord)
		local nextBase = zBase or state.LastBaseZ or 200
		state.LastBaseZ = nextBase

		captureOriginalZIndex(tabRecord)

		if state.LastAppliedBase ~= nextBase then
			for object, original in pairs(state.Original) do
				if object and object.Parent and hasZIndex(object) then
					object.ZIndex = nextBase + original
				end
			end
			state.LastAppliedBase = nextBase
		end

		if not state.DescendantConn then
			state.DescendantConn = tabRecord.TabPage.DescendantAdded:Connect(function(descendant)
				if not tabRecord.IsSplit then
					return
				end
				if not hasZIndex(descendant) then
					return
				end
				if state.Original[descendant] == nil then
					state.Original[descendant] = descendant.ZIndex
				end
				descendant.ZIndex = state.LastBaseZ + state.Original[descendant]
			end)
		end
	end

	local function restoreOriginalZIndex(tabRecord)
		local state = tabZIndexState[tabRecord]
		if not state then
			return
		end

		if state.DescendantConn then
			state.DescendantConn:Disconnect()
			state.DescendantConn = nil
		end

		for object, original in pairs(state.Original) do
			if object and object.Parent and hasZIndex(object) then
				object.ZIndex = original
			end
		end

		tabZIndexState[tabRecord] = nil
	end

	local function getPanelSize(root)
		local viewport = root.AbsoluteSize
		local mainSize = self.Main.AbsoluteSize

		local panelWidth = math.clamp(math.floor(mainSize.X * 0.68), 250, 420)
		local panelHeight = math.clamp(math.floor(mainSize.Y), 180, math.max(180, viewport.Y - 12))
		return Vector2.new(panelWidth, panelHeight)
	end

	local function setPanelLayer(panelData, baseZ)
		panelData.LayerZ = baseZ
		panelData.Frame.ZIndex = baseZ
		panelData.Header.ZIndex = baseZ + 1
		panelData.Content.ZIndex = baseZ + 1
		panelData.Title.ZIndex = baseZ + 2
		panelData.DockButton.ZIndex = baseZ + 2
		applySplitZIndex(panelData.TabRecord, baseZ + 2)
	end

	local setPanelHoverState
	local applyPanelTheme

	local function ensureSplitRoot()
		if splitRoot and splitRoot.Parent then
			return splitRoot
		end

		splitRoot = Instance.new("Frame")
		splitRoot.Name = "TabSplitRoot"
		splitRoot.BackgroundTransparency = 1
		splitRoot.BorderSizePixel = 0
		splitRoot.Size = UDim2.fromScale(1, 1)
		splitRoot.ZIndex = 180
		splitRoot.Visible = (not splitHidden) and (not splitMinimized)
		splitRoot.Parent = self.Rayfield

		table.insert(rootConnections, self.Main:GetPropertyChangedSignal("AbsolutePosition"):Connect(function()
			self.layoutPanels()
		end))
		table.insert(rootConnections, self.Main:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
			self.layoutPanels()
		end))
		table.insert(rootConnections, self.Rayfield:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
			self.layoutPanels()
		end))
		table.insert(rootConnections, self.Main:GetPropertyChangedSignal("BackgroundColor3"):Connect(function()
			for _, panelData in pairs(splitPanels) do
				if panelData then
					applyPanelTheme(panelData)
				end
			end
		end))

		return splitRoot
	end

	local function refreshRootVisibility()
		if splitRoot and splitRoot.Parent then
			splitRoot.Visible = (not splitHidden) and (not splitMinimized)
		end
	end

	if enabled then
		task.defer(function()
			if isDestroyed() then
				return
			end
			ensureSplitRoot()
			refreshRootVisibility()
		end)
	end

	local function createGhost(text, position)
		local root = ensureSplitRoot()
		local theme = self.getSelectedTheme and self.getSelectedTheme()

		local ghost = Instance.new("Frame")
		ghost.Name = "TabSplitGhost"
		ghost.BackgroundColor3 = (theme and theme.ElementBackground) or Color3.fromRGB(35, 35, 35)
		ghost.BackgroundTransparency = 0.18
		ghost.BorderSizePixel = 0
		ghost.Size = UDim2.fromOffset(170, 28)
		ghost.Position = UDim2.fromOffset(position.X - 85, position.Y - 14)
		ghost.ZIndex = 240
		ghost.Parent = root

		local corner = Instance.new("UICorner")
		corner.CornerRadius = UDim.new(0, 7)
		corner.Parent = ghost

		local stroke = Instance.new("UIStroke")
		stroke.Thickness = 1.2
		stroke.Transparency = 0.2
		stroke.Color = (theme and theme.ElementStroke) or Color3.fromRGB(90, 90, 90)
		stroke.Parent = ghost

		local label = Instance.new("TextLabel")
		label.BackgroundTransparency = 1
		label.Size = UDim2.new(1, -10, 1, 0)
		label.Position = UDim2.new(0, 5, 0, 0)
		label.Text = text
		label.Font = Enum.Font.GothamSemibold
		label.TextSize = 11
		label.TextXAlignment = Enum.TextXAlignment.Left
		label.TextColor3 = (theme and theme.TextColor) or Color3.fromRGB(255, 255, 255)
		label.ZIndex = ghost.ZIndex + 1
		label.Parent = ghost

		return ghost
	end

	local function updateGhostPosition(ghost, point)
		if ghost and ghost.Parent and point then
			ghost.Position = UDim2.fromOffset(point.X - math.floor(ghost.AbsoluteSize.X / 2), point.Y - math.floor(ghost.AbsoluteSize.Y / 2))
		end
	end

	local function clearGhost(ghost)
		if ghost and ghost.Parent then
			self.Animation:Create(ghost, TweenInfo.new(0.08, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
				BackgroundTransparency = 1
			}):Play()
			task.delay(0.09, function()
				if ghost and ghost.Parent then
					ghost:Destroy()
				end
			end)
		end
	end

	if enabled then
		task.defer(function()
			if isDestroyed() then
				return
			end
			local warmGhost = createGhost("", Vector2.new(-9999, -9999))
			if warmGhost then
				warmGhost:Destroy()
			end
		end)
	end

	local function getSplitPanelCount()
		return #panelOrder
	end

	local function canSplitTab(tabRecord)
		if not enabled then
			return false, "Tab split is disabled for this window."
		end
		if isBlocked() then
			return false, "Tab split is temporarily blocked while UI is busy."
		end
		if not tabRecord then
			return false, "Rayfield Mod: Invalid Tab ID in Splitter"
		end
		if tabRecord.IsSplit then
			return false, "This tab is already split."
		end
		if tabRecord.Name == "Rayfield Settings" and tabRecord.Ext and not allowSettingsSplit then
			return false, "Splitting Rayfield Settings is disabled."
		end
		if maxSplitTabs and getSplitPanelCount() >= maxSplitTabs then
			return false, "Reached max split tabs: " .. tostring(maxSplitTabs)
		end
		local dockedCount = 0
		for _, record in ipairs(tabRecords) do
			if not record.IsSplit and record.TabPage and record.TabPage.Parent == self.Elements then
				dockedCount += 1
			end
		end
		if dockedCount <= 1 then
			return false, "At least one tab must remain in main UI."
		end
		return true
	end

	local function chooseFallbackTab(excluded)
		for _, record in ipairs(tabRecords) do
			if record ~= excluded and not record.IsSplit and record.TabPage and record.TabPage.Parent == self.Elements then
				return record
			end
		end
		return nil
	end

	local function getTabPersistenceId(tabRecord)
		if not tabRecord then
			return nil
		end
		if type(tabRecord.PersistenceId) == "string" and tabRecord.PersistenceId ~= "" then
			return tabRecord.PersistenceId
		end
		if type(tabRecord.Name) == "string" and tabRecord.Name ~= "" then
			return tabRecord.Name
		end
		return nil
	end

	local function getVirtualHostId(tabRecord)
		local persistenceId = getTabPersistenceId(tabRecord)
		if not persistenceId then
			return nil
		end
		return "tab:" .. tostring(persistenceId)
	end

	local function virtualRegisterHost(tabRecord)
		if not (viewportVirtualization and type(viewportVirtualization.registerHost) == "function") then
			return
		end
		local hostId = getVirtualHostId(tabRecord)
		if hostId and tabRecord and tabRecord.TabPage and tabRecord.TabPage.Parent then
			pcall(viewportVirtualization.registerHost, hostId, tabRecord.TabPage, {
				mode = "auto"
			})
		end
	end

	local function virtualUnregisterHost(tabRecord)
		if not (viewportVirtualization and type(viewportVirtualization.unregisterHost) == "function") then
			return
		end
		local hostId = getVirtualHostId(tabRecord)
		if hostId then
			pcall(viewportVirtualization.unregisterHost, hostId)
		end
	end

	local function virtualRefreshHost(tabRecord, reason)
		if not (viewportVirtualization and type(viewportVirtualization.refreshHost) == "function") then
			return
		end
		local hostId = getVirtualHostId(tabRecord)
		if hostId then
			pcall(viewportVirtualization.refreshHost, hostId, reason or "tabsplit_refresh")
		end
	end

	local function virtualSetHostSuppressed(tabRecord, suppressed, reason)
		if not (viewportVirtualization and type(viewportVirtualization.setHostSuppressed) == "function") then
			return
		end
		local hostId = getVirtualHostId(tabRecord)
		if hostId then
			pcall(viewportVirtualization.setHostSuppressed, hostId, suppressed == true)
			if suppressed ~= true then
				pcall(viewportVirtualization.refreshHost, hostId, reason or "tabsplit_unsuppress")
			end
		end
	end

	setPanelHoverState = function(panelData, active, instant)
		if not (panelData and panelData.Frame and panelData.Frame.Parent) then
			return
		end

		panelData.HoverActive = active and true or false

		local theme = self.getSelectedTheme and self.getSelectedTheme()
		local accent = (theme and theme.SliderProgress) or Color3.fromRGB(112, 189, 255)
		local strokeColor = (theme and theme.ElementStroke) or Color3.fromRGB(85, 85, 85)

		if panelData.GlowStroke then
			panelData.GlowStroke.Color = accent
		end
		if panelData.SoftGlowStroke then
			panelData.SoftGlowStroke.Color = accent
		end
		if panelData.Stroke then
			panelData.Stroke.Color = active and accent:Lerp(strokeColor, 0.35) or strokeColor
		end

		local duration = instant and 0 or 0.12
		if panelData.Stroke then
			self.Animation:Create(panelData.Stroke, TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
				Thickness = active and 1.35 or 1,
				Transparency = active and 0.22 or 0.35
			}):Play()
		end
		if panelData.GlowStroke then
			self.Animation:Create(panelData.GlowStroke, TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
				Thickness = active and 2.8 or 1.1,
				Transparency = active and 0.62 or 1
			}):Play()
		end
		if panelData.SoftGlowStroke then
			self.Animation:Create(panelData.SoftGlowStroke, TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
				Thickness = active and 4.6 or 2.8,
				Transparency = active and 0.84 or 1
			}):Play()
		end
	end

	applyPanelTheme = function(panelData)
		if not panelData then
			return
		end
		local theme = self.getSelectedTheme and self.getSelectedTheme()
		if not theme then
			return
		end

		panelData.Frame.BackgroundColor3 = theme.SecondaryElementBackground or panelData.Frame.BackgroundColor3
		panelData.Header.BackgroundColor3 = theme.Topbar or panelData.Header.BackgroundColor3
		panelData.Title.TextColor3 = theme.TextColor or panelData.Title.TextColor3
		panelData.DockButton.BackgroundColor3 = theme.ElementBackgroundHover or panelData.DockButton.BackgroundColor3
		panelData.DockButton.TextColor3 = theme.TextColor or panelData.DockButton.TextColor3
		setPanelHoverState(panelData, panelData.HoverActive or panelData.Dragging, true)
	end

	local function removePanelOrderEntry(panelId)
		if type(TabSplitReorderLib) == "table" and type(TabSplitReorderLib.removePanel) == "function" then
			local ok, removed = pcall(TabSplitReorderLib.removePanel, panelOrder, panelId)
			if ok then
				return removed == true
			end
		end

		for i = #panelOrder, 1, -1 do
			if panelOrder[i] == panelId then
				table.remove(panelOrder, i)
				return true
			end
		end
		return false
	end

	local function appendPanelOrderEntry(panelId)
		if type(TabSplitReorderLib) == "table" and type(TabSplitReorderLib.appendPanel) == "function" then
			local ok, appended = pcall(TabSplitReorderLib.appendPanel, panelOrder, panelId)
			if ok and appended then
				return true
			end
		end

		removePanelOrderEntry(panelId)
		table.insert(panelOrder, panelId)
		return true
	end

	local function removePanelRecord(panelId)
		removePanelOrderEntry(panelId)
		splitPanels[panelId] = nil
	end

	local function cleanupPanel(panelData)
		if not panelData then
			return
		end

		if panelData.InputId then
			unregisterSharedInput(panelData.InputId)
		end

		if panelData.Cleanup then
			for _, cleanupFn in ipairs(panelData.Cleanup) do
				pcall(cleanupFn)
			end
			table.clear(panelData.Cleanup)
		end

		if panelData.Frame and panelData.Frame.Parent then
			panelData.Frame:Destroy()
		end
	end

	local function bringPanelToFront(panelData)
		if not panelData then
			return
		end

		if type(TabSplitReorderLib) == "table" and type(TabSplitReorderLib.bringToFront) == "function" then
			local ok, moved = pcall(TabSplitReorderLib.bringToFront, panelOrder, panelData.Id)
			if not ok or not moved then
				appendPanelOrderEntry(panelData.Id)
			end
		else
			appendPanelOrderEntry(panelData.Id)
		end
		self.layoutPanels()
	end

	local function attachPanelDrag(panelData)
		TabSplitDragDockLib.attachPanelDrag(panelData, {
			dragThreshold = DRAG_THRESHOLD,
			isBlocked = isBlocked,
			getInputPosition = getInputPosition,
			isPointInside = isPointInside,
			bringPanelToFront = bringPanelToFront,
			setPanelHoverState = setPanelHoverState,
			isPointInsideTabList = isPointInsideTabList,
			dockTab = function(tabRecord)
				self.dockTab(tabRecord)
			end,
			ensureSplitRoot = ensureSplitRoot,
			getPanelSize = getPanelSize,
			clampPositionToViewport = clampPositionToViewport,
			layoutPanels = function()
				self.layoutPanels()
			end,
			registerSharedInput = registerSharedInput
		})
	end

	local function createPanelShell(tabRecord)
		local root = ensureSplitRoot()
		splitIndex += 1
		local panelId = self.HttpService:GenerateGUID(false) .. "-" .. tostring(splitIndex)
		local theme = self.getSelectedTheme and self.getSelectedTheme()
		local panelData = TabSplitPanelLib.createShell({
			root = root,
			panelId = panelId,
			tabRecord = tabRecord,
			theme = theme,
			inputId = self.HttpService:GenerateGUID(false),
			baseZ = 190,
			setPanelHoverState = setPanelHoverState
		})

		table.insert(panelData.Cleanup, panelData.DockButton.MouseButton1Click:Connect(function()
			self.dockTab(tabRecord)
		end))

		applyPanelTheme(panelData)
		attachPanelDrag(panelData)
		return panelData
	end

	function self.layoutPanels()
		if isDestroyed() then
			return
		end

		local root = ensureSplitRoot()
		if not root or not root.Parent then
			return
		end

		if #panelOrder <= 0 then
			return
		end

		local panelSize = getPanelSize(root)
		local mainPos = self.Main.AbsolutePosition
		local mainSize = self.Main.AbsoluteSize

		local rightX = mainPos.X + mainSize.X + 16
		local leftX = mainPos.X - panelSize.X - 16
		local baseX = rightX
		if baseX + panelSize.X > root.AbsoluteSize.X - PANEL_MARGIN then
			baseX = math.max(PANEL_MARGIN, leftX)
		end

		for index, panelId in ipairs(panelOrder) do
			local panelData = splitPanels[panelId]
			if panelData and panelData.Frame and panelData.Frame.Parent then
				local baseZ = 190 + ((index - 1) * 8)
				setPanelLayer(panelData, baseZ)
				panelData.Frame.Size = UDim2.fromOffset(panelSize.X, panelSize.Y)

				if not panelData.Dragging then
					if panelData.ManualPosition then
						local clampedManual = clampPositionToViewport(root, panelData.ManualPosition, panelSize)
						panelData.ManualPosition = clampedManual
						panelData.Frame.Position = UDim2.fromOffset(clampedManual.X, clampedManual.Y)
					else
						local step = index - 1
						local targetX = math.clamp(baseX + ((step % 2) * 18), PANEL_MARGIN, math.max(PANEL_MARGIN, root.AbsoluteSize.X - panelSize.X - PANEL_MARGIN))
						local targetY = math.clamp(mainPos.Y + (step * 26), PANEL_MARGIN, math.max(PANEL_MARGIN, root.AbsoluteSize.Y - panelSize.Y - PANEL_MARGIN))
						self.Animation:Create(panelData.Frame, TweenInfo.new(0.16, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
							Position = UDim2.fromOffset(targetX, targetY)
						}):Play()
					end
				end
			end
		end

		notifyLayoutDirty("layout_panels")
	end

	function self.splitTab(tabRecord, dropPoint)
		local allowed, reason = canSplitTab(tabRecord)
		if not allowed then
			if reason then
				safeNotify({
					Title = "Tab Split",
					Content = reason,
					Duration = 3
				})
			end
			return false
		end

		if not (tabRecord.TabPage and tabRecord.TabButton and tabRecord.TabPage.Parent) then
			return false
		end

		if isPointInsideMain(dropPoint) then
			return false
		end

		if self.Elements.UIPageLayout.CurrentPage == tabRecord.TabPage then
			local fallback = chooseFallbackTab(tabRecord)
			if fallback and type(fallback.Activate) == "function" then
				fallback.Activate(true)
			end
		end

		local panelData = createPanelShell(tabRecord)
		splitPanels[panelData.Id] = panelData
		appendPanelOrderEntry(panelData.Id)
		tabToPanel[tabRecord] = panelData.Id

		local root = ensureSplitRoot()
		local panelSize = getPanelSize(root)
		local splitDropPoint = dropPoint or getInputPosition()
		local desiredStart = Vector2.new(
			splitDropPoint.X - math.floor(panelSize.X * 0.5),
			splitDropPoint.Y - 14
		)
		panelData.ManualPosition = clampPositionToViewport(root, desiredStart, panelSize)
		panelData.Frame.Position = UDim2.fromOffset(panelData.ManualPosition.X, panelData.ManualPosition.Y)

		tabRecord.IsSplit = true
		tabRecord.SplitPanelId = panelData.Id

		tabRecord.TabButton.Visible = false
		local interact = tabRecord.TabButton:FindFirstChild("Interact")
		if interact then
			interact.Visible = false
		end

		tabRecord.TabPage.Parent = panelData.Content
		tabRecord.TabPage.AnchorPoint = Vector2.zero
		tabRecord.TabPage.Position = UDim2.new(0, 0, 0, 0)
		tabRecord.TabPage.Size = UDim2.new(1, 0, 1, 0)
		tabRecord.TabPage.Visible = true
		tabRecord.TabPage.Active = true
		panelData.Content.Active = true
		panelData.Content.ClipsDescendants = true
		virtualSetHostSuppressed(tabRecord, splitHidden or splitMinimized, "tab_split")
		virtualRefreshHost(tabRecord, "tab_split")

		captureOriginalZIndex(tabRecord)
		bringPanelToFront(panelData)
		self.layoutPanels()
		refreshRootVisibility()
		self.syncMinimized(splitMinimized)
		notifyLayoutDirty("tab_split")

		return true
	end

	function self.dockTab(tabRecord)
		if not tabRecord then
			return false, "Rayfield Mod: Invalid Tab ID in Splitter"
		end

		local panelId = tabToPanel[tabRecord] or tabRecord.SplitPanelId
		if not panelId then
			return false, "Rayfield Mod: Tab is not currently split"
		end

		local panelData = splitPanels[panelId]
		if not panelData then
			tabRecord.IsSplit = false
			tabRecord.SplitPanelId = nil
			tabToPanel[tabRecord] = nil
			restoreOriginalZIndex(tabRecord)
			return false, "Rayfield Mod: Invalid Tab ID in Splitter (stale split panel)"
		end

		if tabRecord.TabPage then
			tabRecord.TabPage.Parent = self.Elements
			tabRecord.TabPage.AnchorPoint = Vector2.zero
			tabRecord.TabPage.Position = UDim2.new(0, 0, 0, 0)
			tabRecord.TabPage.Size = UDim2.new(1, 0, 1, 0)
			tabRecord.TabPage.Visible = true
			tabRecord.TabPage.Active = true
			virtualSetHostSuppressed(tabRecord, false, "tab_dock")
			virtualRefreshHost(tabRecord, "tab_dock")
		end

		restoreOriginalZIndex(tabRecord)

		if tabRecord.TabButton then
			local shouldBeVisible = tabRecord.DefaultVisible
			if shouldBeVisible == nil then
				shouldBeVisible = true
			end
			tabRecord.TabButton.Visible = shouldBeVisible
			local interact = tabRecord.TabButton:FindFirstChild("Interact")
			if interact then
				interact.Visible = shouldBeVisible
			end
		end

		tabRecord.IsSplit = false
		tabRecord.SplitPanelId = nil
		tabToPanel[tabRecord] = nil

		removePanelRecord(panelId)
		cleanupPanel(panelData)

		if type(tabRecord.Activate) == "function" then
			tabRecord.Activate(true)
		end

		self.layoutPanels()
		notifyLayoutDirty("tab_dock")
		return true
	end

	local function unregisterTab(tabRecord)
		local cleanup = tabGestureCleanup[tabRecord]
		if not cleanup then
			return
		end

		if cleanup.InputId then
			unregisterSharedInput(cleanup.InputId)
		end
		if cleanup.Connections then
			for _, connection in ipairs(cleanup.Connections) do
				if connection then
					connection:Disconnect()
				end
			end
			table.clear(cleanup.Connections)
		end
		if cleanup.ClearVisuals then
			pcall(cleanup.ClearVisuals)
		end

		tabGestureCleanup[tabRecord] = nil
		for i = #tabRecords, 1, -1 do
			if tabRecords[i] == tabRecord then
				table.remove(tabRecords, i)
				break
			end
		end
		virtualUnregisterHost(tabRecord)
	end

	function self.registerTab(tabRecord)
		if not tabRecord or tabGestureCleanup[tabRecord] then
			return
		end
		if not (tabRecord.TabButton and tabRecord.TabButton.Parent) then
			return
		end

		table.insert(tabRecords, tabRecord)
		tabRecord.IsSplit = false
		tabRecord.SplitPanelId = nil
		tabRecord.SuppressNextClick = false
		virtualRegisterHost(tabRecord)
		virtualSetHostSuppressed(tabRecord, splitHidden or splitMinimized, "tab_register")
		virtualRefreshHost(tabRecord, "tab_register")
		captureOriginalZIndex(tabRecord)

		local interact = tabRecord.TabButton:FindFirstChild("Interact")
		if not interact then
			return
		end

		local inputId = self.HttpService:GenerateGUID(false)
		local connections = {}
		local state = {
			pressing = false,
			dragArmed = false,
			pressInput = nil,
			pointer = nil,
			holdToken = 0,
			ghost = nil,
			ghostTarget = nil,
			ghostFollowConnection = nil,
			hoverCounter = 0,
			hoverActive = false,
			cueFrame = nil,
			cueStroke = nil,
			cueGlowStroke = nil,
			cueBlurStroke = nil,
			cueThemeConnection = nil
		}

		local function getCueColor()
			local theme = self.getSelectedTheme and self.getSelectedTheme()
			return (theme and theme.SliderProgress) or Color3.fromRGB(112, 189, 255)
		end

		local function ensureCue()
			if isDestroyed() or not (tabRecord.TabButton and tabRecord.TabButton.Parent) then
				return false
			end

			if state.cueFrame
				and state.cueFrame.Parent
				and state.cueStroke
				and state.cueGlowStroke
				and (REDUCED_EFFECTS or state.cueBlurStroke)
			then
				return true
			end

			if state.cueThemeConnection then
				state.cueThemeConnection:Disconnect()
				state.cueThemeConnection = nil
			end

			state.cueFrame = Instance.new("Frame")
			state.cueFrame.Name = "TabSplitCue"
			state.cueFrame.BackgroundTransparency = 1
			state.cueFrame.BorderSizePixel = 0
			state.cueFrame.Size = UDim2.fromScale(1, 1)
			state.cueFrame.Position = UDim2.fromOffset(0, 0)
			state.cueFrame.ZIndex = tabRecord.TabButton.ZIndex + 8
			state.cueFrame.Active = false
			state.cueFrame.Parent = tabRecord.TabButton

			local sourceCorner = tabRecord.TabButton:FindFirstChildOfClass("UICorner")
			if sourceCorner then
				local cueCorner = Instance.new("UICorner")
				cueCorner.CornerRadius = sourceCorner.CornerRadius
				cueCorner.Parent = state.cueFrame
			end

			state.cueStroke = Instance.new("UIStroke")
			state.cueStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
			state.cueStroke.Color = getCueColor()
			state.cueStroke.Thickness = TAB_CUE_IDLE_THICKNESS
			state.cueStroke.Transparency = 1
			state.cueStroke.Parent = state.cueFrame

			state.cueGlowStroke = Instance.new("UIStroke")
			state.cueGlowStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
			state.cueGlowStroke.Color = getCueColor()
			state.cueGlowStroke.Thickness = TAB_CUE_IDLE_THICKNESS + 1.4
			state.cueGlowStroke.Transparency = 1
			state.cueGlowStroke.Parent = state.cueFrame

			if not REDUCED_EFFECTS then
				state.cueBlurStroke = Instance.new("UIStroke")
				state.cueBlurStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
				state.cueBlurStroke.Color = getCueColor()
				state.cueBlurStroke.Thickness = TAB_CUE_IDLE_THICKNESS + 3.2
				state.cueBlurStroke.Transparency = 1
				state.cueBlurStroke.Parent = state.cueFrame
			else
				state.cueBlurStroke = nil
			end

			state.cueThemeConnection = self.Main:GetPropertyChangedSignal("BackgroundColor3"):Connect(function()
				local cueColor = getCueColor()
				if state.cueStroke and state.cueStroke.Parent then
					state.cueStroke.Color = cueColor
				end
				if state.cueGlowStroke and state.cueGlowStroke.Parent then
					state.cueGlowStroke.Color = cueColor
				end
				if state.cueBlurStroke and state.cueBlurStroke.Parent then
					state.cueBlurStroke.Color = cueColor
				end
			end)

			return true
		end

		local function setCue(transparency, thickness, duration)
			if not ensureCue() or not (state.cueStroke and state.cueStroke.Parent) then
				return
			end

			local glowTransparency = (transparency >= 0.99)
				and 1
				or math.clamp(transparency + 0.34, 0.45, 0.98)
			local glowThickness = thickness + 1.4
			local blurTransparency = (transparency >= 0.99)
				and 1
				or math.clamp(transparency + 0.52, 0.7, 0.995)
			local blurThickness = thickness + 3.2

			if not duration or duration <= 0 then
				state.cueStroke.Transparency = transparency
				state.cueStroke.Thickness = thickness
				if state.cueGlowStroke and state.cueGlowStroke.Parent then
					state.cueGlowStroke.Transparency = glowTransparency
					state.cueGlowStroke.Thickness = glowThickness
				end
				if (not REDUCED_EFFECTS) and state.cueBlurStroke and state.cueBlurStroke.Parent then
					state.cueBlurStroke.Transparency = blurTransparency
					state.cueBlurStroke.Thickness = blurThickness
				end
				return
			end

			self.Animation:Create(state.cueStroke, TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
				Transparency = transparency,
				Thickness = thickness
			}):Play()

			if state.cueGlowStroke and state.cueGlowStroke.Parent then
				self.Animation:Create(state.cueGlowStroke, TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
					Transparency = glowTransparency,
					Thickness = glowThickness
				}):Play()
			end
			if (not REDUCED_EFFECTS) and state.cueBlurStroke and state.cueBlurStroke.Parent then
				self.Animation:Create(state.cueBlurStroke, TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
					Transparency = blurTransparency,
					Thickness = blurThickness
				}):Play()
			end
		end

		local function refreshCue()
			if tabRecord.IsSplit then
				setCue(1, TAB_CUE_IDLE_THICKNESS, 0.08)
				return
			end

			if state.dragArmed then
				setCue(TAB_CUE_READY_TRANSPARENCY, TAB_CUE_READY_THICKNESS, 0.08)
				return
			end

			if state.pressing then
				setCue(TAB_CUE_HOLD_TRANSPARENCY, TAB_CUE_HOLD_THICKNESS, 0.08)
				return
			end

			if state.hoverActive then
				setCue(TAB_CUE_HOVER_TRANSPARENCY, TAB_CUE_HOVER_THICKNESS, 0.12)
			else
				setCue(1, TAB_CUE_IDLE_THICKNESS, 0.12)
			end
		end

		local function runCueProgress(token)
			local started = os.clock()
			while state.pressing and state.holdToken == token and not state.dragArmed and not tabRecord.IsSplit do
				local progress = math.clamp((os.clock() - started) / holdDuration, 0, 1)
				local transparency = TAB_CUE_HOVER_TRANSPARENCY + ((TAB_CUE_HOLD_TRANSPARENCY - TAB_CUE_HOVER_TRANSPARENCY) * progress)
				local thickness = TAB_CUE_HOVER_THICKNESS + ((TAB_CUE_HOLD_THICKNESS - TAB_CUE_HOVER_THICKNESS) * progress)
				setCue(transparency, thickness, 0)
				task.wait()
			end
		end

		local function cleanupCue()
			if state.cueThemeConnection then
				state.cueThemeConnection:Disconnect()
				state.cueThemeConnection = nil
			end
			if state.cueFrame and state.cueFrame.Parent then
				state.cueFrame:Destroy()
			end
			state.cueFrame = nil
			state.cueStroke = nil
			state.cueGlowStroke = nil
			state.cueBlurStroke = nil
		end

		local function stopGhostFollow()
			if state.ghostFollowConnection then
				state.ghostFollowConnection:Disconnect()
				state.ghostFollowConnection = nil
			end
		end

		local function startGhostFollow()
			stopGhostFollow()
			state.ghostFollowConnection = self.RunService.RenderStepped:Connect(function(deltaTime)
				if not (state.ghost and state.ghost.Parent and state.ghostTarget) then
					return
				end

				local halfWidth = math.floor(state.ghost.AbsoluteSize.X * 0.5)
				local halfHeight = math.floor(state.ghost.AbsoluteSize.Y * 0.5)
				local desired = Vector2.new(state.ghostTarget.X - halfWidth, state.ghostTarget.Y - halfHeight)
				local current = Vector2.new(state.ghost.Position.X.Offset, state.ghost.Position.Y.Offset)
				local alpha = math.clamp(deltaTime * (TAB_GHOST_FOLLOW_SPEED * 60), 0, 1)
				local nextPosition = current:Lerp(desired, alpha)

				state.ghost.Position = UDim2.fromOffset(math.floor(nextPosition.X + 0.5), math.floor(nextPosition.Y + 0.5))
			end)
		end

		local function clearVisuals()
			stopGhostFollow()
			clearGhost(state.ghost)
			state.ghost = nil
			state.ghostTarget = nil
			cleanupCue()
		end

		local function beginPress(input)
			if isBlocked() then
				return
			end

			state.pressing = true
			state.dragArmed = false
			state.pressInput = input
			state.pointer = getInputPosition(input)
			state.ghostTarget = state.pointer
			state.holdToken += 1
			local token = state.holdToken

			refreshCue()
			task.spawn(runCueProgress, token)

			task.delay(holdDuration, function()
				if token ~= state.holdToken or not state.pressing then
					return
				end

				local allowed, reason = canSplitTab(tabRecord)
				if not allowed then
					if reason and reason ~= "This tab is already split." then
						safeNotify({
							Title = "Tab Split",
							Content = reason,
							Duration = 2.8
						})
					end
					tabRecord.SuppressNextClick = true
					refreshCue()
					return
				end

				state.dragArmed = true
				tabRecord.SuppressNextClick = true
				refreshCue()
				state.ghost = createGhost("Split: " .. tostring(tabRecord.Name), state.pointer)
				state.ghostTarget = state.pointer
				startGhostFollow()
			end)
		end

		local function finishPress(input)
			if not state.pressInput then
				return
			end

			local sameTouch = input == state.pressInput
			local mouseEnded = state.pressInput.UserInputType == Enum.UserInputType.MouseButton1 and input.UserInputType == Enum.UserInputType.MouseButton1
			if not sameTouch and not mouseEnded then
				return
			end

			state.pressing = false
			state.pressInput = nil
			state.holdToken += 1

			if state.dragArmed then
				state.dragArmed = false
				stopGhostFollow()
				local dropPoint = state.pointer or getInputPosition(input)
				clearGhost(state.ghost)
				state.ghost = nil
				state.ghostTarget = nil
				tabRecord.SuppressNextClick = true

				if not isPointInsideMain(dropPoint) then
					self.splitTab(tabRecord, dropPoint)
				end
			else
				stopGhostFollow()
				clearGhost(state.ghost)
				state.ghost = nil
				state.ghostTarget = nil
			end

			refreshCue()
		end

		table.insert(connections, interact.InputBegan:Connect(function(input)
			local inputType = input.UserInputType
			if inputType ~= Enum.UserInputType.MouseButton1 and inputType ~= Enum.UserInputType.Touch then
				return
			end
			beginPress(input)
		end))

		table.insert(connections, tabRecord.TabButton.AncestryChanged:Connect(function()
			if not tabRecord.TabButton:IsDescendantOf(game) then
				unregisterTab(tabRecord)
			end
		end))

		table.insert(connections, interact.MouseEnter:Connect(function()
			if tabRecord.IsSplit then
				return
			end
			state.hoverCounter += 1
			state.hoverActive = state.hoverCounter > 0
			refreshCue()
		end))

		table.insert(connections, interact.MouseLeave:Connect(function()
			state.hoverCounter = math.max(0, state.hoverCounter - 1)
			state.hoverActive = state.hoverCounter > 0
			if not state.pressing and not state.dragArmed then
				refreshCue()
			end
		end))

		registerSharedInput(inputId, function(input)
			if not state.pressing or not state.pressInput then
				return
			end

			local sameTouch = input == state.pressInput
			local mouseMove = state.pressInput.UserInputType == Enum.UserInputType.MouseButton1 and input.UserInputType == Enum.UserInputType.MouseMovement
			if not sameTouch and not mouseMove then
				return
			end

			state.pointer = getInputPosition(input)
			if state.dragArmed and state.ghost then
				state.ghostTarget = state.pointer
				updateGhostPosition(state.ghost, state.pointer)
			end
		end, finishPress)

		refreshCue()

		tabGestureCleanup[tabRecord] = {
			InputId = inputId,
			Connections = connections,
			ClearVisuals = clearVisuals
		}
	end

	function self.setLayoutDirtyCallback(callback)
		layoutDirtyCallback = type(callback) == "function" and callback or nil
	end

	function self.getLayoutSnapshot()
		local snapshot = {
			version = 1,
			panels = {}
		}

		for tabRecord, panelId in pairs(tabToPanel) do
			local persistenceId = getTabPersistenceId(tabRecord)
			local panelData = panelId and splitPanels[panelId] or nil
			if persistenceId and panelData and panelData.Frame and panelData.Frame.Parent then
				local frame = panelData.Frame
				local pos = frame.Position
				local size = frame.Size
				snapshot.panels[persistenceId] = {
					position = {
						x = pos.X.Offset,
						y = pos.Y.Offset
					},
					size = {
						x = size.X.Offset,
						y = size.Y.Offset
					}
				}
			end
		end

		return snapshot
	end

	function self.applyLayoutSnapshot(snapshot)
		if type(snapshot) ~= "table" then
			return false
		end

		local panels = snapshot.panels
		if type(panels) ~= "table" then
			return false
		end

		for _, tabRecord in ipairs(tabRecords) do
			local persistenceId = getTabPersistenceId(tabRecord)
			local panelLayout = persistenceId and panels[persistenceId] or nil
			if type(panelLayout) == "table" and panelLayout.position and not tabRecord.IsSplit then
				local size = panelLayout.size or {}
				local width = tonumber(size.x) or 300
				local height = tonumber(size.y) or 220
				local x = tonumber(panelLayout.position.x) or 0
				local y = tonumber(panelLayout.position.y) or 0
				local dropPoint = Vector2.new(
					x + math.floor(width * 0.5),
					y + 16
				)
				local splitOk = self.splitTab(tabRecord, dropPoint)
				if splitOk then
					local panelId = tabToPanel[tabRecord]
					local panelData = panelId and splitPanels[panelId] or nil
					if panelData and panelData.Frame and panelData.Frame.Parent then
						local root = ensureSplitRoot()
						local targetWidth = math.max(math.floor(width), 250)
						local targetHeight = math.max(math.floor(height), 180)
						local targetSize = Vector2.new(targetWidth, targetHeight)
						local clamped = clampPositionToViewport(root, Vector2.new(x, y), targetSize)
						panelData.ManualPosition = clamped
						panelData.Frame.Size = UDim2.fromOffset(targetWidth, targetHeight)
						panelData.Frame.Position = UDim2.fromOffset(clamped.X, clamped.Y)
					end
				end
			elseif panelLayout == nil and tabRecord.IsSplit then
				self.dockTab(tabRecord)
			end
		end

		self.layoutPanels()
		refreshRootVisibility()
		return true
	end

	function self.syncHidden(isHidden)
		splitHidden = isHidden and true or false
		refreshRootVisibility()
		for tabRecord, panelId in pairs(tabToPanel) do
			if panelId then
				virtualSetHostSuppressed(tabRecord, splitHidden or splitMinimized, "sync_hidden")
				if not splitHidden and not splitMinimized then
					virtualRefreshHost(tabRecord, "sync_hidden_visible")
				end
			end
		end
	end

	function self.syncMinimized(isMinimized)
		splitMinimized = isMinimized and true or false
		refreshRootVisibility()
		for _, panelData in pairs(splitPanels) do
			if panelData and panelData.Frame and panelData.Frame.Parent then
				panelData.Frame.Visible = (not splitHidden) and (not splitMinimized)
				if splitHidden or splitMinimized then
					panelData.HoverPanel = false
					panelData.HoverHeader = false
					panelData.HoverDock = false
					panelData.HoverActive = false
					panelData.Dragging = false
					setPanelHoverState(panelData, false, true)
				end
			end
		end
		for tabRecord, panelId in pairs(tabToPanel) do
			if panelId then
				virtualSetHostSuppressed(tabRecord, splitHidden or splitMinimized, "sync_minimized")
				if not splitHidden and not splitMinimized then
					virtualRefreshHost(tabRecord, "sync_minimized_visible")
				end
			end
		end
	end

	function self.destroy()
		for tabRecord, panelId in pairs(tabToPanel) do
			if panelId then
				restoreOriginalZIndex(tabRecord)
			end
		end

		for tabRecord, _ in pairs(tabGestureCleanup) do
			unregisterTab(tabRecord)
		end

		for _, panelData in pairs(splitPanels) do
			cleanupPanel(panelData)
		end

		for _, tabRecord in ipairs(tabRecords) do
			virtualUnregisterHost(tabRecord)
		end

		table.clear(splitPanels)
		table.clear(tabToPanel)
		table.clear(panelOrder)
		table.clear(tabRecords)

		local zRecords = {}
		for tabRecord, _ in pairs(tabZIndexState) do
			table.insert(zRecords, tabRecord)
		end
		for _, tabRecord in ipairs(zRecords) do
			restoreOriginalZIndex(tabRecord)
		end

		for _, connection in ipairs(rootConnections) do
			if connection then
				connection:Disconnect()
			end
		end
		table.clear(rootConnections)

		disconnectSharedInput()

		if splitRoot and splitRoot.Parent then
			splitRoot:Destroy()
		end
		splitRoot = nil
	end

	return self
end

return TabSplitModule
]])
put("src/feature/tabsplit/dragdock.lua", [[local TabSplitDragDock = {}

function TabSplitDragDock.attachPanelDrag(panelData, opts)
	local state = {
		pressing = false,
		dragging = false,
		pressInput = nil,
		startPointer = nil,
		startPosition = nil,
		pointer = nil
	}

	local function resetState()
		state.pressing = false
		state.dragging = false
		state.pressInput = nil
		state.startPointer = nil
		state.startPosition = nil
		state.pointer = nil
		panelData.Dragging = false
		opts.setPanelHoverState(panelData, panelData.HoverActive, false)
	end

	local function beginPress(input)
		if opts.isBlocked() or not (panelData.Frame and panelData.Frame.Parent) then
			return
		end

		local pointer = opts.getInputPosition(input)
		if opts.isPointInside(panelData.DockButton, pointer, 0) then
			return
		end

		state.pressing = true
		state.dragging = false
		state.pressInput = input
		state.startPointer = pointer
		state.pointer = pointer
		if panelData.ManualPosition then
			state.startPosition = panelData.ManualPosition
		else
			state.startPosition = Vector2.new(panelData.Frame.AbsolutePosition.X, panelData.Frame.AbsolutePosition.Y)
		end

		opts.bringPanelToFront(panelData)
	end

	local function finishPress(input)
		if not state.pressInput then
			return
		end

		local sameTouch = input == state.pressInput
		local mouseEnded = state.pressInput.UserInputType == Enum.UserInputType.MouseButton1 and input.UserInputType == Enum.UserInputType.MouseButton1
		if not sameTouch and not mouseEnded then
			return
		end

		local wasDragging = state.dragging
		local dropPoint = state.pointer or opts.getInputPosition(input)
		resetState()

		if not wasDragging then
			return
		end

		if opts.isPointInsideTabList(dropPoint) then
			opts.dockTab(panelData.TabRecord)
			return
		end

		local root = opts.ensureSplitRoot()
		local panelSize = opts.getPanelSize(root)
		local currentPosition = panelData.ManualPosition or Vector2.new(panelData.Frame.AbsolutePosition.X, panelData.Frame.AbsolutePosition.Y)
		local clamped = opts.clampPositionToViewport(root, currentPosition, panelSize)
		panelData.ManualPosition = clamped
		panelData.Frame.Position = UDim2.fromOffset(clamped.X, clamped.Y)
		opts.layoutPanels()
	end

	table.insert(panelData.Cleanup, panelData.Header.InputBegan:Connect(function(input)
		local inputType = input.UserInputType
		if inputType ~= Enum.UserInputType.MouseButton1 and inputType ~= Enum.UserInputType.Touch then
			return
		end
		beginPress(input)
	end))

	opts.registerSharedInput(panelData.InputId, function(input)
		if not state.pressing or not state.pressInput then
			return
		end

		local sameTouch = input == state.pressInput
		local mouseMove = state.pressInput.UserInputType == Enum.UserInputType.MouseButton1 and input.UserInputType == Enum.UserInputType.MouseMovement
		if not sameTouch and not mouseMove then
			return
		end

		state.pointer = opts.getInputPosition(input)
		local delta = state.pointer - state.startPointer
		if not state.dragging and delta.Magnitude >= opts.dragThreshold then
			state.dragging = true
			panelData.Dragging = true
			opts.setPanelHoverState(panelData, true, false)
		end

		if state.dragging then
			local root = opts.ensureSplitRoot()
			local panelSize = opts.getPanelSize(root)
			local desired = state.startPosition + delta
			local clamped = opts.clampPositionToViewport(root, desired, panelSize)
			panelData.ManualPosition = clamped
			panelData.Frame.Position = UDim2.fromOffset(clamped.X, clamped.Y)
		end
	end, finishPress)

	table.insert(panelData.Cleanup, resetState)
end

return TabSplitDragDock
]])
put("src/feature/tabsplit/hover-effects.lua", [[local HoverEffects = {}

function HoverEffects.resolveAccent(theme)
	theme = theme or {}
	return theme.SliderProgress or theme.TabStroke or Color3.fromRGB(110, 175, 240)
end

function HoverEffects.getHoverStrokeState(isHovered)
	if isHovered then
		return {
			thickness = 1.2,
			transparency = 0.35
		}
	end
	return {
		thickness = 1,
		transparency = 0.5
	}
end

return HoverEffects]])
put("src/feature/tabsplit/init.lua", [[local client = _G and _G.__RayfieldApiClient
if not client then
	error("Rayfield ApiClient is not initialized")
end

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
return client.fetchAndExecute(root .. "src/feature/tabsplit/controller.lua")]])
put("src/feature/tabsplit/layout-free-drag.lua", [[local LayoutFreeDrag = {}

function LayoutFreeDrag.clampToViewport(position, size, viewportSize, margin)
	margin = margin or 8
	local x = math.clamp(position.X.Offset, margin, math.max(margin, viewportSize.X - size.X.Offset - margin))
	local y = math.clamp(position.Y.Offset, margin, math.max(margin, viewportSize.Y - size.Y.Offset - margin))
	return UDim2.new(0, x, 0, y)
end

return LayoutFreeDrag]])
put("src/feature/tabsplit/panel.lua", [[local TabSplitPanel = {}

function TabSplitPanel.bindHover(panelData, syncPanelHover)
	table.insert(panelData.Cleanup, panelData.Frame.MouseEnter:Connect(function()
		panelData.HoverPanel = true
		syncPanelHover()
	end))
	table.insert(panelData.Cleanup, panelData.Frame.MouseLeave:Connect(function()
		panelData.HoverPanel = false
		syncPanelHover()
	end))
	table.insert(panelData.Cleanup, panelData.Header.MouseEnter:Connect(function()
		panelData.HoverHeader = true
		syncPanelHover()
	end))
	table.insert(panelData.Cleanup, panelData.Header.MouseLeave:Connect(function()
		panelData.HoverHeader = false
		syncPanelHover()
	end))
	table.insert(panelData.Cleanup, panelData.DockButton.MouseEnter:Connect(function()
		panelData.HoverDock = true
		syncPanelHover()
	end))
	table.insert(panelData.Cleanup, panelData.DockButton.MouseLeave:Connect(function()
		panelData.HoverDock = false
		syncPanelHover()
	end))
end

function TabSplitPanel.createShell(opts)
	local panel = Instance.new("Frame")
	panel.Name = "TabSplitPanel-" .. tostring(opts.tabRecord.Name)
	panel.BackgroundColor3 = (opts.theme and opts.theme.SecondaryElementBackground) or Color3.fromRGB(35, 35, 35)
	panel.BorderSizePixel = 0
	panel.ZIndex = opts.baseZ
	panel.Parent = opts.root

	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 9)
	corner.Parent = panel

	local stroke = Instance.new("UIStroke")
	stroke.Color = (opts.theme and opts.theme.ElementStroke) or Color3.fromRGB(80, 80, 80)
	stroke.Thickness = 1.1
	stroke.Transparency = 0.25
	stroke.Parent = panel

	local glowStroke = Instance.new("UIStroke")
	glowStroke.Color = (opts.theme and opts.theme.SliderProgress) or Color3.fromRGB(112, 189, 255)
	glowStroke.Thickness = 1.2
	glowStroke.Transparency = 1
	glowStroke.Parent = panel

	local softGlowStroke = Instance.new("UIStroke")
	softGlowStroke.Color = (opts.theme and opts.theme.SliderProgress) or Color3.fromRGB(112, 189, 255)
	softGlowStroke.Thickness = 2.8
	softGlowStroke.Transparency = 1
	softGlowStroke.Parent = panel

	local header = Instance.new("Frame")
	header.Name = "Header"
	header.BackgroundColor3 = (opts.theme and opts.theme.Topbar) or Color3.fromRGB(25, 25, 25)
	header.BorderSizePixel = 0
	header.Size = UDim2.new(1, 0, 0, 34)
	header.ZIndex = panel.ZIndex + 1
	header.Parent = panel
	header.Active = true

	local headerCorner = Instance.new("UICorner")
	headerCorner.CornerRadius = UDim.new(0, 9)
	headerCorner.Parent = header

	local title = Instance.new("TextLabel")
	title.Name = "Title"
	title.BackgroundTransparency = 1
	title.Size = UDim2.new(1, -96, 1, 0)
	title.Position = UDim2.new(0, 10, 0, 0)
	title.Text = tostring(opts.tabRecord.Name)
	title.TextColor3 = (opts.theme and opts.theme.TextColor) or Color3.fromRGB(255, 255, 255)
	title.Font = Enum.Font.GothamSemibold
	title.TextSize = 12
	title.TextXAlignment = Enum.TextXAlignment.Left
	title.ZIndex = header.ZIndex + 1
	title.Parent = header

	local dockButton = Instance.new("TextButton")
	dockButton.Name = "Dock"
	dockButton.Size = UDim2.fromOffset(64, 22)
	dockButton.Position = UDim2.new(1, -74, 0.5, -11)
	dockButton.BackgroundColor3 = (opts.theme and opts.theme.ElementBackgroundHover) or Color3.fromRGB(55, 55, 55)
	dockButton.BorderSizePixel = 0
	dockButton.Text = "Dock"
	dockButton.TextColor3 = (opts.theme and opts.theme.TextColor) or Color3.fromRGB(255, 255, 255)
	dockButton.Font = Enum.Font.GothamBold
	dockButton.TextSize = 10
	dockButton.ZIndex = header.ZIndex + 1
	dockButton.Parent = header

	local dockCorner = Instance.new("UICorner")
	dockCorner.CornerRadius = UDim.new(0, 6)
	dockCorner.Parent = dockButton

	local content = Instance.new("Frame")
	content.Name = "Content"
	content.BackgroundTransparency = 1
	content.BorderSizePixel = 0
	content.Position = UDim2.fromOffset(0, 34)
	content.Size = UDim2.new(1, 0, 1, -34)
	content.ClipsDescendants = true
	content.Active = true
	content.ZIndex = panel.ZIndex + 1
	content.Parent = panel

	local panelData = {
		Id = opts.panelId,
		Frame = panel,
		Header = header,
		Title = title,
		DockButton = dockButton,
		Content = content,
		Stroke = stroke,
		GlowStroke = glowStroke,
		SoftGlowStroke = softGlowStroke,
		TabRecord = opts.tabRecord,
		Cleanup = {},
		InputId = opts.inputId,
		ManualPosition = nil,
		Dragging = false,
		HoverPanel = false,
		HoverHeader = false,
		HoverDock = false,
		HoverActive = false,
		LayerZ = opts.baseZ
	}

	local function syncPanelHover()
		panelData.HoverActive = panelData.HoverPanel or panelData.HoverHeader or panelData.HoverDock
		if not panelData.Dragging then
			opts.setPanelHoverState(panelData, panelData.HoverActive, false)
		end
	end

	TabSplitPanel.bindHover(panelData, syncPanelHover)
	return panelData
end

return TabSplitPanel
]])
put("src/feature/tabsplit/reorder_tab_split.lua", [[local TabSplitReorder = {}

function TabSplitReorder.removePanel(panelOrder, panelId)
	if type(panelOrder) ~= "table" or panelId == nil then
		return false
	end

	for i = #panelOrder, 1, -1 do
		if panelOrder[i] == panelId then
			table.remove(panelOrder, i)
			return true
		end
	end
	return false
end

function TabSplitReorder.appendPanel(panelOrder, panelId)
	if type(panelOrder) ~= "table" or panelId == nil then
		return false
	end

	TabSplitReorder.removePanel(panelOrder, panelId)
	table.insert(panelOrder, panelId)
	return true
end

function TabSplitReorder.bringToFront(panelOrder, panelId)
	return TabSplitReorder.appendPanel(panelOrder, panelId)
end

return TabSplitReorder
]])
put("src/feature/tabsplit/state.lua", [[local TabSplitState = {}

function TabSplitState.create(ctx)
	local sharedInputChanged = {}
	local sharedInputEnded = {}
	local sharedInputConnections = nil

	local function ensureSharedInput()
		if sharedInputConnections then
			return
		end

		sharedInputConnections = {
			ctx.UserInputService.InputChanged:Connect(function(input)
				for _, cb in pairs(sharedInputChanged) do
					cb(input)
				end
			end),
			ctx.UserInputService.InputEnded:Connect(function(input)
				for _, cb in pairs(sharedInputEnded) do
					cb(input)
				end
			end)
		}
	end

	local function registerSharedInput(id, onChanged, onEnded)
		ensureSharedInput()
		if type(onChanged) == "function" then
			sharedInputChanged[id] = onChanged
		end
		if type(onEnded) == "function" then
			sharedInputEnded[id] = onEnded
		end
	end

	local function unregisterSharedInput(id)
		sharedInputChanged[id] = nil
		sharedInputEnded[id] = nil
	end

	local function disconnectSharedInput()
		table.clear(sharedInputChanged)
		table.clear(sharedInputEnded)
		if sharedInputConnections then
			for _, connection in ipairs(sharedInputConnections) do
				if connection then
					connection:Disconnect()
				end
			end
			sharedInputConnections = nil
		end
	end

	local function getInputPosition(input)
		if input and input.Position then
			return Vector2.new(input.Position.X, input.Position.Y)
		end
		return ctx.UserInputService:GetMouseLocation()
	end

	local function isPointInside(guiObject, point, padding)
		if not (guiObject and guiObject.Parent and point) then
			return false
		end

		local pad = padding or 0
		local absPos = guiObject.AbsolutePosition
		local absSize = guiObject.AbsoluteSize
		return point.X >= (absPos.X - pad)
			and point.X <= (absPos.X + absSize.X + pad)
			and point.Y >= (absPos.Y - pad)
			and point.Y <= (absPos.Y + absSize.Y + pad)
	end

	local function isPointInsideMain(point)
		return isPointInside(ctx.Main, point, 0)
	end

	local function isPointInsideTabList(point)
		return isPointInside(ctx.TabList, point, 10)
	end

	local function clampPositionToViewport(root, desiredPosition, panelSize, panelMargin)
		local margin = panelMargin or 8
		local viewport = root.AbsoluteSize
		local clampedX = math.clamp(
			desiredPosition.X,
			margin,
			math.max(margin, viewport.X - panelSize.X - margin)
		)
		local clampedY = math.clamp(
			desiredPosition.Y,
			margin,
			math.max(margin, viewport.Y - panelSize.Y - margin)
		)
		return Vector2.new(clampedX, clampedY)
	end

	local function hasZIndex(guiObject)
		return pcall(function()
			local _ = guiObject.ZIndex
		end)
	end

	return {
		ensureSharedInput = ensureSharedInput,
		registerSharedInput = registerSharedInput,
		unregisterSharedInput = unregisterSharedInput,
		disconnectSharedInput = disconnectSharedInput,
		getInputPosition = getInputPosition,
		isPointInside = isPointInside,
		isPointInsideMain = isPointInsideMain,
		isPointInsideTabList = isPointInsideTabList,
		clampPositionToViewport = clampPositionToViewport,
		hasZIndex = hasZIndex
	}
end

return TabSplitState
]])
put("src/feature/tabsplit/zindex.lua", [[local ZIndex = {}

function ZIndex.capture(root)
	local map = setmetatable({}, { __mode = "k" })
	if not root then
		return map
	end
	for _, descendant in ipairs(root:GetDescendants()) do
		if descendant:IsA("GuiObject") then
			map[descendant] = descendant.ZIndex
		end
	end
	if root:IsA("GuiObject") then
		map[root] = root.ZIndex
	end
	return map
end

function ZIndex.apply(root, map, zBase)
	if not root or not map then
		return
	end
	zBase = zBase or 20
	for instance, original in pairs(map) do
		if instance and instance.Parent and instance:IsA("GuiObject") then
			instance.ZIndex = math.max(original, zBase)
		end
	end
end

function ZIndex.restore(map)
	if not map then
		return
	end
	for instance, original in pairs(map) do
		if instance and instance.Parent and instance:IsA("GuiObject") then
			instance.ZIndex = original
		end
	end
end

return ZIndex]])
put("src/legacy/forward.lua", [[local Forward = {}

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
local compileString = loadstring or load
if not compileString then
	error("No Lua compiler function available (loadstring/load)")
end

local function compileChunk(source, label)
	if type(source) ~= "string" then
		error("Invalid Lua source for " .. tostring(label) .. ": " .. type(source))
	end
	source = source:gsub("^\239\187\191", "")
	source = source:gsub("^\0+", "")
	local chunk, err = compileString(source)
	if not chunk then
		error("Failed to compile " .. tostring(label) .. ": " .. tostring(err))
	end
	return chunk
end

local clientSource = game:HttpGet(root .. "src/api/client.lua")
local client = compileChunk(clientSource, "src/api/client.lua")()
if type(client) ~= "table" or type(client.fetchAndExecute) ~= "function" then
	error("Invalid API client bootstrap: missing fetchAndExecute")
end

if _G and _G.__RayfieldWidgetBootstrap == nil then
	local okBootstrap, bootstrapModule = pcall(client.fetchAndExecute, root .. "src/ui/elements/widgets/bootstrap.lua")
	if not okBootstrap then
		error("Failed to preload widget bootstrap: " .. tostring(bootstrapModule))
	end
	if type(bootstrapModule) ~= "table" or type(bootstrapModule.bootstrapWidget) ~= "function" then
		error("Invalid widget bootstrap module: missing bootstrapWidget")
	end
	_G.__RayfieldWidgetBootstrap = bootstrapModule
end

local loader = client.fetchAndExecute(root .. "src/api/loader.lua")
if type(loader) ~= "table" or type(loader.load) ~= "function" then
	error("Invalid API loader bootstrap: missing loader.load")
end

local function getScriptRef()
	local scriptRef = nil
	pcall(function()
		scriptRef = script
	end)
	return scriptRef
end

function Forward.module(moduleName)
	return loader.load(moduleName, {
		tryStudioRequire = false,
		scriptRef = getScriptRef()
	})
end

function Forward.path(path)
	return loader.loadPath(path)
end

return Forward
]])
put("src/legacy/map.lua", [[return {
	legacyWrappers = {
		"Main loader/rayfield-modified.lua",
		"Main loader/rayfield-all-in-one.lua",
		"feature/rayfield-all-in-one.lua",
		"feature/rayfield-theme.lua",
		"feature/rayfield-settings.lua",
		"feature/rayfield-config.lua",
		"feature/rayfield-utilities.lua",
		"feature/rayfield-ui-state.lua",
		"feature/rayfield-elements.lua",
		"feature/rayfield-elements-extracted.lua",
		"feature/rayfield-drag.lua",
		"feature/rayfield-tab-split.lua",
		"feature/mini-window-system.lua",
		"feature/rayfield-enhanced.lua",
		"feature/rayfield-advanced-features.lua"
	}
}
]])
put("src/services/config.lua", [[-- Rayfield Configuration Management Module
-- Handles configuration save/load and color packing

local ConfigModule = {}

function ConfigModule.init(ctx)
	local self = {}

	-- Inject dependencies
	self.HttpService = ctx.HttpService
	self.TweenService = ctx.TweenService
	self.Animation = ctx.Animation
	self.RayfieldLibrary = ctx.RayfieldLibrary
	self.callSafely = ctx.callSafely
	self.ConfigurationFolder = ctx.ConfigurationFolder
	self.ConfigurationExtension = ctx.ConfigurationExtension
	self.getCFileName = ctx.getCFileName
	self.getCEnabled = ctx.getCEnabled
	self.getGlobalLoaded = ctx.getGlobalLoaded
	self.getLayoutSnapshot = ctx.getLayoutSnapshot
	self.applyLayoutSnapshot = ctx.applyLayoutSnapshot
	self.getElementsSystem = ctx.getElementsSystem
	self.layoutKey = tostring(ctx.layoutKey or "__rayfield_layout")
	self.useStudio = ctx.useStudio
	self.debugX = ctx.debugX

	-- Config load smoothing defaults
	local LOAD_CHUNK_THRESHOLD = 42
	local LOAD_BATCH_SIZE = 12
	local LOAD_BATCH_DELAY_SEC = 0.02
	local LOAD_TAB_GAP_DELAY_SEC = 0.03
	local LOAD_FADE_DURATION_SEC = 0.12
	local LOAD_FADE_DESCENDANT_LIMIT = 8

	-- Color packing/unpacking utilities
	local function PackColor(Color)
		return { R = Color.R * 255, G = Color.G * 255, B = Color.B * 255 }
	end

	local function UnpackColor(Color)
		return Color3.fromRGB(Color.R, Color.G, Color.B)
	end

	local function cloneValue(value)
		local shared = type(_G) == "table" and _G.__RayfieldSharedUtils or nil
		if type(shared) == "table" and type(shared.cloneTable) == "function" then
			return shared.cloneTable(value)
		end
		if type(value) ~= "table" then
			return value
		end
		local out = {}
		for key, nested in pairs(value) do
			out[key] = cloneValue(nested)
		end
		return out
	end

	local function valuesEqual(left, right)
		local shared = type(_G) == "table" and _G.__RayfieldSharedUtils or nil
		if type(shared) == "table" and type(shared.deepEqual) == "function" then
			return shared.deepEqual(left, right)
		end
		if left == right then
			return true
		end
		if type(left) ~= "table" or type(right) ~= "table" then
			return false
		end
		for key, value in pairs(left) do
			if not valuesEqual(value, right[key]) then
				return false
			end
		end
		for key in pairs(right) do
			if left[key] == nil then
				return false
			end
		end
		return true
	end

	local function getPersistValue(flag)
		if type(flag) ~= "table" then
			return nil
		end

		if flag.Type == "ColorPicker" and flag.Color then
			return PackColor(flag.Color)
		end

		if type(flag.GetPersistValue) == "function" then
			local ok, value = pcall(flag.GetPersistValue, flag)
			if ok then
				return cloneValue(value)
			end
		end

		local value = flag.CurrentValue
		if value == nil then
			value = flag.CurrentKeybind or flag.CurrentOption or flag.Color
		end
		return cloneValue(value)
	end

	local function resolveTabId(flag)
		if type(flag) ~= "table" then
			return "__global"
		end
		local tabId = rawget(flag, "__TabPersistenceId") or rawget(flag, "__TabId")
		if tabId == nil then
			return "__global"
		end
		return tostring(tabId)
	end

	local function resolveTabOrder(flag, tabId)
		if type(flag) == "table" then
			local tabOrder = tonumber(rawget(flag, "__TabLayoutOrder"))
			if tabOrder then
				return tabOrder
			end
		end
		if type(self.getElementsSystem) == "function" then
			local elementsSystem = self.getElementsSystem()
			if elementsSystem and type(elementsSystem.getTabLayoutOrderByPersistenceId) == "function" then
				local okOrder, tabOrder = pcall(elementsSystem.getTabLayoutOrderByPersistenceId, tabId)
				if okOrder and type(tabOrder) == "number" then
					return tabOrder
				end
			end
		end
		return math.huge
	end

	local function resolveElementOrder(flag)
		if type(flag) ~= "table" then
			return math.huge
		end
		return tonumber(rawget(flag, "__ElementLayoutOrder")) or math.huge
	end

	local function resolveFlagGuiObject(flag)
		if type(flag) ~= "table" then
			return nil
		end
		local guiObject = rawget(flag, "__GuiObject")
		if guiObject and guiObject.Parent then
			return guiObject
		end
		return nil
	end

	local function tweenProperty(instance, propertyName, fromValue, toValue, tweenInfo)
		if fromValue == nil or toValue == nil then
			return
		end
		local okSetFrom = pcall(function()
			instance[propertyName] = fromValue
		end)
		if not okSetFrom then
			return
		end
		local okTween, tween = pcall(function()
			if self.Animation and type(self.Animation.Create) == "function" then
				return self.Animation:Create(instance, tweenInfo, {
					[propertyName] = toValue
				})
			end
			return nil
		end)
		if okTween and tween then
			tween:Play()
		end
	end

	local function fadeElementVisual(guiObject)
		if not (self.TweenService and type(self.TweenService.Create) == "function") then
			return
		end
		if not (guiObject and guiObject.Parent and guiObject:IsA("GuiObject")) then
			return
		end
		if guiObject.Visible == false then
			return
		end

		local tweenInfo = TweenInfo.new(LOAD_FADE_DURATION_SEC, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)

		local okBg, bgTransparency = pcall(function()
			return guiObject.BackgroundTransparency
		end)
		if okBg and type(bgTransparency) == "number" and bgTransparency < 1 then
			local startValue = math.clamp(bgTransparency + 0.2, 0, 1)
			tweenProperty(guiObject, "BackgroundTransparency", startValue, bgTransparency, tweenInfo)
		end

		local function applyDescendantFade(descendant)
			if descendant:IsA("UIStroke") then
				local okStroke, strokeTransparency = pcall(function()
					return descendant.Transparency
				end)
				if okStroke and type(strokeTransparency) == "number" and strokeTransparency < 1 then
					local startValue = math.clamp(strokeTransparency + 0.35, 0, 1)
					tweenProperty(descendant, "Transparency", startValue, strokeTransparency, tweenInfo)
					return true
				end
			elseif descendant:IsA("TextLabel") or descendant:IsA("TextButton") or descendant:IsA("TextBox") then
				local okText, textTransparency = pcall(function()
					return descendant.TextTransparency
				end)
				if okText and type(textTransparency) == "number" and textTransparency < 1 then
					local startValue = math.clamp(textTransparency + 0.35, 0, 1)
					tweenProperty(descendant, "TextTransparency", startValue, textTransparency, tweenInfo)
					return true
				end
			elseif descendant:IsA("ImageLabel") or descendant:IsA("ImageButton") then
				local okImage, imageTransparency = pcall(function()
					return descendant.ImageTransparency
				end)
				if okImage and type(imageTransparency) == "number" and imageTransparency < 1 then
					local startValue = math.clamp(imageTransparency + 0.35, 0, 1)
					tweenProperty(descendant, "ImageTransparency", startValue, imageTransparency, tweenInfo)
					return true
				end
			end
			return false
		end

		local processedDescendants = 0
		for _, child in ipairs(guiObject:GetChildren()) do
			if processedDescendants >= LOAD_FADE_DESCENDANT_LIMIT then
				break
			end
			if applyDescendantFade(child) then
				processedDescendants += 1
			end
			if processedDescendants >= LOAD_FADE_DESCENDANT_LIMIT then
				break
			end
			for _, grandChild in ipairs(child:GetChildren()) do
				if processedDescendants >= LOAD_FADE_DESCENDANT_LIMIT then
					break
				end
				if applyDescendantFade(grandChild) then
					processedDescendants += 1
				end
			end
		end
	end

	local function collectLoadEntries(Data)
		local entries = {}

		for FlagName, Flag in pairs(self.RayfieldLibrary.Flags) do
			local FlagValue = Data[FlagName]
			if FlagValue ~= nil then
				local tabId = resolveTabId(Flag)
				table.insert(entries, {
					flagName = FlagName,
					flag = Flag,
					rawValue = FlagValue,
					tabId = tabId,
					tabOrder = resolveTabOrder(Flag, tabId),
					elementOrder = resolveElementOrder(Flag),
					guiObject = resolveFlagGuiObject(Flag)
				})
			else
				warn("Rayfield | Unable to find '" .. tostring(FlagName) .. "' in the save file.")
				print("The error above may not be an issue if new elements have been added or not been set values.")
			end
		end

		table.sort(entries, function(left, right)
			if left.tabOrder ~= right.tabOrder then
				return left.tabOrder < right.tabOrder
			end
			if left.tabId ~= right.tabId then
				return tostring(left.tabId) < tostring(right.tabId)
			end
			if left.elementOrder ~= right.elementOrder then
				return left.elementOrder < right.elementOrder
			end
			return tostring(left.flagName) < tostring(right.flagName)
		end)

		return entries
	end

	local function groupEntriesByTab(entries)
		local groupsByTab = {}
		local groups = {}

		for _, entry in ipairs(entries) do
			local group = groupsByTab[entry.tabId]
			if not group then
				group = {
					tabId = entry.tabId,
					tabOrder = entry.tabOrder,
					entries = {}
				}
				groupsByTab[entry.tabId] = group
				table.insert(groups, group)
			end
			table.insert(group.entries, entry)
		end

		table.sort(groups, function(left, right)
			if left.tabOrder ~= right.tabOrder then
				return left.tabOrder < right.tabOrder
			end
			return tostring(left.tabId) < tostring(right.tabId)
		end)

		return groups
	end

	local function applyFlagValue(entry)
		local flagName = entry.flagName
		local flag = entry.flag
		local flagValue = entry.rawValue
		local beforeValue = getPersistValue(flag)
		local nextValue = cloneValue(flagValue)
		if flag.Type == "ColorPicker" and type(flagValue) == "table" then
			nextValue = UnpackColor(flagValue)
		end
		if type(flag.Set) == "function" then
			local okSet, errSet = pcall(flag.Set, flag, nextValue)
			if not okSet then
				warn("Rayfield | Failed to apply flag '" .. tostring(flagName) .. "': " .. tostring(errSet))
			end
		else
			warn("Rayfield | Flag '" .. tostring(flagName) .. "' is missing Set()")
		end
		local afterValue = getPersistValue(flag)
		return not valuesEqual(beforeValue, afterValue)
	end

	local function applyConfigurationData(Data)
		if type(Data) ~= "table" then
			warn("Rayfield | Configuration data must be a table.")
			return false
		end

		local changed = false
		local entries = collectLoadEntries(Data)
		local groupedByTab = groupEntriesByTab(entries)
		local heavyLoad = #entries >= LOAD_CHUNK_THRESHOLD
		local processedInBatch = 0

		for _, group in ipairs(groupedByTab) do
			for _, entry in ipairs(group.entries) do
				if applyFlagValue(entry) then
					changed = true
				end
				fadeElementVisual(entry.guiObject)

				if heavyLoad then
					processedInBatch += 1
					if processedInBatch >= LOAD_BATCH_SIZE then
						processedInBatch = 0
						task.wait(LOAD_BATCH_DELAY_SEC)
					end
				end
			end

			if heavyLoad then
				task.wait(LOAD_TAB_GAP_DELAY_SEC)
			end
		end

		if type(self.applyLayoutSnapshot) == "function" then
			local LayoutData = Data[self.layoutKey]
			if type(LayoutData) == "table" then
				local okLayout, layoutErr = pcall(self.applyLayoutSnapshot, LayoutData)
				if not okLayout then
					warn("Rayfield | Failed to apply layout data: " .. tostring(layoutErr))
				end
			end
		end

		return changed
	end

	-- Load configuration from JSON string
	local function LoadConfiguration(Configuration)
		local success, Data = pcall(function()
			return self.HttpService:JSONDecode(Configuration)
		end)

		if not success then
			warn("Rayfield had an issue decoding the configuration file, please try delete the file and reopen Rayfield.")
			return
		end

		return applyConfigurationData(Data)
	end

	local function buildConfigurationData()
		local Data = {}
		for flagName, flag in pairs(self.RayfieldLibrary.Flags) do
			Data[flagName] = getPersistValue(flag)
		end

		if type(self.getLayoutSnapshot) == "function" then
			local okLayout, layoutSnapshot = pcall(self.getLayoutSnapshot)
			if okLayout and type(layoutSnapshot) == "table" then
				Data[self.layoutKey] = cloneValue(layoutSnapshot)
			end
		end

		return Data
	end

	local function persistConfigurationData(Data)
		local okEncode, encodedOrErr = pcall(function()
			return self.HttpService:JSONEncode(Data)
		end)
		if not okEncode then
			warn("Rayfield | Failed to encode configuration data: " .. tostring(encodedOrErr))
			return false
		end

		local encoded = tostring(encodedOrErr)

		if self.useStudio then
			if script.Parent:FindFirstChild("configuration") then
				script.Parent.configuration:Destroy()
			end

			local ScreenGui = Instance.new("ScreenGui")
			ScreenGui.Parent = script.Parent
			ScreenGui.Name = "configuration"

			local TextBox = Instance.new("TextBox")
			TextBox.Parent = ScreenGui
			TextBox.Size = UDim2.new(0, 800, 0, 50)
			TextBox.AnchorPoint = Vector2.new(0.5, 0)
			TextBox.Position = UDim2.new(0.5, 0, 0, 30)
			TextBox.Text = encoded
			TextBox.ClearTextOnFocus = false
		end

		if self.debugX then
			warn(encoded)
		end

		if type(writefile) ~= "function" then
			return self.useStudio == true
		end

		if isfolder and makefolder and not self.callSafely(isfolder, self.ConfigurationFolder) then
			self.callSafely(makefolder, self.ConfigurationFolder)
		end

		local writeResult = self.callSafely(
			writefile,
			self.ConfigurationFolder .. "/" .. self.getCFileName() .. self.ConfigurationExtension,
			encoded
		)
		return writeResult ~= false
	end

	local function ExportConfigurationData()
		return cloneValue(buildConfigurationData())
	end

	local function ImportConfigurationData(dataTable)
		if type(dataTable) ~= "table" then
			return false, "Configuration data must be a table."
		end

		local okApply, changedOrErr = pcall(function()
			return applyConfigurationData(cloneValue(dataTable))
		end)
		if not okApply then
			return false, tostring(changedOrErr)
		end

		return true, changedOrErr == true
	end

	-- Save configuration to file
	local function SaveConfiguration()
		if not self.getCEnabled() or not self.getGlobalLoaded() then
			return
		end

		if self.debugX then
			print("Saving")
		end

		local Data = buildConfigurationData()
		persistConfigurationData(Data)
	end

	local function SaveConfigurationForced()
		local Data = buildConfigurationData()
		return persistConfigurationData(Data)
	end

	-- Export functions
	self.PackColor = PackColor
	self.UnpackColor = UnpackColor
	self.LoadConfiguration = LoadConfiguration
	self.SaveConfiguration = SaveConfiguration
	self.ExportConfigurationData = ExportConfigurationData
	self.ImportConfigurationData = ImportConfigurationData
	self.SaveConfigurationForced = SaveConfigurationForced
	self.setLayoutHandlers = function(getSnapshotFn, applySnapshotFn, layoutKey)
		self.getLayoutSnapshot = getSnapshotFn
		self.applyLayoutSnapshot = applySnapshotFn
		if type(layoutKey) == "string" and layoutKey ~= "" then
			self.layoutKey = layoutKey
		end
	end

	return self
end

return ConfigModule
]])
put("src/services/element-sync.lua", [[-- Rayfield unified element state/visual synchronization service
-- Pipeline: normalize -> applyVisual -> emitCallback -> persist

local ElementSyncModule = {}

local TRACE_FLAG = "__RAYFIELD_ELEMENT_SYNC_TRACE"
local TRACE_PREFIX = "[RAYFIELD][ELEMENT_SYNC]"

local function getSharedUtils()
	if type(_G) == "table" and type(_G.__RayfieldSharedUtils) == "table" then
		return _G.__RayfieldSharedUtils
	end
	return nil
end

local function trim(value)
	local shared = getSharedUtils()
	if shared and type(shared.trim) == "function" then
		return shared.trim(value)
	end
	if type(value) ~= "string" then
		return ""
	end
	local out = value:gsub("^%s+", "")
	out = out:gsub("%s+$", "")
	return out
end

local function cloneArray(source)
	local result = {}
	if type(source) ~= "table" then
		return result
	end
	for index, value in ipairs(source) do
		result[index] = value
	end
	return result
end

local function cloneTable(source)
	local shared = getSharedUtils()
	if shared and type(shared.cloneTable) == "function" then
		return shared.cloneTable(source)
	end
	if type(source) ~= "table" then
		return source
	end
	local result = {}
	for key, value in pairs(source) do
		if type(value) == "table" then
			result[key] = cloneTable(value)
		else
			result[key] = value
		end
	end
	return result
end

local function deepEqual(left, right, seen)
	local shared = getSharedUtils()
	if shared and type(shared.deepEqual) == "function" then
		return shared.deepEqual(left, right, seen)
	end
	if left == right then
		return true
	end
	if type(left) ~= "table" or type(right) ~= "table" then
		return false
	end

	seen = seen or {}
	if seen[left] and seen[left] == right then
		return true
	end
	seen[left] = right

	for key, value in pairs(left) do
		if not deepEqual(value, right[key], seen) then
			return false
		end
	end

	for key in pairs(right) do
		if left[key] == nil then
			return false
		end
	end

	return true
end

local function defaultWarn(message)
	warn(TRACE_PREFIX .. " " .. tostring(message))
end

local function shouldTrace()
	return type(_G) == "table" and _G[TRACE_FLAG] == true
end

local function trace(branchId, payload)
	if not shouldTrace() then
		return
	end
	local data = payload or {}
	print(string.format(
		"%s branch_id=%s stage=%s token=%s reason=%s",
		TRACE_PREFIX,
		tostring(branchId or "unknown"),
		tostring(data.stage or "n/a"),
		tostring(data.token or "n/a"),
		tostring(data.reason or "n/a")
	))
end

local function fail(code, message)
	error(string.format("[%s] %s", tostring(code), tostring(message)), 2)
end

local function normalizeBoolean(rawValue)
	return rawValue == true
end

local function normalizeNumberRange(rawValue, options)
	local opts = options or {}
	local minValue = tonumber(opts.min) or 0
	local maxValue = tonumber(opts.max) or 1
	if maxValue <= minValue then
		maxValue = minValue + 1
	end

	local increment = tonumber(opts.increment) or 1
	if increment <= 0 then
		increment = 1
	end

	local value = tonumber(rawValue)
	if value == nil then
		value = tonumber(opts.default) or minValue
	end
	value = math.clamp(value, minValue, maxValue)
	value = math.floor((value / increment) + 0.5) * increment
	value = math.floor((value * 10000000) + 0.5) / 10000000
	value = math.clamp(value, minValue, maxValue)
	return value
end

local function normalizeText(rawValue, options)
	local opts = options or {}
	local value = rawValue
	if value == nil then
		value = opts.default
	end
	if value == nil then
		value = ""
	end
	value = tostring(value)
	if opts.trim ~= false then
		value = trim(value)
	end
	return value
end

local function normalizeSelection(rawSelection, options)
	local opts = options or {}
	local allowedMap = {}
	local normalizedAllowed = {}

	if type(opts.allowedValues) == "table" then
		for _, entry in ipairs(opts.allowedValues) do
			local key = tostring(entry)
			if not allowedMap[key] then
				allowedMap[key] = true
				table.insert(normalizedAllowed, key)
			end
		end
	end

	local function toArray(value)
		local out = {}
		if value == nil then
			return out
		end
		if type(value) == "string" then
			out[1] = value
			return out
		end
		if type(value) ~= "table" then
			out[1] = tostring(value)
			return out
		end

		if #value > 0 then
			for _, entry in ipairs(value) do
				if entry ~= nil then
					table.insert(out, tostring(entry))
				end
			end
		else
			for _, entry in pairs(value) do
				if entry ~= nil then
					table.insert(out, tostring(entry))
				end
			end
		end
		return out
	end

	local multiple = opts.multiple == true
	local dedupe = {}
	local normalized = {}
	for _, entry in ipairs(toArray(rawSelection)) do
		if (next(allowedMap) == nil or allowedMap[entry]) and not dedupe[entry] then
			dedupe[entry] = true
			table.insert(normalized, entry)
		end
	end

	if not multiple and #normalized > 1 then
		normalized = { normalized[1] }
	end

	local fallbackApplied = false
	local fallbackPolicy = tostring(opts.clearBehavior or "default"):lower()
	if fallbackPolicy ~= "none" and #normalized == 0 then
		local fallback = {}
		for _, entry in ipairs(toArray(opts.defaultSelection)) do
			if (next(allowedMap) == nil or allowedMap[entry]) and not dedupe[entry] then
				dedupe[entry] = true
				table.insert(fallback, entry)
			end
		end
		if not multiple and #fallback > 1 then
			fallback = { fallback[1] }
		end
		if #fallback > 0 then
			normalized = fallback
			fallbackApplied = true
		end
	end

	local previous = opts.previousSelection
	local changed = not deepEqual(previous, normalized)
	return normalized, {
		fallbackApplied = fallbackApplied,
		changed = changed,
		allowedValues = normalizedAllowed
	}
end

function ElementSyncModule.init(ctx)
	local self = {}
	local context = ctx or {}
	local warningFn = type(context.warn) == "function" and context.warn or defaultWarn

	local records = {}
	local recordsByTab = {}
	local tokenCounter = 0

	local function unregister(token)
		local record = records[token]
		if not record then
			return false
		end
		records[token] = nil

		local tabId = record.tabId or "__global"
		local tabBucket = recordsByTab[tabId]
		if tabBucket then
			tabBucket[token] = nil
			if next(tabBucket) == nil then
				recordsByTab[tabId] = nil
			end
		end

		trace("UNREGISTER", {
			stage = "unregister",
			token = token,
			reason = "record_removed"
		})
		return true
	end

	local function register(spec)
		if type(spec) ~= "table" then
			fail("E_SPEC_INVALID", "register(spec) expects table")
		end
		if type(spec.getState) ~= "function" then
			fail("E_SPEC_INVALID", "spec.getState must be a function")
		end
		if type(spec.normalize) ~= "function" then
			fail("E_SPEC_INVALID", "spec.normalize must be a function")
		end
		if type(spec.applyVisual) ~= "function" then
			fail("E_SPEC_INVALID", "spec.applyVisual must be a function")
		end
		if type(spec.emitCallback) ~= "function" then
			fail("E_SPEC_INVALID", "spec.emitCallback must be a function")
		end
		if type(spec.persist) ~= "function" then
			fail("E_SPEC_INVALID", "spec.persist must be a function")
		end

		tokenCounter += 1
		local token = "element_sync_" .. tostring(tokenCounter)
		spec.token = token
		records[token] = spec

		local tabId = spec.tabId or "__global"
		recordsByTab[tabId] = recordsByTab[tabId] or {}
		recordsByTab[tabId][token] = true

		trace("REGISTER", {
			stage = "register",
			token = token,
			reason = tostring(spec.name or "unnamed")
		})
		return token
	end

	local function isRecordActive(record)
		if not record then
			return false
		end
		if type(record.isAlive) == "function" then
			local ok, alive = pcall(record.isAlive)
			if not ok or alive == false then
				return false
			end
		end
		return true
	end

	local function commit(token, nextState, options)
		options = options or {}
		local record = records[token]
		if not record then
			return false, { error = "record_missing" }
		end
		if not isRecordActive(record) then
			unregister(token)
			return false, { error = "record_inactive" }
		end

		local previousState = nil
		local okPrev, prevResult = pcall(record.getState)
		if okPrev then
			previousState = cloneTable(prevResult)
		end

		trace("COMMIT_NORMALIZE", {
			stage = "normalize",
			token = token,
			reason = options.reason or "unknown"
		})
		local normalizeOk, normalizedState, normalizeMeta = pcall(record.normalize, nextState, {
			previousState = previousState,
			reason = options.reason,
			source = options.source,
			options = options
		})
		if not normalizeOk then
			warningFn("normalize failed for token=" .. tostring(token) .. " error=" .. tostring(normalizedState))
			return false, { error = "normalize_failed", detail = normalizedState }
		end

		local meta = type(normalizeMeta) == "table" and normalizeMeta or {}
		local changed = meta.changed
		if changed == nil then
			changed = not deepEqual(previousState, normalizedState)
		end
		local fallbackApplied = meta.fallbackApplied == true
		local emitCallback = options.emitCallback
		if emitCallback == nil then
			emitCallback = true
		end
		local shouldPersist = options.persist
		if shouldPersist == nil then
			shouldPersist = true
		end

		trace("COMMIT_VISUAL", {
			stage = "applyVisual",
			token = token,
			reason = options.reason or "unknown"
		})
		local visualOk, visualErr = pcall(record.applyVisual, normalizedState, {
			previousState = previousState,
			changed = changed,
			fallbackApplied = fallbackApplied,
			reason = options.reason,
			source = options.source,
			options = options
		})
		if not visualOk then
			warningFn("applyVisual failed for token=" .. tostring(token) .. " error=" .. tostring(visualErr))
		end

		local callbackOk = true
		local callbackErr = nil
		local shouldEmit = emitCallback and (changed or fallbackApplied or options.forceCallback == true)
		if shouldEmit then
			trace("COMMIT_CALLBACK", {
				stage = "emitCallback",
				token = token,
				reason = options.reason or "unknown"
			})
			callbackOk, callbackErr = pcall(record.emitCallback, normalizedState, {
				previousState = previousState,
				changed = changed,
				fallbackApplied = fallbackApplied,
				reason = options.reason,
				source = options.source,
				options = options
			})
			if not callbackOk and type(record.onCallbackError) == "function" then
				pcall(record.onCallbackError, callbackErr)
			end
		end

		local isExt = false
		if type(record.isExt) == "function" then
			local okExt, value = pcall(record.isExt)
			isExt = okExt and value == true or false
		end

		if shouldPersist and callbackOk and not isExt then
			trace("COMMIT_PERSIST", {
				stage = "persist",
				token = token,
				reason = options.reason or "unknown"
			})
			local okPersist, persistErr = pcall(record.persist, normalizedState, {
				previousState = previousState,
				changed = changed,
				fallbackApplied = fallbackApplied,
				reason = options.reason,
				source = options.source,
				options = options
			})
			if not okPersist then
				warningFn("persist failed for token=" .. tostring(token) .. " error=" .. tostring(persistErr))
			end
		end

		local result = {
			token = token,
			normalized = cloneTable(normalizedState),
			changed = changed,
			fallbackApplied = fallbackApplied,
			callbackOk = callbackOk,
			callbackError = callbackErr,
			reason = options.reason,
			source = options.source
		}

		return callbackOk, result
	end

	local function resync(token, reason)
		local record = records[token]
		if not record then
			return false
		end
		if type(record.isVisibleContext) == "function" then
			local okVisible, visible = pcall(record.isVisibleContext)
			if not okVisible or visible == false then
				return false
			end
		end
		local okState, currentState = pcall(record.getState)
		if not okState then
			return false
		end
		local _, result = commit(token, currentState, {
			reason = reason or "resync",
			source = "resync",
			emitCallback = false,
			persist = false,
			forceCallback = false
		})
		return result ~= nil
	end

	local function resyncTab(tabId, reason)
		local bucket = recordsByTab[tabId or "__global"]
		if not bucket then
			return 0
		end
		local syncedCount = 0
		for token in pairs(bucket) do
			if resync(token, reason or "resync_tab") then
				syncedCount += 1
			end
		end
		return syncedCount
	end

	local function destroy()
		for token in pairs(records) do
			records[token] = nil
		end
		for tabId in pairs(recordsByTab) do
			recordsByTab[tabId] = nil
		end
	end

	self.register = register
	self.unregister = unregister
	self.commit = commit
	self.resync = resync
	self.resyncTab = resyncTab
	self.destroy = destroy
	self.normalize = {
		boolean = normalizeBoolean,
		numberRange = normalizeNumberRange,
		text = normalizeText,
		selection = normalizeSelection
	}

	return self
end

return ElementSyncModule
]])
put("src/services/integrity.lua", [=[--[[
	Rayfield Integrity Service
	Enforces GitHub-only execution and monitors for unauthorized modifications.
]]

local IntegrityService = {}

local WHITELISTED_ORIGINS = {
	"https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/",
	"https://github.com/Ahlstarr-Mayjishan/Rayfield-mod/"
}

function IntegrityService.init(ctx)
	local self = {}
	local isSecure = true
	local originError = nil

	-- Layer 5: Integrity check (Steel Layer)
	local function checkOrigin()
		local source = debug.info(1, "s")
		
		-- If running in Studio, allow local
		if game:GetService("RunService"):IsStudio() then
			return true
		end

		local valid = false
		for _, origin in ipairs(WHITELISTED_ORIGINS) do
			if source:find(origin, 1, true) then
				valid = true
				break
			end
		end

		if not valid then
			isSecure = false
			originError = "Unauthorized Source: " .. source
			warn("Rayfield | SECURITY ALERT: Execution blocked from unauthorized source.")
		end
		
		return valid
	end

	function self.verifySystemIntegrity()
		if not checkOrigin() then
			return false, originError
		end
		
		-- Cross-check with SecurityAdapter if available
		if ctx.SecurityAdapter and ctx.SecurityAdapter.isTampered() then
			return false, "System Tampered"
		end
		
		return true
	end

	function self.getSignature()
		if not isSecure then return "SIG_INVALID" end
		-- Generates a temporary signature for this session
		return "SIG-" .. tick() .. "-" .. game.JobId:sub(1,4)
	end

	return self
end

return IntegrityService
]=])
put("src/services/keybind-sequence.lua", [[local KeybindSequence = {}

local DEFAULT_MAX_STEPS = 4
local DEFAULT_STEP_TIMEOUT_MS = 800

local MODIFIER_ORDER = {
	"LeftControl",
	"RightControl",
	"LeftShift",
	"RightShift",
	"LeftAlt",
	"RightAlt"
}

local MODIFIER_SET = {
	LeftControl = true,
	RightControl = true,
	LeftShift = true,
	RightShift = true,
	LeftAlt = true,
	RightAlt = true
}

local TOKEN_ALIASES = {
	ctrl = "LeftControl",
	control = "LeftControl",
	leftctrl = "LeftControl",
	leftcontrol = "LeftControl",
	rightctrl = "RightControl",
	rightcontrol = "RightControl",
	shift = "LeftShift",
	leftshift = "LeftShift",
	rightshift = "RightShift",
	alt = "LeftAlt",
	leftalt = "LeftAlt",
	rightalt = "RightAlt"
}

local DISPLAY_TOKEN_MAP = {
	LeftControl = "Ctrl",
	RightControl = "Ctrl",
	LeftShift = "Shift",
	RightShift = "Shift",
	LeftAlt = "Alt",
	RightAlt = "Alt"
}

local function getSharedUtils()
	if type(_G) == "table" and type(_G.__RayfieldSharedUtils) == "table" then
		return _G.__RayfieldSharedUtils
	end
	return nil
end

local function trim(value)
	local shared = getSharedUtils()
	if shared and type(shared.trim) == "function" then
		return shared.trim(value)
	end
	if type(value) ~= "string" then
		return ""
	end
	local out = value:gsub("^%s+", "")
	out = out:gsub("%s+$", "")
	return out
end

local function split(value, separator)
	local list = {}
	if type(value) ~= "string" or value == "" then
		return list
	end

	local pattern = string.format("([^%s]+)", separator)
	for token in string.gmatch(value, pattern) do
		table.insert(list, token)
	end
	return list
end

local function toNumber(value, fallback)
	local numberValue = tonumber(value)
	if numberValue == nil then
		return fallback
	end
	return numberValue
end

local function resolveToken(rawToken)
	if typeof(rawToken) == "EnumItem" and rawToken.EnumType == Enum.KeyCode then
		return rawToken.Name
	end

	local token = trim(tostring(rawToken or ""))
	if token == "" then
		return nil, "empty_token"
	end

	token = token:gsub("^Enum%.KeyCode%.", "")
	token = token:gsub("^KeyCode%.", "")
	local lowerToken = string.lower(token)

	if TOKEN_ALIASES[lowerToken] then
		return TOKEN_ALIASES[lowerToken]
	end

	local ok, keyCode = pcall(function()
		return Enum.KeyCode[token]
	end)
	if ok and keyCode then
		return keyCode.Name
	end

	return nil, "invalid_token:" .. tostring(token)
end

local function isModifierName(name)
	return MODIFIER_SET[name] == true
end

local function orderedModifierNames(modifierMap)
	local ordered = {}
	for _, modifierName in ipairs(MODIFIER_ORDER) do
		if modifierMap[modifierName] then
			table.insert(ordered, modifierName)
		end
	end
	return ordered
end

local function parseStep(stepString)
	local tokens = split(stepString, "+")
	if #tokens == 0 then
		return nil, "step_empty"
	end

	local modifierMap = {}
	local primary = nil

	for _, token in ipairs(tokens) do
		local resolvedToken, resolveErr = resolveToken(token)
		if not resolvedToken then
			return nil, resolveErr
		end

		if isModifierName(resolvedToken) then
			modifierMap[resolvedToken] = true
		else
			if primary ~= nil then
				return nil, "step_has_multiple_primary"
			end
			primary = resolvedToken
		end
	end

	if primary == nil then
		return nil, "step_missing_primary"
	end

	local modifiersOrdered = orderedModifierNames(modifierMap)
	local canonicalParts = {}
	for _, modifierName in ipairs(modifiersOrdered) do
		table.insert(canonicalParts, modifierName)
	end
	table.insert(canonicalParts, primary)

	return {
		primary = primary,
		modifierMap = modifierMap,
		modifiersOrdered = modifiersOrdered,
		canonical = table.concat(canonicalParts, "+")
	}
end

local function buildCanonicalFromSteps(steps)
	local parts = {}
	for _, step in ipairs(steps) do
		table.insert(parts, step.canonical)
	end
	return table.concat(parts, ">")
end

function KeybindSequence.parseCanonical(rawValue, options)
	local opts = options or {}
	local maxSteps = math.max(1, math.floor(toNumber(opts.maxSteps, DEFAULT_MAX_STEPS)))

	if rawValue == nil then
		return nil, nil, "binding_is_nil"
	end

	if typeof(rawValue) == "EnumItem" and rawValue.EnumType == Enum.KeyCode then
		rawValue = rawValue.Name
	end

	if type(rawValue) ~= "string" then
		return nil, nil, "binding_not_string"
	end

	local binding = trim(rawValue)
	if binding == "" then
		return nil, nil, "binding_empty"
	end

	local rawSteps = split(binding, ">")
	if #rawSteps == 0 then
		return nil, nil, "binding_has_no_steps"
	end
	if #rawSteps > maxSteps then
		return nil, nil, "binding_exceeds_max_steps"
	end

	local steps = {}
	for index, rawStep in ipairs(rawSteps) do
		local step, stepErr = parseStep(rawStep)
		if not step then
			return nil, nil, string.format("step_%d_%s", index, tostring(stepErr))
		end
		table.insert(steps, step)
	end

	local canonical = buildCanonicalFromSteps(steps)
	return canonical, steps, nil
end

function KeybindSequence.normalize(rawValue, options)
	local canonical, steps, parseErr = KeybindSequence.parseCanonical(rawValue, options)
	if canonical then
		return canonical, steps, nil
	end

	if type(rawValue) == "table" then
		if type(rawValue.Canonical) == "string" then
			return KeybindSequence.parseCanonical(rawValue.Canonical, options)
		end
		if type(rawValue.CurrentKeybind) == "string" then
			return KeybindSequence.parseCanonical(rawValue.CurrentKeybind, options)
		end
	end

	return nil, nil, parseErr
end

function KeybindSequence.parseUserInput(text, customParser, options)
	local opts = options or {}
	local fallbackToDefault = opts.fallbackToDefault ~= false

	if type(customParser) == "function" then
		local ok, customValueOrErr, maybeErr = pcall(customParser, text)
		if ok and customValueOrErr ~= nil then
			local canonical, steps, normalizeErr = KeybindSequence.normalize(customValueOrErr, options)
			if canonical then
				return canonical, steps, nil
			end
			if not fallbackToDefault then
				return nil, nil, normalizeErr
			end
		elseif not ok and not fallbackToDefault then
			return nil, nil, tostring(customValueOrErr)
		elseif ok and customValueOrErr == nil and not fallbackToDefault then
			return nil, nil, tostring(maybeErr or "custom_parser_returned_nil")
		end
	end

	return KeybindSequence.normalize(text, options)
end

function KeybindSequence.formatDisplay(rawValue, customFormatter, options)
	local canonical = nil
	local steps = nil
	if type(rawValue) == "table" and type(rawValue.canonical) == "string" and type(rawValue.steps) == "table" then
		canonical = rawValue.canonical
		steps = rawValue.steps
	elseif type(rawValue) == "table" and rawValue[1] and rawValue[1].canonical then
		steps = rawValue
		canonical = buildCanonicalFromSteps(steps)
	else
		canonical, steps = KeybindSequence.normalize(rawValue, options)
	end

	if not canonical or not steps then
		return ""
	end

	if type(customFormatter) == "function" then
		local ok, customText = pcall(customFormatter, canonical, steps)
		if ok and type(customText) == "string" and customText ~= "" then
			return customText
		end
	end

	local stepLabels = {}
	for _, step in ipairs(steps) do
		local tokens = {}
		for _, modifierName in ipairs(step.modifiersOrdered) do
			table.insert(tokens, DISPLAY_TOKEN_MAP[modifierName] or modifierName)
		end
		table.insert(tokens, DISPLAY_TOKEN_MAP[step.primary] or step.primary)
		table.insert(stepLabels, table.concat(tokens, " + "))
	end

	return table.concat(stepLabels, " > ")
end

function KeybindSequence.matchStep(input, stepSpec, userInputService)
	if not input or not stepSpec then
		return false
	end

	if input.UserInputType ~= Enum.UserInputType.Keyboard then
		return false
	end
	if not input.KeyCode or input.KeyCode == Enum.KeyCode.Unknown then
		return false
	end
	if input.KeyCode.Name ~= stepSpec.primary then
		return false
	end

	if not userInputService or type(userInputService.IsKeyDown) ~= "function" then
		return false
	end

	for modifierName in pairs(stepSpec.modifierMap) do
		local modifierCode = Enum.KeyCode[modifierName]
		if modifierCode and not userInputService:IsKeyDown(modifierCode) then
			return false
		end
	end

	return true
end

function KeybindSequence.captureStepFromInput(input, userInputService)
	if not input or input.UserInputType ~= Enum.UserInputType.Keyboard or not input.KeyCode or input.KeyCode == Enum.KeyCode.Unknown then
		return nil, nil, "input_not_keyboard"
	end

	local primaryName = input.KeyCode.Name
	if isModifierName(primaryName) then
		return nil, nil, "input_modifier_only"
	end

	local modifierTokens = {}
	if userInputService and type(userInputService.IsKeyDown) == "function" then
		for _, modifierName in ipairs(MODIFIER_ORDER) do
			local modifierCode = Enum.KeyCode[modifierName]
			if modifierCode and userInputService:IsKeyDown(modifierCode) then
				table.insert(modifierTokens, modifierName)
			end
		end
	end

	table.insert(modifierTokens, primaryName)
	local canonicalStep = table.concat(modifierTokens, "+")
	local stepSpec, stepErr = parseStep(canonicalStep)
	if not stepSpec then
		return nil, nil, stepErr
	end
	return stepSpec.canonical, stepSpec, nil
end

function KeybindSequence.newMatcher(options)
	local opts = options or {}
	local maxSteps = math.max(1, math.floor(toNumber(opts.maxSteps, DEFAULT_MAX_STEPS)))
	local timeoutMs = math.max(1, math.floor(toNumber(opts.stepTimeoutMs, DEFAULT_STEP_TIMEOUT_MS)))
	local timeoutSeconds = timeoutMs / 1000

	local stateIndex = 1
	local stateLastStepTime = nil
	local cachedCanonical = nil
	local cachedSteps = nil

	local function reset()
		stateIndex = 1
		stateLastStepTime = nil
	end

	local function ensureParsed(binding)
		if type(binding) == "table" and binding.canonical and binding.steps then
			return binding.canonical, binding.steps, nil
		end

		local canonical, steps, parseErr = KeybindSequence.normalize(binding, {
			maxSteps = maxSteps
		})
		if not canonical then
			return nil, nil, parseErr
		end

		return canonical, steps, nil
	end

	local function setBinding(binding)
		local canonical, steps, parseErr = ensureParsed(binding)
		if not canonical then
			return nil, nil, parseErr
		end
		cachedCanonical = canonical
		cachedSteps = steps
		reset()
		return canonical, steps, nil
	end

	local function consume(input, binding, userInputService, processed)
		if processed then
			return false, nil, nil
		end

		local canonical = cachedCanonical
		local steps = cachedSteps

		if binding ~= nil then
			local nextCanonical, nextSteps, parseErr = ensureParsed(binding)
			if not nextCanonical then
				reset()
				return false, nil, parseErr
			end
			if nextCanonical ~= cachedCanonical then
				cachedCanonical = nextCanonical
				cachedSteps = nextSteps
				reset()
			end
			canonical = cachedCanonical
			steps = cachedSteps
		end

		if not canonical or not steps or #steps == 0 then
			return false, nil, "binding_not_initialized"
		end

		local now = os.clock()
		if stateLastStepTime and (now - stateLastStepTime) > timeoutSeconds then
			reset()
		end

		local expectedStep = steps[stateIndex]
		if expectedStep and KeybindSequence.matchStep(input, expectedStep, userInputService) then
			if stateIndex >= #steps then
				reset()
				return true, expectedStep, nil
			end
			stateIndex += 1
			stateLastStepTime = now
			return false, expectedStep, nil
		end

		local firstStep = steps[1]
		if stateIndex ~= 1 and firstStep and KeybindSequence.matchStep(input, firstStep, userInputService) then
			if #steps == 1 then
				reset()
				return true, firstStep, nil
			end
			stateIndex = 2
			stateLastStepTime = now
			return false, firstStep, nil
		end

		reset()
		return false, nil, nil
	end

	return {
		reset = reset,
		setBinding = setBinding,
		consume = consume
	}
end

KeybindSequence.DEFAULT_MAX_STEPS = DEFAULT_MAX_STEPS
KeybindSequence.DEFAULT_STEP_TIMEOUT_MS = DEFAULT_STEP_TIMEOUT_MS

return KeybindSequence
]])
put("src/services/layout-persistence.lua", [[-- Rayfield Layout Persistence Module
-- Collects/restores layout snapshots and debounces config save requests.

local LayoutPersistence = {}

local function getSharedUtils()
	if type(_G) == "table" and type(_G.__RayfieldSharedUtils) == "table" then
		return _G.__RayfieldSharedUtils
	end
	return nil
end

local function cloneTable(value)
	local shared = getSharedUtils()
	if shared and type(shared.cloneTable) == "function" then
		return shared.cloneTable(value)
	end
	if type(value) ~= "table" then
		return value
	end

	local out = {}
	for key, nested in pairs(value) do
		out[key] = cloneTable(nested)
	end
	return out
end

function LayoutPersistence.init(ctx)
	local self = {}

	ctx = ctx or {}
	local providers = {}
	local saveToken = 0
	local dirty = false
	local applying = false

	self.version = tonumber(ctx.version) or 1
	self.layoutKey = tostring(ctx.layoutKey or "__rayfield_layout")

	local getEnabled = ctx.getEnabled
	if type(getEnabled) ~= "function" then
		getEnabled = function()
			return true
		end
	end

	local getDebounceMs = ctx.getDebounceMs
	if type(getDebounceMs) ~= "function" then
		getDebounceMs = function()
			return 300
		end
	end

	local requestSave = ctx.requestSave
	if type(requestSave) ~= "function" then
		requestSave = function()
			return false
		end
	end

	local function isEnabled()
		local ok, enabled = pcall(getEnabled)
		if not ok then
			return false
		end
		return enabled == true
	end

	local function requestSaveNow(reason)
		local ok = pcall(requestSave, reason)
		return ok
	end

	local function sortedProviders()
		local sequence = {}
		for name, provider in pairs(providers) do
			table.insert(sequence, {
				name = name,
				order = tonumber(provider.order) or 100,
				provider = provider
			})
		end
		table.sort(sequence, function(left, right)
			if left.order == right.order then
				return left.name < right.name
			end
			return left.order < right.order
		end)
		return sequence
	end

	function self.registerProvider(name, opts)
		if type(name) ~= "string" or name == "" then
			return false
		end

		opts = opts or {}
		providers[name] = {
			order = tonumber(opts.order) or 100,
			snapshot = opts.snapshot,
			apply = opts.apply
		}
		return true
	end

	function self.unregisterProvider(name)
		providers[name] = nil
	end

	function self.getLayoutSnapshot()
		if not isEnabled() then
			return nil
		end

		local payload = {
			version = self.version
		}

		for _, entry in ipairs(sortedProviders()) do
			local snapshotFn = entry.provider.snapshot
			if type(snapshotFn) == "function" then
				local ok, snapshot = pcall(snapshotFn)
				if ok and snapshot ~= nil then
					payload[entry.name] = cloneTable(snapshot)
				end
			end
		end

		return payload
	end

	function self.applyLayoutSnapshot(payload)
		if type(payload) ~= "table" then
			return false
		end

		applying = true
		local okAll = true

		for _, entry in ipairs(sortedProviders()) do
			local applyFn = entry.provider.apply
			if type(applyFn) == "function" then
				local section = payload[entry.name]
				if section ~= nil then
					local ok = pcall(applyFn, cloneTable(section), cloneTable(payload))
					if not ok then
						okAll = false
					end
				end
			end
		end

		applying = false
		dirty = false
		return okAll
	end

	function self.markDirty(reason)
		if applying or not isEnabled() then
			return
		end

		dirty = true
		saveToken += 1
		local myToken = saveToken
		local debounceMs = tonumber(getDebounceMs()) or 300
		if debounceMs < 50 then
			debounceMs = 50
		end
		local delaySec = debounceMs / 1000

		task.delay(delaySec, function()
			if myToken ~= saveToken then
				return
			end
			if not dirty or applying or not isEnabled() then
				return
			end
			dirty = false
			requestSaveNow(reason or "layout_dirty")
		end)
	end

	function self.flush(reason)
		if applying or not isEnabled() then
			return false
		end

		dirty = false
		return requestSaveNow(reason or "layout_flush")
	end

	function self.isApplying()
		return applying
	end

	function self.isDirty()
		return dirty
	end

	return self
end

return LayoutPersistence
]])
put("src/services/ownership-tracker.lua", [[-- Rayfield Ownership Tracker
-- Scoped ownership registry for precise cleanup of UI features/resources.

local OwnershipTracker = {}

local function isInstance(value)
	return typeof(value) == "Instance"
end

local function isConnection(value)
	return typeof(value) == "RBXScriptConnection"
end

local function normalizeScopeId(scopeId)
	local normalized = tostring(scopeId or "")
	if normalized == "" then
		return "scope:default"
	end
	return normalized
end

local function safeDisconnect(connection)
	if not connection then
		return
	end
	if isConnection(connection) then
		pcall(function()
			connection:Disconnect()
		end)
		return
	end
	if type(connection) == "table" and type(connection.Disconnect) == "function" then
		pcall(connection.Disconnect, connection)
	end
end

local function safeCancelTask(taskHandle)
	if not taskHandle then
		return
	end
	if type(taskHandle) == "thread" then
		pcall(task.cancel, taskHandle)
	end
end

local function removeArrayValue(list, value)
	if type(list) ~= "table" then
		return
	end
	for index = #list, 1, -1 do
		if list[index] == value then
			table.remove(list, index)
		end
	end
end

local function clearOwnershipAttributes(instance, attrs, ownerValue, sessionValue)
	if not isInstance(instance) or type(instance.GetAttribute) ~= "function" or type(instance.SetAttribute) ~= "function" then
		return
	end

	local owned = false
	local okOwner, currentOwner = pcall(instance.GetAttribute, instance, attrs.owner)
	if okOwner and currentOwner == ownerValue then
		owned = true
	end
	local okSession, currentSession = pcall(instance.GetAttribute, instance, attrs.session)
	if okSession and currentSession == sessionValue then
		owned = true
	end
	if not owned then
		return
	end

	pcall(instance.SetAttribute, instance, attrs.owner, nil)
	pcall(instance.SetAttribute, instance, attrs.session, nil)
	pcall(instance.SetAttribute, instance, attrs.scope, nil)
end

local function setOwnershipAttributes(instance, attrs, ownerValue, sessionValue, scopeId)
	if not isInstance(instance) or type(instance.SetAttribute) ~= "function" then
		return
	end
	pcall(instance.SetAttribute, instance, attrs.owner, ownerValue)
	pcall(instance.SetAttribute, instance, attrs.session, sessionValue)
	pcall(instance.SetAttribute, instance, attrs.scope, scopeId)
end

function OwnershipTracker.init(ctx)
	local self = {}
	ctx = ctx or {}

	local HttpService = ctx.HttpService or game:GetService("HttpService")
	local ownerValue = tostring(ctx.owner or "rayfield-mod")
	local scopePrefix = tostring(ctx.scopePrefix or "rayfield")
	local attrs = {
		owner = tostring(ctx.ownerAttribute or "RayfieldOwner"),
		session = tostring(ctx.sessionAttribute or "RayfieldSession"),
		scope = tostring(ctx.scopeAttribute or "RayfieldScope")
	}

	local sessionValue = nil
	do
		local okGuid, guid = pcall(function()
			return HttpService:GenerateGUID(false)
		end)
		if okGuid and type(guid) == "string" and guid ~= "" then
			sessionValue = guid
		else
			sessionValue = tostring(math.floor(os.clock() * 100000))
		end
	end

	local scopeMap = {}
	local scopeOrder = {}
	local instanceToScope = setmetatable({}, { __mode = "k" })

	local function ensureScope(scopeId, meta)
		local normalizedScope = normalizeScopeId(scopeId)
		local scope = scopeMap[normalizedScope]
		if scope then
			if type(meta) == "table" then
				scope.meta = scope.meta or {}
				for key, value in pairs(meta) do
					if scope.meta[key] == nil then
						scope.meta[key] = value
					end
				end
			end
			return scope
		end

		scope = {
			id = normalizedScope,
			meta = type(meta) == "table" and meta or {},
			instances = setmetatable({}, { __mode = "k" }),
			connections = {},
			tasks = {},
			cleanups = {}
		}
		scopeMap[normalizedScope] = scope
		table.insert(scopeOrder, normalizedScope)
		return scope
	end

	local function removeScope(scopeId)
		scopeMap[scopeId] = nil
		removeArrayValue(scopeOrder, scopeId)
	end

	local function setInstanceScope(instance, scopeId)
		if not isInstance(instance) then
			return
		end

		local previousScopeId = instanceToScope[instance]
		if previousScopeId and previousScopeId ~= scopeId then
			local previousScope = scopeMap[previousScopeId]
			if previousScope then
				previousScope.instances[instance] = nil
			end
		end

		instanceToScope[instance] = scopeId
	end

	local function clearInstanceScope(instance, expectedScopeId)
		if not isInstance(instance) then
			return
		end
		if expectedScopeId and instanceToScope[instance] ~= expectedScopeId then
			return
		end
		instanceToScope[instance] = nil
	end

	self.createScope = function(scopeId, meta)
		local normalizedScope = normalizeScopeId(scopeId)
		ensureScope(normalizedScope, meta)
		return normalizedScope
	end

	self.makeScopeId = function(kind, identifier)
		local safeKind = tostring(kind or "scope")
		local safeIdentifier = tostring(identifier or "")
		if safeIdentifier == "" then
			safeIdentifier = tostring(math.floor(os.clock() * 100000))
		end
		return string.format("%s:%s:%s", scopePrefix, safeKind, safeIdentifier)
	end

	self.claimInstance = function(instance, scopeId, meta)
		if not isInstance(instance) then
			return false
		end
		local scope = ensureScope(scopeId, meta)
		setInstanceScope(instance, scope.id)
		scope.instances[instance] = true
		setOwnershipAttributes(instance, attrs, ownerValue, sessionValue, scope.id)
		return true
	end

	self.trackConnection = function(connection, scopeId)
		if not connection then
			return false
		end
		local scope = ensureScope(scopeId)
		table.insert(scope.connections, connection)
		return true
	end

	self.trackTask = function(taskHandle, scopeId)
		if not taskHandle then
			return false
		end
		local scope = ensureScope(scopeId)
		table.insert(scope.tasks, taskHandle)
		return true
	end

	self.trackCleanup = function(cleanupFn, scopeId)
		if type(cleanupFn) ~= "function" then
			return false
		end
		local scope = ensureScope(scopeId)
		table.insert(scope.cleanups, cleanupFn)
		return true
	end

	self.cleanupScope = function(scopeId, opts)
		local normalizedScope = normalizeScopeId(scopeId)
		local scope = scopeMap[normalizedScope]
		if not scope then
			return false
		end

		opts = opts or {}
		local shouldDestroyInstances = opts.destroyInstances == true
		local shouldClearAttributes = opts.clearAttributes ~= false

		for index = #scope.connections, 1, -1 do
			safeDisconnect(scope.connections[index])
			scope.connections[index] = nil
		end

		for index = #scope.tasks, 1, -1 do
			safeCancelTask(scope.tasks[index])
			scope.tasks[index] = nil
		end

		for index = #scope.cleanups, 1, -1 do
			local cleanupFn = scope.cleanups[index]
			scope.cleanups[index] = nil
			pcall(cleanupFn, opts)
		end

		for instance in pairs(scope.instances) do
			clearInstanceScope(instance, normalizedScope)

			if shouldClearAttributes then
				clearOwnershipAttributes(instance, attrs, ownerValue, sessionValue)
			end

			if shouldDestroyInstances and instance and instance.Parent then
				pcall(function()
					instance:Destroy()
				end)
			end
			scope.instances[instance] = nil
		end

		removeScope(normalizedScope)
		return true
	end

	self.cleanupByInstance = function(instance, opts)
		if not isInstance(instance) then
			return false
		end
		local scopeId = instanceToScope[instance]
		if not scopeId and type(instance.GetAttribute) == "function" then
			local okScope, attrScope = pcall(instance.GetAttribute, instance, attrs.scope)
			if okScope and type(attrScope) == "string" and attrScope ~= "" then
				scopeId = attrScope
			end
		end
		if not scopeId then
			return false
		end
		return self.cleanupScope(scopeId, opts)
	end

	self.cleanupSession = function(opts)
		opts = opts or {}
		local scopeSnapshot = {}
		for index, scopeId in ipairs(scopeOrder) do
			scopeSnapshot[index] = scopeId
		end

		for _, scopeId in ipairs(scopeSnapshot) do
			self.cleanupScope(scopeId, opts)
		end

		local shouldSweepRoot = opts.sweepRoot == true
		local shouldDestroyInstances = opts.destroyInstances == true
		local shouldClearAttributes = opts.clearAttributes ~= false
		local getRootGui = ctx.getRootGui
		if shouldSweepRoot and type(getRootGui) == "function" then
			local okRoot, root = pcall(getRootGui)
			if okRoot and isInstance(root) then
				local sweepList = { root }
				for _, descendant in ipairs(root:GetDescendants()) do
					table.insert(sweepList, descendant)
				end

				for _, instance in ipairs(sweepList) do
					local okOwner, currentOwner = pcall(instance.GetAttribute, instance, attrs.owner)
					local okSession, currentSession = pcall(instance.GetAttribute, instance, attrs.session)
					if okOwner and okSession and currentOwner == ownerValue and currentSession == sessionValue then
						if shouldClearAttributes then
							clearOwnershipAttributes(instance, attrs, ownerValue, sessionValue)
						end
						if shouldDestroyInstances and instance.Parent then
							pcall(function()
								instance:Destroy()
							end)
						end
					end
				end
			end
		end

		return true
	end

	self.getStats = function()
		local stats = {
			scopes = 0,
			instances = 0,
			connections = 0,
			tasks = 0,
			cleanups = 0
		}
		for _, scope in pairs(scopeMap) do
			stats.scopes += 1
			stats.connections += #scope.connections
			stats.tasks += #scope.tasks
			stats.cleanups += #scope.cleanups
			for _ in pairs(scope.instances) do
				stats.instances += 1
			end
		end
		return stats
	end

	self.getSignature = function()
		return {
			owner = ownerValue,
			session = sessionValue,
			ownerAttribute = attrs.owner,
			sessionAttribute = attrs.session,
			scopeAttribute = attrs.scope
		}
	end

	return self
end

return OwnershipTracker
]])
put("src/services/settings.lua", [=[--[[
	Rayfield Settings/Config System Module
	Extracted from rayfield-modified.lua
	
	This module handles:
	- Settings table management
	- Loading/saving settings from/to file
	- Settings UI creation
	- Setting overrides
]]

local SettingsModule = {}

-- Default settings table structure
SettingsModule.defaultSettings = {
	General = {
		rayfieldOpen = {Type = 'bind', Value = 'K', Name = 'Rayfield Keybind'},
	},
	System = {
		usageAnalytics = {Type = 'toggle', Value = true, Name = 'Anonymised Analytics'},
	},
	Appearance = {
		uiPreset = {
			Type = "dropdown",
			Value = "Comfort",
			Name = "UI Preset",
			Options = {"Compact", "Comfort", "Focus"}
		},
		transitionProfile = {
			Type = "dropdown",
			Value = "Smooth",
			Name = "Transition Profile",
			Options = {"Minimal", "Smooth", "Snappy", "Off"}
		}
	},
	Favorites = {
		showPinBadges = {Type = "toggle", Value = true, Name = "Show Pin Badges"},
		pinnedIds = {Type = "hidden", Value = {}, Name = "Pinned Control IDs"}
	},
	Onboarding = {
		suppressed = {Type = "hidden", Value = false, Name = "Onboarding Suppressed"}
	},
	ThemeStudio = {
		baseTheme = {Type = "hidden", Value = "Default", Name = "Base Theme"},
		useCustom = {Type = "toggle", Value = false, Name = "Use Custom Theme"},
		customThemePacked = {Type = "hidden", Value = {}, Name = "Custom Theme Colors"}
	},
	Layout = {
		collapsedSections = {Type = "hidden", Value = {}, Name = "Collapsed Sections"}
	}
}

-- Initialize module with dependencies
function SettingsModule.init(ctx)
	local self = {}
	
	-- Store dependencies from context
	self.RayfieldFolder = ctx.RayfieldFolder
	self.ConfigurationExtension = ctx.ConfigurationExtension
	self.HttpService = ctx.HttpService
	self.useStudio = ctx.useStudio
	self.callSafely = ctx.callSafely
	self.Topbar = ctx.Topbar
	self.TabList = ctx.TabList
	self.Elements = ctx.Elements
	
	-- State variables
	self.settingsTable = {}
	self.overriddenSettings = {}
	self.cachedSettings = nil
	self.settingsInitialized = false
	self.settingsCreated = false
	self.shareCodeHandlers = {}
	self.shareCodeDraft = ""
	self.shareCodeInput = nil
	self.experienceHandlers = {}

	local function cloneSerializable(value)
		local valueType = type(value)
		if valueType == "function" or valueType == "userdata" or valueType == "thread" then
			return nil
		end
		if valueType ~= "table" then
			return value
		end

		local out = {}
		for key, nestedValue in pairs(value) do
			if key ~= "Element" then
				local keyType = type(key)
				if keyType ~= "function" and keyType ~= "userdata" and keyType ~= "thread" then
					local cloned = cloneSerializable(nestedValue)
					if cloned ~= nil then
						out[key] = cloned
					end
				end
			end
		end
		return out
	end

	local function valuesEqual(a, b)
		if a == b then
			return true
		end
		if type(a) ~= type(b) then
			return false
		end
		if type(a) ~= "table" then
			return false
		end

		for key, valueA in pairs(a) do
			if not valuesEqual(valueA, b[key]) then
				return false
			end
		end
		for key in pairs(b) do
			if a[key] == nil then
				return false
			end
		end
		return true
	end

	local function buildInternalSettingsData()
		local out = {}
		for categoryName, settingCategory in pairs(self.settingsTable) do
			out[categoryName] = {}
			for settingName, setting in pairs(settingCategory) do
				out[categoryName][settingName] = {
					Type = setting.Type,
					Value = cloneSerializable(setting.Value),
					Name = setting.Name
				}
			end
		end
		return out
	end
	
	-- Initialize settings table with defaults
	for category, settings in pairs(SettingsModule.defaultSettings) do
		self.settingsTable[category] = {}
		for name, setting in pairs(settings) do
			self.settingsTable[category][name] = {
				Type = setting.Type,
				Value = cloneSerializable(setting.Value),
				Name = setting.Name,
				Options = cloneSerializable(setting.Options),
				Element = nil
			}
		end
	end
	
	-- Override a setting value
	function self.overrideSetting(category, name, value)
		self.overriddenSettings[category .. "." .. name] = value
	end
	
	-- Get setting value (checks overrides first)
	function self.getSetting(category, name)
		local key = tostring(category or "") .. "." .. tostring(name or "")
		if self.overriddenSettings[key] ~= nil then
			return self.overriddenSettings[key]
		end
		if self.settingsTable[category] and self.settingsTable[category][name] ~= nil then
			return self.settingsTable[category][name].Value
		end
		return nil
	end

	function self.setSettingValue(category, name, value, persist)
		if not (self.settingsTable[category] and self.settingsTable[category][name]) then
			return false, "Unknown setting."
		end

		local setting = self.settingsTable[category][name]
		local previousValue = setting.Value
		local nextValue = cloneSerializable(value)
		local changed = not valuesEqual(previousValue, nextValue)
		setting.Value = nextValue
		self.overriddenSettings[tostring(category) .. "." .. tostring(name)] = nil

		if changed and setting.Element and type(setting.Element.Set) == "function" then
			local okSet = pcall(function()
				setting.Element:Set(nextValue)
			end)
			if not okSet then
				-- Keep in-memory value even if UI element fails.
			end
		end

		if persist ~= false then
			self.saveSettings()
		end
		return true, "ok"
	end

	function self.ExportInternalSettingsData()
		return buildInternalSettingsData()
	end

	function self.ImportInternalSettingsData(dataTable)
		if type(dataTable) ~= "table" then
			return false, "Internal settings data must be a table."
		end

		local appliedCount = 0
		for categoryName, settingCategory in pairs(self.settingsTable) do
			local incomingCategory = dataTable[categoryName]
			if type(incomingCategory) == "table" then
				for settingName, setting in pairs(settingCategory) do
					local incomingSetting = incomingCategory[settingName]
					if type(incomingSetting) == "table" and incomingSetting.Value ~= nil then
						local nextValue = cloneSerializable(incomingSetting.Value)
						setting.Value = nextValue
						self.overriddenSettings[categoryName .. "." .. settingName] = nil
						if setting.Element and type(setting.Element.Set) == "function" then
							local okSet, errSet = pcall(function()
								setting.Element:Set(nextValue)
							end)
							if not okSet then
								warn("Rayfield | Failed to apply internal setting '" .. categoryName .. "." .. settingName .. "': " .. tostring(errSet))
							end
						end
						appliedCount += 1
					end
				end
			end
		end

		return true, appliedCount
	end

	function self.getShareCodeInputValue()
		return tostring(self.shareCodeDraft or "")
	end

	function self.setShareCodeInputValue(value)
		self.shareCodeDraft = tostring(value or "")
		if self.shareCodeInput and type(self.shareCodeInput.Set) == "function" then
			pcall(function()
				self.shareCodeInput:Set(self.shareCodeDraft)
			end)
		end
		return self.shareCodeDraft
	end

	local function syncShareCodeInputFromHandlers()
		local handlers = self.shareCodeHandlers
		if type(handlers) ~= "table" then
			return
		end
		if type(handlers.getActiveShareCode) ~= "function" then
			return
		end

		local okGet, code = pcall(handlers.getActiveShareCode)
		if okGet and type(code) == "string" then
			self.setShareCodeInputValue(code)
		end
	end

	function self.setShareCodeHandlers(handlers)
		if type(handlers) == "table" then
			self.shareCodeHandlers = handlers
		else
			self.shareCodeHandlers = {}
		end
		syncShareCodeInputFromHandlers()
	end

	function self.setExperienceHandlers(handlers)
		if type(handlers) == "table" then
			self.experienceHandlers = handlers
		else
			self.experienceHandlers = {}
		end
	end
	
	-- Save settings to file
	function self.saveSettings()
		local encoded
		local success, err = pcall(function()
			encoded = self.HttpService:JSONEncode(buildInternalSettingsData())
		end)

		if success then
			if self.useStudio then
				if script.Parent['get.val'] then
					script.Parent['get.val'].Value = encoded
				end
			end
			if type(writefile) ~= "function" then
				return self.useStudio == true
			end
			local writeResult = self.callSafely(writefile, self.RayfieldFolder..'/settings'..self.ConfigurationExtension, encoded)
			return writeResult ~= false
		end
		return false
	end
	
	-- Update a setting and save
	function self.updateSetting(category, setting, value)
		if not self.settingsInitialized then
			return
		end
		self.settingsTable[category][setting].Value = value
		self.overriddenSettings[category .. "." .. setting] = nil
		self.saveSettings()
	end
	
	-- Load settings from file
	function self.loadSettings()
		local file = nil

		task.spawn(function()
			local ok, err = xpcall(function()
				if self.callSafely(isfolder, self.RayfieldFolder) then
					if self.callSafely(isfile, self.RayfieldFolder..'/settings'..self.ConfigurationExtension) then
						file = self.callSafely(readfile, self.RayfieldFolder..'/settings'..self.ConfigurationExtension)
					end
				end

				-- for debug in studio
				if self.useStudio then
					file = [[
			{"General":{"rayfieldOpen":{"Value":"K","Type":"bind","Name":"Rayfield Keybind","Element":{"HoldToInteract":false,"Ext":true,"Name":"Rayfield Keybind","Set":null,"CallOnChange":true,"Callback":null,"CurrentKeybind":"K"}}},"System":{"usageAnalytics":{"Value":false,"Type":"toggle","Name":"Anonymised Analytics","Element":{"Ext":true,"Name":"Anonymised Analytics","Set":null,"CurrentValue":false,"Callback":null}}}}
		]]
				end

				if file then
					local success, decodedFile = pcall(function() return self.HttpService:JSONDecode(file) end)
					if success and type(decodedFile) == "table" then
						file = decodedFile
					else
						file = {}
					end
				else
					file = {}
				end

				if not self.settingsCreated then 
					self.cachedSettings = file
					return
				end

				if type(file) == "table" and next(file) ~= nil then
					for categoryName, settingCategory in pairs(self.settingsTable) do
						if file[categoryName] then
							for settingName, setting in pairs(settingCategory) do
								if file[categoryName][settingName] then
									setting.Value = cloneSerializable(file[categoryName][settingName].Value)
									if setting.Element and type(setting.Element.Set) == "function" then
										setting.Element:Set(self.getSetting(categoryName, settingName))
									end
								end
							end
						end
					end
				else
					for settingName, settingValue in pairs(self.overriddenSettings) do
						local split = string.split(settingName, ".")
						assert(#split == 2, "Rayfield | Invalid overridden setting name: " .. settingName)
						local categoryName = split[1]
						local settingNameOnly = split[2]
						if self.settingsTable[categoryName] and self.settingsTable[categoryName][settingNameOnly] then
							local targetSetting = self.settingsTable[categoryName][settingNameOnly]
							if targetSetting.Element and type(targetSetting.Element.Set) == "function" then
								targetSetting.Element:Set(settingValue)
							else
								targetSetting.Value = cloneSerializable(settingValue)
							end
						end
					end
				end
				self.settingsInitialized = true
			end, debug.traceback)
			if not ok then
				warn("Rayfield | Failed to load settings: " .. tostring(err))
			end
		end)
	end


	-- Create settings UI tab
	function self.createSettings(window)
		local hasFilePersistence = type(writefile) == "function"
			and type(isfile) == "function"
			and type(readfile) == "function"
			and type(isfolder) == "function"
			and type(makefolder) == "function"

		local newTab = window:CreateTab('Rayfield Settings', 0, true)

		if self.TabList['Rayfield Settings'] then
			self.TabList['Rayfield Settings'].LayoutOrder = 1000
		end

		if self.Elements['Rayfield Settings'] then
			self.Elements['Rayfield Settings'].LayoutOrder = 1000
		end

		if not hasFilePersistence and not self.useStudio then
			warn("Rayfield | File APIs are unavailable. Settings, Theme Studio, and Share Code will run in session-only mode.")
			newTab:CreateSection("Session")
			newTab:CreateParagraph({
				Title = "Session-only settings",
				Content = "File APIs are not available. Export/import code and UI customization still work, but local file persistence is disabled for this session."
			})
		end

		local function notifyShareCodeResult(success, message)
			local handlers = self.shareCodeHandlers
			if type(handlers) == "table" and type(handlers.notify) == "function" then
				local okNotify = pcall(handlers.notify, success == true, tostring(message or ""))
				if okNotify then
					return
				end
			end
			if success ~= true then
				warn("Rayfield | " .. tostring(message or "Share code operation failed."))
			end
		end

		local function runImportCode()
			local handlers = self.shareCodeHandlers
			if type(handlers) ~= "table" or type(handlers.importCode) ~= "function" then
				notifyShareCodeResult(false, "Share code system unavailable.")
				return
			end

			local okCall, success, message = pcall(handlers.importCode, tostring(self.shareCodeDraft or ""))
			if not okCall then
				notifyShareCodeResult(false, tostring(success))
				return
			end

			if success == true and type(handlers.getActiveShareCode) == "function" then
				local okGet, code = pcall(handlers.getActiveShareCode)
				if okGet and type(code) == "string" then
					self.setShareCodeInputValue(code)
				end
			end
			notifyShareCodeResult(success == true, message)
		end

		local function runImportSettings()
			local handlers = self.shareCodeHandlers
			if type(handlers) ~= "table" or type(handlers.importSettings) ~= "function" then
				notifyShareCodeResult(false, "Share code system unavailable.")
				return
			end

			local okCall, success, message = pcall(handlers.importSettings)
			if not okCall then
				notifyShareCodeResult(false, tostring(success))
				return
			end

			if type(handlers.getActiveShareCode) == "function" then
				local okGet, code = pcall(handlers.getActiveShareCode)
				if okGet and type(code) == "string" then
					self.setShareCodeInputValue(code)
				end
			end
			notifyShareCodeResult(success == true, message)
		end

		local function runExportSettings()
			local handlers = self.shareCodeHandlers
			if type(handlers) ~= "table" or type(handlers.exportSettings) ~= "function" then
				notifyShareCodeResult(false, "Share code system unavailable.")
				return
			end

			local okCall, exportedCode, message = pcall(handlers.exportSettings)
			if not okCall then
				notifyShareCodeResult(false, tostring(exportedCode))
				return
			end

			local success = type(exportedCode) == "string" and exportedCode ~= ""
			if success then
				self.setShareCodeInputValue(exportedCode)
			elseif type(handlers.getActiveShareCode) == "function" then
				local okGet, code = pcall(handlers.getActiveShareCode)
				if okGet and type(code) == "string" then
					self.setShareCodeInputValue(code)
				end
			end
			notifyShareCodeResult(success, message)
		end

		local function runCopyShareCode()
			local handlers = self.shareCodeHandlers
			if type(handlers) ~= "table" or type(handlers.copyShareCode) ~= "function" then
				notifyShareCodeResult(false, "Share code system unavailable.")
				return
			end

			local okCall, success, message = pcall(handlers.copyShareCode)
			if not okCall then
				notifyShareCodeResult(false, tostring(success))
				return
			end

			if type(handlers.getActiveShareCode) == "function" then
				local okGet, code = pcall(handlers.getActiveShareCode)
				if okGet and type(code) == "string" then
					self.setShareCodeInputValue(code)
				end
			end
			notifyShareCodeResult(success == true, message)
		end

		local function notifyExperienceResult(success, message)
			local handlers = self.experienceHandlers
			if type(handlers) == "table" and type(handlers.notify) == "function" then
				local okNotify = pcall(handlers.notify, success == true, tostring(message or ""))
				if okNotify then
					return
				end
			end
			if success ~= true then
				warn("Rayfield | " .. tostring(message or "UI experience operation failed."))
			end
		end

		local genericSkipCategories = {
			Appearance = true,
			Favorites = true,
			ThemeStudio = true,
			Onboarding = true
		}

		-- Create generic sections and elements
		for categoryName, settingCategory in pairs(self.settingsTable) do
			if not genericSkipCategories[categoryName] then
				local sectionCreated = false
				for settingName, setting in pairs(settingCategory) do
					if setting.Type ~= "hidden" then
						if not sectionCreated then
							newTab:CreateSection(categoryName)
							sectionCreated = true
						end

						if setting.Type == 'input' then
							setting.Element = newTab:CreateInput({
								Name = setting.Name,
								CurrentValue = setting.Value,
								PlaceholderText = setting.Placeholder,
								Ext = true,
								RemoveTextAfterFocusLost = setting.ClearOnFocus,
								Callback = function(Value)
									self.updateSetting(categoryName, settingName, Value)
								end,
							})
						elseif setting.Type == 'toggle' then
							setting.Element = newTab:CreateToggle({
								Name = setting.Name,
								CurrentValue = setting.Value,
								Ext = true,
								Callback = function(Value)
									self.updateSetting(categoryName, settingName, Value)
								end,
							})
						elseif setting.Type == 'bind' then
							setting.Element = newTab:CreateKeybind({
								Name = setting.Name,
								CurrentKeybind = setting.Value,
								HoldToInteract = false,
								Ext = true,
								CallOnChange = true,
								Callback = function(Value)
									self.updateSetting(categoryName, settingName, Value)
								end,
							})
						elseif setting.Type == "dropdown" then
							setting.Element = newTab:CreateDropdown({
								Name = setting.Name,
								Options = setting.Options or {},
								CurrentOption = setting.Value,
								MultipleOptions = false,
								Ext = true,
								Callback = function(selection)
									local nextValue = nil
									if type(selection) == "table" then
										nextValue = selection[1]
									else
										nextValue = selection
									end
									self.updateSetting(categoryName, settingName, tostring(nextValue or ""))
								end
							})
						end
					end
				end
			end
		end

		local function invokeExperience(handlerName, ...)
			local experienceHandlers = self.experienceHandlers
			if type(experienceHandlers) ~= "table" then
				return false, "UI experience system unavailable.", nil
			end
			local handler = experienceHandlers[handlerName]
			if type(handler) ~= "function" then
				return false, "Handler unavailable: " .. tostring(handlerName), nil
			end
			local okCall, resultA, resultB = pcall(handler, ...)
			if not okCall then
				return false, tostring(resultA), nil
			end
			if type(resultA) == "boolean" then
				return resultA, resultB, nil
			end
			return true, resultA, resultB
		end

		newTab:CreateSection("Experience")
		local appearanceCategory = self.settingsTable.Appearance or {}
		local uiPresetSetting = appearanceCategory.uiPreset
		local transitionSetting = appearanceCategory.transitionProfile

		if uiPresetSetting then
			uiPresetSetting.Element = newTab:CreateDropdown({
				Name = uiPresetSetting.Name or "UI Preset",
				Options = uiPresetSetting.Options or {"Compact", "Comfort", "Focus"},
				CurrentOption = self.getSetting("Appearance", "uiPreset") or uiPresetSetting.Value,
				MultipleOptions = false,
				Ext = true,
				Callback = function(selection)
					local value = type(selection) == "table" and selection[1] or selection
					value = tostring(value or "")
					local ok, message = invokeExperience("setUIPreset", value)
					if ok then
						self.updateSetting("Appearance", "uiPreset", value)
					end
					notifyExperienceResult(ok, message)
				end
			})
		end

		if transitionSetting then
			transitionSetting.Element = newTab:CreateDropdown({
				Name = transitionSetting.Name or "Transition Profile",
				Options = transitionSetting.Options or {"Minimal", "Smooth", "Snappy", "Off"},
				CurrentOption = self.getSetting("Appearance", "transitionProfile") or transitionSetting.Value,
				MultipleOptions = false,
				Ext = true,
				Callback = function(selection)
					local value = type(selection) == "table" and selection[1] or selection
					value = tostring(value or "")
					local ok, message = invokeExperience("setTransitionProfile", value)
					if ok then
						self.updateSetting("Appearance", "transitionProfile", value)
					end
					notifyExperienceResult(ok, message)
				end
			})
		end

		newTab:CreateButton({
			Name = "Replay Onboarding",
			Ext = true,
			Callback = function()
				local ok, message = invokeExperience("showOnboarding", true)
				notifyExperienceResult(ok, message)
			end
		})

		newTab:CreateSection("Favorites Manager")
		local favoritesCategory = self.settingsTable.Favorites or {}
		local selectedFavoriteId = ""
		local favoritesOptionMap = {}
		local favoritesOptionOrder = {}
		local favoritesDropdownElement = nil

		local function listFavoriteControlOptions()
			favoritesOptionMap = {}
			favoritesOptionOrder = {}
			local fallback = "(No controls found)"
			local options = { fallback }
			favoritesOptionMap[fallback] = nil

			local controls = nil
			local okList, listOrMessage = invokeExperience("listControls", true)
			if okList and type(listOrMessage) == "table" and #listOrMessage > 0 then
				controls = listOrMessage
			end
			if type(controls) == "table" and #controls > 0 then
				options = {}
				for _, control in ipairs(controls) do
					local controlId = tostring(control.id or "")
					if controlId ~= "" then
						local label = string.format("[%s] %s (%s)", tostring(control.type or "Element"), tostring(control.name or controlId), controlId)
						table.insert(options, label)
						favoritesOptionMap[label] = controlId
						table.insert(favoritesOptionOrder, controlId)
					end
				end
			end

			return options
		end

		local function refreshFavoritesDropdown()
			local options = listFavoriteControlOptions()
			local targetLabel = options[1]
			for _, label in ipairs(options) do
				if favoritesOptionMap[label] == selectedFavoriteId then
					targetLabel = label
					break
				end
			end

			if favoritesDropdownElement and type(favoritesDropdownElement.Refresh) == "function" then
				favoritesDropdownElement:Refresh(options)
				if type(favoritesDropdownElement.Set) == "function" and targetLabel then
					favoritesDropdownElement:Set(targetLabel)
				end
			end
		end

		favoritesDropdownElement = newTab:CreateDropdown({
			Name = "Control",
			Options = listFavoriteControlOptions(),
			CurrentOption = nil,
			MultipleOptions = false,
			Ext = true,
			Callback = function(selection)
				local label = type(selection) == "table" and selection[1] or selection
				selectedFavoriteId = favoritesOptionMap[tostring(label or "")] or ""
			end
		})

		local showPinBadgesSetting = favoritesCategory.showPinBadges
		if showPinBadgesSetting then
			showPinBadgesSetting.Element = newTab:CreateToggle({
				Name = showPinBadgesSetting.Name or "Show Pin Badges",
				CurrentValue = self.getSetting("Favorites", "showPinBadges"),
				Ext = true,
				Callback = function(value)
					self.updateSetting("Favorites", "showPinBadges", value == true)
					local okPin, message = invokeExperience("setPinBadgesVisible", value == true)
					notifyExperienceResult(okPin, message)
				end
			})
			local okInit, message = invokeExperience("setPinBadgesVisible", self.getSetting("Favorites", "showPinBadges") ~= false)
			if not okInit then
				notifyExperienceResult(false, message)
			end
		end

		newTab:CreateButton({
			Name = "Pin Selected",
			Ext = true,
			Callback = function()
				if selectedFavoriteId == "" then
					notifyExperienceResult(false, "No control selected.")
					return
				end
				local ok, message = invokeExperience("pinControl", selectedFavoriteId)
				notifyExperienceResult(ok, message)
				refreshFavoritesDropdown()
			end
		})

		newTab:CreateButton({
			Name = "Unpin Selected",
			Ext = true,
			Callback = function()
				if selectedFavoriteId == "" then
					notifyExperienceResult(false, "No control selected.")
					return
				end
				local ok, message = invokeExperience("unpinControl", selectedFavoriteId)
				notifyExperienceResult(ok, message)
				refreshFavoritesDropdown()
			end
		})

		newTab:CreateButton({
			Name = "Refresh Controls",
			Ext = true,
			Callback = function()
				refreshFavoritesDropdown()
				notifyExperienceResult(true, "Control list refreshed.")
			end
		})

		newTab:CreateButton({
			Name = "Open Favorites Tab",
			Ext = true,
			Callback = function()
				local ok, message = invokeExperience("openFavoritesTab")
				notifyExperienceResult(ok, message)
			end
		})

		newTab:CreateSection("Theme Studio")
		local themeCategory = self.settingsTable.ThemeStudio or {}
		local themeColorElements = {}
		local themeBaseDropdown = nil

		local function listThemeNames()
			local okNames, names = invokeExperience("getThemeNames")
			if okNames and type(names) == "table" and #names > 0 then
				return names
			end
			return {"Default"}
		end

		local function getThemeColorValue(themeKey)
			local okColor, color = invokeExperience("getThemeStudioColor", themeKey)
			if okColor and typeof(color) == "Color3" then
				return color
			end
			return Color3.fromRGB(255, 255, 255)
		end

		local baseThemeSetting = themeCategory.baseTheme
		themeBaseDropdown = newTab:CreateDropdown({
			Name = "Base Theme",
			Options = listThemeNames(),
			CurrentOption = self.getSetting("ThemeStudio", "baseTheme") or "Default",
			MultipleOptions = false,
			Ext = true,
				Callback = function(selection)
					local value = type(selection) == "table" and selection[1] or selection
					value = tostring(value or "Default")
					local ok, message = invokeExperience("setThemeStudioBaseTheme", value)
					if ok then
						self.setSettingValue("ThemeStudio", "baseTheme", value, true)
					end
				notifyExperienceResult(ok, message)
			end
		})
		if baseThemeSetting then
			baseThemeSetting.Element = themeBaseDropdown
		end

		local useCustomSetting = themeCategory.useCustom
		if useCustomSetting then
			useCustomSetting.Element = newTab:CreateToggle({
				Name = useCustomSetting.Name or "Use Custom Theme",
				CurrentValue = self.getSetting("ThemeStudio", "useCustom") == true,
				Ext = true,
				Callback = function(value)
					local boolValue = value == true
					local ok, message = invokeExperience("setThemeStudioUseCustom", boolValue)
					if ok then
						self.setSettingValue("ThemeStudio", "useCustom", boolValue, true)
					end
					notifyExperienceResult(ok, message)
				end
			})
		end

		local themeKeys = {}
		local okThemeKeys, resolvedThemeKeys = invokeExperience("getThemeStudioKeys")
		if okThemeKeys and type(resolvedThemeKeys) == "table" then
			themeKeys = resolvedThemeKeys
		end
		for _, themeKey in ipairs(themeKeys) do
			local keyName = tostring(themeKey)
			themeColorElements[keyName] = newTab:CreateColorPicker({
				Name = keyName,
				Color = getThemeColorValue(keyName),
				Ext = true,
				Callback = function(color)
					local okColor, message = invokeExperience("setThemeStudioColor", keyName, color)
					if okColor then
						self.setSettingValue("ThemeStudio", "useCustom", true, false)
						local packedSetting = self.getSetting("ThemeStudio", "customThemePacked")
						if type(packedSetting) ~= "table" then
							packedSetting = {}
						end
						packedSetting[keyName] = {
							R = math.floor(color.R * 255 + 0.5),
							G = math.floor(color.G * 255 + 0.5),
							B = math.floor(color.B * 255 + 0.5)
						}
						self.setSettingValue("ThemeStudio", "customThemePacked", packedSetting, false)
					end
					notifyExperienceResult(okColor, message)
				end
			})
		end

		newTab:CreateButton({
			Name = "Apply Draft",
			Ext = true,
			Callback = function()
				local ok, message = invokeExperience("applyThemeStudioDraft")
				notifyExperienceResult(ok, message)
			end
		})

		newTab:CreateButton({
			Name = "Reset To Base",
			Ext = true,
			Callback = function()
				local ok, message = invokeExperience("resetThemeStudio")
				if ok then
					self.setSettingValue("ThemeStudio", "useCustom", false, false)
					self.setSettingValue("ThemeStudio", "customThemePacked", {}, false)
					if useCustomSetting and useCustomSetting.Element and type(useCustomSetting.Element.Set) == "function" then
						useCustomSetting.Element:Set(false)
					end
					if themeBaseDropdown and type(themeBaseDropdown.Set) == "function" then
						local nextBase = self.getSetting("ThemeStudio", "baseTheme") or "Default"
						themeBaseDropdown:Set(nextBase)
					end
					for keyName, colorElement in pairs(themeColorElements) do
						if colorElement and type(colorElement.Set) == "function" then
							colorElement:Set(getThemeColorValue(keyName))
						end
					end
					self.saveSettings()
				end
				notifyExperienceResult(ok, message)
			end
		})

		newTab:CreateSection("Share Code")

		self.shareCodeInput = newTab:CreateInput({
			Name = "Share Code",
			CurrentValue = self.getShareCodeInputValue(),
			PlaceholderText = "Paste RFSC1 share code here",
			Ext = true,
			RemoveTextAfterFocusLost = false,
			Callback = function(value)
				self.shareCodeDraft = tostring(value or "")
			end,
		})

		newTab:CreateButton({
			Name = "Import Code",
			Ext = true,
			Callback = runImportCode,
		})

		newTab:CreateButton({
			Name = "Import Settings",
			Ext = true,
			Callback = runImportSettings,
		})

		newTab:CreateButton({
			Name = "Export Settings",
			Ext = true,
			Callback = runExportSettings,
		})

		newTab:CreateButton({
			Name = "Copy Share code",
			Ext = true,
			Callback = runCopyShareCode,
		})

		self.settingsCreated = true
		syncShareCodeInputFromHandlers()
		self.loadSettings()
		self.saveSettings()
	end

	return self
end

return SettingsModule
]=])
put("src/services/theme.lua", [=[--[[
	Rayfield Theme System Module
	Extracted from rayfield-modified.lua
	
	This module handles:
	- Theme definitions (Default, Ocean, AmberGlow, Light, Amethyst, Green, Bloom, DarkBlue, Serenity)
	- Theme switching functionality
	- Icon system integration
]]

local ThemeModule = {}

-- Theme Definitions
ThemeModule.Themes = {
	Default = {
		TextColor = Color3.fromRGB(240, 240, 240),

		Background = Color3.fromRGB(25, 25, 25),
		Topbar = Color3.fromRGB(34, 34, 34),
		Shadow = Color3.fromRGB(20, 20, 20),

		NotificationBackground = Color3.fromRGB(20, 20, 20),
		NotificationActionsBackground = Color3.fromRGB(230, 230, 230),

		TabBackground = Color3.fromRGB(80, 80, 80),
		TabStroke = Color3.fromRGB(85, 85, 85),
		TabBackgroundSelected = Color3.fromRGB(210, 210, 210),
		TabTextColor = Color3.fromRGB(240, 240, 240),
		SelectedTabTextColor = Color3.fromRGB(50, 50, 50),

		ElementBackground = Color3.fromRGB(35, 35, 35),
		ElementBackgroundHover = Color3.fromRGB(40, 40, 40),
		SecondaryElementBackground = Color3.fromRGB(25, 25, 25),
		ElementStroke = Color3.fromRGB(50, 50, 50),
		SecondaryElementStroke = Color3.fromRGB(40, 40, 40),

		SliderBackground = Color3.fromRGB(50, 138, 220),
		SliderProgress = Color3.fromRGB(50, 138, 220),
		SliderStroke = Color3.fromRGB(58, 163, 255),

		ToggleBackground = Color3.fromRGB(30, 30, 30),
		ToggleEnabled = Color3.fromRGB(0, 146, 214),
		ToggleDisabled = Color3.fromRGB(100, 100, 100),
		ToggleEnabledStroke = Color3.fromRGB(0, 170, 255),
		ToggleDisabledStroke = Color3.fromRGB(125, 125, 125),
		ToggleEnabledOuterStroke = Color3.fromRGB(100, 100, 100),
		ToggleDisabledOuterStroke = Color3.fromRGB(65, 65, 65),

		DropdownSelected = Color3.fromRGB(40, 40, 40),
		DropdownUnselected = Color3.fromRGB(30, 30, 30),

		InputBackground = Color3.fromRGB(30, 30, 30),
		InputStroke = Color3.fromRGB(65, 65, 65),
		PlaceholderColor = Color3.fromRGB(178, 178, 178),

		TooltipBackground = Color3.fromRGB(20, 20, 20),
		TooltipTextColor = Color3.fromRGB(240, 240, 240),
		TooltipStroke = Color3.fromRGB(55, 55, 55),

		ChartLine = Color3.fromRGB(70, 160, 255),
		ChartGrid = Color3.fromRGB(55, 55, 55),
		ChartFill = Color3.fromRGB(45, 110, 180),

		LogInfo = Color3.fromRGB(210, 220, 235),
		LogWarn = Color3.fromRGB(255, 210, 120),
		LogError = Color3.fromRGB(255, 120, 120),

		ConfirmArmed = Color3.fromRGB(180, 110, 40),
		SectionChevron = Color3.fromRGB(220, 220, 220)
	},

	Ocean = {
		TextColor = Color3.fromRGB(230, 240, 240),

		Background = Color3.fromRGB(20, 30, 30),
		Topbar = Color3.fromRGB(25, 40, 40),
		Shadow = Color3.fromRGB(15, 20, 20),

		NotificationBackground = Color3.fromRGB(25, 35, 35),
		NotificationActionsBackground = Color3.fromRGB(230, 240, 240),

		TabBackground = Color3.fromRGB(40, 60, 60),
		TabStroke = Color3.fromRGB(50, 70, 70),
		TabBackgroundSelected = Color3.fromRGB(100, 180, 180),
		TabTextColor = Color3.fromRGB(210, 230, 230),
		SelectedTabTextColor = Color3.fromRGB(20, 50, 50),

		ElementBackground = Color3.fromRGB(30, 50, 50),
		ElementBackgroundHover = Color3.fromRGB(40, 60, 60),
		SecondaryElementBackground = Color3.fromRGB(30, 45, 45),
		ElementStroke = Color3.fromRGB(45, 70, 70),
		SecondaryElementStroke = Color3.fromRGB(40, 65, 65),

		SliderBackground = Color3.fromRGB(0, 110, 110),
		SliderProgress = Color3.fromRGB(0, 140, 140),
		SliderStroke = Color3.fromRGB(0, 160, 160),

		ToggleBackground = Color3.fromRGB(30, 50, 50),
		ToggleEnabled = Color3.fromRGB(0, 130, 130),
		ToggleDisabled = Color3.fromRGB(70, 90, 90),
		ToggleEnabledStroke = Color3.fromRGB(0, 160, 160),
		ToggleDisabledStroke = Color3.fromRGB(85, 105, 105),
		ToggleEnabledOuterStroke = Color3.fromRGB(50, 100, 100),
		ToggleDisabledOuterStroke = Color3.fromRGB(45, 65, 65),

		DropdownSelected = Color3.fromRGB(30, 60, 60),
		DropdownUnselected = Color3.fromRGB(25, 40, 40),

		InputBackground = Color3.fromRGB(30, 50, 50),
		InputStroke = Color3.fromRGB(50, 70, 70),
		PlaceholderColor = Color3.fromRGB(140, 160, 160)
	},

	AmberGlow = {
		TextColor = Color3.fromRGB(255, 245, 230),

		Background = Color3.fromRGB(45, 30, 20),
		Topbar = Color3.fromRGB(55, 40, 25),
		Shadow = Color3.fromRGB(35, 25, 15),

		NotificationBackground = Color3.fromRGB(50, 35, 25),
		NotificationActionsBackground = Color3.fromRGB(245, 230, 215),

		TabBackground = Color3.fromRGB(75, 50, 35),
		TabStroke = Color3.fromRGB(90, 60, 45),
		TabBackgroundSelected = Color3.fromRGB(230, 180, 100),
		TabTextColor = Color3.fromRGB(250, 220, 200),
		SelectedTabTextColor = Color3.fromRGB(50, 30, 10),

		ElementBackground = Color3.fromRGB(60, 45, 35),
		ElementBackgroundHover = Color3.fromRGB(70, 50, 40),
		SecondaryElementBackground = Color3.fromRGB(55, 40, 30),
		ElementStroke = Color3.fromRGB(85, 60, 45),
		SecondaryElementStroke = Color3.fromRGB(75, 50, 35),

		SliderBackground = Color3.fromRGB(220, 130, 60),
		SliderProgress = Color3.fromRGB(250, 150, 75),
		SliderStroke = Color3.fromRGB(255, 170, 85),

		ToggleBackground = Color3.fromRGB(55, 40, 30),
		ToggleEnabled = Color3.fromRGB(240, 130, 30),
		ToggleDisabled = Color3.fromRGB(90, 70, 60),
		ToggleEnabledStroke = Color3.fromRGB(255, 160, 50),
		ToggleDisabledStroke = Color3.fromRGB(110, 85, 75),
		ToggleEnabledOuterStroke = Color3.fromRGB(200, 100, 50),
		ToggleDisabledOuterStroke = Color3.fromRGB(75, 60, 55),

		DropdownSelected = Color3.fromRGB(70, 50, 40),
		DropdownUnselected = Color3.fromRGB(55, 40, 30),

		InputBackground = Color3.fromRGB(60, 45, 35),
		InputStroke = Color3.fromRGB(90, 65, 50),
		PlaceholderColor = Color3.fromRGB(190, 150, 130)
	},
	Light = {
		TextColor = Color3.fromRGB(40, 40, 40),

		Background = Color3.fromRGB(245, 245, 245),
		Topbar = Color3.fromRGB(230, 230, 230),
		Shadow = Color3.fromRGB(200, 200, 200),

		NotificationBackground = Color3.fromRGB(250, 250, 250),
		NotificationActionsBackground = Color3.fromRGB(240, 240, 240),

		TabBackground = Color3.fromRGB(235, 235, 235),
		TabStroke = Color3.fromRGB(215, 215, 215),
		TabBackgroundSelected = Color3.fromRGB(255, 255, 255),
		TabTextColor = Color3.fromRGB(80, 80, 80),
		SelectedTabTextColor = Color3.fromRGB(0, 0, 0),

		ElementBackground = Color3.fromRGB(240, 240, 240),
		ElementBackgroundHover = Color3.fromRGB(225, 225, 225),
		SecondaryElementBackground = Color3.fromRGB(235, 235, 235),
		ElementStroke = Color3.fromRGB(210, 210, 210),
		SecondaryElementStroke = Color3.fromRGB(210, 210, 210),

		SliderBackground = Color3.fromRGB(150, 180, 220),
		SliderProgress = Color3.fromRGB(100, 150, 200),
		SliderStroke = Color3.fromRGB(120, 170, 220),

		ToggleBackground = Color3.fromRGB(220, 220, 220),
		ToggleEnabled = Color3.fromRGB(0, 146, 214),
		ToggleDisabled = Color3.fromRGB(150, 150, 150),
		ToggleEnabledStroke = Color3.fromRGB(0, 170, 255),
		ToggleDisabledStroke = Color3.fromRGB(170, 170, 170),
		ToggleEnabledOuterStroke = Color3.fromRGB(100, 100, 100),
		ToggleDisabledOuterStroke = Color3.fromRGB(180, 180, 180),

		DropdownSelected = Color3.fromRGB(230, 230, 230),
		DropdownUnselected = Color3.fromRGB(220, 220, 220),

		InputBackground = Color3.fromRGB(240, 240, 240),
		InputStroke = Color3.fromRGB(180, 180, 180),
		PlaceholderColor = Color3.fromRGB(140, 140, 140)
	},

	Amethyst = {
		TextColor = Color3.fromRGB(240, 240, 240),

		Background = Color3.fromRGB(30, 20, 40),
		Topbar = Color3.fromRGB(40, 25, 50),
		Shadow = Color3.fromRGB(20, 15, 30),

		NotificationBackground = Color3.fromRGB(35, 20, 40),
		NotificationActionsBackground = Color3.fromRGB(240, 240, 250),

		TabBackground = Color3.fromRGB(60, 40, 80),
		TabStroke = Color3.fromRGB(70, 45, 90),
		TabBackgroundSelected = Color3.fromRGB(180, 140, 200),
		TabTextColor = Color3.fromRGB(230, 230, 240),
		SelectedTabTextColor = Color3.fromRGB(50, 20, 50),

		ElementBackground = Color3.fromRGB(45, 30, 60),
		ElementBackgroundHover = Color3.fromRGB(50, 35, 70),
		SecondaryElementBackground = Color3.fromRGB(40, 30, 55),
		ElementStroke = Color3.fromRGB(70, 50, 85),
		SecondaryElementStroke = Color3.fromRGB(65, 45, 80),

		SliderBackground = Color3.fromRGB(100, 60, 150),
		SliderProgress = Color3.fromRGB(130, 80, 180),
		SliderStroke = Color3.fromRGB(150, 100, 200),

		ToggleBackground = Color3.fromRGB(45, 30, 55),
		ToggleEnabled = Color3.fromRGB(120, 60, 150),
		ToggleDisabled = Color3.fromRGB(94, 47, 117),
		ToggleEnabledStroke = Color3.fromRGB(140, 80, 170),
		ToggleDisabledStroke = Color3.fromRGB(124, 71, 150),
		ToggleEnabledOuterStroke = Color3.fromRGB(90, 40, 120),
		ToggleDisabledOuterStroke = Color3.fromRGB(80, 50, 110),

		DropdownSelected = Color3.fromRGB(50, 35, 70),
		DropdownUnselected = Color3.fromRGB(35, 25, 50),

		InputBackground = Color3.fromRGB(45, 30, 60),
		InputStroke = Color3.fromRGB(80, 50, 110),
		PlaceholderColor = Color3.fromRGB(178, 150, 200)
	},

	Green = {
		TextColor = Color3.fromRGB(30, 60, 30),

		Background = Color3.fromRGB(235, 245, 235),
		Topbar = Color3.fromRGB(210, 230, 210),
		Shadow = Color3.fromRGB(200, 220, 200),

		NotificationBackground = Color3.fromRGB(240, 250, 240),
		NotificationActionsBackground = Color3.fromRGB(220, 235, 220),

		TabBackground = Color3.fromRGB(215, 235, 215),
		TabStroke = Color3.fromRGB(190, 210, 190),
		TabBackgroundSelected = Color3.fromRGB(245, 255, 245),
		TabTextColor = Color3.fromRGB(50, 80, 50),
		SelectedTabTextColor = Color3.fromRGB(20, 60, 20),

		ElementBackground = Color3.fromRGB(225, 240, 225),
		ElementBackgroundHover = Color3.fromRGB(210, 225, 210),
		SecondaryElementBackground = Color3.fromRGB(235, 245, 235),
		ElementStroke = Color3.fromRGB(180, 200, 180),
		SecondaryElementStroke = Color3.fromRGB(180, 200, 180),

		SliderBackground = Color3.fromRGB(90, 160, 90),
		SliderProgress = Color3.fromRGB(70, 130, 70),
		SliderStroke = Color3.fromRGB(100, 180, 100),

		ToggleBackground = Color3.fromRGB(215, 235, 215),
		ToggleEnabled = Color3.fromRGB(60, 130, 60),
		ToggleDisabled = Color3.fromRGB(150, 175, 150),
		ToggleEnabledStroke = Color3.fromRGB(80, 150, 80),
		ToggleDisabledStroke = Color3.fromRGB(130, 150, 130),
		ToggleEnabledOuterStroke = Color3.fromRGB(100, 160, 100),
		ToggleDisabledOuterStroke = Color3.fromRGB(160, 180, 160),

		DropdownSelected = Color3.fromRGB(225, 240, 225),
		DropdownUnselected = Color3.fromRGB(210, 225, 210),

		InputBackground = Color3.fromRGB(235, 245, 235),
		InputStroke = Color3.fromRGB(180, 200, 180),
		PlaceholderColor = Color3.fromRGB(120, 140, 120)
	},

	Bloom = {
		TextColor = Color3.fromRGB(60, 40, 50),

		Background = Color3.fromRGB(255, 240, 245),
		Topbar = Color3.fromRGB(250, 220, 225),
		Shadow = Color3.fromRGB(230, 190, 195),

		NotificationBackground = Color3.fromRGB(255, 235, 240),
		NotificationActionsBackground = Color3.fromRGB(245, 215, 225),

		TabBackground = Color3.fromRGB(240, 210, 220),
		TabStroke = Color3.fromRGB(230, 200, 210),
		TabBackgroundSelected = Color3.fromRGB(255, 225, 235),
		TabTextColor = Color3.fromRGB(80, 40, 60),
		SelectedTabTextColor = Color3.fromRGB(50, 30, 50),

		ElementBackground = Color3.fromRGB(255, 235, 240),
		ElementBackgroundHover = Color3.fromRGB(245, 220, 230),
		SecondaryElementBackground = Color3.fromRGB(255, 235, 240),
		ElementStroke = Color3.fromRGB(230, 200, 210),
		SecondaryElementStroke = Color3.fromRGB(230, 200, 210),

		SliderBackground = Color3.fromRGB(240, 130, 160),
		SliderProgress = Color3.fromRGB(250, 160, 180),
		SliderStroke = Color3.fromRGB(255, 180, 200),

		ToggleBackground = Color3.fromRGB(240, 210, 220),
		ToggleEnabled = Color3.fromRGB(255, 140, 170),
		ToggleDisabled = Color3.fromRGB(200, 180, 185),
		ToggleEnabledStroke = Color3.fromRGB(250, 160, 190),
		ToggleDisabledStroke = Color3.fromRGB(210, 180, 190),
		ToggleEnabledOuterStroke = Color3.fromRGB(220, 160, 180),
		ToggleDisabledOuterStroke = Color3.fromRGB(190, 170, 180),

		DropdownSelected = Color3.fromRGB(250, 220, 225),
		DropdownUnselected = Color3.fromRGB(240, 210, 220),

		InputBackground = Color3.fromRGB(255, 235, 240),
		InputStroke = Color3.fromRGB(220, 190, 200),
		PlaceholderColor = Color3.fromRGB(170, 130, 140)
	},

	DarkBlue = {
		TextColor = Color3.fromRGB(230, 230, 230),

		Background = Color3.fromRGB(20, 25, 30),
		Topbar = Color3.fromRGB(30, 35, 40),
		Shadow = Color3.fromRGB(15, 20, 25),

		NotificationBackground = Color3.fromRGB(25, 30, 35),
		NotificationActionsBackground = Color3.fromRGB(45, 50, 55),

		TabBackground = Color3.fromRGB(35, 40, 45),
		TabStroke = Color3.fromRGB(45, 50, 60),
		TabBackgroundSelected = Color3.fromRGB(40, 70, 100),
		TabTextColor = Color3.fromRGB(200, 200, 200),
		SelectedTabTextColor = Color3.fromRGB(255, 255, 255),

		ElementBackground = Color3.fromRGB(30, 35, 40),
		ElementBackgroundHover = Color3.fromRGB(40, 45, 50),
		SecondaryElementBackground = Color3.fromRGB(35, 40, 45),
		ElementStroke = Color3.fromRGB(45, 50, 60),
		SecondaryElementStroke = Color3.fromRGB(40, 45, 55),

		SliderBackground = Color3.fromRGB(0, 90, 180),
		SliderProgress = Color3.fromRGB(0, 120, 210),
		SliderStroke = Color3.fromRGB(0, 150, 240),

		ToggleBackground = Color3.fromRGB(35, 40, 45),
		ToggleEnabled = Color3.fromRGB(0, 120, 210),
		ToggleDisabled = Color3.fromRGB(70, 70, 80),
		ToggleEnabledStroke = Color3.fromRGB(0, 150, 240),
		ToggleDisabledStroke = Color3.fromRGB(75, 75, 85),
		ToggleEnabledOuterStroke = Color3.fromRGB(20, 100, 180),
		ToggleDisabledOuterStroke = Color3.fromRGB(55, 55, 65),

		DropdownSelected = Color3.fromRGB(30, 70, 90),
		DropdownUnselected = Color3.fromRGB(25, 30, 35),

		InputBackground = Color3.fromRGB(25, 30, 35),
		InputStroke = Color3.fromRGB(45, 50, 60),
		PlaceholderColor = Color3.fromRGB(150, 150, 160)
	},

	Serenity = {
		TextColor = Color3.fromRGB(50, 55, 60),
		Background = Color3.fromRGB(240, 245, 250),
		Topbar = Color3.fromRGB(215, 225, 235),
		Shadow = Color3.fromRGB(200, 210, 220),

		NotificationBackground = Color3.fromRGB(210, 220, 230),
		NotificationActionsBackground = Color3.fromRGB(225, 230, 240),

		TabBackground = Color3.fromRGB(200, 210, 220),
		TabStroke = Color3.fromRGB(180, 190, 200),
		TabBackgroundSelected = Color3.fromRGB(175, 185, 200),
		TabTextColor = Color3.fromRGB(50, 55, 60),
		SelectedTabTextColor = Color3.fromRGB(30, 35, 40),

		ElementBackground = Color3.fromRGB(210, 220, 230),
		ElementBackgroundHover = Color3.fromRGB(220, 230, 240),
		SecondaryElementBackground = Color3.fromRGB(200, 210, 220),
		ElementStroke = Color3.fromRGB(190, 200, 210),
		SecondaryElementStroke = Color3.fromRGB(180, 190, 200),

		SliderBackground = Color3.fromRGB(200, 220, 235),
		SliderProgress = Color3.fromRGB(70, 130, 180),
		SliderStroke = Color3.fromRGB(150, 180, 220),

		ToggleBackground = Color3.fromRGB(210, 220, 230),
		ToggleEnabled = Color3.fromRGB(70, 160, 210),
		ToggleDisabled = Color3.fromRGB(180, 180, 180),
		ToggleEnabledStroke = Color3.fromRGB(60, 150, 200),
		ToggleDisabledStroke = Color3.fromRGB(140, 140, 140),
		ToggleEnabledOuterStroke = Color3.fromRGB(100, 120, 140),
		ToggleDisabledOuterStroke = Color3.fromRGB(120, 120, 130),

		DropdownSelected = Color3.fromRGB(220, 230, 240),
		DropdownUnselected = Color3.fromRGB(200, 210, 220),

		InputBackground = Color3.fromRGB(220, 230, 240),
		InputStroke = Color3.fromRGB(180, 190, 200),
		PlaceholderColor = Color3.fromRGB(150, 150, 150)
	},
}

local THEME_FALLBACK_KEYS = {
	TooltipBackground = {"SecondaryElementBackground", "ElementBackground", "Background"},
	TooltipTextColor = {"TextColor"},
	TooltipStroke = {"SecondaryElementStroke", "ElementStroke"},
	LoadingSpinner = {"SliderProgress", "ToggleEnabled"},
	LoadingTrack = {"SliderBackground", "SecondaryElementBackground"},
	LoadingBar = {"SliderProgress", "ToggleEnabled"},
	LoadingText = {"TextColor"},
	ChartLine = {"SliderProgress", "SliderBackground"},
	ChartGrid = {"ElementStroke", "SecondaryElementStroke"},
	ChartFill = {"SliderBackground", "ChartLine"},
	LogInfo = {"TextColor"},
	LogWarn = {"SliderStroke", "SliderProgress"},
	LogError = {"ToggleEnabled", "SliderStroke"},
	ConfirmArmed = {"ToggleEnabled", "SliderProgress"},
	SectionChevron = {"TextColor", "TabTextColor"}
}

local function cloneThemeTable(theme)
	local out = {}
	if type(theme) ~= "table" then
		return out
	end
	for key, value in pairs(theme) do
		out[key] = value
	end
	return out
end

local function resolveThemeWithFallback(theme)
	local defaultTheme = ThemeModule.Themes.Default or {}
	local resolved = cloneThemeTable(theme)

	for key, fallbackChain in pairs(THEME_FALLBACK_KEYS) do
		if resolved[key] == nil then
			local fallbackValue = nil
			if type(fallbackChain) == "table" then
				for _, fallbackKey in ipairs(fallbackChain) do
					if resolved[fallbackKey] ~= nil then
						fallbackValue = resolved[fallbackKey]
						break
					end
					if defaultTheme[fallbackKey] ~= nil then
						fallbackValue = defaultTheme[fallbackKey]
						break
					end
				end
			end
			if fallbackValue == nil then
				fallbackValue = defaultTheme[key]
			end
			if fallbackValue ~= nil then
				resolved[key] = fallbackValue
			end
		end
	end

	for key, defaultValue in pairs(defaultTheme) do
		if resolved[key] == nil then
			resolved[key] = defaultValue
		end
	end

	return resolved
end

-- Initialize module with dependencies
function ThemeModule.init(ctx)
	local self = {}

	-- Store dependencies from context
	self.Rayfield = ctx.Rayfield
	self.Main = ctx.Main
	self.Topbar = ctx.Topbar
	self.Elements = ctx.Elements
	self.Notifications = ctx.Notifications
	self.Icons = ctx.Icons

	-- Current selected theme
	self.SelectedTheme = resolveThemeWithFallback(ThemeModule.Themes.Default)

	-- Reactive Theme System
	local ThemeValues = Instance.new("Folder")
	ThemeValues.Name = "ThemeValues"
	ThemeValues.Parent = self.Main

	local activeBindings = setmetatable({}, {__mode = "k"}) -- [object] = { [property] = record }
	local objectWatchers = setmetatable({}, {__mode = "k"}) -- [object] = { destroyConn?, ancestryConn? }
	local values = {}

	local function disconnectConnection(connection)
		if connection and typeof(connection) == "RBXScriptConnection" and connection.Connected then
			connection:Disconnect()
		end
	end

	local function cleanupObjectBindings(object)
		local bindingMap = activeBindings[object]
		if bindingMap then
			for _, record in pairs(bindingMap) do
				disconnectConnection(record.connection)
			end
			activeBindings[object] = nil
		end

		local watcher = objectWatchers[object]
		if watcher then
			disconnectConnection(watcher.destroying)
			disconnectConnection(watcher.ancestry)
			objectWatchers[object] = nil
		end
	end

	local function ensureObjectWatcher(object)
		if not object or objectWatchers[object] then
			return
		end

		local watcher = {}
		local okDestroying, destroyingSignal = pcall(function()
			return object.Destroying
		end)
		if okDestroying and destroyingSignal and destroyingSignal.Connect then
			watcher.destroying = destroyingSignal:Connect(function()
				cleanupObjectBindings(object)
			end)
		else
			watcher.ancestry = object.AncestryChanged:Connect(function(_, parent)
				if parent == nil then
					cleanupObjectBindings(object)
				end
			end)
		end

		objectWatchers[object] = watcher
	end

	local function unbindTheme(object, property)
		if not object then
			return
		end

		local bindingMap = activeBindings[object]
		if not bindingMap then
			return
		end

		if property then
			local record = bindingMap[property]
			if record then
				disconnectConnection(record.connection)
				bindingMap[property] = nil
			end
			if next(bindingMap) == nil then
				cleanupObjectBindings(object)
			end
			return
		end

		cleanupObjectBindings(object)
	end

	-- Initialize ValueObjects for all theme properties
	for key, value in pairs(ThemeModule.Themes.Default) do
		local colorValue = Instance.new("Color3Value")
		colorValue.Name = key
		colorValue.Value = value
		colorValue.Parent = ThemeValues
		values[key] = colorValue
	end

	-- Helper to bind an object's property to a theme color
	function self.bindTheme(object, property, themeKey)
		if not object then
			return
		end

		unbindTheme(object, property)

		local valueObj = values[themeKey]
		if not valueObj then
			-- During teardown/reload, values table can be cleared before late bind calls.
			-- Skip noisy warnings when the key itself is valid in theme schema.
			if ThemeModule.Themes.Default and ThemeModule.Themes.Default[themeKey] ~= nil then
				return
			end
			warn("Rayfield | Theme key not found: " .. tostring(themeKey))
			return
		end

		-- Set initial value
		local ok = pcall(function()
			object[property] = valueObj.Value
		end)
		if not ok then
			return
		end

		-- Listen for changes
		local connection = valueObj.Changed:Connect(function(newColor)
			pcall(function()
				object[property] = newColor
			end)
		end)

		activeBindings[object] = activeBindings[object] or {}
		activeBindings[object][property] = {
			connection = connection,
			themeKey = themeKey
		}
		ensureObjectWatcher(object)

		return connection
	end

	function self.unbindTheme(object, property)
		unbindTheme(object, property)
	end

	function self.cleanupObjectBindings(object)
		cleanupObjectBindings(object)
	end

	function self.GetBindingStats()
		local objectsBound = 0
		local propertiesBound = 0
		for _, bindingMap in pairs(activeBindings) do
			if type(bindingMap) == "table" and next(bindingMap) ~= nil then
				objectsBound = objectsBound + 1
				for _ in pairs(bindingMap) do
					propertiesBound = propertiesBound + 1
				end
			end
		end
		return {
			objectsBound = objectsBound,
			propertiesBound = propertiesBound
		}
	end

	-- Get icon from Lucide icon library
	function self.getIcon(name)
		if not self.Icons then
			warn("Lucide Icons: Cannot use icons as icons library is not loaded")
			return
		end
		name = string.match(string.lower(name), "^%s*(.*)%s*$")
		local sizedicons = self.Icons['48px']
		local r = sizedicons[name]
		if not r then
			error("Lucide Icons: Failed to find icon by the name of \"" .. name .. "\"", 2)
		end

		local rirs = r[2]
		local riro = r[3]

		return {
			id = r[1],
			imageRectSize = Vector2.new(rirs[1], rirs[2]),
			imageRectOffset = Vector2.new(riro[1], riro[2])
		}
	end

	-- Change theme function
	function self.ChangeTheme(Theme)
		local selected = nil
		if typeof(Theme) == 'string' then
			selected = ThemeModule.Themes[Theme]
		elseif typeof(Theme) == 'table' then
			selected = Theme
		end

		if not selected then return end

		self.SelectedTheme = resolveThemeWithFallback(selected)

		-- Update all ValueObjects - this triggers listeners in all elements
		for key, value in pairs(self.SelectedTheme) do
			if values[key] then
				values[key].Value = value
			end
		end

		-- Special case for search which isn't fully reactive yet or has complex mapping
		if self.Main:FindFirstChild('Notice') then
			self.Main.Notice.BackgroundColor3 = self.SelectedTheme.Background
		end
	end

	-- Cleanup function to prevent memory leaks on Rayfield:Destroy() + reload
	function self.cleanup()
		for object in pairs(activeBindings) do
			cleanupObjectBindings(object)
		end
		for object, watcher in pairs(objectWatchers) do
			disconnectConnection(watcher.destroying)
			disconnectConnection(watcher.ancestry)
			objectWatchers[object] = nil
		end

		-- Destroy the ThemeValues folder
		if ThemeValues and ThemeValues.Parent then
			ThemeValues:Destroy()
		end
		table.clear(values)
	end

	return self
end

return ThemeModule
]=])
put("src/services/utilities.lua", [[-- Rayfield Utilities & Lifecycle Module
-- Handles utility functions, dragging, visibility, and lifecycle management

local UtilitiesModule = {}
local SharedUtils = {}

function SharedUtils.trim(value)
	if type(value) ~= "string" then
		return ""
	end
	local out = value:gsub("^%s+", "")
	out = out:gsub("%s+$", "")
	return out
end

function SharedUtils.cloneTable(value)
	if type(value) ~= "table" then
		return value
	end
	local out = {}
	for key, nested in pairs(value) do
		out[SharedUtils.cloneTable(key)] = SharedUtils.cloneTable(nested)
	end
	return out
end

function SharedUtils.deepEqual(left, right, seen)
	if left == right then
		return true
	end
	if type(left) ~= "table" or type(right) ~= "table" then
		return false
	end
	seen = seen or {}
	if seen[left] and seen[left] == right then
		return true
	end
	seen[left] = right

	for key, value in pairs(left) do
		if not SharedUtils.deepEqual(value, right[key], seen) then
			return false
		end
	end
	for key in pairs(right) do
		if left[key] == nil then
			return false
		end
	end
	return true
end

UtilitiesModule.Shared = SharedUtils
UtilitiesModule.trim = SharedUtils.trim
UtilitiesModule.cloneTable = SharedUtils.cloneTable
UtilitiesModule.deepEqual = SharedUtils.deepEqual

if type(_G) == "table" then
	_G.__RayfieldSharedUtils = SharedUtils
end

function UtilitiesModule.init(ctx)
	local self = {}
	
	-- Inject dependencies
	self.TweenService = ctx.TweenService
	self.Animation = ctx.Animation or ctx.TweenService
	self.RunService = ctx.RunService
	self.UserInputService = ctx.UserInputService
	self.getService = ctx.getService
	self.Main = ctx.Main
	self.Rayfield = ctx.Rayfield
	self.dragBar = ctx.dragBar
	self.dragBarCosmetic = ctx.dragBarCosmetic
	self.getHidden = ctx.getHidden
	self.useMobileSizing = ctx.useMobileSizing
	self.Hide = ctx.Hide
	self.Unhide = ctx.Unhide
	self.getDebounce = ctx.getDebounce
	self.setRayfieldDestroyed = ctx.setRayfieldDestroyed
	self.keybindConnections = ctx.keybindConnections
	
	-- Utility: Get asset URI from ID or icon name
	local function getAssetUri(id, Icons)
		local assetUri = "rbxassetid://0" -- Default to empty image
		if type(id) == "number" then
			assetUri = "rbxassetid://" .. id
		elseif type(id) == "string" and not Icons then
			warn("Rayfield | Cannot use Lucide icons as icons library is not loaded")
		else
			warn("Rayfield | The icon argument must either be an icon ID (number) or a Lucide icon name (string)")
		end
		return assetUri
	end
	
	-- Make a GUI object draggable
	local function makeDraggable(object, dragObject, enableTaptic, tapticOffset)
		local dragging = false
		local relative = nil
		local activeInput = nil
		local pointerPosition = nil
		
		local offset = Vector2.zero
		local screenGui = object:FindFirstAncestorWhichIsA("ScreenGui")
		if screenGui and screenGui.IgnoreGuiInset then
			offset += self.getService('GuiService'):GetGuiInset()
		end
		
		if dragObject:IsA("GuiObject") then
			dragObject.Active = true
		end
		
		local function updatePointerFromInput(input)
			if input and input.Position then
				pointerPosition = Vector2.new(input.Position.X, input.Position.Y)
			end
		end
		
		local function getPointerPosition()
			if pointerPosition then
				return pointerPosition
			end
			return self.UserInputService:GetMouseLocation()
		end
		
		local function connectFunctions()
			if self.dragBar and enableTaptic then
				self.dragBar.MouseEnter:Connect(function()
					if not dragging and not self.getHidden() then
						self.Animation:Create(self.dragBarCosmetic, TweenInfo.new(0.25, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {BackgroundTransparency = 0.5, Size = UDim2.new(0, 120, 0, 4)}):Play()
					end
				end)
				
				self.dragBar.MouseLeave:Connect(function()
					if not dragging and not self.getHidden() then
						self.Animation:Create(self.dragBarCosmetic, TweenInfo.new(0.25, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {BackgroundTransparency = 0.7, Size = UDim2.new(0, 100, 0, 4)}):Play()
					end
				end)
			end
		end
		
		connectFunctions()
		
		dragObject.InputBegan:Connect(function(input, processed)
			local inputType = input.UserInputType
			
			if inputType == Enum.UserInputType.MouseButton1 or inputType == Enum.UserInputType.Touch then
				dragging = true
				activeInput = input
				updatePointerFromInput(input)
				
				relative = object.AbsolutePosition + object.AbsoluteSize * object.AnchorPoint - getPointerPosition()
				if enableTaptic and not self.getHidden() then
					self.Animation:Create(self.dragBarCosmetic, TweenInfo.new(0.35, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {Size = UDim2.new(0, 110, 0, 4), BackgroundTransparency = 0}):Play()
				end
			end
		end)
		
		local inputChanged = self.UserInputService.InputChanged:Connect(function(input)
			if not dragging then return end
			
			if activeInput and input == activeInput then
				updatePointerFromInput(input)
			elseif activeInput and activeInput.UserInputType == Enum.UserInputType.MouseButton1 and input.UserInputType == Enum.UserInputType.MouseMovement then
				updatePointerFromInput(input)
			end
		end)
		
		local inputEnded = self.UserInputService.InputEnded:Connect(function(input)
			if not dragging then return end
			
			local inputType = input.UserInputType
			local touchEnded = activeInput and activeInput.UserInputType == Enum.UserInputType.Touch and input == activeInput
			if inputType == Enum.UserInputType.MouseButton1 or touchEnded then
				dragging = false
				activeInput = nil
				pointerPosition = nil
				
				connectFunctions()
				
				if enableTaptic and not self.getHidden() then
					self.Animation:Create(self.dragBarCosmetic, TweenInfo.new(0.35, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {Size = UDim2.new(0, 100, 0, 4), BackgroundTransparency = 0.7}):Play()
				end
			end
		end)
		
		local renderStepped = self.RunService.RenderStepped:Connect(function(deltaTime)
			if dragging and not self.getHidden() then
				local position = getPointerPosition() + relative + offset
				if enableTaptic and tapticOffset then
					local tapticY = (self.useMobileSizing and tapticOffset[2]) or tapticOffset[1]
					-- Lerp-based follow instead of creating new tweens every frame
					local objAlpha = math.clamp(1 - math.exp(-deltaTime * 7), 0, 1)
					local objCur = object.Position
					local objNext = objCur:Lerp(UDim2.fromOffset(position.X, position.Y), objAlpha)
					object.Position = objNext
					local barParent = dragObject.Parent
					local barAlpha = math.clamp(1 - math.exp(-deltaTime * 50), 0, 1)
					local barCur = barParent.Position
					barParent.Position = barCur:Lerp(UDim2.fromOffset(position.X, position.Y + tapticY), barAlpha)
				else
					if self.dragBar and tapticOffset then
						self.dragBar.Position = UDim2.fromOffset(position.X, position.Y + ((self.useMobileSizing and tapticOffset[2]) or tapticOffset[1]))
					end
					object.Position = UDim2.fromOffset(position.X, position.Y)
				end
			end
		end)
		
		object.Destroying:Connect(function()
			if inputChanged then inputChanged:Disconnect() end
			if inputEnded then inputEnded:Disconnect() end
			if renderStepped then renderStepped:Disconnect() end
		end)
	end
	
	-- Set visibility with optional notification
	local function setVisibility(visibility, notify)
		if self.getDebounce() then return end
		if visibility then
			self.Unhide()
		else
			self.Hide(notify)
		end
	end
	
	-- Destroy Rayfield and cleanup
	local function destroy(hideHotkeyConnection)
		self.setRayfieldDestroyed(true)
		if hideHotkeyConnection then
			hideHotkeyConnection:Disconnect()
		end
		for _, connection in self.keybindConnections do
			connection:Disconnect()
		end
		self.Rayfield:Destroy()
	end
	
	-- Export functions
	self.getAssetUri = getAssetUri
	self.makeDraggable = makeDraggable
	self.setVisibility = setVisibility
	self.destroy = destroy
	
	return self
end

return UtilitiesModule
]])
put("src/services/viewport-virtualization.lua", [[-- Rayfield Viewport Virtualization Service
-- Event-driven offscreen hibernation with spacer preservation.

local ViewportVirtualization = {}

local DEFAULTS = {
	Enabled = true,
	AlwaysOn = true,
	FullSuspend = true,
	OverscanPx = 120,
	UpdateHz = 30,
	FadeOnScroll = true,
	DisableFadeDuringResize = true,
	ResizeDebounceMs = 100,
	MinElementsToActivate = 0
}

local function getSharedUtils()
	if type(_G) == "table" and type(_G.__RayfieldSharedUtils) == "table" then
		return _G.__RayfieldSharedUtils
	end
	return nil
end

local function cloneTable(value)
	local shared = getSharedUtils()
	if shared and type(shared.cloneTable) == "function" then
		return shared.cloneTable(value)
	end
	if type(value) ~= "table" then
		return value
	end
	local out = {}
	for key, nested in pairs(value) do
		out[key] = cloneTable(nested)
	end
	return out
end

local function mergeDefaults(input)
	local out = cloneTable(DEFAULTS)
	if type(input) ~= "table" then
		return out
	end
	for key, value in pairs(input) do
		out[key] = value
	end

	out.Enabled = out.Enabled ~= false
	out.AlwaysOn = out.AlwaysOn ~= false
	out.FullSuspend = out.FullSuspend ~= false
	out.FadeOnScroll = out.FadeOnScroll ~= false
	out.DisableFadeDuringResize = out.DisableFadeDuringResize ~= false

	local overscan = tonumber(out.OverscanPx)
	if not overscan then
		overscan = DEFAULTS.OverscanPx
	end
	if overscan < 0 then
		overscan = 0
	end
	out.OverscanPx = math.floor(overscan)

	local updateHz = tonumber(out.UpdateHz)
	if not updateHz or updateHz <= 0 then
		updateHz = DEFAULTS.UpdateHz
	end
	out.UpdateHz = math.max(5, math.floor(updateHz))

	local resizeDebounce = tonumber(out.ResizeDebounceMs)
	if not resizeDebounce or resizeDebounce < 0 then
		resizeDebounce = DEFAULTS.ResizeDebounceMs
	end
	out.ResizeDebounceMs = math.max(0, math.floor(resizeDebounce))

	local minElements = tonumber(out.MinElementsToActivate)
	if not minElements or minElements < 0 then
		minElements = 0
	end
	out.MinElementsToActivate = math.floor(minElements)

	return out
end

local function safeDisconnect(connection)
	if not connection then
		return
	end
	pcall(function()
		connection:Disconnect()
	end)
end

local function isAlive(instance)
	return typeof(instance) == "Instance" and instance.Parent ~= nil
end

local function resolveToken(recordsByObject, recordsByToken, tokenOrObject)
	if type(tokenOrObject) == "string" then
		return tokenOrObject, recordsByToken[tokenOrObject]
	end
	if typeof(tokenOrObject) == "Instance" then
		local token = recordsByObject[tokenOrObject]
		if token then
			return token, recordsByToken[token]
		end
	end
	return nil, nil
end

function ViewportVirtualization.init(ctx)
	local self = {}
	ctx = ctx or {}

	self.Config = mergeDefaults(ctx.Settings)
	self.RunService = ctx.RunService or game:GetService("RunService")
	self.TweenService = ctx.TweenService or game:GetService("TweenService")
	self.UserInputService = ctx.UserInputService or game:GetService("UserInputService")
	self.AnimationEngine = ctx.AnimationEngine
	self.RootGui = ctx.RootGui
	self.warn = type(ctx.warn) == "function" and ctx.warn or function(message)
		warn("Rayfield | ViewportVirtualization " .. tostring(message))
	end

	local hosts = {}
	local hostOrder = {}
	local records = {}
	local recordsByObject = setmetatable({}, { __mode = "k" })
	local tokenCounter = 0
	local updateConnection = nil
	local updateAccumulator = 0
	local updateInterval = 1 / self.Config.UpdateHz
	local storageRoot = nil

	local function ensureStorageRoot()
		if storageRoot and storageRoot.Parent then
			return storageRoot
		end
		local parentGui = self.RootGui
		if not parentGui or not parentGui.Parent then
			return nil
		end
		local frame = Instance.new("Frame")
		frame.Name = "ViewportVirtualizationStorage"
		frame.BackgroundTransparency = 1
		frame.BorderSizePixel = 0
		frame.Size = UDim2.fromOffset(0, 0)
		frame.Position = UDim2.fromOffset(-10000, -10000)
		frame.Visible = false
		frame.Parent = parentGui
		storageRoot = frame
		return storageRoot
	end

	local function clearStorageRoot()
		if storageRoot then
			pcall(function()
				storageRoot:Destroy()
			end)
		end
		storageRoot = nil
	end

	local function countHostElements(host)
		local count = 0
		for token in pairs(host.elements) do
			if records[token] then
				count += 1
			end
		end
		return count
	end

	local function shouldUseFade(host)
		if not self.Config.FadeOnScroll then
			return false
		end
		if self.Config.DisableFadeDuringResize and host.resizeInProgress then
			return false
		end
		return host.lastReason == "scroll"
	end

	local function markHostDirty(hostId, reason)
		local host = hosts[hostId]
		if not host then
			return false
		end
		host.dirty = true
		host.lastReason = reason or host.lastReason or "update"
		return true
	end

	local function suspendObjectAnimations(guiObject)
		if self.Config.FullSuspend ~= true then
			return
		end
		local engine = self.AnimationEngine
		if type(engine) ~= "table" then
			return
		end
		local function stopTarget(target)
			if type(engine.CancelObject) == "function" then
				pcall(engine.CancelObject, engine, target)
			end
			if type(engine.StopTextForObject) == "function" then
				pcall(engine.StopTextForObject, engine, target)
			end
		end
		stopTarget(guiObject)
		for _, descendant in ipairs(guiObject:GetDescendants()) do
			if descendant:IsA("GuiObject") then
				stopTarget(descendant)
			end
		end
	end

	local function applyFade(guiObject, fadeOut)
		local targetAlpha = fadeOut and 1 or 0
		if not isAlive(guiObject) then
			return
		end
		if type(self.AnimationEngine) == "table" and type(self.AnimationEngine.AnimateProperty) == "function" then
			pcall(self.AnimationEngine.AnimateProperty, self.AnimationEngine, guiObject, "BackgroundTransparency", targetAlpha, 0.08, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
			if guiObject:IsA("TextLabel") or guiObject:IsA("TextButton") then
				pcall(self.AnimationEngine.AnimateProperty, self.AnimationEngine, guiObject, "TextTransparency", targetAlpha, 0.08, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
			end
			if guiObject:IsA("ImageLabel") or guiObject:IsA("ImageButton") then
				pcall(self.AnimationEngine.AnimateProperty, self.AnimationEngine, guiObject, "ImageTransparency", targetAlpha, 0.08, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
			end
		end
	end

	local function updateCachedHeight(record, targetObject)
		local height = nil
		if targetObject and targetObject.Parent then
			height = tonumber(targetObject.AbsoluteSize.Y)
		end
		if not height or height <= 0 then
			height = record.cachedHeight
		end
		if not height or height <= 0 then
			height = 32
		end
		record.cachedHeight = math.max(1, math.floor(height + 0.5))
	end

	local function ensureSpacer(record)
		local guiObject = record.guiObject
		if not guiObject or not guiObject.Parent then
			return nil
		end

		updateCachedHeight(record, guiObject)
		local spacer = Instance.new("Frame")
		spacer.Name = "ViewportSpacer-" .. tostring(guiObject.Name)
		spacer.BackgroundTransparency = 1
		spacer.BorderSizePixel = 0
		spacer.Size = UDim2.new(guiObject.Size.X.Scale, guiObject.Size.X.Offset, 0, record.cachedHeight)
		spacer.LayoutOrder = guiObject.LayoutOrder
		spacer.ZIndex = guiObject.ZIndex
		spacer.Parent = guiObject.Parent
		return spacer
	end

	local function wakeRecord(token, reason, options)
		local record = records[token]
		if not record or not record.sleeping then
			return false
		end

		local guiObject = record.guiObject
		if not guiObject then
			return false
		end

		local targetParent = (record.spacer and record.spacer.Parent) or record.originalParent
		if targetParent and targetParent.Parent then
			guiObject.Parent = targetParent
			if record.originalLayoutOrder ~= nil then
				guiObject.LayoutOrder = record.originalLayoutOrder
			end
			guiObject.Visible = true
			updateCachedHeight(record, guiObject)
		end

		if record.spacer then
			pcall(function()
				record.spacer:Destroy()
			end)
			record.spacer = nil
		end

		if guiObject.SetAttribute then
			pcall(guiObject.SetAttribute, guiObject, "RayfieldViewportSleeping", false)
		end

		record.sleeping = false
		record.originalParent = nil
		record.originalLayoutOrder = nil

		local fadeAllowed = options and options.fade == true
		if fadeAllowed then
			applyFade(guiObject, false)
		end

		if type(record.onWake) == "function" then
			pcall(record.onWake, {
				reason = reason or "wake",
				token = token
			})
		end
		return true
	end

	local function sleepRecord(token, reason, options)
		local record = records[token]
		if not record or record.sleeping then
			return false
		end
		local guiObject = record.guiObject
		if not isAlive(guiObject) then
			return false
		end
		if record.busy then
			return false
		end
		local busyAttribute = false
		if guiObject.GetAttribute then
			local okAttr, value = pcall(guiObject.GetAttribute, guiObject, "RayfieldInteractionBusy")
			busyAttribute = okAttr and value == true
		end
		if busyAttribute then
			return false
		end

		local storage = ensureStorageRoot()
		if not storage then
			return false
		end

		local spacer = ensureSpacer(record)
		if not spacer then
			return false
		end

		record.originalParent = guiObject.Parent
		record.originalLayoutOrder = guiObject.LayoutOrder
		record.spacer = spacer

		local fadeAllowed = options and options.fade == true
		if fadeAllowed then
			applyFade(guiObject, true)
		end

		suspendObjectAnimations(guiObject)
		guiObject.Visible = false
		guiObject.Parent = storage
		record.sleeping = true
		if guiObject.SetAttribute then
			pcall(guiObject.SetAttribute, guiObject, "RayfieldViewportSleeping", true)
		end
		if type(record.onSleep) == "function" then
			pcall(record.onSleep, {
				reason = reason or "sleep",
				token = token
			})
		end
		return true
	end

	local function computeViewport(host)
		local hostObject = host.object
		if not (hostObject and hostObject.Parent) then
			return nil
		end

		local overscan = host.overscan
		if host.mode == "scrolling" then
			local scrollY = hostObject.CanvasPosition.Y
			local viewHeight = hostObject.AbsoluteSize.Y
			return scrollY - overscan, scrollY + viewHeight + overscan, scrollY
		end

		local viewHeight = hostObject.AbsoluteSize.Y
		return 0 - overscan, viewHeight + overscan, 0
	end

	local function computeBounds(host, record)
		local hostObject = host.object
		if not (hostObject and hostObject.Parent) then
			return nil, nil
		end

		local target = record.sleeping and record.spacer or record.guiObject
		if not (target and target.Parent) then
			return nil, nil
		end

		updateCachedHeight(record, target)

		local top
		if host.mode == "scrolling" then
			top = (target.AbsolutePosition.Y - hostObject.AbsolutePosition.Y) + hostObject.CanvasPosition.Y
		else
			top = target.AbsolutePosition.Y - hostObject.AbsolutePosition.Y
		end
		local bottom = top + math.max(1, record.cachedHeight or 1)
		return top, bottom
	end

	local function evaluateHost(hostId)
		local host = hosts[hostId]
		if not host then
			return
		end
		if not isAlive(host.object) then
			self.unregisterHost(hostId)
			return
		end

		local elementCount = countHostElements(host)
		if host.paused then
			for token in pairs(host.elements) do
				sleepRecord(token, "host_paused", { fade = false })
			end
			host.dirty = false
			host.lastReason = nil
			return
		end
		if elementCount <= self.Config.MinElementsToActivate then
			for token in pairs(host.elements) do
				wakeRecord(token, "below_threshold", { fade = false })
			end
			host.dirty = false
			host.lastReason = nil
			return
		end

		local viewportTop, viewportBottom = computeViewport(host)
		if viewportTop == nil then
			host.dirty = false
			host.lastReason = nil
			return
		end

		local fadeAllowed = shouldUseFade(host)
		for token in pairs(host.elements) do
			local record = records[token]
			if not record then
				host.elements[token] = nil
			else
				if record.hostId ~= hostId then
					host.elements[token] = nil
				else
					local busy = record.busy
					if not busy and record.guiObject and record.guiObject.GetAttribute then
						local okAttr, value = pcall(record.guiObject.GetAttribute, record.guiObject, "RayfieldInteractionBusy")
						busy = okAttr and value == true
					end
					if busy then
						wakeRecord(token, "busy", { fade = false })
					else
						local top, bottom = computeBounds(host, record)
						if top ~= nil and bottom ~= nil then
							local visible = bottom >= viewportTop and top <= viewportBottom
							if visible then
								wakeRecord(token, "visible", {
									fade = fadeAllowed
								})
							else
								sleepRecord(token, "offscreen", {
									fade = fadeAllowed
								})
							end
						end
					end
				end
			end
		end

		host.dirty = false
		host.lastReason = nil
	end

	local function ensureUpdateLoop()
		if updateConnection or self.Config.Enabled ~= true then
			return
		end
		updateConnection = self.RunService.RenderStepped:Connect(function(deltaTime)
			updateAccumulator += deltaTime
			if updateAccumulator < updateInterval then
				return
			end
			updateAccumulator = 0
			for _, hostId in ipairs(hostOrder) do
				local host = hosts[hostId]
				if host and host.dirty then
					evaluateHost(hostId)
				end
			end
		end)
	end

	local function disconnectUpdateLoopIfIdle()
		if next(hosts) ~= nil then
			return
		end
		if updateConnection then
			safeDisconnect(updateConnection)
			updateConnection = nil
		end
	end

	local function unregisterRecord(token)
		local record = records[token]
		if not record then
			return false
		end

		wakeRecord(token, "unregister", { fade = false })

		for _, connection in ipairs(record.connections) do
			safeDisconnect(connection)
		end
		table.clear(record.connections)

		local guiObject = record.guiObject
		if guiObject and guiObject.SetAttribute then
			pcall(guiObject.SetAttribute, guiObject, "RayfieldVirtualToken", nil)
			pcall(guiObject.SetAttribute, guiObject, "RayfieldViewportSleeping", false)
		end

		if guiObject then
			recordsByObject[guiObject] = nil
		end

		local host = hosts[record.hostId]
		if host then
			host.elements[token] = nil
			markHostDirty(record.hostId, "element_unregister")
		end

		records[token] = nil
		return true
	end

	self.registerHost = function(hostId, hostObject, options)
		if self.Config.Enabled ~= true then
			return false
		end
		if type(hostId) ~= "string" or hostId == "" then
			return false
		end
		if typeof(hostObject) ~= "Instance" or not hostObject:IsA("GuiObject") then
			return false
		end

		local previousTokens = nil
		local existingHost = hosts[hostId]
		if existingHost then
			previousTokens = {}
			for token in pairs(existingHost.elements) do
				table.insert(previousTokens, token)
			end
		end
		self.unregisterHost(hostId)

		local opts = options or {}
		local mode = tostring(opts.mode or "auto")
		if mode == "auto" then
			if hostObject:IsA("ScrollingFrame") then
				mode = "scrolling"
			else
				mode = "clipped"
			end
		end

		local host = {
			id = hostId,
			object = hostObject,
			mode = mode,
			overscan = tonumber(opts.overscan) or self.Config.OverscanPx,
			elements = {},
			connections = {},
			dirty = true,
			paused = false,
			resizeInProgress = false,
			resizeToken = 0,
			lastReason = "register"
		}
		if host.overscan < 0 then
			host.overscan = 0
		end

		local function onResize()
			host.resizeInProgress = true
			host.resizeToken += 1
			local token = host.resizeToken
			markHostDirty(hostId, "resize")
			if self.Config.DisableFadeDuringResize then
				local delaySec = math.max(0, self.Config.ResizeDebounceMs) / 1000
				task.delay(delaySec, function()
					local current = hosts[hostId]
					if current and current.resizeToken == token then
						current.resizeInProgress = false
						markHostDirty(hostId, "resize_settle")
					end
				end)
			else
				host.resizeInProgress = false
			end
		end

		table.insert(host.connections, hostObject:GetPropertyChangedSignal("AbsoluteSize"):Connect(onResize))
		table.insert(host.connections, hostObject:GetPropertyChangedSignal("AbsolutePosition"):Connect(function()
			markHostDirty(hostId, "position")
		end))

		if host.mode == "scrolling" and hostObject:IsA("ScrollingFrame") then
			table.insert(host.connections, hostObject:GetPropertyChangedSignal("CanvasPosition"):Connect(function()
				markHostDirty(hostId, "scroll")
			end))
			table.insert(host.connections, hostObject:GetPropertyChangedSignal("CanvasSize"):Connect(function()
				markHostDirty(hostId, "canvas")
			end))
		end

		table.insert(host.connections, hostObject.ChildAdded:Connect(function(child)
			if child:IsA("UIListLayout") then
				table.insert(host.connections, child:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
					markHostDirty(hostId, "content_size")
				end))
				markHostDirty(hostId, "layout_added")
			end
		end))
		table.insert(host.connections, hostObject.ChildRemoved:Connect(function()
			markHostDirty(hostId, "child_removed")
		end))

		local hasDestroying = false
		local okDestroying = pcall(function()
			hasDestroying = hostObject.Destroying ~= nil
		end)
		if okDestroying and hasDestroying then
			table.insert(host.connections, hostObject.Destroying:Connect(function()
				self.unregisterHost(hostId)
			end))
		end
		table.insert(host.connections, hostObject.AncestryChanged:Connect(function(_, parent)
			if parent == nil then
				self.unregisterHost(hostId)
			else
				markHostDirty(hostId, "reparent")
			end
		end))

		hosts[hostId] = host
		table.insert(hostOrder, hostId)
		if previousTokens then
			for _, token in ipairs(previousTokens) do
				local record = records[token]
				if record then
					record.hostId = hostId
					host.elements[token] = true
				end
			end
		end
		ensureUpdateLoop()
		markHostDirty(hostId, "register")
		return true
	end

	self.unregisterHost = function(hostId)
		local host = hosts[hostId]
		if not host then
			return false
		end

		for token in pairs(host.elements) do
			local record = records[token]
			if record and record.hostId == hostId then
				wakeRecord(token, "host_unregister", { fade = false })
				record.hostId = nil
			end
		end

		for _, connection in ipairs(host.connections) do
			safeDisconnect(connection)
		end
		table.clear(host.connections)
		hosts[hostId] = nil

		for index = #hostOrder, 1, -1 do
			if hostOrder[index] == hostId then
				table.remove(hostOrder, index)
			end
		end

		disconnectUpdateLoopIfIdle()
		return true
	end

	self.refreshHost = function(hostId, reason)
		return markHostDirty(hostId, reason or "refresh")
	end

	self.setHostSuppressed = function(hostId, suppressed)
		local host = hosts[hostId]
		if not host then
			return false
		end
		host.paused = suppressed == true
		if host.paused then
			for token in pairs(host.elements) do
				sleepRecord(token, "host_suppressed", { fade = false })
			end
			host.dirty = false
			host.lastReason = nil
		else
			markHostDirty(hostId, "host_unsuppressed")
		end
		return true
	end

	self.registerElement = function(hostId, guiObject, options)
		if self.Config.Enabled ~= true then
			return nil
		end
		local host = hosts[hostId]
		if not host then
			return nil
		end
		if typeof(guiObject) ~= "Instance" or not guiObject:IsA("GuiObject") then
			return nil
		end

		tokenCounter += 1
		local token = "viewport_element_" .. tostring(tokenCounter)
		local opts = options or {}
		local record = {
			token = token,
			guiObject = guiObject,
			hostId = hostId,
			sleeping = false,
			spacer = nil,
			originalParent = nil,
			originalLayoutOrder = nil,
			cachedHeight = math.max(1, math.floor(guiObject.AbsoluteSize.Y + 0.5)),
			busy = false,
			onWake = opts.onWake,
			onSleep = opts.onSleep,
			meta = opts.meta,
			connections = {}
		}

		records[token] = record
		recordsByObject[guiObject] = token
		host.elements[token] = true

		if guiObject.SetAttribute then
			pcall(guiObject.SetAttribute, guiObject, "RayfieldVirtualToken", token)
		end

		table.insert(record.connections, guiObject:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
			updateCachedHeight(record, guiObject)
			markHostDirty(record.hostId, "element_size")
		end))
		table.insert(record.connections, guiObject:GetPropertyChangedSignal("Visible"):Connect(function()
			markHostDirty(record.hostId, "element_visibility")
		end))
		table.insert(record.connections, guiObject.AncestryChanged:Connect(function(_, parent)
			if parent == nil and not record.sleeping then
				unregisterRecord(token)
				return
			end
			if record.hostId then
				markHostDirty(record.hostId, "element_reparent")
			end
		end))

		local okDestroying, destroyingSignal = pcall(function()
			return guiObject.Destroying
		end)
		if okDestroying and destroyingSignal and destroyingSignal.Connect then
			table.insert(record.connections, destroyingSignal:Connect(function()
				unregisterRecord(token)
			end))
		end

		ensureUpdateLoop()
		markHostDirty(hostId, "element_register")
		return token
	end

	self.unregisterElement = function(tokenOrObject)
		local token = nil
		local record = nil
		token, record = resolveToken(recordsByObject, records, tokenOrObject)
		if not token or not record then
			return false
		end
		return unregisterRecord(token)
	end

	self.moveElementToHost = function(tokenOrObject, hostId, reason)
		local host = hosts[hostId]
		if not host then
			return false
		end

		local token, record = resolveToken(recordsByObject, records, tokenOrObject)
		if not token or not record then
			return false
		end

		local previousHostId = record.hostId
		if previousHostId == hostId then
			markHostDirty(hostId, reason or "move_same_host")
			return true
		end

		wakeRecord(token, "move_host", { fade = false })
		if previousHostId and hosts[previousHostId] then
			hosts[previousHostId].elements[token] = nil
			markHostDirty(previousHostId, "element_moved")
		end

		record.hostId = hostId
		host.elements[token] = true
		markHostDirty(hostId, reason or "element_moved")
		return true
	end

	self.setElementBusy = function(tokenOrObject, busy)
		local token, record = resolveToken(recordsByObject, records, tokenOrObject)
		if not token or not record then
			return false
		end
		record.busy = busy == true
		if record.busy then
			wakeRecord(token, "busy", { fade = false })
		end
		if record.hostId then
			markHostDirty(record.hostId, "element_busy")
		end
		return true
	end

	self.notifyElementHostChanged = function(tokenOrObject, reason)
		local _, record = resolveToken(recordsByObject, records, tokenOrObject)
		if not record then
			return false
		end
		if record.hostId then
			markHostDirty(record.hostId, reason or "host_changed")
		end
		return true
	end

	self.getStats = function()
		local hostCount = 0
		for _ in pairs(hosts) do
			hostCount += 1
		end
		local elementCount = 0
		for _ in pairs(records) do
			elementCount += 1
		end
		local sleepingCount = 0
		for _, record in pairs(records) do
			if record.sleeping then
				sleepingCount += 1
			end
		end
		return {
			hosts = hostCount,
			elements = elementCount,
			sleeping = sleepingCount
		}
	end

	self.destroy = function()
		for token in pairs(records) do
			unregisterRecord(token)
		end

		local hostIds = {}
		for hostId in pairs(hosts) do
			table.insert(hostIds, hostId)
		end
		for _, hostId in ipairs(hostIds) do
			self.unregisterHost(hostId)
		end

		if updateConnection then
			safeDisconnect(updateConnection)
			updateConnection = nil
		end
		updateAccumulator = 0
		clearStorageRoot()
	end

	return self
end

return ViewportVirtualization
]])
put("src/ui/elements/common/destroy.lua", [[local Destroy = {}

function Destroy.execute(element)
	if type(element) == "table" and type(element.Destroy) == "function" then
		return element:Destroy()
	end
end

return Destroy]])
put("src/ui/elements/common/theme-bindings.lua", [[local ThemeBindings = {}

function ThemeBindings.bind(bindThemeFn, target, property, themeKey)
	if type(bindThemeFn) == "function" then
		return bindThemeFn(target, property, themeKey)
	end
end

return ThemeBindings]])
put("src/ui/elements/common/visibility.lua", [[local Visibility = {}

function Visibility.show(element)
	if type(element) == "table" and type(element.Show) == "function" then
		return element:Show()
	end
end

function Visibility.hide(element)
	if type(element) == "table" and type(element.Hide) == "function" then
		return element:Hide()
	end
end

function Visibility.set(element, isVisible)
	if type(element) == "table" and type(element.SetVisible) == "function" then
		return element:SetVisible(isVisible)
	end
end

return Visibility]])
put("src/ui/elements/factory.lua", [[local client = _G and _G.__RayfieldApiClient
if not client then
	error("Rayfield ApiClient is not initialized")
end

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
return client.fetchAndExecute(root .. "src/ui/elements/factory/init.lua")]])
put("src/ui/elements/factory/create-section.lua", [[local CreateSection = {}

function CreateSection.execute(tabObject, ...)
	if type(tabObject) == "table" and type(tabObject.CreateSection) == "function" then
		return tabObject:CreateSection(...)
	end
	error("CreateSection.execute expects a tab object returned from :CreateTab")
end

return CreateSection]])
put("src/ui/elements/factory/create-tab.lua", [[local client = _G and _G.__RayfieldApiClient
if not client then
	error("Rayfield ApiClient is not initialized")
end

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
local FactoryModule = client.fetchAndExecute(root .. "src/ui/elements/factory/init.lua")

local CreateTab = {}

function CreateTab.execute(factoryState, ...)
	if type(factoryState) == "table" and type(factoryState.CreateTab) == "function" then
		return factoryState.CreateTab(...)
	end
	error("CreateTab.execute expects a factory state returned from ElementsModule.init(ctx)")
end

CreateTab.FactoryModule = FactoryModule

return CreateTab]])
put("src/ui/elements/factory/init.lua", [[-- Rayfield Element Factories Module
-- Handles tab creation and all element factories

local ElementsModule = {}

function ElementsModule.init(ctx)
	local self = {}

	-- Inject dependencies
	self.TweenService = ctx.TweenService
	self.Animation = ctx.Animation or ctx.TweenService
	self.RunService = ctx.RunService
	self.UserInputService = ctx.UserInputService
	self.HttpService = ctx.HttpService
	self.Main = ctx.Main
	self.Topbar = ctx.Topbar
	self.TabList = ctx.TabList
	self.Elements = ctx.Elements
	self.Rayfield = ctx.Rayfield
	self.RayfieldLibrary = ctx.RayfieldLibrary
	self.Icons = ctx.Icons
	self.getIcon = ctx.getIcon
	self.getAssetUri = ctx.getAssetUri
	self.getSelectedTheme = ctx.getSelectedTheme
	self.rayfieldDestroyed = ctx.rayfieldDestroyed
	self.getMinimised = ctx.getMinimised or function() return false end
	self.getSetting = ctx.getSetting
	self.getInternalSetting = ctx.getInternalSetting or self.getSetting
	self.setInternalSetting = ctx.setInternalSetting
	self.bindTheme = ctx.bindTheme
	self.SaveConfiguration = ctx.SaveConfiguration
	self.makeElementDetachable = ctx.makeElementDetachable
	self.ElementSync = ctx.ElementSync
	self.ViewportVirtualization = ctx.ViewportVirtualization
	self.KeybindSequence = ctx.KeybindSequence
	self.ResourceOwnership = ctx.ResourceOwnership
	-- Improvement 4: Add safe fallbacks for critical dependencies
	self.keybindConnections = ctx.keybindConnections or {} -- Fallback to empty table
	self.getDebounce = ctx.getDebounce or function() return false end
	self.setDebounce = ctx.setDebounce or function(val) end

	self.useMobileSizing = ctx.useMobileSizing
	local LogService = nil
	do
		local okLogService, serviceOrErr = pcall(function()
			return game:GetService("LogService")
		end)
		if okLogService then
			LogService = serviceOrErr
		end
	end

	-- Window Settings (passed from CreateWindow)
	local Settings = ctx.Settings or {}

	-- Module state
	local FirstTab = false
	local tabNameCounts = {}
	local tabRecordsByPersistenceId = {}
	local allControlsById = {}
	local controlOrder = {}
	local controlsByFlag = {}
	local pinnedControlIds = {}
	local controlRegistrySubscribers = {}
	local controlIdSalt = 0
	local pinBadgesVisible = true
	local tooltipState = {
		frame = nil,
		label = nil,
		text = "",
		activeKey = nil
	}
	local logHub = {
		connection = nil,
		subscribers = {}
	}

	local function cloneArray(values)
		local out = {}
		if type(values) ~= "table" then
			return out
		end
		for index, value in ipairs(values) do
			out[index] = value
		end
		return out
	end

	local function ownershipCreateScope(scopeId, metadata)
		if not (self.ResourceOwnership and type(self.ResourceOwnership.createScope) == "function") then
			return nil
		end
		local okScope, scopeOrErr = pcall(self.ResourceOwnership.createScope, scopeId, metadata)
		if okScope and type(scopeOrErr) == "string" and scopeOrErr ~= "" then
			return scopeOrErr
		end
		if okScope then
			return scopeId
		end
		return nil
	end

	local function ownershipClaimInstance(instance, scopeId, metadata)
		if not (self.ResourceOwnership and type(self.ResourceOwnership.claimInstance) == "function") then
			return false
		end
		local okClaim, claimed = pcall(self.ResourceOwnership.claimInstance, instance, scopeId, metadata)
		return okClaim and claimed == true
	end

	local function ownershipTrackConnection(connection, scopeId)
		if not connection or type(scopeId) ~= "string" or scopeId == "" then
			return false
		end
		if not (self.ResourceOwnership and type(self.ResourceOwnership.trackConnection) == "function") then
			return false
		end
		local okTrack, tracked = pcall(self.ResourceOwnership.trackConnection, connection, scopeId)
		return okTrack and tracked == true
	end

	local function ownershipTrackCleanup(cleanupFn, scopeId)
		if type(cleanupFn) ~= "function" or type(scopeId) ~= "string" or scopeId == "" then
			return false
		end
		if not (self.ResourceOwnership and type(self.ResourceOwnership.trackCleanup) == "function") then
			return false
		end
		local okTrack, tracked = pcall(self.ResourceOwnership.trackCleanup, cleanupFn, scopeId)
		return okTrack and tracked == true
	end

	local function ownershipCleanupScope(scopeId, options)
		if type(scopeId) ~= "string" or scopeId == "" then
			return false
		end
		if not (self.ResourceOwnership and type(self.ResourceOwnership.cleanupScope) == "function") then
			return false
		end
		local okCleanup, cleaned = pcall(self.ResourceOwnership.cleanupScope, scopeId, options or {
			destroyInstances = false,
			clearAttributes = true
		})
		return okCleanup and cleaned == true
	end

	local function cloneSerializable(value, seen)
		local valueType = type(value)
		if valueType == "function" or valueType == "userdata" or valueType == "thread" then
			return nil
		end
		if valueType ~= "table" then
			return value
		end
		seen = seen or {}
		if seen[value] then
			return seen[value]
		end
		local out = {}
		seen[value] = out
		for key, nested in pairs(value) do
			if key ~= "Element" then
				local clonedKey = cloneSerializable(key, seen)
				local clonedNested = cloneSerializable(nested, seen)
				if clonedKey ~= nil and clonedNested ~= nil then
					out[clonedKey] = clonedNested
				end
			end
		end
		return out
	end

	local function clampNumber(value, minimum, maximum, fallback)
		local numberValue = tonumber(value)
		if not numberValue then
			numberValue = tonumber(fallback) or 0
		end
		if minimum ~= nil then
			numberValue = math.max(minimum, numberValue)
		end
		if maximum ~= nil then
			numberValue = math.min(maximum, numberValue)
		end
		return numberValue
	end

	local function packColor3(colorValue)
		if typeof(colorValue) ~= "Color3" then
			return nil
		end
		return {
			R = math.floor((colorValue.R * 255) + 0.5),
			G = math.floor((colorValue.G * 255) + 0.5),
			B = math.floor((colorValue.B * 255) + 0.5)
		}
	end

	local function unpackColor3(colorValue)
		if type(colorValue) ~= "table" then
			return nil
		end
		local r = tonumber(colorValue.R)
		local g = tonumber(colorValue.G)
		local b = tonumber(colorValue.B)
		if not (r and g and b) then
			return nil
		end
		return Color3.fromRGB(
			math.clamp(math.floor(r + 0.5), 0, 255),
			math.clamp(math.floor(g + 0.5), 0, 255),
			math.clamp(math.floor(b + 0.5), 0, 255)
		)
	end

	local function roundToPrecision(value, precision)
		local digits = math.max(0, math.floor(tonumber(precision) or 0))
		local scale = 10 ^ digits
		return math.floor((tonumber(value) or 0) * scale + 0.5) / scale
	end

	local function ensureTooltipFrame()
		if tooltipState.frame and tooltipState.frame.Parent then
			return tooltipState.frame
		end

		local host = self.Rayfield or self.Main
		if not host then
			return nil
		end

		local frame = Instance.new("Frame")
		frame.Name = "RayfieldTooltip"
		frame.AnchorPoint = Vector2.new(0, 1)
		frame.Position = UDim2.new(0, 0, 0, 0)
		frame.Size = UDim2.new(0, 220, 0, 30)
		frame.BackgroundTransparency = 0.05
		frame.BorderSizePixel = 0
		frame.Visible = false
		frame.ZIndex = 500
		frame.Parent = host
		pcall(function()
			frame.Active = false
		end)

		local corner = Instance.new("UICorner")
		corner.CornerRadius = UDim.new(0, 6)
		corner.Parent = frame

		local stroke = Instance.new("UIStroke")
		stroke.Thickness = 1
		stroke.Transparency = 0.15
		stroke.Parent = frame

		local label = Instance.new("TextLabel")
		label.Name = "Text"
		label.BackgroundTransparency = 1
		label.TextXAlignment = Enum.TextXAlignment.Left
		label.TextYAlignment = Enum.TextYAlignment.Top
		label.TextWrapped = true
		label.Font = Enum.Font.Gotham
		label.TextSize = 12
		label.Position = UDim2.new(0, 8, 0, 6)
		label.Size = UDim2.new(1, -16, 1, -12)
		label.ZIndex = 501
		label.Parent = frame

		tooltipState.frame = frame
		tooltipState.label = label

		local function applyTooltipTheme()
			local theme = self.getSelectedTheme and self.getSelectedTheme()
			if not theme then
				return
			end
			frame.BackgroundColor3 = theme.TooltipBackground or theme.SecondaryElementBackground or theme.ElementBackground
			label.TextColor3 = theme.TooltipTextColor or theme.TextColor
			stroke.Color = theme.TooltipStroke or theme.ElementStroke or theme.SecondaryElementStroke
		end
		applyTooltipTheme()
		if self.Rayfield and self.Rayfield.Main then
			self.Rayfield.Main:GetPropertyChangedSignal("BackgroundColor3"):Connect(function()
				if frame and frame.Parent then
					applyTooltipTheme()
				end
			end)
		end

		return frame
	end

	local function hideTooltip(key)
		if key ~= nil and tooltipState.activeKey ~= key then
			return
		end
		tooltipState.activeKey = nil
		if tooltipState.frame then
			tooltipState.frame.Visible = false
		end
	end

	local function showTooltip(key, guiObject, text)
		local frame = ensureTooltipFrame()
		if not frame or not guiObject or not guiObject.Parent then
			return
		end
		local textValue = tostring(text or "")
		if textValue == "" then
			hideTooltip(key)
			return
		end
		tooltipState.activeKey = key
		tooltipState.text = textValue
		if tooltipState.label then
			tooltipState.label.Text = textValue
		end

		local mousePosition = nil
		local okPos, posValue = pcall(function()
			return self.UserInputService:GetMouseLocation()
		end)
		if okPos then
			mousePosition = posValue
		else
			mousePosition = Vector2.new(guiObject.AbsolutePosition.X, guiObject.AbsolutePosition.Y)
		end

		local width = math.clamp(math.max(160, (#textValue * 6) + 16), 160, 360)
		local lines = math.max(1, math.ceil(#textValue / 38))
		local height = math.max(24, (lines * 14) + 12)
		frame.Size = UDim2.new(0, width, 0, height)

		local hostSize = self.Rayfield and self.Rayfield.AbsoluteSize or Vector2.new(1200, 800)
		local x = mousePosition.X + 14
		local y = mousePosition.Y - 10
		if x + width > hostSize.X then
			x = math.max(8, mousePosition.X - width - 14)
		end
		if y - height < 0 then
			y = mousePosition.Y + height
		end
		frame.Position = UDim2.new(0, x, 0, y)
		frame.Visible = true
	end

	local function ensureLogHubConnected()
		if not LogService or logHub.connection then
			return
		end
		logHub.connection = LogService.MessageOut:Connect(function(message, messageType)
			local level = "info"
			if messageType == Enum.MessageType.MessageWarning then
				level = "warn"
			elseif messageType == Enum.MessageType.MessageError then
				level = "error"
			end
			for callback in pairs(logHub.subscribers) do
				local ok = pcall(callback, level, tostring(message or ""))
				if not ok then
					logHub.subscribers[callback] = nil
				end
			end
		end)
	end

	local function subscribeGlobalLogs(callback)
		if type(callback) ~= "function" then
			return function() end
		end
		logHub.subscribers[callback] = true
		ensureLogHubConnected()
		local disposed = false
		return function()
			if disposed then
				return
			end
			disposed = true
			logHub.subscribers[callback] = nil
			if not next(logHub.subscribers) and logHub.connection then
				logHub.connection:Disconnect()
				logHub.connection = nil
			end
		end
	end

	local function emitControlRegistryChange(reason)
		for callback in pairs(controlRegistrySubscribers) do
			local ok = pcall(callback, tostring(reason or "changed"))
			if not ok then
				controlRegistrySubscribers[callback] = nil
			end
		end
	end

	local function isControlRecordAlive(record)
		if type(record) ~= "table" then
			return false
		end
		local guiObject = record.GuiObject
		return guiObject and guiObject.Parent ~= nil
	end

	local function applyPinnedVisual(record)
		if type(record) ~= "table" then
			return
		end
		local pinButton = record.PinButton
		if not pinButton then
			return
		end
		local pinned = pinnedControlIds[record.Id] == true
		pinButton.Text = pinned and "" or ""
		pinButton.TextColor3 = pinned and Color3.fromRGB(255, 215, 120) or Color3.fromRGB(225, 225, 225)
	end

	local function getRecordByIdOrFlag(idOrFlag)
		if type(idOrFlag) ~= "string" then
			return nil
		end
		local key = tostring(idOrFlag)
		local record = allControlsById[key]
		if record then
			return record
		end
		if controlsByFlag[key] then
			return controlsByFlag[key]
		end
		local byFlagName = controlsByFlag["flag:" .. key]
		if byFlagName then
			return byFlagName
		end
		return nil
	end

	local function setControlPinnedState(record, shouldPin)
		if type(record) ~= "table" or type(record.Id) ~= "string" then
			return false, "Control record is invalid."
		end

		if shouldPin then
			pinnedControlIds[record.Id] = true
		else
			pinnedControlIds[record.Id] = nil
		end
		applyPinnedVisual(record)
		emitControlRegistryChange(shouldPin and "pin" or "unpin")
		return true, shouldPin and "Pinned." or "Unpinned."
	end

	local function pinControl(idOrFlag)
		local record = getRecordByIdOrFlag(tostring(idOrFlag or ""))
		if not record then
			return false, "Control not found."
		end
		return setControlPinnedState(record, true)
	end

	local function unpinControl(idOrFlag)
		local record = getRecordByIdOrFlag(tostring(idOrFlag or ""))
		if not record then
			return false, "Control not found."
		end
		return setControlPinnedState(record, false)
	end

	local function getPinnedIds(pruneMissing)
		local orderedPinned = {}
		for _, id in ipairs(controlOrder) do
			if pinnedControlIds[id] then
				local record = allControlsById[id]
				if record and isControlRecordAlive(record) then
					table.insert(orderedPinned, id)
				elseif pruneMissing == true then
					pinnedControlIds[id] = nil
				end
			end
		end
		return orderedPinned
	end

	local function setPinnedIds(ids)
		pinnedControlIds = {}
		if type(ids) == "table" then
			for _, value in ipairs(ids) do
				if type(value) == "string" and value ~= "" then
					pinnedControlIds[value] = true
				end
			end
		end
		for _, record in pairs(allControlsById) do
			applyPinnedVisual(record)
		end
		emitControlRegistryChange("set_pinned_ids")
	end

	local function setPinBadgesVisible(visible)
		local show = visible ~= false
		pinBadgesVisible = show
		for _, record in pairs(allControlsById) do
			local pinButton = record.PinButton
			if pinButton then
				pinButton.Visible = show
			end
		end
		emitControlRegistryChange("set_pin_badges_visible")
	end

	local function listControlsForFavorites(pruneMissing)
		local out = {}
		for _, id in ipairs(controlOrder) do
			local record = allControlsById[id]
			if record and isControlRecordAlive(record) then
				table.insert(out, {
					id = record.Id,
					tabId = record.TabPersistenceId,
					name = record.Name,
					type = record.Type,
					flag = record.Flag,
					pinned = pinnedControlIds[record.Id] == true
				})
			elseif pruneMissing == true and pinnedControlIds[id] then
				pinnedControlIds[id] = nil
			end
		end
		return out
	end

	local function getControlRecordById(id)
		local record = allControlsById[tostring(id or "")]
		if not record then
			return nil
		end
		if not isControlRecordAlive(record) then
			return nil
		end
		return record
	end

	-- Extract code starts here

		local function CreateTab(Name, Image, Ext)
			local basePersistenceId = tostring(Name)
			local persistenceIndex = (tabNameCounts[basePersistenceId] or 0) + 1
			tabNameCounts[basePersistenceId] = persistenceIndex
			local tabPersistenceId = persistenceIndex > 1 and (basePersistenceId .. "#" .. tostring(persistenceIndex)) or basePersistenceId
			local SDone = false
			local TabButton = self.TabList.Template:Clone()
			TabButton.Name = Name
			TabButton.Title.Text = Name
			TabButton.Parent = self.TabList
			TabButton.Title.TextWrapped = false
			TabButton.Size = UDim2.new(0, TabButton.Title.TextBounds.X + 30, 0, 30)
	
			if Image and Image ~= 0 then
				if typeof(Image) == 'string' and self.Icons then
					local asset = self.getIcon(Image)
	
					TabButton.Image.Image = 'rbxassetid://'..asset.id
					TabButton.Image.ImageRectOffset = asset.imageRectOffset
					TabButton.Image.ImageRectSize = asset.imageRectSize
				else
					TabButton.Image.Image = self.getAssetUri(Image)
				end
	
				TabButton.Title.AnchorPoint = Vector2.new(0, 0.5)
				TabButton.Title.Position = UDim2.new(0, 37, 0.5, 0)
				TabButton.Image.Visible = true
				TabButton.Title.TextXAlignment = Enum.TextXAlignment.Left
				TabButton.Size = UDim2.new(0, TabButton.Title.TextBounds.X + 52, 0, 30)
			end
	
	
	
			TabButton.BackgroundTransparency = 1
			TabButton.Title.TextTransparency = 1
			TabButton.Image.ImageTransparency = 1
			TabButton.UIStroke.Transparency = 1

			local TabHoverGlow = Instance.new("UIStroke")
			TabHoverGlow.Name = "HoverGlow"
			TabHoverGlow.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
			TabHoverGlow.Thickness = 2.8
			TabHoverGlow.Transparency = 1
			TabHoverGlow.Color = Color3.fromRGB(110, 175, 240)
			TabHoverGlow.Parent = TabButton
	
			TabButton.Visible = not Ext or false
	
			-- Create self.Elements Page
			local TabPage = self.Elements.Template:Clone()
			TabPage.Name = Name
			TabPage.Visible = true
	
			TabPage.LayoutOrder = #self.Elements:GetChildren() or Ext and 10000
	
			for _, TemplateElement in ipairs(TabPage:GetChildren()) do
				if TemplateElement.ClassName == "Frame" and TemplateElement.Name ~= "Placeholder" then
					TemplateElement:Destroy()
				end
			end

			TabPage.Parent = self.Elements

			local tabRecord = {
				Name = Name,
				PersistenceId = tabPersistenceId,
				Ext = Ext and true or false,
				TabButton = TabButton,
				TabPage = TabPage,
				DefaultVisible = TabButton.Visible,
				IsSplit = false,
				SplitPanelId = nil,
				SuppressNextClick = false,
				IsSettings = (Name == "Rayfield Settings" and Ext == true)
			}
			tabRecordsByPersistenceId[tabPersistenceId] = tabRecord
			local tabHover = false
			
			-- Reactive coloring for TabPage elements
			TabPage.ChildAdded:Connect(function(Element)
				if Element.ClassName == "Frame" and Element.Name ~= "Placeholder" and Element.Name ~= "SectionSpacing" and Element.Name ~= "Divider" and Element.Name ~= "SectionTitle" and Element.Name ~= "SearchTitle-fsefsefesfsefesfesfThanks" then
					self.bindTheme(Element, "BackgroundColor3", "ElementBackground")
					-- Guard: not all frames have a UIStroke child
					if Element:FindFirstChildWhichIsA("UIStroke") then
						self.bindTheme(Element.UIStroke, "Color", "ElementStroke")
					end
				end
			end)
			
			if not FirstTab and not Ext then
				self.Elements.UIPageLayout.Animated = false
				self.Elements.UIPageLayout:JumpTo(TabPage)
				self.Elements.UIPageLayout.Animated = true
			end
	
			self.bindTheme(TabButton.UIStroke, "Color", "TabStroke")
	
			local function UpdateTabColors()
				TabButton.UIStroke.Color = self.getSelectedTheme().TabStroke
				TabHoverGlow.Color = self.getSelectedTheme().SliderProgress or self.getSelectedTheme().TabStroke
				if self.Elements.UIPageLayout.CurrentPage == TabPage then
					tabHover = false
					TabButton.UIStroke.Thickness = 1
					TabHoverGlow.Transparency = 1
					TabButton.BackgroundColor3 = self.getSelectedTheme().TabBackgroundSelected
					TabButton.Image.ImageColor3 = self.getSelectedTheme().SelectedTabTextColor
					TabButton.Title.TextColor3 = self.getSelectedTheme().SelectedTabTextColor
				else
					if not tabHover then
						TabButton.UIStroke.Thickness = 1
						TabHoverGlow.Transparency = 1
					end
					TabButton.BackgroundColor3 = self.getSelectedTheme().TabBackground
					TabButton.Image.ImageColor3 = self.getSelectedTheme().TabTextColor
					TabButton.Title.TextColor3 = self.getSelectedTheme().TabTextColor
				end
			end

			local function applyTabHoverVisual(duration)
				if tabRecord.IsSplit then
					return
				end
				if self.Elements.UIPageLayout.CurrentPage == TabPage then
					return
				end

				local tweenDuration = duration or 0.16
				local theme = self.getSelectedTheme() or {}
				local targetBackgroundTransparency = tabHover and 0.58 or 0.7
				local targetStrokeTransparency = tabHover and 0.32 or 0.5
				local targetStrokeThickness = tabHover and 1.2 or 1
				local targetStrokeColor = tabHover and (theme.SliderProgress or theme.TabStroke) or theme.TabStroke
				local targetGlowTransparency = tabHover and 0.84 or 1
				local targetGlowThickness = tabHover and 3.3 or 2.8
				local targetGlowColor = theme.SliderProgress or theme.TabStroke
				local targetTextTransparency = tabHover and 0.05 or 0.2
				local targetImageTransparency = tabHover and 0.05 or 0.2

				self.Animation:Create(TabButton, TweenInfo.new(tweenDuration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundTransparency = targetBackgroundTransparency}):Play()
				self.Animation:Create(TabButton.UIStroke, TweenInfo.new(tweenDuration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
					Transparency = targetStrokeTransparency,
					Thickness = targetStrokeThickness,
					Color = targetStrokeColor
				}):Play()
				self.Animation:Create(TabHoverGlow, TweenInfo.new(tweenDuration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
					Transparency = targetGlowTransparency,
					Thickness = targetGlowThickness,
					Color = targetGlowColor
				}):Play()
				self.Animation:Create(TabButton.Title, TweenInfo.new(tweenDuration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {TextTransparency = targetTextTransparency}):Play()
				self.Animation:Create(TabButton.Image, TweenInfo.new(tweenDuration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {ImageTransparency = targetImageTransparency}):Play()
			end

			-- Listen for theme changes to update tab colors
			local themeValueFolder = self.Main:FindFirstChild("ThemeValues")
			if themeValueFolder then
				themeValueFolder:FindFirstChild("Background").Changed:Connect(UpdateTabColors)
			end
			
			self.Elements.UIPageLayout:GetPropertyChangedSignal("CurrentPage"):Connect(UpdateTabColors)
	
	
			-- Animate
			task.wait(0.1)
			if FirstTab or Ext then
				TabButton.BackgroundColor3 = self.getSelectedTheme().TabBackground
				TabButton.Image.ImageColor3 = self.getSelectedTheme().TabTextColor
				TabButton.Title.TextColor3 = self.getSelectedTheme().TabTextColor
				self.Animation:Create(TabButton, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0.7}):Play()
				self.Animation:Create(TabButton.Title, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {TextTransparency = 0.2}):Play()
				self.Animation:Create(TabButton.Image, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {ImageTransparency = 0.2}):Play()
				self.Animation:Create(TabButton.UIStroke, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {Transparency = 0.5}):Play()
				TabHoverGlow.Transparency = 1
			elseif not Ext then
				FirstTab = Name
				TabButton.BackgroundColor3 = self.getSelectedTheme().TabBackgroundSelected
				TabButton.Image.ImageColor3 = self.getSelectedTheme().SelectedTabTextColor
				TabButton.Title.TextColor3 = self.getSelectedTheme().SelectedTabTextColor
				self.Animation:Create(TabButton.Image, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {ImageTransparency = 0}):Play()
				self.Animation:Create(TabButton, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0}):Play()
				self.Animation:Create(TabButton.Title, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {TextTransparency = 0}):Play()
				TabHoverGlow.Transparency = 1
			end
	
			local function activateTab(ignoreMinimisedCheck)
				if tabRecord.IsSplit then return false end
				if not ignoreMinimisedCheck and self.getMinimised() then return false end

				tabHover = false
				self.Animation:Create(TabButton, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0}):Play()
				self.Animation:Create(TabButton.UIStroke, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {Transparency = 1}):Play()
				self.Animation:Create(TabButton.Title, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {TextTransparency = 0}):Play()
				self.Animation:Create(TabButton.Image, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {ImageTransparency = 0}):Play()
				self.Animation:Create(TabButton, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().TabBackgroundSelected}):Play()
				self.Animation:Create(TabButton.Title, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {TextColor3 = self.getSelectedTheme().SelectedTabTextColor}):Play()
				self.Animation:Create(TabButton.Image, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {ImageColor3 = self.getSelectedTheme().SelectedTabTextColor}):Play()
				TabButton.UIStroke.Thickness = 1
				TabButton.UIStroke.Color = self.getSelectedTheme().TabStroke
				TabHoverGlow.Transparency = 1

				for _, OtherTabButton in ipairs(self.TabList:GetChildren()) do
					if OtherTabButton.Name ~= "Template" and OtherTabButton.ClassName == "Frame" and OtherTabButton ~= TabButton and OtherTabButton.Name ~= "Placeholder" and OtherTabButton.Visible then
						self.Animation:Create(OtherTabButton, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().TabBackground}):Play()
						self.Animation:Create(OtherTabButton.Title, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {TextColor3 = self.getSelectedTheme().TabTextColor}):Play()
						self.Animation:Create(OtherTabButton.Image, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {ImageColor3 = self.getSelectedTheme().TabTextColor}):Play()
						self.Animation:Create(OtherTabButton, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0.7}):Play()
						self.Animation:Create(OtherTabButton.Title, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {TextTransparency = 0.2}):Play()
						self.Animation:Create(OtherTabButton.Image, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {ImageTransparency = 0.2}):Play()
						self.Animation:Create(OtherTabButton.UIStroke, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {Transparency = 0.5}):Play()
						OtherTabButton.UIStroke.Thickness = 1
						OtherTabButton.UIStroke.Color = self.getSelectedTheme().TabStroke
						local otherGlow = OtherTabButton:FindFirstChild("HoverGlow")
						if otherGlow and otherGlow:IsA("UIStroke") then
							otherGlow.Transparency = 1
						end
					end
				end

				if self.Elements.UIPageLayout.CurrentPage ~= TabPage then
					self.Elements.UIPageLayout:JumpTo(TabPage)
				end

				return true
			end

			tabRecord.Activate = activateTab

			TabButton.Interact.MouseEnter:Connect(function()
				if self.Elements.UIPageLayout.CurrentPage == TabPage then
					return
				end
				tabHover = true
				applyTabHoverVisual(0.14)
			end)

			TabButton.Interact.MouseLeave:Connect(function()
				tabHover = false
				UpdateTabColors()
				applyTabHoverVisual(0.14)
			end)
	
			TabButton.Interact.MouseButton1Click:Connect(function()
				if tabRecord.SuppressNextClick then
					tabRecord.SuppressNextClick = false
					return
				end

				activateTab(false)
			end)
	
			-- Preserve module context for Tab:Create* methods where `self` is Tab.
			local Tab = setmetatable({}, { __index = self })
			Tab.__TabRecord = tabRecord
			function Tab:GetInternalRecord()
				return tabRecord
			end
			tabRecord.Tab = Tab
	
			-- Element tracking system for extended API
			local elementSync = self.ElementSync
			local tabSyncId = tabRecord.PersistenceId or tabRecord.Name or tostring(TabPage)
			local tabVirtualHostId = "tab:" .. tostring(tabPersistenceId)
			local viewportVirtualization = self.ViewportVirtualization
			local tabSyncTokens = {}
			local TabElements = {} -- Stores all elements created in this tab
			local TabSections = {}-- Stores all sections created in this tab
			local currentImplicitSection = nil
			local hoverBindings = {}
			local hoverSyncConnection = nil
			local hoverSyncAccumulator = 0
			local hoverSyncDirty = true
			local hoverLastPointer = nil
			local hoverLastPage = nil
			local hoverBindingCount = 0
			local HOVER_SYNC_INTERVAL = 1 / 30
			local virtualHostRegistered = false
			local syncHoverBindingsFromPointer
			local markHoverSyncDirty

			local function markVirtualHostDirty(reason)
				if viewportVirtualization and type(viewportVirtualization.refreshHost) == "function" then
					pcall(viewportVirtualization.refreshHost, tabVirtualHostId, reason or "tab_update")
				end
			end

			local function registerVirtualHost()
				if not (viewportVirtualization and type(viewportVirtualization.registerHost) == "function") then
					return false
				end
				local okRegister, registerResult = pcall(viewportVirtualization.registerHost, tabVirtualHostId, TabPage, {
					mode = "auto"
				})
				virtualHostRegistered = okRegister and registerResult == true
				return virtualHostRegistered
			end

			local function unregisterVirtualHost()
				if not virtualHostRegistered then
					return
				end
				virtualHostRegistered = false
				if viewportVirtualization and type(viewportVirtualization.unregisterHost) == "function" then
					pcall(viewportVirtualization.unregisterHost, tabVirtualHostId)
				end
			end

			local function registerVirtualElement(guiObject, elementName, elementType, syncToken)
				if not virtualHostRegistered then
					return nil
				end
				if not (viewportVirtualization and type(viewportVirtualization.registerElement) == "function") then
					return nil
				end
				local okToken, virtualToken = pcall(viewportVirtualization.registerElement, tabVirtualHostId, guiObject, {
					meta = {
						name = elementName,
						elementType = elementType,
						tabId = tabPersistenceId
					},
					onWake = function()
						if syncToken and elementSync then
							elementSync.resync(syncToken, "viewport_wake")
						end
						markHoverSyncDirty()
						task.defer(function()
							syncHoverBindingsFromPointer(nil, true)
						end)
					end
				})
				if not okToken then
					return nil
				end
				if guiObject and guiObject.SetAttribute and type(virtualToken) == "string" then
					guiObject:SetAttribute("RayfieldVirtualToken", virtualToken)
				end
				return virtualToken
			end

			registerVirtualHost()

			markHoverSyncDirty = function()
				hoverSyncDirty = true
			end

			local function getPointerLocation()
				local ok, pointer = pcall(function()
					return self.UserInputService:GetMouseLocation()
				end)
				if ok then
					return pointer
				end
				return nil
			end

			local function isPointInsideGui(point, guiObject)
				if not point or not guiObject or not guiObject.Parent then
					return false
				end
				local pos = guiObject.AbsolutePosition
				local size = guiObject.AbsoluteSize
				if size.X <= 0 or size.Y <= 0 then
					return false
				end
				return point.X >= pos.X
					and point.Y >= pos.Y
					and point.X <= (pos.X + size.X)
					and point.Y <= (pos.Y + size.Y)
			end

			local function cleanupHoverBinding(key)
				local binding = hoverBindings[key]
				if not binding then
					return
				end
				if binding.Hovered and binding.OnLeave then
					pcall(binding.OnLeave)
				end
				binding.Hovered = false
				if binding.DestroyingConnection then
					binding.DestroyingConnection:Disconnect()
					binding.DestroyingConnection = nil
				end
				hoverBindings[key] = nil
				hoverBindingCount = math.max(0, hoverBindingCount - 1)
				markHoverSyncDirty()
				if hoverBindingCount <= 0 and hoverSyncConnection then
					hoverSyncConnection:Disconnect()
					hoverSyncConnection = nil
				end
			end

			syncHoverBindingsFromPointer = function(point, force)
				local pointer = point or getPointerLocation()
				local currentPage = self.Elements.UIPageLayout.CurrentPage
				local isCurrentTab = currentPage == TabPage

				for _, binding in pairs(hoverBindings) do
					local guiObject = binding.GuiObject
					local shouldHover = false
					if isCurrentTab and guiObject and guiObject.Parent and guiObject.Visible and guiObject:IsDescendantOf(TabPage) then
						shouldHover = isPointInsideGui(pointer, guiObject)
					end

					if force or binding.Hovered ~= shouldHover then
						binding.Hovered = shouldHover
						if shouldHover then
							if binding.OnEnter then
								binding.OnEnter()
							end
						else
							if binding.OnLeave then
								binding.OnLeave()
							end
						end
					end
				end

				hoverLastPointer = pointer
				hoverLastPage = currentPage
				hoverSyncDirty = false
			end

			local function ensureHoverSyncConnection()
				if hoverSyncConnection then
					return
				end

				hoverSyncConnection = self.RunService.RenderStepped:Connect(function(deltaTime)
					if hoverBindingCount <= 0 then
						return
					end
					hoverSyncAccumulator += deltaTime
					if hoverSyncAccumulator < HOVER_SYNC_INTERVAL then
						return
					end
					hoverSyncAccumulator = 0
					local pointer = getPointerLocation()
					local currentPage = self.Elements.UIPageLayout.CurrentPage
					local shouldSync = hoverSyncDirty
					if not shouldSync then
						if currentPage ~= hoverLastPage then
							shouldSync = true
						elseif pointer and hoverLastPointer then
							if math.abs(pointer.X - hoverLastPointer.X) >= 1 or math.abs(pointer.Y - hoverLastPointer.Y) >= 1 then
								shouldSync = true
							end
						elseif pointer ~= hoverLastPointer then
							shouldSync = true
						end
					end
					if shouldSync then
						syncHoverBindingsFromPointer(pointer, false)
					end
				end)
			end

			local function cleanupAllHoverBindings()
				for key in pairs(hoverBindings) do
					cleanupHoverBinding(key)
				end
				hoverBindingCount = 0
				if hoverSyncConnection then
					hoverSyncConnection:Disconnect()
					hoverSyncConnection = nil
				end
				markHoverSyncDirty()
			end

			local function registerHoverBinding(guiObject, onEnter, onLeave, key)
				if not (guiObject and guiObject:IsA("GuiObject")) then
					return nil
				end

				local bindingKey = key or self.HttpService:GenerateGUID(false)
				cleanupHoverBinding(bindingKey)

				local binding = {
					GuiObject = guiObject,
					OnEnter = onEnter,
					OnLeave = onLeave,
					Hovered = false,
					DestroyingConnection = nil
				}
				local destroyingSignal = nil
				local signalOk, signalValue = pcall(function()
					return guiObject.Destroying
				end)
				if signalOk and signalValue and signalValue.Connect then
					destroyingSignal = signalValue
				end
				if destroyingSignal then
					binding.DestroyingConnection = destroyingSignal:Connect(function()
						cleanupHoverBinding(bindingKey)
					end)
				else
					binding.DestroyingConnection = guiObject.AncestryChanged:Connect(function()
						if not guiObject:IsDescendantOf(game) then
							cleanupHoverBinding(bindingKey)
						end
					end)
				end
				hoverBindings[bindingKey] = binding
				hoverBindingCount += 1
				markHoverSyncDirty()
				ensureHoverSyncConnection()

				task.defer(function()
					if hoverBindings[bindingKey] then
						syncHoverBindingsFromPointer(nil, true)
					end
				end)

				return bindingKey
			end

			local hoverCurrentPageConnection = self.Elements.UIPageLayout:GetPropertyChangedSignal("CurrentPage"):Connect(function()
				markHoverSyncDirty()
				syncHoverBindingsFromPointer(nil, true)
				markVirtualHostDirty("current_page_changed")
				if elementSync and self.Elements.UIPageLayout.CurrentPage == TabPage then
					elementSync.resyncTab(tabSyncId, "tab_page_changed")
				end
			end)
			TabPage.Destroying:Connect(function()
				tabRecordsByPersistenceId[tabPersistenceId] = nil
				if hoverCurrentPageConnection then
					hoverCurrentPageConnection:Disconnect()
					hoverCurrentPageConnection = nil
				end
				for _, trackedElement in ipairs(TabElements) do
					local elementObject = trackedElement and trackedElement.Object
					if type(elementObject) == "table" then
						local cleanupScopeId = nil
						if type(elementObject.GetCleanupScope) == "function" then
							local okScope, scopeValue = pcall(elementObject.GetCleanupScope, elementObject)
							if okScope and type(scopeValue) == "string" and scopeValue ~= "" then
								cleanupScopeId = scopeValue
							end
						end
						if not cleanupScopeId and type(elementObject.__CleanupScope) == "string" and elementObject.__CleanupScope ~= "" then
							cleanupScopeId = elementObject.__CleanupScope
						end
						if cleanupScopeId then
							ownershipCleanupScope(cleanupScopeId, {
								destroyInstances = false,
								clearAttributes = true
							})
						end
					end
				end
				cleanupAllHoverBindings()
				unregisterVirtualHost()
				if elementSync and tabSyncTokens then
					for token in pairs(tabSyncTokens) do
						elementSync.unregister(token)
						tabSyncTokens[token] = nil
					end
				end
			end)
			TabPage.AncestryChanged:Connect(function()
				markVirtualHostDirty("tab_reparent")
			end)

			local function registerElementSync(spec)
				if not elementSync then
					return nil
				end
				spec = spec or {}
				spec.tabId = tabSyncId
				local token = elementSync.register(spec)
				if token then
					tabSyncTokens[token] = true
				end
				return token
			end

			local function unregisterElementSync(token)
				if not token or not elementSync then
					return
				end
				elementSync.unregister(token)
				tabSyncTokens[token] = nil
			end

			local function commitElementSync(token, nextState, options)
				if not token or not elementSync then
					return false, nil
				end
				return elementSync.commit(token, nextState, options)
			end

			local function getCollapsedSectionsMap()
				if type(self.getInternalSetting) ~= "function" then
					return {}
				end
				local map = self.getInternalSetting("Layout", "collapsedSections")
				if type(map) ~= "table" then
					return {}
				end
				return cloneSerializable(map)
			end

			local function setCollapsedSectionsMap(nextMap)
				if type(self.setInternalSetting) == "function" then
					self.setInternalSetting("Layout", "collapsedSections", cloneSerializable(nextMap or {}), true)
					return
				end
				if type(self.getSetting) == "function" and type(self.SaveConfiguration) == "function" then
					self.SaveConfiguration()
				end
			end

			local function persistCollapsedState(sectionKey, collapsed)
				if type(sectionKey) ~= "string" or sectionKey == "" then
					return
				end
				local map = getCollapsedSectionsMap()
				map[sectionKey] = collapsed == true
				setCollapsedSectionsMap(map)
			end

			local function resolveElementParent(elementType, elementObject)
				if not (elementObject and type(elementObject) == "table") then
					return TabPage
				end
				if elementType == "Section" or elementType == "CollapsibleSection" then
					return TabPage
				end

				local explicitSection = rawget(elementObject, "__ParentSection")
				if type(explicitSection) == "table" then
					local content = rawget(explicitSection, "__SectionContentFrame")
					if content and content.Parent then
						return content
					end
				end

				if currentImplicitSection then
					local implicitContent = currentImplicitSection.ContentFrame
					if implicitContent and implicitContent.Parent then
						return implicitContent
					end
				end

				return TabPage
			end
	
			-- Helper function to add extended API to all elements
			local function addExtendedAPI(elementObject, elementName, elementType, guiObject, hoverBindingKey, syncToken)
				local flagName = type(elementObject) == "table" and tostring(elementObject.Flag or "") or ""
				local baseFavoriteId = nil
				if flagName ~= "" then
					baseFavoriteId = "flag:" .. flagName
				else
					local layoutOrder = (guiObject and tonumber(guiObject.LayoutOrder)) or 0
					baseFavoriteId = string.format(
						"path:%s:%s:%s:%d",
						tostring(tabPersistenceId),
						tostring(elementType or "Element"),
						tostring(elementName or "Unnamed"),
						layoutOrder
					)
				end

				local favoriteId = baseFavoriteId
				while allControlsById[favoriteId] and allControlsById[favoriteId].GuiObject ~= guiObject do
					controlIdSalt += 1
					favoriteId = baseFavoriteId .. "#" .. tostring(controlIdSalt)
				end

				local controlRecord = {
					Id = favoriteId,
					Name = tostring(elementName or "Unnamed"),
					Type = tostring(elementType or "Element"),
					Flag = flagName ~= "" and flagName or nil,
					TabPersistenceId = tabPersistenceId,
					GuiObject = guiObject,
					ElementObject = elementObject,
					TabPage = TabPage,
					PinButton = nil,
					CleanupScope = nil
				}
				local resolvedParent = resolveElementParent(elementType, elementObject)
				if guiObject and resolvedParent and guiObject.Parent ~= resolvedParent then
					guiObject.Parent = resolvedParent
				end

				local cleanupScopeId = ownershipCreateScope("element:" .. tostring(favoriteId), {
					kind = "element",
					tabId = tabPersistenceId,
					favoriteId = favoriteId,
					elementType = tostring(elementType or "Element"),
					elementName = tostring(elementName or "Unnamed")
				})
				if cleanupScopeId and guiObject then
					ownershipClaimInstance(guiObject, cleanupScopeId, {
						favoriteId = favoriteId,
						tabId = tabPersistenceId,
						elementType = tostring(elementType or "Element")
					})
					controlRecord.CleanupScope = cleanupScopeId
				end

				allControlsById[favoriteId] = controlRecord
				table.insert(controlOrder, favoriteId)
				if controlRecord.Flag then
					controlsByFlag[controlRecord.Flag] = controlRecord
					controlsByFlag["flag:" .. controlRecord.Flag] = controlRecord
				end

				local virtualToken = registerVirtualElement(guiObject, elementName, elementType, syncToken)
				local detachable = self.makeElementDetachable and self.makeElementDetachable(guiObject, elementName, elementType) or nil
				if detachable and type(detachable.SetPersistenceMetadata) == "function" then
					local metadata = {
						flag = type(elementObject) == "table" and elementObject.Flag or nil,
						tabId = tabPersistenceId,
						virtualHostId = tabVirtualHostId,
						elementName = elementName,
						elementType = elementType
					}
					pcall(detachable.SetPersistenceMetadata, metadata)
				end
				local ancestrySyncConnection = nil
				local pinConnection = nil
				local tooltipHoverBindingKey = nil
				local tooltipTouchBeganConnection = nil
				local tooltipTouchEndedConnection = nil
				local tooltipTouchActive = false
				local tooltipTouchToken = 0
				if guiObject and guiObject.SetAttribute then
					guiObject:SetAttribute("RayfieldElementSyncToken", syncToken)
					guiObject:SetAttribute("RayfieldFavoriteId", favoriteId)
				end
				if syncToken and elementSync and guiObject and guiObject.AncestryChanged then
					ancestrySyncConnection = guiObject.AncestryChanged:Connect(function()
						task.defer(function()
							if guiObject and guiObject.Parent then
								elementSync.resync(syncToken, "element_reparent")
							end
						end)
					end)
				end

				local function applyTooltipBehavior(options)
					if tooltipHoverBindingKey then
						cleanupHoverBinding(tooltipHoverBindingKey)
						tooltipHoverBindingKey = nil
					end
					if tooltipTouchBeganConnection then
						tooltipTouchBeganConnection:Disconnect()
						tooltipTouchBeganConnection = nil
					end
					if tooltipTouchEndedConnection then
						tooltipTouchEndedConnection:Disconnect()
						tooltipTouchEndedConnection = nil
					end
					hideTooltip(favoriteId)

					if not (guiObject and guiObject:IsA("GuiObject")) then
						return
					end
					local tooltipText = tostring((options and options.Text) or "")
					if tooltipText == "" then
						return
					end
					local desktopDelay = clampNumber(options and options.DesktopDelay, 0.01, 5, 0.15)
					local mobileDelay = clampNumber(options and options.MobileDelay, 0.01, 5, 0.35)

					tooltipHoverBindingKey = registerHoverBinding(guiObject,
						function()
							task.delay(desktopDelay, function()
								local binding = hoverBindings[tooltipHoverBindingKey]
								if binding and binding.Hovered and guiObject and guiObject.Parent then
									showTooltip(favoriteId, guiObject, tooltipText)
								end
							end)
						end,
						function()
							hideTooltip(favoriteId)
						end,
						"tooltip:" .. favoriteId
					)

					tooltipTouchBeganConnection = guiObject.InputBegan:Connect(function(input)
						if input.UserInputType ~= Enum.UserInputType.Touch then
							return
						end
						tooltipTouchActive = true
						tooltipTouchToken += 1
						local token = tooltipTouchToken
						task.delay(mobileDelay, function()
							if tooltipTouchActive and tooltipTouchToken == token and guiObject and guiObject.Parent then
								showTooltip(favoriteId, guiObject, tooltipText)
							end
						end)
					end)
					tooltipTouchEndedConnection = guiObject.InputEnded:Connect(function(input)
						if input.UserInputType ~= Enum.UserInputType.Touch then
							return
						end
						tooltipTouchActive = false
						hideTooltip(favoriteId)
					end)
				end

				local canAttachPinButton = (guiObject and guiObject:IsA("GuiObject")) and (
					controlRecord.Type == "Button"
					or controlRecord.Type == "Toggle"
					or controlRecord.Type == "Slider"
					or controlRecord.Type == "Input"
					or controlRecord.Type == "Dropdown"
					or controlRecord.Type == "Keybind"
					or controlRecord.Type == "ColorPicker"
					or controlRecord.Type == "TrackBar"
					or controlRecord.Type == "StatusBar"
					or controlRecord.Type == "Bar"
					or controlRecord.Type == "NumberStepper"
					or controlRecord.Type == "ConfirmButton"
					or controlRecord.Type == "Gallery"
					or controlRecord.Type == "Image"
					or controlRecord.Type == "Chart"
					or controlRecord.Type == "LogConsole"
					or controlRecord.Type == "LoadingSpinner"
					or controlRecord.Type == "LoadingBar"
				)
				if canAttachPinButton then
					local pinButton = Instance.new("TextButton")
					pinButton.Name = "FavoritePin"
					pinButton.AnchorPoint = Vector2.new(1, 0)
					pinButton.Position = UDim2.new(1, -6, 0, 4)
					pinButton.Size = UDim2.new(0, 16, 0, 16)
					pinButton.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
					pinButton.BackgroundTransparency = 0.25
					pinButton.BorderSizePixel = 0
					pinButton.Text = ""
					pinButton.TextScaled = true
					pinButton.TextWrapped = true
					pinButton.TextColor3 = Color3.fromRGB(225, 225, 225)
					pinButton.Font = Enum.Font.GothamBold
					pinButton.ZIndex = (guiObject.ZIndex or 1) + 7
					pinButton.AutoButtonColor = true
					pinButton.Visible = pinBadgesVisible
					pinButton.Parent = guiObject

					local pinCorner = Instance.new("UICorner")
					pinCorner.CornerRadius = UDim.new(0, 5)
					pinCorner.Parent = pinButton

					controlRecord.PinButton = pinButton
					applyPinnedVisual(controlRecord)

					pinConnection = pinButton.MouseButton1Click:Connect(function()
						local currentlyPinned = pinnedControlIds[favoriteId] == true
						setControlPinnedState(controlRecord, not currentlyPinned)
					end)
				end

				local tooltipOptions = rawget(elementObject, "__TooltipOptions")
				if tooltipOptions == nil and type(elementObject) == "table" then
					local tooltipText = rawget(elementObject, "Tooltip")
					if tooltipText ~= nil then
						tooltipOptions = { Text = tostring(tooltipText) }
					end
				end
				if type(tooltipOptions) == "table" then
					applyTooltipBehavior(tooltipOptions)
				end
				emitControlRegistryChange("control_added")
	
				-- Destroy with tracking removal
				local originalDestroy = elementObject.Destroy
				elementObject.Destroy = function(self)
					if cleanupScopeId then
						ownershipCleanupScope(cleanupScopeId, {
							destroyInstances = false,
							clearAttributes = true
						})
						cleanupScopeId = nil
						self.__CleanupScope = nil
					end
					if hoverBindingKey then
						cleanupHoverBinding(hoverBindingKey)
					end
					if guiObject and guiObject.SetAttribute then
						guiObject:SetAttribute("RayfieldElementSyncToken", nil)
						guiObject:SetAttribute("RayfieldVirtualToken", nil)
						guiObject:SetAttribute("RayfieldFavoriteId", nil)
					end
					if viewportVirtualization and type(viewportVirtualization.unregisterElement) == "function" then
						if virtualToken then
							pcall(viewportVirtualization.unregisterElement, virtualToken)
						elseif guiObject then
							pcall(viewportVirtualization.unregisterElement, guiObject)
						end
					end
					virtualToken = nil
					unregisterElementSync(syncToken)
					if ancestrySyncConnection then
						ancestrySyncConnection:Disconnect()
						ancestrySyncConnection = nil
					end
					if pinConnection then
						pinConnection:Disconnect()
						pinConnection = nil
					end
					if tooltipTouchBeganConnection then
						tooltipTouchBeganConnection:Disconnect()
						tooltipTouchBeganConnection = nil
					end
					if tooltipTouchEndedConnection then
						tooltipTouchEndedConnection:Disconnect()
						tooltipTouchEndedConnection = nil
					end
					if tooltipHoverBindingKey then
						cleanupHoverBinding(tooltipHoverBindingKey)
						tooltipHoverBindingKey = nil
					end
					hideTooltip(favoriteId)
					if controlRecord.PinButton and controlRecord.PinButton.Parent then
						controlRecord.PinButton:Destroy()
					end
					if controlRecord.Flag then
						controlsByFlag[controlRecord.Flag] = nil
						controlsByFlag["flag:" .. controlRecord.Flag] = nil
					end
					allControlsById[favoriteId] = nil
					if detachable and detachable.Destroy then
						detachable.Destroy()
					end
					if originalDestroy then
						originalDestroy(self)
					end
					-- Remove from tracking
					for i, element in ipairs(TabElements) do
						if element.Object == elementObject then
							table.remove(TabElements, i)
							break
						end
					end
					emitControlRegistryChange("control_removed")
					markVirtualHostDirty("element_destroy")
				end
	
				-- Visibility methods
				function elementObject:Show()
					guiObject.Visible = true
					if syncToken and elementSync then
						elementSync.resync(syncToken, "element_show")
					end
					markVirtualHostDirty("element_show")
				end
	
				function elementObject:Hide()
					guiObject.Visible = false
					if syncToken and elementSync then
						elementSync.resync(syncToken, "element_hide")
					end
					markVirtualHostDirty("element_hide")
				end
	
				function elementObject:SetVisible(visible)
					guiObject.Visible = visible
					if syncToken and elementSync then
						elementSync.resync(syncToken, "element_set_visible")
					end
					markVirtualHostDirty("element_set_visible")
				end
	
				function elementObject:GetParent()
					return Tab
				end
	
				if detachable then
					function elementObject:Detach(position)
						local result = detachable.Detach(position)
						if syncToken and elementSync then
							elementSync.resync(syncToken, "element_detach")
						end
						markVirtualHostDirty("element_detach")
						return result
					end
	
					function elementObject:Dock()
						local result = detachable.Dock()
						if syncToken and elementSync then
							elementSync.resync(syncToken, "element_dock")
						end
						markVirtualHostDirty("element_dock")
						return result
					end
	
					function elementObject:GetRememberedState()
						return detachable.GetRememberedState()
					end
	
					function elementObject:IsDetached()
						return detachable.IsDetached()
					end
				end
	
				-- Add metadata
				elementObject.Name = elementName
				elementObject.Type = elementType
				elementObject.Flag = type(elementObject) == "table" and elementObject.Flag or nil
				elementObject.__ElementSyncToken = syncToken
				elementObject.__TabPersistenceId = tabPersistenceId
				elementObject.__TabLayoutOrder = tonumber(TabPage.LayoutOrder) or 0
				elementObject.__ElementLayoutOrder = (guiObject and tonumber(guiObject.LayoutOrder)) or 0
				elementObject.__GuiObject = guiObject
				elementObject.__TabPage = TabPage
				elementObject.__FavoriteId = favoriteId
				elementObject.__CleanupScope = cleanupScopeId

				function elementObject:GetFavoriteId()
					return favoriteId
				end

				function elementObject:GetCleanupScope()
					return cleanupScopeId
				end

				function elementObject:Pin()
					return pinControl(favoriteId)
				end

				function elementObject:Unpin()
					return unpinControl(favoriteId)
				end

				function elementObject:IsPinned()
					return pinnedControlIds[favoriteId] == true
				end

				function elementObject:SetTooltip(textOrOptions)
					local options
					if type(textOrOptions) == "table" then
						options = {
							Text = tostring(textOrOptions.Text or textOrOptions.text or ""),
							DesktopDelay = clampNumber(textOrOptions.DesktopDelay or textOrOptions.desktopDelay, 0.01, 5, 0.15),
							MobileDelay = clampNumber(textOrOptions.MobileDelay or textOrOptions.mobileDelay, 0.01, 5, 0.35)
						}
					else
						options = {
							Text = tostring(textOrOptions or ""),
							DesktopDelay = 0.15,
							MobileDelay = 0.35
						}
					end
					elementObject.__TooltipOptions = options
					applyTooltipBehavior(options)
					return true, "ok"
				end

				function elementObject:ClearTooltip()
					elementObject.__TooltipOptions = nil
					applyTooltipBehavior({Text = ""})
					hideTooltip(favoriteId)
					return true, "ok"
				end

				-- Add to tracking
				table.insert(TabElements, {
					Name = elementName,
					Type = elementType,
					Object = elementObject,
					GuiObject = guiObject,
					HoverBindingKey = hoverBindingKey,
					SyncToken = syncToken
				})
	
				return elementObject
			end
	
			-- Tab utility functions
			function Tab:GetElements()
				return TabElements
			end
	
			function Tab:FindElement(name)
				for _, element in ipairs(TabElements) do
					if element.Name == name then
						return element.Object
					end
				end
				return nil
			end
	
			function Tab:Clear()
				if elementSync then
					for token in pairs(tabSyncTokens) do
						elementSync.unregister(token)
						tabSyncTokens[token] = nil
					end
				end
				-- Snapshot elements and clear tracking first to avoid
				-- concurrent modification (custom Destroy also removes from TabElements)
				local snapshot = {}
				for i, element in ipairs(TabElements) do
					snapshot[i] = element
				end
				-- Clear tracking table before destroying to prevent index corruption
				for i = #TabElements, 1, -1 do
					TabElements[i] = nil
				end
				-- Now safely destroy each element
				for _, element in ipairs(snapshot) do
					if element.Object and element.Object.Destroy then
						element.Object:Destroy()
					end
				end
				cleanupAllHoverBindings()
				markVirtualHostDirty("tab_clear")
			end
	
			-- Button
			function Tab:CreateButton(ButtonSettings)
				local ButtonValue = {}
	
				local Button = self.Elements.Template.Button:Clone()
				Button.Name = ButtonSettings.Name
				Button.Title.Text = ButtonSettings.Name
				Button.Visible = true
				Button.Parent = TabPage
	
				Button.BackgroundTransparency = 1
				Button.UIStroke.Transparency = 1
				Button.Title.TextTransparency = 1
	
				self.Animation:Create(Button, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0}):Play()
				self.Animation:Create(Button.UIStroke, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {Transparency = 0}):Play()
				self.Animation:Create(Button.Title, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {TextTransparency = 0}):Play()
	
	
				Button.Interact.MouseButton1Click:Connect(function()
					local Success, Response = pcall(ButtonSettings.Callback)
					-- Prevents animation from trying to play if the button's callback called RayfieldLibrary:Destroy()
					if self.rayfieldDestroyed() then
						return
					end
					if not Success then
						self.Animation:Create(Button, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = Color3.fromRGB(85, 0, 0)}):Play()
						self.Animation:Create(Button.ElementIndicator, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
						self.Animation:Create(Button.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 1}):Play()
						Button.Title.Text = "Callback Error"
						print("Rayfield | "..ButtonSettings.Name.." Callback Error " ..tostring(Response))
						warn('Check docs.sirius.menu for help with Rayfield specific development.')
						task.wait(0.5)
						Button.Title.Text = ButtonSettings.Name
						self.Animation:Create(Button, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackground}):Play()
						self.Animation:Create(Button.ElementIndicator, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {TextTransparency = 0.9}):Play()
						self.Animation:Create(Button.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 0}):Play()
					else
						if not ButtonSettings.Ext then
							self.SaveConfiguration(ButtonSettings.Name..'\n')
						end
						self.Animation:Create(Button, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackgroundHover}):Play()
						self.Animation:Create(Button.ElementIndicator, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
						self.Animation:Create(Button.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 1}):Play()
						task.wait(0.2)
						self.Animation:Create(Button, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackground}):Play()
						self.Animation:Create(Button.ElementIndicator, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {TextTransparency = 0.9}):Play()
						self.Animation:Create(Button.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 0}):Play()
					end
				end)
	
				local buttonHoverBindingKey = registerHoverBinding(Button,
					function()
						self.Animation:Create(Button, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackgroundHover}):Play()
						self.Animation:Create(Button.ElementIndicator, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {TextTransparency = 0.7}):Play()
					end,
					function()
						self.Animation:Create(Button, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackground}):Play()
						self.Animation:Create(Button.ElementIndicator, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {TextTransparency = 0.9}):Play()
					end
				)
	
				function ButtonValue:Set(NewButton)
					Button.Title.Text = NewButton
					Button.Name = NewButton
				end
	
				function ButtonValue:Destroy()
					Button:Destroy()
				end
	
				-- Add extended API
				addExtendedAPI(ButtonValue, ButtonSettings.Name, "Button", Button, buttonHoverBindingKey)
	
				return ButtonValue
			end
	
			-- ColorPicker
			function Tab:CreateColorPicker(ColorPickerSettings) -- by Throit
				ColorPickerSettings.Type = "ColorPicker"
				local ColorPicker = self.Elements.Template.ColorPicker:Clone()
				local Background = ColorPicker.CPBackground
				local Display = Background.Display
				local Main = Background.MainCP
				local Slider = ColorPicker.ColorSlider
				ColorPicker.ClipsDescendants = true
				ColorPicker.Name = ColorPickerSettings.Name
				ColorPicker.Title.Text = ColorPickerSettings.Name
				ColorPicker.Visible = true
				ColorPicker.Parent = TabPage
				ColorPicker.Size = UDim2.new(1, -10, 0, 45)
				Background.Size = UDim2.new(0, 39, 0, 22)
				Display.BackgroundTransparency = 0
				self.Main.MainPoint.ImageTransparency = 1
				ColorPicker.Interact.Size = UDim2.new(1, 0, 1, 0)
				ColorPicker.Interact.Position = UDim2.new(0.5, 0, 0.5, 0)
				ColorPicker.RGB.Position = UDim2.new(0, 17, 0, 70)
				ColorPicker.HexInput.Position = UDim2.new(0, 17, 0, 90)
				self.Main.ImageTransparency = 1
				Background.BackgroundTransparency = 1
	
				for _, rgbinput in ipairs(ColorPicker.RGB:GetChildren()) do
					if rgbinput:IsA("Frame") then
						rgbinput.BackgroundColor3 = self.getSelectedTheme().InputBackground
						rgbinput.UIStroke.Color = self.getSelectedTheme().InputStroke
					end
				end
	
				ColorPicker.HexInput.BackgroundColor3 = self.getSelectedTheme().InputBackground
				ColorPicker.HexInput.UIStroke.Color = self.getSelectedTheme().InputStroke
	
				local opened = false 
				local mouse = Players.LocalPlayer:GetMouse()
				self.Main.Image = "http://www.roblox.com/asset/?id=11415645739"
				local mainDragging = false 
				local sliderDragging = false 
				ColorPicker.Interact.MouseButton1Down:Connect(function()
					task.spawn(function()
						self.Animation:Create(ColorPicker, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackgroundHover}):Play()
						self.Animation:Create(ColorPicker.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 1}):Play()
						task.wait(0.2)
						self.Animation:Create(ColorPicker, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackground}):Play()
						self.Animation:Create(ColorPicker.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 0}):Play()
					end)
	
					if not opened then
						opened = true 
						self.Animation:Create(Background, TweenInfo.new(0.45, Enum.EasingStyle.Exponential), {Size = UDim2.new(0, 18, 0, 15)}):Play()
						task.wait(0.1)
						self.Animation:Create(ColorPicker, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Size = UDim2.new(1, -10, 0, 120)}):Play()
						self.Animation:Create(Background, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Size = UDim2.new(0, 173, 0, 86)}):Play()
						self.Animation:Create(Display, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundTransparency = 1}):Play()
						self.Animation:Create(ColorPicker.Interact, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Position = UDim2.new(0.289, 0, 0.5, 0)}):Play()
						self.Animation:Create(ColorPicker.RGB, TweenInfo.new(0.8, Enum.EasingStyle.Exponential), {Position = UDim2.new(0, 17, 0, 40)}):Play()
						self.Animation:Create(ColorPicker.HexInput, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {Position = UDim2.new(0, 17, 0, 73)}):Play()
						self.Animation:Create(ColorPicker.Interact, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Size = UDim2.new(0.574, 0, 1, 0)}):Play()
						self.Animation:Create(self.Main.MainPoint, TweenInfo.new(0.2, Enum.EasingStyle.Exponential), {ImageTransparency = 0}):Play()
						self.Animation:Create(Main, TweenInfo.new(0.2, Enum.EasingStyle.Exponential), {ImageTransparency = self.getSelectedTheme() ~= self.RayfieldLibrary.Theme.Default and 0.25 or 0.1}):Play()
						self.Animation:Create(Background, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0}):Play()
					else
						opened = false
						self.Animation:Create(ColorPicker, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Size = UDim2.new(1, -10, 0, 45)}):Play()
						self.Animation:Create(Background, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Size = UDim2.new(0, 39, 0, 22)}):Play()
						self.Animation:Create(ColorPicker.Interact, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Size = UDim2.new(1, 0, 1, 0)}):Play()
						self.Animation:Create(ColorPicker.Interact, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Position = UDim2.new(0.5, 0, 0.5, 0)}):Play()
						self.Animation:Create(ColorPicker.RGB, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Position = UDim2.new(0, 17, 0, 70)}):Play()
						self.Animation:Create(ColorPicker.HexInput, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {Position = UDim2.new(0, 17, 0, 90)}):Play()
						self.Animation:Create(Display, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0}):Play()
						self.Animation:Create(self.Main.MainPoint, TweenInfo.new(0.2, Enum.EasingStyle.Exponential), {ImageTransparency = 1}):Play()
						self.Animation:Create(Main, TweenInfo.new(0.2, Enum.EasingStyle.Exponential), {ImageTransparency = 1}):Play()
						self.Animation:Create(Background, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundTransparency = 1}):Play()
					end
	
				end)
	
				self.UserInputService.InputEnded:Connect(function(input, gameProcessed) if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
						local wasDragging = mainDragging or sliderDragging
						mainDragging = false
						sliderDragging = false
						if wasDragging and not ColorPickerSettings.Ext then
							self.SaveConfiguration()
						end
					end end)
				self.Main.MouseButton1Down:Connect(function()
					if opened then
						mainDragging = true 
					end
				end)
				self.Main.MainPoint.MouseButton1Down:Connect(function()
					if opened then
						mainDragging = true 
					end
				end)
				Slider.MouseButton1Down:Connect(function()
					sliderDragging = true 
				end)
				Slider.SliderPoint.MouseButton1Down:Connect(function()
					sliderDragging = true 
				end)
				local h,s,v = ColorPickerSettings.Color:ToHSV()
				local color = Color3.fromHSV(h,s,v) 
				local hex = string.format("#%02X%02X%02X",color.R*0xFF,color.G*0xFF,color.B*0xFF)
				ColorPicker.HexInput.InputBox.Text = hex
				local function setDisplay()
					--Main
					self.Main.MainPoint.Position = UDim2.new(s,-self.Main.MainPoint.AbsoluteSize.X/2,1-v,-self.Main.MainPoint.AbsoluteSize.Y/2)
					self.Main.MainPoint.ImageColor3 = Color3.fromHSV(h,s,v)
					Background.BackgroundColor3 = Color3.fromHSV(h,1,1)
					Display.BackgroundColor3 = Color3.fromHSV(h,s,v)
					--Slider 
					local x = h * Slider.AbsoluteSize.X
					Slider.SliderPoint.Position = UDim2.new(0,x-Slider.SliderPoint.AbsoluteSize.X/2,0.5,0)
					Slider.SliderPoint.ImageColor3 = Color3.fromHSV(h,1,1)
					local color = Color3.fromHSV(h,s,v) 
					local r,g,b = math.floor((color.R*255)+0.5),math.floor((color.G*255)+0.5),math.floor((color.B*255)+0.5)
					ColorPicker.RGB.RInput.InputBox.Text = tostring(r)
					ColorPicker.RGB.GInput.InputBox.Text = tostring(g)
					ColorPicker.RGB.BInput.InputBox.Text = tostring(b)
					hex = string.format("#%02X%02X%02X",color.R*0xFF,color.G*0xFF,color.B*0xFF)
					ColorPicker.HexInput.InputBox.Text = hex
				end
				setDisplay()
				ColorPicker.HexInput.InputBox.FocusLost:Connect(function()
					if not pcall(function()
							local r, g, b = string.match(ColorPicker.HexInput.InputBox.Text, "^#?(%w%w)(%w%w)(%w%w)$")
							local rgbColor = Color3.fromRGB(tonumber(r, 16),tonumber(g, 16), tonumber(b, 16))
							h,s,v = rgbColor:ToHSV()
							hex = ColorPicker.HexInput.InputBox.Text
							setDisplay()
							ColorPickerSettings.Color = rgbColor
						end) 
					then 
						ColorPicker.HexInput.InputBox.Text = hex 
					end
					pcall(function()ColorPickerSettings.Callback(Color3.fromHSV(h,s,v))end)
					local r,g,b = math.floor((h*255)+0.5),math.floor((s*255)+0.5),math.floor((v*255)+0.5)
					ColorPickerSettings.Color = Color3.fromRGB(r,g,b)
					if not ColorPickerSettings.Ext then
						self.SaveConfiguration()
					end
				end)
				--RGB
				local function rgbBoxes(box,toChange)
					local value = tonumber(box.Text) 
					local color = Color3.fromHSV(h,s,v) 
					local oldR,oldG,oldB = math.floor((color.R*255)+0.5),math.floor((color.G*255)+0.5),math.floor((color.B*255)+0.5)
					local save 
					if toChange == "R" then save = oldR;oldR = value elseif toChange == "G" then save = oldG;oldG = value else save = oldB;oldB = value end
					if value then 
						value = math.clamp(value,0,255)
						h,s,v = Color3.fromRGB(oldR,oldG,oldB):ToHSV()
	
						setDisplay()
					else 
						box.Text = tostring(save)
					end
					local r,g,b = math.floor((h*255)+0.5),math.floor((s*255)+0.5),math.floor((v*255)+0.5)
					ColorPickerSettings.Color = Color3.fromRGB(r,g,b)
					if not ColorPickerSettings.Ext then
						self.SaveConfiguration(ColorPickerSettings.Flag..'\n'..tostring(ColorPickerSettings.Color))
					end
				end
				ColorPicker.RGB.RInput.InputBox.FocusLost:connect(function()
					rgbBoxes(ColorPicker.RGB.RInput.InputBox,"R")
					pcall(function()ColorPickerSettings.Callback(Color3.fromHSV(h,s,v))end)
				end)
				ColorPicker.RGB.GInput.InputBox.FocusLost:connect(function()
					rgbBoxes(ColorPicker.RGB.GInput.InputBox,"G")
					pcall(function()ColorPickerSettings.Callback(Color3.fromHSV(h,s,v))end)
				end)
				ColorPicker.RGB.BInput.InputBox.FocusLost:connect(function()
					rgbBoxes(ColorPicker.RGB.BInput.InputBox,"B")
					pcall(function()ColorPickerSettings.Callback(Color3.fromHSV(h,s,v))end)
				end)
	
				local prevH, prevS, prevV = h, s, v
				self.RunService.RenderStepped:connect(function()
					if mainDragging then
						local localX = math.clamp(mouse.X-self.Main.AbsolutePosition.X,0,self.Main.AbsoluteSize.X)
						local localY = math.clamp(mouse.Y-self.Main.AbsolutePosition.Y,0,self.Main.AbsoluteSize.Y)
						self.Main.MainPoint.Position = UDim2.new(0,localX-self.Main.MainPoint.AbsoluteSize.X/2,0,localY-self.Main.MainPoint.AbsoluteSize.Y/2)
						s = localX / self.Main.AbsoluteSize.X
						v = 1 - (localY / self.Main.AbsoluteSize.Y)
						local color = Color3.fromHSV(h,s,v)
						Display.BackgroundColor3 = color
						self.Main.MainPoint.ImageColor3 = color
						Background.BackgroundColor3 = Color3.fromHSV(h,1,1)
						local r,g,b = math.floor((color.R*255)+0.5),math.floor((color.G*255)+0.5),math.floor((color.B*255)+0.5)
						ColorPicker.RGB.RInput.InputBox.Text = tostring(r)
						ColorPicker.RGB.GInput.InputBox.Text = tostring(g)
						ColorPicker.RGB.BInput.InputBox.Text = tostring(b)
						ColorPicker.HexInput.InputBox.Text = string.format("#%02X%02X%02X",color.R*0xFF,color.G*0xFF,color.B*0xFF)
						ColorPickerSettings.Color = Color3.fromRGB(r,g,b)
						if h ~= prevH or s ~= prevS or v ~= prevV then
							prevH, prevS, prevV = h, s, v
							pcall(ColorPickerSettings.Callback, color)
						end
					end
					if sliderDragging then
						local localX = math.clamp(mouse.X-Slider.AbsolutePosition.X,0,Slider.AbsoluteSize.X)
						h = localX / Slider.AbsoluteSize.X
						local color = Color3.fromHSV(h,s,v)
						local hueColor = Color3.fromHSV(h,1,1)
						Display.BackgroundColor3 = color
						Slider.SliderPoint.Position = UDim2.new(0,localX-Slider.SliderPoint.AbsoluteSize.X/2,0.5,0)
						Slider.SliderPoint.ImageColor3 = hueColor
						Background.BackgroundColor3 = hueColor
						self.Main.MainPoint.ImageColor3 = color
						local r,g,b = math.floor((color.R*255)+0.5),math.floor((color.G*255)+0.5),math.floor((color.B*255)+0.5)
						ColorPicker.RGB.RInput.InputBox.Text = tostring(r)
						ColorPicker.RGB.GInput.InputBox.Text = tostring(g)
						ColorPicker.RGB.BInput.InputBox.Text = tostring(b)
						ColorPicker.HexInput.InputBox.Text = string.format("#%02X%02X%02X",color.R*0xFF,color.G*0xFF,color.B*0xFF)
						ColorPickerSettings.Color = Color3.fromRGB(r,g,b)
						if h ~= prevH or s ~= prevS or v ~= prevV then
							prevH, prevS, prevV = h, s, v
							pcall(ColorPickerSettings.Callback, color)
						end
					end
				end)
	
				if Settings.ConfigurationSaving then
					if Settings.ConfigurationSaving.Enabled and ColorPickerSettings.Flag then
						self.RayfieldLibrary.Flags[ColorPickerSettings.Flag] = ColorPickerSettings
					end
				end
	
				function ColorPickerSettings:Set(RGBColor)
					ColorPickerSettings.Color = RGBColor
					h,s,v = ColorPickerSettings.Color:ToHSV()
					color = Color3.fromHSV(h,s,v)
					setDisplay()
				end
	
				local colorPickerHoverBindingKey = registerHoverBinding(ColorPicker,
					function()
						self.Animation:Create(ColorPicker, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackgroundHover}):Play()
					end,
					function()
						self.Animation:Create(ColorPicker, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackground}):Play()
					end
				)
	
				self.Rayfield.Main:GetPropertyChangedSignal('BackgroundColor3'):Connect(function()
					for _, rgbinput in ipairs(ColorPicker.RGB:GetChildren()) do
						if rgbinput:IsA("Frame") then
							rgbinput.BackgroundColor3 = self.getSelectedTheme().InputBackground
							rgbinput.UIStroke.Color = self.getSelectedTheme().InputStroke
						end
					end
	
					ColorPicker.HexInput.BackgroundColor3 = self.getSelectedTheme().InputBackground
					ColorPicker.HexInput.UIStroke.Color = self.getSelectedTheme().InputStroke
				end)
	
				function ColorPickerSettings:Destroy()
					ColorPicker:Destroy()
				end
	
				-- Add extended API
				addExtendedAPI(ColorPickerSettings, ColorPickerSettings.Name, "ColorPicker", ColorPicker, colorPickerHoverBindingKey)
	
				return ColorPickerSettings
			end
	
			-- Section
			function Tab:CreateSection(SectionName)
				currentImplicitSection = nil

				local SectionValue = {}
	
				if SDone then
					local SectionSpace = self.Elements.Template.SectionSpacing:Clone()
					SectionSpace.Visible = true
					SectionSpace.Parent = TabPage
				end
	
				local Section = self.Elements.Template.SectionTitle:Clone()
				Section.Title.Text = SectionName
				Section.Visible = true
				Section.Parent = TabPage
	
				Section.Title.TextTransparency = 1
				self.Animation:Create(Section.Title, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {TextTransparency = 0.4}):Play()
	
				function SectionValue:Set(NewSection)
					Section.Title.Text = NewSection
				end
	
				function SectionValue:Destroy()
					Section:Destroy()
				end
	
				-- Add extended API
				addExtendedAPI(SectionValue, SectionName, "Section", Section)
	
				SDone = true

				return SectionValue
			end

			function Tab:CreateCollapsibleSection(sectionSettings)
				local settingsValue = sectionSettings
				if type(settingsValue) == "string" then
					settingsValue = { Name = settingsValue }
				end
				settingsValue = settingsValue or {}
				local sectionName = tostring(settingsValue.Name or settingsValue.Title or "Section")
				local sectionId = tostring(settingsValue.Id or sectionName)
				local sectionKey = tostring(tabPersistenceId) .. "::" .. sectionId
				local persistState = settingsValue.PersistState ~= false
				local implicitScope = settingsValue.ImplicitScope ~= false

				local collapsedMap = getCollapsedSectionsMap()
				local initialCollapsed = settingsValue.Collapsed == true
				if persistState and type(collapsedMap[sectionKey]) == "boolean" then
					initialCollapsed = collapsedMap[sectionKey]
				end

				local root = Instance.new("Frame")
				root.Name = "CollapsibleSection"
				root.Size = UDim2.new(1, -10, 0, 28)
				root.AutomaticSize = Enum.AutomaticSize.Y
				root.BackgroundTransparency = 1
				root.BorderSizePixel = 0
				root.Visible = true
				root.Parent = TabPage

				local rootList = Instance.new("UIListLayout")
				rootList.SortOrder = Enum.SortOrder.LayoutOrder
				rootList.Padding = UDim.new(0, 6)
				rootList.Parent = root

				local header = Instance.new("Frame")
				header.Name = "Header"
				header.Size = UDim2.new(1, 0, 0, 26)
				header.BackgroundColor3 = self.getSelectedTheme().SecondaryElementBackground
				header.BorderSizePixel = 0
				header.Parent = root

				local headerCorner = Instance.new("UICorner")
				headerCorner.CornerRadius = UDim.new(0, 6)
				headerCorner.Parent = header

				local headerStroke = Instance.new("UIStroke")
				headerStroke.Color = self.getSelectedTheme().SecondaryElementStroke
				headerStroke.Parent = header

				local titleLabel = Instance.new("TextLabel")
				titleLabel.BackgroundTransparency = 1
				titleLabel.Position = UDim2.new(0, 10, 0, 0)
				titleLabel.Size = UDim2.new(1, -38, 1, 0)
				titleLabel.Font = Enum.Font.GothamSemibold
				titleLabel.TextSize = 13
				titleLabel.TextXAlignment = Enum.TextXAlignment.Left
				titleLabel.TextColor3 = self.getSelectedTheme().TextColor
				titleLabel.Text = sectionName
				titleLabel.Parent = header

				local chevron = Instance.new("TextLabel")
				chevron.BackgroundTransparency = 1
				chevron.AnchorPoint = Vector2.new(1, 0.5)
				chevron.Position = UDim2.new(1, -10, 0.5, 0)
				chevron.Size = UDim2.new(0, 16, 0, 16)
				chevron.Font = Enum.Font.GothamBold
				chevron.TextSize = 15
				chevron.TextColor3 = self.getSelectedTheme().SectionChevron or self.getSelectedTheme().TextColor
				chevron.Text = "v"
				chevron.Parent = header

				local interact = Instance.new("TextButton")
				interact.BackgroundTransparency = 1
				interact.Size = UDim2.new(1, 0, 1, 0)
				interact.Text = ""
				interact.Parent = header

				local content = Instance.new("Frame")
				content.Name = "Content"
				content.BackgroundTransparency = 1
				content.BorderSizePixel = 0
				content.Size = UDim2.new(1, 0, 0, 0)
				content.AutomaticSize = Enum.AutomaticSize.Y
				content.Parent = root

				local contentLayout = Instance.new("UIListLayout")
				contentLayout.SortOrder = Enum.SortOrder.LayoutOrder
				contentLayout.Padding = UDim.new(0, 6)
				contentLayout.Parent = content

				local sectionRecord = {
					Key = sectionKey,
					Root = root,
					Header = header,
					ContentFrame = content,
					Collapsed = false,
					ImplicitScope = implicitScope
				}

				local sectionValue = {
					__SectionContentFrame = content,
					__SectionRecord = sectionRecord
				}

				local function applyCollapsedState(nextCollapsed, persist)
					sectionRecord.Collapsed = nextCollapsed == true
					content.Visible = not sectionRecord.Collapsed
					chevron.Text = sectionRecord.Collapsed and ">" or "v"
					if persist ~= false and persistState then
						persistCollapsedState(sectionKey, sectionRecord.Collapsed)
					end
				end

				function sectionValue:Set(newName)
					sectionName = tostring(newName or sectionName)
					titleLabel.Text = sectionName
				end

				function sectionValue:Collapse()
					applyCollapsedState(true, true)
				end

				function sectionValue:Expand()
					applyCollapsedState(false, true)
				end

				function sectionValue:Toggle()
					applyCollapsedState(not sectionRecord.Collapsed, true)
				end

				function sectionValue:IsCollapsed()
					return sectionRecord.Collapsed == true
				end

				function sectionValue:Destroy()
					if currentImplicitSection == sectionRecord then
						currentImplicitSection = nil
					end
					local snapshot = {}
					for _, tracked in ipairs(TabElements) do
						snapshot[#snapshot + 1] = tracked
					end
					for _, tracked in ipairs(snapshot) do
						if tracked.GuiObject and tracked.GuiObject:IsDescendantOf(content) and tracked.Object and type(tracked.Object.Destroy) == "function" then
							tracked.Object:Destroy()
						end
					end
					root:Destroy()
				end

				interact.MouseButton1Click:Connect(function()
					sectionValue:Toggle()
				end)

				self.Rayfield.Main:GetPropertyChangedSignal("BackgroundColor3"):Connect(function()
					if not root.Parent then
						return
					end
					header.BackgroundColor3 = self.getSelectedTheme().SecondaryElementBackground
					headerStroke.Color = self.getSelectedTheme().SecondaryElementStroke
					titleLabel.TextColor3 = self.getSelectedTheme().TextColor
					chevron.TextColor3 = self.getSelectedTheme().SectionChevron or self.getSelectedTheme().TextColor
				end)

				applyCollapsedState(initialCollapsed, false)
				currentImplicitSection = implicitScope and sectionRecord or nil
				table.insert(TabSections, sectionRecord)
				addExtendedAPI(sectionValue, sectionName, "CollapsibleSection", root)
				return sectionValue
			end

			local function resolveElementParentFromSettings(elementObject, sourceSettings)
				if type(sourceSettings) == "table" and type(sourceSettings.ParentSection) == "table" then
					elementObject.__ParentSection = sourceSettings.ParentSection
				end
				if type(sourceSettings) == "table" and sourceSettings.Tooltip ~= nil then
					elementObject.__TooltipOptions = {
						Text = tostring(sourceSettings.Tooltip),
						DesktopDelay = clampNumber(sourceSettings.TooltipDesktopDelay, 0.01, 5, 0.15),
						MobileDelay = clampNumber(sourceSettings.TooltipMobileDelay, 0.01, 5, 0.35)
					}
				end
			end

			local function connectThemeRefresh(handler)
				if type(handler) ~= "function" then
					return
				end
				self.Rayfield.Main:GetPropertyChangedSignal("BackgroundColor3"):Connect(function()
					pcall(handler)
				end)
			end

			local function startRenderLoop(loopState, stepFn)
				if type(loopState) ~= "table" or type(stepFn) ~= "function" then
					return false, "Invalid render loop setup."
				end
				if loopState.Connection then
					return true, "already_running"
				end
				loopState.Connection = self.RunService.RenderStepped:Connect(function(deltaTime)
					pcall(stepFn, deltaTime)
				end)
				return true, "ok"
			end

			local function stopRenderLoop(loopState)
				if type(loopState) ~= "table" then
					return false, "Invalid render loop state."
				end
				if loopState.Connection then
					loopState.Connection:Disconnect()
					loopState.Connection = nil
					return true, "ok"
				end
				return true, "already_stopped"
			end

			function Tab:CreateNumberStepper(stepperSettings)
				local settingsValue = stepperSettings or {}
				local stepper = {}
				stepper.Name = tostring(settingsValue.Name or "Number Stepper")
				stepper.Flag = settingsValue.Flag
				stepper.CurrentValue = clampNumber(settingsValue.CurrentValue, settingsValue.Min, settingsValue.Max, 0)

				local minValue = tonumber(settingsValue.Min)
				local maxValue = tonumber(settingsValue.Max)
				local stepValue = math.max(0.0001, tonumber(settingsValue.Step) or 1)
				local precision = math.max(0, math.floor(tonumber(settingsValue.Precision) or 2))
				local callback = type(settingsValue.Callback) == "function" and settingsValue.Callback or function() end

				local root = Instance.new("Frame")
				root.Name = stepper.Name
				root.Size = UDim2.new(1, -10, 0, 45)
				root.BackgroundColor3 = self.getSelectedTheme().ElementBackground
				root.BorderSizePixel = 0
				root.Visible = true
				root.Parent = TabPage

				local corner = Instance.new("UICorner")
				corner.CornerRadius = UDim.new(0, 6)
				corner.Parent = root

				local stroke = Instance.new("UIStroke")
				stroke.Color = self.getSelectedTheme().ElementStroke
				stroke.Parent = root

				local title = Instance.new("TextLabel")
				title.BackgroundTransparency = 1
				title.Position = UDim2.new(0, 10, 0, 0)
				title.Size = UDim2.new(0.45, -8, 1, 0)
				title.TextXAlignment = Enum.TextXAlignment.Left
				title.Font = Enum.Font.GothamMedium
				title.TextSize = 13
				title.Text = stepper.Name
				title.TextColor3 = self.getSelectedTheme().TextColor
				title.Parent = root

				local minus = Instance.new("TextButton")
				minus.Name = "Minus"
				minus.AnchorPoint = Vector2.new(1, 0.5)
				minus.Position = UDim2.new(1, -78, 0.5, 0)
				minus.Size = UDim2.new(0, 22, 0, 22)
				minus.Text = "-"
				minus.Font = Enum.Font.GothamBold
				minus.TextSize = 16
				minus.TextColor3 = self.getSelectedTheme().TextColor
				minus.BackgroundColor3 = self.getSelectedTheme().InputBackground
				minus.BorderSizePixel = 0
				minus.Parent = root

				local valueBox = Instance.new("TextBox")
				valueBox.Name = "Value"
				valueBox.AnchorPoint = Vector2.new(1, 0.5)
				valueBox.Position = UDim2.new(1, -50, 0.5, 0)
				valueBox.Size = UDim2.new(0, 56, 0, 22)
				valueBox.ClearTextOnFocus = false
				valueBox.Font = Enum.Font.Gotham
				valueBox.TextSize = 13
				valueBox.TextColor3 = self.getSelectedTheme().TextColor
				valueBox.PlaceholderText = "0"
				valueBox.BackgroundColor3 = self.getSelectedTheme().InputBackground
				valueBox.BorderSizePixel = 0
				valueBox.Parent = root

				local plus = Instance.new("TextButton")
				plus.Name = "Plus"
				plus.AnchorPoint = Vector2.new(1, 0.5)
				plus.Position = UDim2.new(1, -22, 0.5, 0)
				plus.Size = UDim2.new(0, 22, 0, 22)
				plus.Text = "+"
				plus.Font = Enum.Font.GothamBold
				plus.TextSize = 16
				plus.TextColor3 = self.getSelectedTheme().TextColor
				plus.BackgroundColor3 = self.getSelectedTheme().InputBackground
				plus.BorderSizePixel = 0
				plus.Parent = root

				local function formatValue(numberValue)
					local template = "%." .. tostring(precision) .. "f"
					return string.format(template, numberValue)
				end

				local function commitValue(nextValue, options)
					options = options or {}
					local normalized = roundToPrecision(clampNumber(nextValue, minValue, maxValue, stepper.CurrentValue), precision)
					if normalized == stepper.CurrentValue and options.force ~= true then
						valueBox.Text = formatValue(stepper.CurrentValue)
						return
					end
					stepper.CurrentValue = normalized
					valueBox.Text = formatValue(normalized)
					local okCallback, callbackErr = pcall(callback, normalized)
					if not okCallback then
						warn("Rayfield | NumberStepper callback failed: " .. tostring(callbackErr))
					end
					if settingsValue.Ext ~= true and options.persist ~= false then
						self.SaveConfiguration()
					end
				end

				minus.MouseButton1Click:Connect(function()
					commitValue(stepper.CurrentValue - stepValue, {persist = true})
				end)
				plus.MouseButton1Click:Connect(function()
					commitValue(stepper.CurrentValue + stepValue, {persist = true})
				end)
				valueBox.FocusLost:Connect(function()
					commitValue(valueBox.Text, {persist = true, force = true})
				end)

				function stepper:Set(nextValue)
					commitValue(nextValue, {persist = true, force = true})
				end

				function stepper:Get()
					return stepper.CurrentValue
				end

				function stepper:Increment()
					commitValue(stepper.CurrentValue + stepValue, {persist = true})
				end

				function stepper:Decrement()
					commitValue(stepper.CurrentValue - stepValue, {persist = true})
				end

				function stepper:Destroy()
					root:Destroy()
				end

				connectThemeRefresh(function()
					root.BackgroundColor3 = self.getSelectedTheme().ElementBackground
					stroke.Color = self.getSelectedTheme().ElementStroke
					title.TextColor3 = self.getSelectedTheme().TextColor
					minus.TextColor3 = self.getSelectedTheme().TextColor
					minus.BackgroundColor3 = self.getSelectedTheme().InputBackground
					plus.TextColor3 = self.getSelectedTheme().TextColor
					plus.BackgroundColor3 = self.getSelectedTheme().InputBackground
					valueBox.TextColor3 = self.getSelectedTheme().TextColor
					valueBox.BackgroundColor3 = self.getSelectedTheme().InputBackground
				end)

				resolveElementParentFromSettings(stepper, settingsValue)
				commitValue(stepper.CurrentValue, {persist = false, force = true})
				addExtendedAPI(stepper, stepper.Name, "NumberStepper", root)

				if Settings.ConfigurationSaving and Settings.ConfigurationSaving.Enabled and stepper.Flag then
					self.RayfieldLibrary.Flags[stepper.Flag] = stepper
				end

				return stepper
			end

			function Tab:CreateConfirmButton(confirmSettings)
				local settingsValue = confirmSettings or {}
				local element = {}
				element.Name = tostring(settingsValue.Name or "Confirm Button")
				element.Flag = settingsValue.Flag
				element.Ext = settingsValue.Ext

				local callback = type(settingsValue.Callback) == "function" and settingsValue.Callback or function() end
				local mode = tostring(settingsValue.ConfirmMode or "hold"):lower()
				local holdDuration = clampNumber(settingsValue.HoldDuration, 0.05, 6, 1.2)
				local doubleWindow = clampNumber(settingsValue.DoubleWindow, 0.05, 4, 0.4)
				local timeout = clampNumber(settingsValue.Timeout, 0.2, 12, 2)
				local armed = false
				local armedToken = 0
				local lastClickTime = 0
				local holdActive = false
				local holdToken = 0

				local root = Instance.new("Frame")
				root.Name = element.Name
				root.Size = UDim2.new(1, -10, 0, 45)
				root.BackgroundColor3 = self.getSelectedTheme().ElementBackground
				root.BorderSizePixel = 0
				root.Visible = true
				root.Parent = TabPage

				local corner = Instance.new("UICorner")
				corner.CornerRadius = UDim.new(0, 6)
				corner.Parent = root

				local stroke = Instance.new("UIStroke")
				stroke.Color = self.getSelectedTheme().ElementStroke
				stroke.Parent = root

				local button = Instance.new("TextButton")
				button.Name = "Interact"
				button.Size = UDim2.new(1, 0, 1, 0)
				button.BackgroundTransparency = 1
				button.Text = element.Name
				button.Font = Enum.Font.GothamSemibold
				button.TextSize = 13
				button.TextColor3 = self.getSelectedTheme().TextColor
				button.Parent = root

				local function setArmedVisual(value)
					armed = value == true
					if armed then
						root.BackgroundColor3 = self.getSelectedTheme().ConfirmArmed or self.getSelectedTheme().ElementBackgroundHover
					else
						root.BackgroundColor3 = self.getSelectedTheme().ElementBackground
					end
				end

				local function fireConfirmed()
					setArmedVisual(false)
					local okCallback, callbackErr = pcall(callback)
					if not okCallback then
						warn("Rayfield | ConfirmButton callback failed: " .. tostring(callbackErr))
					end
					if settingsValue.Ext ~= true then
						self.SaveConfiguration()
					end
				end

				local function armWithTimeout()
					armedToken += 1
					local localToken = armedToken
					setArmedVisual(true)
					task.delay(timeout, function()
						if armed and armedToken == localToken then
							setArmedVisual(false)
						end
					end)
				end

				local function isModeEnabled(modeName)
					return mode == modeName or mode == "either"
				end

				button.MouseButton1Click:Connect(function()
					local now = os.clock()
					if isModeEnabled("double") then
						if armed and (now - lastClickTime) <= doubleWindow then
							fireConfirmed()
							lastClickTime = 0
							return
						end
						lastClickTime = now
						armWithTimeout()
						return
					end
					if not isModeEnabled("hold") then
						fireConfirmed()
					end
				end)

				button.InputBegan:Connect(function(input)
					if not isModeEnabled("hold") then
						return
					end
					if input.UserInputType ~= Enum.UserInputType.MouseButton1 and input.UserInputType ~= Enum.UserInputType.Touch then
						return
					end
					holdActive = true
					holdToken += 1
					local localToken = holdToken
					setArmedVisual(true)
					task.delay(holdDuration, function()
						if holdActive and holdToken == localToken then
							fireConfirmed()
						end
					end)
				end)

				button.InputEnded:Connect(function(input)
					if not isModeEnabled("hold") then
						return
					end
					if input.UserInputType ~= Enum.UserInputType.MouseButton1 and input.UserInputType ~= Enum.UserInputType.Touch then
						return
					end
					holdActive = false
					if armed then
						setArmedVisual(false)
					end
				end)

				function element:Arm()
					armWithTimeout()
					return true, "armed"
				end

				function element:Cancel()
					holdActive = false
					setArmedVisual(false)
					return true, "cancelled"
				end

				function element:SetMode(nextMode)
					local normalized = tostring(nextMode or "hold"):lower()
					if normalized ~= "hold" and normalized ~= "double" and normalized ~= "either" then
						return false, "Invalid mode."
					end
					mode = normalized
					return true, "ok"
				end

				function element:SetHoldDuration(nextDuration)
					holdDuration = clampNumber(nextDuration, 0.05, 6, holdDuration)
					return true, "ok"
				end

				function element:SetDoubleWindow(nextWindow)
					doubleWindow = clampNumber(nextWindow, 0.05, 4, doubleWindow)
					return true, "ok"
				end

				function element:Destroy()
					root:Destroy()
				end

				connectThemeRefresh(function()
					button.TextColor3 = self.getSelectedTheme().TextColor
					stroke.Color = self.getSelectedTheme().ElementStroke
					setArmedVisual(armed)
				end)

				resolveElementParentFromSettings(element, settingsValue)
				addExtendedAPI(element, element.Name, "ConfirmButton", root)
				return element
			end

			local function resolveImageSourceUri(source)
				local valueType = typeof(source)
				if valueType == "nil" then
					return "rbxassetid://0", nil
				end
				if valueType == "number" then
					return "rbxassetid://" .. tostring(math.floor(source)), nil
				end
				if valueType ~= "string" then
					return "rbxassetid://0", "Image source must be a number or string."
				end
				local normalized = tostring(source)
				if normalized == "" then
					return "rbxassetid://0", "Image source is empty."
				end
				if normalized:match("^rbxassetid://") then
					return normalized, nil
				end
				if normalized:match("^https?://") then
					local hasBridge = type(getcustomasset) == "function" or type(getsynasset) == "function"
					if not hasBridge then
						return "rbxassetid://0", "URL image source unsupported in this executor (no asset bridge)."
					end
					return normalized, nil
				end
				if tonumber(normalized) then
					return "rbxassetid://" .. tostring(math.floor(tonumber(normalized))), nil
				end
				return normalized, nil
			end

			function Tab:CreateImage(imageSettings)
				local settingsValue = imageSettings or {}
				local imageElement = {}
				imageElement.Name = tostring(settingsValue.Name or "Image")
				imageElement.Flag = settingsValue.Flag
				local initialSource, initialWarning = resolveImageSourceUri(settingsValue.Source)
				imageElement.CurrentValue = {
					source = initialSource,
					fitMode = tostring(settingsValue.FitMode or "fill"):lower(),
					caption = tostring(settingsValue.Caption or "")
				}
				if initialWarning then
					warn("Rayfield | Image source warning: " .. tostring(initialWarning))
				end

				local root = Instance.new("Frame")
				root.Name = imageElement.Name
				root.Size = UDim2.new(1, -10, 0, clampNumber(settingsValue.Height, 60, 360, 130))
				root.BackgroundColor3 = self.getSelectedTheme().SecondaryElementBackground
				root.BorderSizePixel = 0
				root.Visible = true
				root.Parent = TabPage

				local corner = Instance.new("UICorner")
				corner.CornerRadius = UDim.new(0, clampNumber(settingsValue.CornerRadius, 0, 24, 8))
				corner.Parent = root

				local stroke = Instance.new("UIStroke")
				stroke.Color = self.getSelectedTheme().SecondaryElementStroke
				stroke.Parent = root

				local image = Instance.new("ImageLabel")
				image.Name = "Image"
				image.BackgroundTransparency = 1
				image.Position = UDim2.new(0, 0, 0, 0)
				image.Size = UDim2.new(1, 0, 1, -24)
				image.Image = imageElement.CurrentValue.source
				image.ScaleType = imageElement.CurrentValue.fitMode == "fit" and Enum.ScaleType.Fit or Enum.ScaleType.Crop
				image.Parent = root

				local caption = Instance.new("TextLabel")
				caption.Name = "Caption"
				caption.BackgroundTransparency = 1
				caption.AnchorPoint = Vector2.new(0.5, 1)
				caption.Position = UDim2.new(0.5, 0, 1, -4)
				caption.Size = UDim2.new(1, -12, 0, 18)
				caption.Font = Enum.Font.Gotham
				caption.TextSize = 12
				caption.TextXAlignment = Enum.TextXAlignment.Left
				caption.TextColor3 = self.getSelectedTheme().TextColor
				caption.Text = imageElement.CurrentValue.caption
				caption.Visible = imageElement.CurrentValue.caption ~= ""
				caption.Parent = root

				local function persistImageState()
					if settingsValue.Ext ~= true then
						self.SaveConfiguration()
					end
				end

				function imageElement:SetSource(nextSource)
					local resolved, warningMessage = resolveImageSourceUri(nextSource)
					imageElement.CurrentValue.source = resolved
					image.Image = imageElement.CurrentValue.source
					persistImageState()
					if warningMessage then
						warn("Rayfield | Image source warning: " .. tostring(warningMessage))
						return false, warningMessage
					end
					return true, "ok"
				end

				function imageElement:GetSource()
					return imageElement.CurrentValue.source
				end

				function imageElement:SetFitMode(nextMode)
					local normalized = tostring(nextMode or "fill"):lower()
					if normalized ~= "fill" and normalized ~= "fit" then
						normalized = "fill"
					end
					imageElement.CurrentValue.fitMode = normalized
					image.ScaleType = normalized == "fit" and Enum.ScaleType.Fit or Enum.ScaleType.Crop
					persistImageState()
				end

				function imageElement:SetCaption(nextCaption)
					imageElement.CurrentValue.caption = tostring(nextCaption or "")
					caption.Text = imageElement.CurrentValue.caption
					caption.Visible = imageElement.CurrentValue.caption ~= ""
					persistImageState()
				end

				function imageElement:GetPersistValue()
					return cloneSerializable(imageElement.CurrentValue)
				end

				function imageElement:Set(value)
					if type(value) == "table" then
						if value.source ~= nil then
							imageElement:SetSource(value.source)
						end
						if value.fitMode ~= nil then
							imageElement:SetFitMode(value.fitMode)
						end
						if value.caption ~= nil then
							imageElement:SetCaption(value.caption)
						end
					else
						imageElement:SetSource(value)
					end
				end

				function imageElement:Destroy()
					root:Destroy()
				end

				connectThemeRefresh(function()
					root.BackgroundColor3 = self.getSelectedTheme().SecondaryElementBackground
					stroke.Color = self.getSelectedTheme().SecondaryElementStroke
					caption.TextColor3 = self.getSelectedTheme().TextColor
				end)

				resolveElementParentFromSettings(imageElement, settingsValue)
				addExtendedAPI(imageElement, imageElement.Name, "Image", root)
				if Settings.ConfigurationSaving and Settings.ConfigurationSaving.Enabled and imageElement.Flag then
					self.RayfieldLibrary.Flags[imageElement.Flag] = imageElement
				end
				return imageElement
			end

			function Tab:CreateGallery(gallerySettings)
				local settingsValue = gallerySettings or {}
				local gallery = {}
				gallery.Name = tostring(settingsValue.Name or "Gallery")
				gallery.Flag = settingsValue.Flag
				local selectionMode = tostring(settingsValue.SelectionMode or "single"):lower()
				if selectionMode ~= "single" and selectionMode ~= "multi" then
					selectionMode = "single"
				end
				local callback = type(settingsValue.Callback) == "function" and settingsValue.Callback or function() end
				local columns = settingsValue.Columns or "auto"
				local items = {}
				local selected = {}

				local root = Instance.new("Frame")
				root.Name = gallery.Name
				root.Size = UDim2.new(1, -10, 0, clampNumber(settingsValue.Height, 140, 520, 220))
				root.BackgroundColor3 = self.getSelectedTheme().ElementBackground
				root.BorderSizePixel = 0
				root.Visible = true
				root.Parent = TabPage

				local corner = Instance.new("UICorner")
				corner.CornerRadius = UDim.new(0, 6)
				corner.Parent = root

				local stroke = Instance.new("UIStroke")
				stroke.Color = self.getSelectedTheme().ElementStroke
				stroke.Parent = root

				local title = Instance.new("TextLabel")
				title.BackgroundTransparency = 1
				title.Position = UDim2.new(0, 10, 0, 0)
				title.Size = UDim2.new(1, -12, 0, 22)
				title.Font = Enum.Font.GothamSemibold
				title.TextXAlignment = Enum.TextXAlignment.Left
				title.TextSize = 13
				title.TextColor3 = self.getSelectedTheme().TextColor
				title.Text = gallery.Name
				title.Parent = root

				local list = Instance.new("ScrollingFrame")
				list.Name = "List"
				list.BackgroundTransparency = 1
				list.BorderSizePixel = 0
				list.Position = UDim2.new(0, 6, 0, 24)
				list.Size = UDim2.new(1, -12, 1, -30)
				list.CanvasSize = UDim2.new(0, 0, 0, 0)
				list.ScrollBarImageTransparency = 0.5
				list.Parent = root

				local grid = Instance.new("UIGridLayout")
				grid.CellPadding = UDim2.new(0, 8, 0, 8)
				grid.SortOrder = Enum.SortOrder.LayoutOrder
				grid.Parent = list

				local function applyGridSizing()
					local targetColumns = 2
					if type(columns) == "number" then
						targetColumns = math.max(1, math.floor(columns))
					else
						targetColumns = math.max(1, math.floor((list.AbsoluteSize.X + 8) / 116))
					end
					local width = math.max(70, math.floor((list.AbsoluteSize.X - ((targetColumns - 1) * 8)) / targetColumns))
					grid.CellSize = UDim2.new(0, width, 0, 92)
				end

				local function snapshotSelection()
					if selectionMode == "single" then
						for id in pairs(selected) do
							return id
						end
						return nil
					end
					local out = {}
					for id in pairs(selected) do
						table.insert(out, id)
					end
					table.sort(out)
					return out
				end

				local function emitSelection()
					local okCallback, callbackErr = pcall(callback, snapshotSelection())
					if not okCallback then
						warn("Rayfield | Gallery callback failed: " .. tostring(callbackErr))
					end
					if settingsValue.Ext ~= true then
						self.SaveConfiguration()
					end
				end

				local cardById = {}

				local function applyCardSelectionVisual(itemId)
					local card = cardById[itemId]
					if not card then
						return
					end
					local active = selected[itemId] == true
					card.BackgroundColor3 = active and (self.getSelectedTheme().DropdownSelected or self.getSelectedTheme().ElementBackgroundHover) or self.getSelectedTheme().SecondaryElementBackground
				end

				local function renderItems()
					for _, child in ipairs(list:GetChildren()) do
						if child:IsA("Frame") then
							child:Destroy()
						end
					end
					cardById = {}

					for index, item in ipairs(items) do
						local itemId = tostring(item.id or item.Id or index)
						local card = Instance.new("Frame")
						card.Name = "Item_" .. itemId
						card.BackgroundColor3 = self.getSelectedTheme().SecondaryElementBackground
						card.BorderSizePixel = 0
						card.LayoutOrder = index
						card.Parent = list

						local cardCorner = Instance.new("UICorner")
						cardCorner.CornerRadius = UDim.new(0, 6)
						cardCorner.Parent = card

						local image = Instance.new("ImageLabel")
						image.BackgroundTransparency = 1
						image.Position = UDim2.new(0, 6, 0, 6)
						image.Size = UDim2.new(1, -12, 1, -30)
						image.ScaleType = Enum.ScaleType.Crop
						image.Image = resolveImageSourceUri(item.image or item.Image or item.source or item.Source)
						image.Parent = card

						local label = Instance.new("TextLabel")
						label.BackgroundTransparency = 1
						label.Position = UDim2.new(0, 6, 1, -22)
						label.Size = UDim2.new(1, -12, 0, 16)
						label.Font = Enum.Font.Gotham
						label.TextSize = 11
						label.TextXAlignment = Enum.TextXAlignment.Left
						label.TextColor3 = self.getSelectedTheme().TextColor
						label.Text = tostring(item.name or item.Name or itemId)
						label.Parent = card

						local interact = Instance.new("TextButton")
						interact.BackgroundTransparency = 1
						interact.Size = UDim2.new(1, 0, 1, 0)
						interact.Text = ""
						interact.Parent = card
						interact.MouseButton1Click:Connect(function()
							if selectionMode == "single" then
								selected = {}
								selected[itemId] = true
							else
								if selected[itemId] then
									selected[itemId] = nil
								else
									selected[itemId] = true
								end
							end
							for id in pairs(cardById) do
								applyCardSelectionVisual(id)
							end
							emitSelection()
						end)

						cardById[itemId] = card
						applyCardSelectionVisual(itemId)
					end

					task.defer(function()
						applyGridSizing()
						list.CanvasSize = UDim2.new(0, 0, 0, grid.AbsoluteContentSize.Y + 8)
					end)
				end

				list:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
					applyGridSizing()
					list.CanvasSize = UDim2.new(0, 0, 0, grid.AbsoluteContentSize.Y + 8)
				end)
				grid:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
					list.CanvasSize = UDim2.new(0, 0, 0, grid.AbsoluteContentSize.Y + 8)
				end)

				function gallery:SetItems(nextItems)
					items = {}
					if type(nextItems) == "table" then
						for _, item in ipairs(nextItems) do
							table.insert(items, cloneSerializable(item))
						end
					end
					renderItems()
				end

				function gallery:AddItem(item)
					if type(item) ~= "table" then
						return
					end
					table.insert(items, cloneSerializable(item))
					renderItems()
				end

				function gallery:RemoveItem(itemId)
					local key = tostring(itemId or "")
					for index, item in ipairs(items) do
						local id = tostring(item.id or item.Id or index)
						if id == key then
							table.remove(items, index)
							selected[key] = nil
							break
						end
					end
					renderItems()
					emitSelection()
				end

				function gallery:Select(itemId)
					local key = tostring(itemId or "")
					if selectionMode == "single" then
						selected = {}
					end
					selected[key] = true
					applyCardSelectionVisual(key)
					emitSelection()
				end

				function gallery:Deselect(itemId)
					local key = tostring(itemId or "")
					selected[key] = nil
					applyCardSelectionVisual(key)
					emitSelection()
				end

				function gallery:ClearSelection()
					selected = {}
					for id in pairs(cardById) do
						applyCardSelectionVisual(id)
					end
					emitSelection()
				end

				function gallery:SetSelection(nextSelection)
					selected = {}
					if selectionMode == "single" then
						local value = type(nextSelection) == "table" and nextSelection[1] or nextSelection
						if value ~= nil then
							selected[tostring(value)] = true
						end
					else
						if type(nextSelection) == "table" then
							for _, value in ipairs(nextSelection) do
								selected[tostring(value)] = true
							end
						elseif nextSelection ~= nil then
							selected[tostring(nextSelection)] = true
						end
					end
					for id in pairs(cardById) do
						applyCardSelectionVisual(id)
					end
					emitSelection()
				end

				function gallery:GetSelection()
					return snapshotSelection()
				end

				function gallery:GetPersistValue()
					return cloneSerializable(snapshotSelection())
				end

				function gallery:Set(value)
					gallery:SetSelection(value)
				end

				function gallery:Destroy()
					root:Destroy()
				end

				connectThemeRefresh(function()
					root.BackgroundColor3 = self.getSelectedTheme().ElementBackground
					stroke.Color = self.getSelectedTheme().ElementStroke
					title.TextColor3 = self.getSelectedTheme().TextColor
					for id in pairs(cardById) do
						local card = cardById[id]
						if card then
							local label = card:FindFirstChildOfClass("TextLabel")
							if label then
								label.TextColor3 = self.getSelectedTheme().TextColor
							end
						end
						applyCardSelectionVisual(id)
					end
				end)

				resolveElementParentFromSettings(gallery, settingsValue)
				gallery:SetItems(settingsValue.Items or {})
				addExtendedAPI(gallery, gallery.Name, "Gallery", root)
				if Settings.ConfigurationSaving and Settings.ConfigurationSaving.Enabled and gallery.Flag then
					self.RayfieldLibrary.Flags[gallery.Flag] = gallery
				end
				return gallery
			end

			function Tab:CreateChart(chartSettings)
				local settingsValue = chartSettings or {}
				local chart = {}
				chart.Name = tostring(settingsValue.Name or "Chart")
				chart.Flag = settingsValue.Flag
				chart.CurrentValue = {
					points = {},
					zoom = 1,
					offset = 0,
					preset = settingsValue.Preset
				}
				local maxPoints = math.max(10, math.floor(tonumber(settingsValue.MaxPoints) or 300))
				local updateHz = math.max(1, math.floor(tonumber(settingsValue.UpdateHz) or 10))
				local callback = type(settingsValue.Callback) == "function" and settingsValue.Callback or function() end
				local showAreaFill = settingsValue.ShowAreaFill ~= false
				local renderPending = false
				local lastRender = 0
				local segmentPool = {}
				local fillPool = {}
				local dragging = false
				local dragStartX = 0

				local root = Instance.new("Frame")
				root.Name = chart.Name
				root.Size = UDim2.new(1, -10, 0, clampNumber(settingsValue.Height, 150, 380, 220))
				root.BackgroundColor3 = self.getSelectedTheme().ElementBackground
				root.BorderSizePixel = 0
				root.Visible = true
				root.Parent = TabPage

				local corner = Instance.new("UICorner")
				corner.CornerRadius = UDim.new(0, 6)
				corner.Parent = root

				local stroke = Instance.new("UIStroke")
				stroke.Color = self.getSelectedTheme().ElementStroke
				stroke.Parent = root

				local title = Instance.new("TextLabel")
				title.BackgroundTransparency = 1
				title.Position = UDim2.new(0, 10, 0, 0)
				title.Size = UDim2.new(1, -90, 0, 22)
				title.Font = Enum.Font.GothamSemibold
				title.TextXAlignment = Enum.TextXAlignment.Left
				title.TextSize = 13
				title.TextColor3 = self.getSelectedTheme().TextColor
				title.Text = chart.Name
				title.Parent = root

				local zoomIn = Instance.new("TextButton")
				zoomIn.Size = UDim2.new(0, 22, 0, 20)
				zoomIn.AnchorPoint = Vector2.new(1, 0)
				zoomIn.Position = UDim2.new(1, -34, 0, 2)
				zoomIn.Text = "+"
				zoomIn.Font = Enum.Font.GothamBold
				zoomIn.TextSize = 14
				zoomIn.TextColor3 = self.getSelectedTheme().TextColor
				zoomIn.BackgroundColor3 = self.getSelectedTheme().InputBackground
				zoomIn.BorderSizePixel = 0
				zoomIn.Parent = root

				local zoomOut = Instance.new("TextButton")
				zoomOut.Size = UDim2.new(0, 22, 0, 20)
				zoomOut.AnchorPoint = Vector2.new(1, 0)
				zoomOut.Position = UDim2.new(1, -8, 0, 2)
				zoomOut.Text = "-"
				zoomOut.Font = Enum.Font.GothamBold
				zoomOut.TextSize = 14
				zoomOut.TextColor3 = self.getSelectedTheme().TextColor
				zoomOut.BackgroundColor3 = self.getSelectedTheme().InputBackground
				zoomOut.BorderSizePixel = 0
				zoomOut.Parent = root

				local plot = Instance.new("Frame")
				plot.Name = "Plot"
				plot.BackgroundColor3 = self.getSelectedTheme().SecondaryElementBackground
				plot.BorderSizePixel = 0
				plot.Position = UDim2.new(0, 8, 0, 26)
				plot.Size = UDim2.new(1, -16, 1, -34)
				plot.ClipsDescendants = true
				plot.Parent = root

				local plotStroke = Instance.new("UIStroke")
				plotStroke.Color = self.getSelectedTheme().ElementStroke
				plotStroke.Transparency = 0.2
				plotStroke.Parent = plot

				local gridLines = {}
				for i = 1, 4 do
					local line = Instance.new("Frame")
					line.BorderSizePixel = 0
					line.Size = UDim2.new(1, 0, 0, 1)
					line.Position = UDim2.new(0, 0, (i - 1) / 3, 0)
					line.BackgroundColor3 = self.getSelectedTheme().ChartGrid or self.getSelectedTheme().ElementStroke
					line.BackgroundTransparency = 0.65
					line.Parent = plot
					gridLines[i] = line
				end

				local drawLayer = Instance.new("Frame")
				drawLayer.BackgroundTransparency = 1
				drawLayer.Size = UDim2.new(1, 0, 1, 0)
				drawLayer.Parent = plot

				local function ensurePoolEntry(pool, index, factory)
					if pool[index] and pool[index].Parent then
						return pool[index]
					end
					local entry = factory()
					pool[index] = entry
					return entry
				end

				local function trimPoints()
					while #chart.CurrentValue.points > maxPoints do
						table.remove(chart.CurrentValue.points, 1)
					end
				end

				local function getVisiblePoints()
					local points = chart.CurrentValue.points
					local total = #points
					if total == 0 then
						return {}
					end
					local visibleCount = math.max(2, math.floor(total / math.max(1, chart.CurrentValue.zoom)))
					local maxOffset = math.max(0, total - visibleCount)
					chart.CurrentValue.offset = math.floor(clampNumber(chart.CurrentValue.offset, 0, maxOffset, chart.CurrentValue.offset))
					local startIndex = total - visibleCount - chart.CurrentValue.offset + 1
					if startIndex < 1 then
						startIndex = 1
					end
					local out = {}
					for index = startIndex, math.min(total, startIndex + visibleCount - 1) do
						table.insert(out, points[index])
					end
					return out
				end

				local function renderNow()
					lastRender = os.clock()
					local visible = getVisiblePoints()
					local pointCount = #visible
					local minY = math.huge
					local maxY = -math.huge
					for _, point in ipairs(visible) do
						local y = tonumber(point.y) or 0
						if y < minY then minY = y end
						if y > maxY then maxY = y end
					end
					if pointCount == 0 then
						minY, maxY = 0, 1
					elseif minY == maxY then
						minY -= 1
						maxY += 1
					end

					local width = math.max(1, plot.AbsoluteSize.X)
					local height = math.max(1, plot.AbsoluteSize.Y)
					local function toPoint(index, yValue)
						local x = pointCount <= 1 and (width * 0.5) or (((index - 1) / (pointCount - 1)) * width)
						local safeY = tonumber(yValue) or minY
						local y = height - (((safeY - minY) / math.max(0.00001, (maxY - minY))) * height)
						return x, y
					end

					local segmentIndex = 0
					for index = 1, pointCount - 1 do
						local x1, y1 = toPoint(index, visible[index].y)
						local x2, y2 = toPoint(index + 1, visible[index + 1].y)
						local dx, dy = x2 - x1, y2 - y1
						local length = math.sqrt((dx * dx) + (dy * dy))
						if length > 0 then
							segmentIndex += 1
							local segment = ensurePoolEntry(segmentPool, segmentIndex, function()
								local line = Instance.new("Frame")
								line.BorderSizePixel = 0
								line.AnchorPoint = Vector2.new(0, 0.5)
								line.Size = UDim2.new(0, 1, 0, 2)
								line.Parent = drawLayer
								return line
							end)
							segment.Visible = true
							segment.BackgroundColor3 = self.getSelectedTheme().ChartLine or self.getSelectedTheme().SliderProgress
							segment.Position = UDim2.new(0, x1, 0, y1)
							segment.Size = UDim2.new(0, length, 0, 2)
							segment.Rotation = math.deg(math.atan2(dy, dx))
						end
					end
					for index = segmentIndex + 1, #segmentPool do
						if segmentPool[index] then
							segmentPool[index].Visible = false
						end
					end

					if showAreaFill then
						local fillIndex = 0
						for index = 1, pointCount do
							local x, y = toPoint(index, visible[index].y)
							fillIndex += 1
							local fill = ensurePoolEntry(fillPool, fillIndex, function()
								local bar = Instance.new("Frame")
								bar.BorderSizePixel = 0
								bar.AnchorPoint = Vector2.new(0.5, 1)
								bar.BackgroundTransparency = 0.78
								bar.Parent = drawLayer
								return bar
							end)
							fill.Visible = true
							fill.BackgroundColor3 = self.getSelectedTheme().ChartFill or self.getSelectedTheme().SliderBackground
							fill.Position = UDim2.new(0, x, 0, height)
							fill.Size = UDim2.new(0, 2, 0, math.max(1, height - y))
						end
						for index = fillIndex + 1, #fillPool do
							if fillPool[index] then
								fillPool[index].Visible = false
							end
						end
					else
						for _, fill in ipairs(fillPool) do
							if fill then
								fill.Visible = false
							end
						end
					end
				end

				local function scheduleRender()
					local interval = 1 / math.max(1, updateHz)
					local now = os.clock()
					local elapsed = now - lastRender
					if elapsed >= interval then
						renderNow()
						return
					end
					if renderPending then
						return
					end
					renderPending = true
					task.delay(interval - elapsed, function()
						renderPending = false
						if root and root.Parent then
							renderNow()
						end
					end)
				end

				local function emitDataChanged(persist)
					trimPoints()
					scheduleRender()
					local okCallback, callbackErr = pcall(callback, chart:GetData())
					if not okCallback then
						warn("Rayfield | Chart callback failed: " .. tostring(callbackErr))
					end
					if persist ~= false and settingsValue.Ext ~= true then
						self.SaveConfiguration()
					end
				end

				function chart:AddPoint(y, x)
					local nextX = tonumber(x)
					if nextX == nil then
						local lastPoint = chart.CurrentValue.points[#chart.CurrentValue.points]
						nextX = (lastPoint and tonumber(lastPoint.x) or 0) + 1
					end
					table.insert(chart.CurrentValue.points, {x = nextX, y = tonumber(y) or 0})
					emitDataChanged(true)
				end

				function chart:SetData(points)
					chart.CurrentValue.points = {}
					if type(points) == "table" then
						for _, point in ipairs(points) do
							if type(point) == "table" then
								local px = tonumber(point.x or point[1]) or (#chart.CurrentValue.points + 1)
								local py = tonumber(point.y or point[2])
								if py ~= nil then
									table.insert(chart.CurrentValue.points, {x = px, y = py})
								end
							elseif tonumber(point) ~= nil then
								table.insert(chart.CurrentValue.points, {x = #chart.CurrentValue.points + 1, y = tonumber(point)})
							end
						end
					end
					emitDataChanged(true)
				end

				function chart:GetData()
					return cloneSerializable(chart.CurrentValue)
				end

				function chart:Clear()
					chart.CurrentValue.points = {}
					chart.CurrentValue.offset = 0
					emitDataChanged(true)
				end

				function chart:SetPreset(nameOrNil)
					chart.CurrentValue.preset = nameOrNil
					if settingsValue.Ext ~= true then
						self.SaveConfiguration()
					end
					return true, "ok"
				end

				function chart:Zoom(factor)
					chart.CurrentValue.zoom = clampNumber((chart.CurrentValue.zoom or 1) * (tonumber(factor) or 1), 1, 12, chart.CurrentValue.zoom)
					emitDataChanged(true)
				end

				function chart:Pan(delta)
					local total = #chart.CurrentValue.points
					local visibleCount = math.max(2, math.floor(total / math.max(1, chart.CurrentValue.zoom)))
					local maxOffset = math.max(0, total - visibleCount)
					chart.CurrentValue.offset = math.floor(clampNumber((chart.CurrentValue.offset or 0) + (tonumber(delta) or 0), 0, maxOffset, 0))
					emitDataChanged(true)
				end

				function chart:GetPersistValue()
					return chart:GetData()
				end

				function chart:Set(value)
					if type(value) == "table" then
						if type(value.points) == "table" then
							chart.CurrentValue.points = cloneSerializable(value.points) or {}
						elseif #value > 0 then
							chart:SetData(value)
							return
						end
						chart.CurrentValue.zoom = clampNumber(value.zoom, 1, 12, chart.CurrentValue.zoom)
						chart.CurrentValue.offset = clampNumber(value.offset, 0, math.huge, chart.CurrentValue.offset)
						if value.preset ~= nil then
							chart.CurrentValue.preset = value.preset
						end
						emitDataChanged(true)
					end
				end

				function chart:Destroy()
					root:Destroy()
				end

				zoomIn.MouseButton1Click:Connect(function()
					chart:Zoom(1.2)
				end)
				zoomOut.MouseButton1Click:Connect(function()
					chart:Zoom(1 / 1.2)
				end)
				plot.InputBegan:Connect(function(input)
					if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
						dragging = true
						dragStartX = input.Position.X
					end
				end)
				plot.InputChanged:Connect(function(input)
					if not dragging then
						return
					end
					if input.UserInputType ~= Enum.UserInputType.MouseMovement and input.UserInputType ~= Enum.UserInputType.Touch then
						return
					end
					local delta = input.Position.X - dragStartX
					if math.abs(delta) >= 10 then
						dragStartX = input.Position.X
						chart:Pan(math.floor(-delta / 22))
					end
				end)
				plot.InputEnded:Connect(function(input)
					if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
						dragging = false
					end
				end)

				connectThemeRefresh(function()
					root.BackgroundColor3 = self.getSelectedTheme().ElementBackground
					stroke.Color = self.getSelectedTheme().ElementStroke
					title.TextColor3 = self.getSelectedTheme().TextColor
					zoomIn.BackgroundColor3 = self.getSelectedTheme().InputBackground
					zoomIn.TextColor3 = self.getSelectedTheme().TextColor
					zoomOut.BackgroundColor3 = self.getSelectedTheme().InputBackground
					zoomOut.TextColor3 = self.getSelectedTheme().TextColor
					plot.BackgroundColor3 = self.getSelectedTheme().SecondaryElementBackground
					plotStroke.Color = self.getSelectedTheme().ElementStroke
					for _, line in ipairs(gridLines) do
						line.BackgroundColor3 = self.getSelectedTheme().ChartGrid or self.getSelectedTheme().ElementStroke
					end
					scheduleRender()
				end)

				resolveElementParentFromSettings(chart, settingsValue)
				if type(settingsValue.Data) == "table" then
					chart:SetData(settingsValue.Data)
				else
					scheduleRender()
				end
				addExtendedAPI(chart, chart.Name, "Chart", root)
				if Settings.ConfigurationSaving and Settings.ConfigurationSaving.Enabled and chart.Flag then
					self.RayfieldLibrary.Flags[chart.Flag] = chart
				end
				return chart
			end

			function Tab:CreateLogConsole(logSettings)
				local settingsValue = logSettings or {}
				local console = {}
				console.Name = tostring(settingsValue.Name or "Log Console")
				console.Flag = settingsValue.Flag
				local captureMode = tostring(settingsValue.CaptureMode or "manual"):lower()
				if captureMode ~= "manual" and captureMode ~= "global" and captureMode ~= "both" then
					captureMode = "manual"
				end
				local maxEntries = math.max(10, math.floor(tonumber(settingsValue.MaxEntries) or 500))
				local autoScroll = settingsValue.AutoScroll ~= false
				local showTimestamp = settingsValue.ShowTimestamp ~= false
				local entries = {}
				local globalUnsubscribe = nil

				local root = Instance.new("Frame")
				root.Name = console.Name
				root.Size = UDim2.new(1, -10, 0, clampNumber(settingsValue.Height, 150, 420, 230))
				root.BackgroundColor3 = self.getSelectedTheme().ElementBackground
				root.BorderSizePixel = 0
				root.Visible = true
				root.Parent = TabPage

				local corner = Instance.new("UICorner")
				corner.CornerRadius = UDim.new(0, 6)
				corner.Parent = root

				local stroke = Instance.new("UIStroke")
				stroke.Color = self.getSelectedTheme().ElementStroke
				stroke.Parent = root

				local title = Instance.new("TextLabel")
				title.BackgroundTransparency = 1
				title.Position = UDim2.new(0, 10, 0, 0)
				title.Size = UDim2.new(1, -110, 0, 22)
				title.TextXAlignment = Enum.TextXAlignment.Left
				title.Font = Enum.Font.GothamSemibold
				title.TextSize = 13
				title.TextColor3 = self.getSelectedTheme().TextColor
				title.Text = console.Name
				title.Parent = root

				local modeLabel = Instance.new("TextLabel")
				modeLabel.BackgroundTransparency = 1
				modeLabel.AnchorPoint = Vector2.new(1, 0)
				modeLabel.Position = UDim2.new(1, -40, 0, 2)
				modeLabel.Size = UDim2.new(0, 64, 0, 18)
				modeLabel.Font = Enum.Font.Gotham
				modeLabel.TextSize = 11
				modeLabel.TextXAlignment = Enum.TextXAlignment.Right
				modeLabel.TextColor3 = self.getSelectedTheme().TextColor
				modeLabel.Text = string.upper(captureMode)
				modeLabel.Parent = root

				local clearButton = Instance.new("TextButton")
				clearButton.AnchorPoint = Vector2.new(1, 0)
				clearButton.Position = UDim2.new(1, -6, 0, 2)
				clearButton.Size = UDim2.new(0, 28, 0, 18)
				clearButton.Text = "CLR"
				clearButton.Font = Enum.Font.GothamBold
				clearButton.TextSize = 9
				clearButton.TextColor3 = self.getSelectedTheme().TextColor
				clearButton.BackgroundColor3 = self.getSelectedTheme().InputBackground
				clearButton.BorderSizePixel = 0
				clearButton.Parent = root

				local list = Instance.new("ScrollingFrame")
				list.Name = "Entries"
				list.BackgroundColor3 = self.getSelectedTheme().SecondaryElementBackground
				list.BorderSizePixel = 0
				list.Position = UDim2.new(0, 8, 0, 24)
				list.Size = UDim2.new(1, -16, 1, -32)
				list.CanvasSize = UDim2.new(0, 0, 0, 0)
				list.ScrollBarImageTransparency = 0.5
				list.Parent = root

				local listLayout = Instance.new("UIListLayout")
				listLayout.Padding = UDim.new(0, 3)
				listLayout.SortOrder = Enum.SortOrder.LayoutOrder
				listLayout.Parent = list

				local function levelColor(level)
					local normalized = tostring(level or "info"):lower()
					if normalized == "warn" then
						return self.getSelectedTheme().LogWarn or self.getSelectedTheme().SliderStroke
					elseif normalized == "error" then
						return self.getSelectedTheme().LogError or self.getSelectedTheme().ToggleEnabled
					end
					return self.getSelectedTheme().LogInfo or self.getSelectedTheme().TextColor
				end

				local function formatEntry(entry)
					local ts = ""
					if showTimestamp then
						ts = "[" .. os.date("%H:%M:%S", math.floor(entry.time or os.time())) .. "] "
					end
					return ts .. "[" .. string.upper(tostring(entry.level or "info")) .. "] " .. tostring(entry.text or "")
				end

				local function trimEntries()
					while #entries > maxEntries do
						table.remove(entries, 1)
					end
				end

				local function renderEntries()
					for _, child in ipairs(list:GetChildren()) do
						if child:IsA("TextLabel") then
							child:Destroy()
						end
					end
					for index, entry in ipairs(entries) do
						local label = Instance.new("TextLabel")
						label.BackgroundTransparency = 1
						label.Size = UDim2.new(1, -8, 0, 16)
						label.Position = UDim2.new(0, 4, 0, 0)
						label.TextXAlignment = Enum.TextXAlignment.Left
						label.Font = Enum.Font.Code
						label.TextSize = 12
						label.TextColor3 = levelColor(entry.level)
						label.Text = formatEntry(entry)
						label.LayoutOrder = index
						label.Parent = list
					end
					task.defer(function()
						list.CanvasSize = UDim2.new(0, 0, 0, listLayout.AbsoluteContentSize.Y + 6)
						if autoScroll then
							list.CanvasPosition = Vector2.new(0, math.max(0, list.CanvasSize.Y.Offset - list.AbsoluteSize.Y))
						end
					end)
				end

				local function appendEntry(level, textValue, persist)
					table.insert(entries, {
						level = tostring(level or "info"):lower(),
						text = tostring(textValue or ""),
						time = os.time()
					})
					trimEntries()
					renderEntries()
					if persist ~= false and settingsValue.Ext ~= true then
						self.SaveConfiguration()
					end
				end

				local function setCaptureMode(nextMode, persist)
					local normalized = tostring(nextMode or "manual"):lower()
					if normalized ~= "manual" and normalized ~= "global" and normalized ~= "both" then
						return false, "Invalid capture mode."
					end
					captureMode = normalized
					modeLabel.Text = string.upper(captureMode)
					if globalUnsubscribe then
						globalUnsubscribe()
						globalUnsubscribe = nil
					end
					if captureMode == "global" or captureMode == "both" then
						globalUnsubscribe = subscribeGlobalLogs(function(level, textValue)
							appendEntry(level, textValue, true)
						end)
					end
					if persist ~= false and settingsValue.Ext ~= true then
						self.SaveConfiguration()
					end
					return true, "ok"
				end

				function console:Log(level, textValue)
					appendEntry(level or "info", textValue, true)
				end

				function console:Info(textValue)
					appendEntry("info", textValue, true)
				end

				function console:Warn(textValue)
					appendEntry("warn", textValue, true)
				end

				function console:Error(textValue)
					appendEntry("error", textValue, true)
				end

				function console:Clear()
					entries = {}
					renderEntries()
					if settingsValue.Ext ~= true then
						self.SaveConfiguration()
					end
				end

				function console:SetCaptureMode(nextMode)
					return setCaptureMode(nextMode, true)
				end

				function console:GetEntries()
					return cloneSerializable(entries)
				end

				function console:GetPersistValue()
					return {
						captureMode = captureMode,
						entries = cloneSerializable(entries)
					}
				end

				function console:Set(value)
					if type(value) == "table" then
						if type(value.entries) == "table" then
							entries = cloneSerializable(value.entries) or {}
							trimEntries()
							renderEntries()
						end
						if value.captureMode ~= nil then
							setCaptureMode(value.captureMode, false)
						end
					end
				end

				function console:Destroy()
					if globalUnsubscribe then
						globalUnsubscribe()
						globalUnsubscribe = nil
					end
					root:Destroy()
				end

				clearButton.MouseButton1Click:Connect(function()
					console:Clear()
				end)
				setCaptureMode(captureMode, false)

				connectThemeRefresh(function()
					root.BackgroundColor3 = self.getSelectedTheme().ElementBackground
					stroke.Color = self.getSelectedTheme().ElementStroke
					title.TextColor3 = self.getSelectedTheme().TextColor
					modeLabel.TextColor3 = self.getSelectedTheme().TextColor
					clearButton.BackgroundColor3 = self.getSelectedTheme().InputBackground
					clearButton.TextColor3 = self.getSelectedTheme().TextColor
					list.BackgroundColor3 = self.getSelectedTheme().SecondaryElementBackground
					renderEntries()
				end)

				resolveElementParentFromSettings(console, settingsValue)
				if type(settingsValue.Entries) == "table" then
					console:Set({
						captureMode = captureMode,
						entries = settingsValue.Entries
					})
				else
					renderEntries()
				end
				addExtendedAPI(console, console.Name, "LogConsole", root)
				if Settings.ConfigurationSaving and Settings.ConfigurationSaving.Enabled and console.Flag then
					self.RayfieldLibrary.Flags[console.Flag] = console
				end
				return console
			end

			function Tab:CreateLoadingSpinner(spinnerSettings)
				local settingsValue = spinnerSettings or {}
				local spinner = {}
				spinner.Name = tostring(settingsValue.Name or "Loading Spinner")
				spinner.Flag = settingsValue.Flag

				local spinnerSize = math.floor(clampNumber(settingsValue.Size, 14, 64, 26))
				local spinnerThickness = clampNumber(settingsValue.Thickness, 1, 8, 3)
				local spinnerSpeed = clampNumber(settingsValue.Speed, 0.1, 8, 1.2)
				local running = settingsValue.AutoStart ~= false
				local customColor = typeof(settingsValue.Color) == "Color3" and settingsValue.Color or nil
				local callback = type(settingsValue.Callback) == "function" and settingsValue.Callback or function() end
				local rotation = 0
				local loopState = {}

				local root = Instance.new("Frame")
				root.Name = spinner.Name
				root.Size = UDim2.new(1, -10, 0, 44)
				root.BackgroundColor3 = self.getSelectedTheme().ElementBackground
				root.BorderSizePixel = 0
				root.Visible = true
				root.Parent = TabPage

				local corner = Instance.new("UICorner")
				corner.CornerRadius = UDim.new(0, 6)
				corner.Parent = root

				local stroke = Instance.new("UIStroke")
				stroke.Color = self.getSelectedTheme().ElementStroke
				stroke.Parent = root

				local title = Instance.new("TextLabel")
				title.BackgroundTransparency = 1
				title.Position = UDim2.new(0, 10, 0, 0)
				title.Size = UDim2.new(1, -70, 1, 0)
				title.TextXAlignment = Enum.TextXAlignment.Left
				title.Font = Enum.Font.GothamMedium
				title.TextSize = 13
				title.TextColor3 = self.getSelectedTheme().TextColor
				title.Text = spinner.Name
				title.Parent = root

				local spinnerHost = Instance.new("Frame")
				spinnerHost.Name = "SpinnerHost"
				spinnerHost.AnchorPoint = Vector2.new(1, 0.5)
				spinnerHost.Position = UDim2.new(1, -12, 0.5, 0)
				spinnerHost.Size = UDim2.new(0, spinnerSize, 0, spinnerSize)
				spinnerHost.BackgroundTransparency = 1
				spinnerHost.Parent = root

				local ring = Instance.new("Frame")
				ring.Name = "Ring"
				ring.Size = UDim2.new(1, 0, 1, 0)
				ring.BackgroundTransparency = 1
				ring.BorderSizePixel = 0
				ring.Parent = spinnerHost

				local ringCorner = Instance.new("UICorner")
				ringCorner.CornerRadius = UDim.new(1, 0)
				ringCorner.Parent = ring

				local ringStroke = Instance.new("UIStroke")
				ringStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
				ringStroke.Thickness = spinnerThickness
				ringStroke.Transparency = 0.55
				ringStroke.Parent = ring

				local dot = Instance.new("Frame")
				dot.Name = "Dot"
				dot.Size = UDim2.new(0, math.max(4, math.floor(spinnerThickness * 1.9)), 0, math.max(4, math.floor(spinnerThickness * 1.9)))
				dot.BackgroundColor3 = self.getSelectedTheme().LoadingSpinner or self.getSelectedTheme().SliderProgress
				dot.BorderSizePixel = 0
				dot.Parent = spinnerHost

				local dotCorner = Instance.new("UICorner")
				dotCorner.CornerRadius = UDim.new(1, 0)
				dotCorner.Parent = dot

				local function resolveSpinnerColor()
					return customColor or self.getSelectedTheme().LoadingSpinner or self.getSelectedTheme().SliderProgress
				end

				local function updateSpinnerPosition()
					local hostWidth = math.max(1, spinnerHost.AbsoluteSize.X)
					local hostHeight = math.max(1, spinnerHost.AbsoluteSize.Y)
					local dotSize = math.max(4, math.floor(spinnerThickness * 1.9))
					dot.Size = UDim2.new(0, dotSize, 0, dotSize)
					local radius = math.max(3, math.min(hostWidth, hostHeight) * 0.5 - math.max(dotSize * 0.55, spinnerThickness))
					local centerX = hostWidth * 0.5
					local centerY = hostHeight * 0.5
					local x = centerX + math.cos(rotation) * radius - (dotSize * 0.5)
					local y = centerY + math.sin(rotation) * radius - (dotSize * 0.5)
					dot.Position = UDim2.new(0, x, 0, y)
				end

				local function applySpinnerVisual()
					root.BackgroundColor3 = self.getSelectedTheme().ElementBackground
					stroke.Color = self.getSelectedTheme().ElementStroke
					title.TextColor3 = self.getSelectedTheme().TextColor
					ringStroke.Color = self.getSelectedTheme().LoadingTrack or self.getSelectedTheme().SliderBackground
					ringStroke.Thickness = spinnerThickness
					dot.BackgroundColor3 = resolveSpinnerColor()
					spinnerHost.Size = UDim2.new(0, spinnerSize, 0, spinnerSize)
					updateSpinnerPosition()
				end

				local function getStateSnapshot()
					return {
						running = running == true,
						speed = spinnerSpeed,
						size = spinnerSize,
						thickness = spinnerThickness
					}
				end

				local function emitStateChanged(persist)
					local okCallback, callbackErr = pcall(callback, cloneSerializable(getStateSnapshot()))
					if not okCallback then
						warn("Rayfield | LoadingSpinner callback failed: " .. tostring(callbackErr))
					end
					if persist ~= false and settingsValue.Ext ~= true then
						self.SaveConfiguration()
					end
				end

				local function stepSpinner(deltaTime)
					if running ~= true then
						return
					end
					rotation += (deltaTime * spinnerSpeed * math.pi * 2)
					if rotation > (math.pi * 2) then
						rotation -= (math.pi * 2)
					end
					updateSpinnerPosition()
				end

				function spinner:Start(persist)
					if running == true then
						startRenderLoop(loopState, stepSpinner)
						return true, "already_running"
					end
					running = true
					startRenderLoop(loopState, stepSpinner)
					emitStateChanged(persist ~= false)
					return true, "ok"
				end

				function spinner:Stop(persist)
					if running ~= true then
						stopRenderLoop(loopState)
						return true, "already_stopped"
					end
					running = false
					stopRenderLoop(loopState)
					emitStateChanged(persist ~= false)
					return true, "ok"
				end

				function spinner:IsRunning()
					return running == true and loopState.Connection ~= nil
				end

				function spinner:SetSpeed(nextSpeed, persist)
					spinnerSpeed = clampNumber(nextSpeed, 0.1, 8, spinnerSpeed)
					emitStateChanged(persist ~= false)
					return true, "ok"
				end

				function spinner:GetSpeed()
					return spinnerSpeed
				end

				function spinner:SetColor(nextColor, persist)
					if typeof(nextColor) ~= "Color3" then
						return false, "SetColor expects Color3."
					end
					customColor = nextColor
					applySpinnerVisual()
					emitStateChanged(persist ~= false)
					return true, "ok"
				end

				function spinner:SetSize(nextSize, persist)
					spinnerSize = math.floor(clampNumber(nextSize, 14, 64, spinnerSize))
					applySpinnerVisual()
					emitStateChanged(persist ~= false)
					return true, "ok"
				end

				function spinner:GetPersistValue()
					local snapshot = getStateSnapshot()
					local packed = packColor3(customColor)
					if packed then
						snapshot.colorPacked = packed
					end
					return snapshot
				end

				function spinner:Set(value)
					if type(value) ~= "table" then
						return
					end
					if value.size ~= nil then
						spinnerSize = math.floor(clampNumber(value.size, 14, 64, spinnerSize))
					end
					if value.thickness ~= nil then
						spinnerThickness = clampNumber(value.thickness, 1, 8, spinnerThickness)
					end
					if value.speed ~= nil then
						spinnerSpeed = clampNumber(value.speed, 0.1, 8, spinnerSpeed)
					end
					if value.colorPacked ~= nil then
						customColor = unpackColor3(value.colorPacked) or customColor
					elseif typeof(value.color) == "Color3" then
						customColor = value.color
					end
					applySpinnerVisual()
					if value.running == true then
						spinner:Start(false)
					elseif value.running == false then
						spinner:Stop(false)
					else
						emitStateChanged(false)
					end
				end

				function spinner:Destroy()
					stopRenderLoop(loopState)
					root:Destroy()
				end

				connectThemeRefresh(function()
					applySpinnerVisual()
				end)

				resolveElementParentFromSettings(spinner, settingsValue)
				applySpinnerVisual()
				if running == true then
					startRenderLoop(loopState, stepSpinner)
				end
				addExtendedAPI(spinner, spinner.Name, "LoadingSpinner", root)
				if Settings.ConfigurationSaving and Settings.ConfigurationSaving.Enabled and spinner.Flag then
					self.RayfieldLibrary.Flags[spinner.Flag] = spinner
				end
				return spinner
			end

			function Tab:CreateLoadingBar(barSettings)
				local settingsValue = barSettings or {}
				local loadingBar = {}
				loadingBar.Name = tostring(settingsValue.Name or "Loading Bar")
				loadingBar.Flag = settingsValue.Flag

				local mode = tostring(settingsValue.Mode or "indeterminate"):lower()
				if mode ~= "indeterminate" and mode ~= "determinate" then
					mode = "indeterminate"
				end
				local speed = clampNumber(settingsValue.Speed, 0.1, 6, 1.1)
				local chunkScale = clampNumber(settingsValue.ChunkScale, 0.1, 0.8, 0.35)
				local progress = clampNumber(settingsValue.Progress, 0, 1, 0)
				local showLabel = settingsValue.ShowLabel == true
				local customLabel = nil
				local labelFormatter = type(settingsValue.LabelFormatter) == "function" and settingsValue.LabelFormatter or nil
				local callback = type(settingsValue.Callback) == "function" and settingsValue.Callback or function() end
				local running = mode == "indeterminate" and settingsValue.AutoStart ~= false
				local loopState = {}
				local animationPhase = 0
				local barHeight = math.floor(clampNumber(settingsValue.Height, 12, 40, 18))

				local root = Instance.new("Frame")
				root.Name = loadingBar.Name
				root.Size = UDim2.new(1, -10, 0, math.max(44, barHeight + 26))
				root.BackgroundColor3 = self.getSelectedTheme().ElementBackground
				root.BorderSizePixel = 0
				root.Visible = true
				root.Parent = TabPage

				local corner = Instance.new("UICorner")
				corner.CornerRadius = UDim.new(0, 6)
				corner.Parent = root

				local stroke = Instance.new("UIStroke")
				stroke.Color = self.getSelectedTheme().ElementStroke
				stroke.Parent = root

				local title = Instance.new("TextLabel")
				title.BackgroundTransparency = 1
				title.Position = UDim2.new(0, 10, 0, 0)
				title.Size = UDim2.new(0.65, 0, 0, 20)
				title.TextXAlignment = Enum.TextXAlignment.Left
				title.Font = Enum.Font.GothamMedium
				title.TextSize = 13
				title.TextColor3 = self.getSelectedTheme().TextColor
				title.Text = loadingBar.Name
				title.Parent = root

				local statusLabel = Instance.new("TextLabel")
				statusLabel.BackgroundTransparency = 1
				statusLabel.AnchorPoint = Vector2.new(1, 0)
				statusLabel.Position = UDim2.new(1, -10, 0, 2)
				statusLabel.Size = UDim2.new(0.35, -4, 0, 18)
				statusLabel.TextXAlignment = Enum.TextXAlignment.Right
				statusLabel.Font = Enum.Font.Gotham
				statusLabel.TextSize = 11
				statusLabel.TextColor3 = self.getSelectedTheme().LoadingText or self.getSelectedTheme().TextColor
				statusLabel.Visible = showLabel
				statusLabel.Parent = root

				local track = Instance.new("Frame")
				track.Name = "Track"
				track.Position = UDim2.new(0, 10, 0, 22)
				track.Size = UDim2.new(1, -20, 0, barHeight)
				track.BackgroundColor3 = self.getSelectedTheme().LoadingTrack or self.getSelectedTheme().SliderBackground
				track.BorderSizePixel = 0
				track.ClipsDescendants = true
				track.Parent = root

				local trackCorner = Instance.new("UICorner")
				trackCorner.CornerRadius = UDim.new(0, math.max(4, math.floor(barHeight * 0.5)))
				trackCorner.Parent = track

				local fill = Instance.new("Frame")
				fill.Name = "Fill"
				fill.Size = UDim2.new(progress, 0, 1, 0)
				fill.BackgroundColor3 = self.getSelectedTheme().LoadingBar or self.getSelectedTheme().SliderProgress
				fill.BorderSizePixel = 0
				fill.Parent = track

				local fillCorner = Instance.new("UICorner")
				fillCorner.CornerRadius = UDim.new(0, math.max(4, math.floor(barHeight * 0.5)))
				fillCorner.Parent = fill

				local chunk = Instance.new("Frame")
				chunk.Name = "Chunk"
				chunk.Size = UDim2.new(chunkScale, 0, 1, 0)
				chunk.Position = UDim2.new(0, 0, 0, 0)
				chunk.BackgroundColor3 = self.getSelectedTheme().LoadingBar or self.getSelectedTheme().SliderProgress
				chunk.BorderSizePixel = 0
				chunk.Parent = track

				local chunkCorner = Instance.new("UICorner")
				chunkCorner.CornerRadius = UDim.new(0, math.max(4, math.floor(barHeight * 0.5)))
				chunkCorner.Parent = chunk

				local function getStateSnapshot()
					return {
						mode = mode,
						running = running == true and mode == "indeterminate",
						progress = progress,
						speed = speed,
						chunkScale = chunkScale,
						label = customLabel
					}
				end

				local function emitStateChanged(persist)
					local okCallback, callbackErr = pcall(callback, cloneSerializable(getStateSnapshot()))
					if not okCallback then
						warn("Rayfield | LoadingBar callback failed: " .. tostring(callbackErr))
					end
					if persist ~= false and settingsValue.Ext ~= true then
						self.SaveConfiguration()
					end
				end

				local function formatLabelText()
					if customLabel and customLabel ~= "" then
						return customLabel
					end
					local percent = math.floor((progress * 100) + 0.5)
					if labelFormatter then
						local okFormat, formatted = pcall(labelFormatter, progress, percent, mode)
						if okFormat and formatted ~= nil then
							return tostring(formatted)
						end
					end
					if mode == "determinate" then
						return tostring(percent) .. "%"
					end
					return "Loading..."
				end

				local function updateBarVisual()
					root.BackgroundColor3 = self.getSelectedTheme().ElementBackground
					stroke.Color = self.getSelectedTheme().ElementStroke
					title.TextColor3 = self.getSelectedTheme().TextColor
					statusLabel.TextColor3 = self.getSelectedTheme().LoadingText or self.getSelectedTheme().TextColor
					statusLabel.Visible = showLabel
					if showLabel then
						statusLabel.Text = formatLabelText()
					end
					track.BackgroundColor3 = self.getSelectedTheme().LoadingTrack or self.getSelectedTheme().SliderBackground
					fill.BackgroundColor3 = self.getSelectedTheme().LoadingBar or self.getSelectedTheme().SliderProgress
					chunk.BackgroundColor3 = self.getSelectedTheme().LoadingBar or self.getSelectedTheme().SliderProgress
					fill.Visible = mode == "determinate"
					chunk.Visible = mode == "indeterminate" and running == true
					if mode == "determinate" then
						fill.Size = UDim2.new(progress, 0, 1, 0)
					end
				end

				local function stepBar(deltaTime)
					if mode ~= "indeterminate" or running ~= true then
						return
					end
					local trackWidth = math.max(1, track.AbsoluteSize.X)
					local chunkWidth = math.max(8, math.floor(trackWidth * chunkScale))
					chunk.Size = UDim2.new(0, chunkWidth, 1, 0)
					animationPhase = (animationPhase + (deltaTime * speed)) % 2
					local t = animationPhase
					if t > 1 then
						t = 2 - t
					end
					local usableWidth = math.max(0, trackWidth - chunkWidth)
					local x = math.floor(usableWidth * t + 0.5)
					chunk.Position = UDim2.new(0, x, 0, 0)
				end

				function loadingBar:Start(persist)
					if mode ~= "indeterminate" then
						return false, "Start is available only in indeterminate mode."
					end
					if running == true then
						startRenderLoop(loopState, stepBar)
						return true, "already_running"
					end
					running = true
					startRenderLoop(loopState, stepBar)
					updateBarVisual()
					emitStateChanged(persist ~= false)
					return true, "ok"
				end

				function loadingBar:Stop(persist)
					if running ~= true then
						stopRenderLoop(loopState)
						return true, "already_stopped"
					end
					running = false
					stopRenderLoop(loopState)
					updateBarVisual()
					emitStateChanged(persist ~= false)
					return true, "ok"
				end

				function loadingBar:IsRunning()
					return mode == "indeterminate" and running == true and loopState.Connection ~= nil
				end

				function loadingBar:SetMode(nextMode, persist)
					local normalized = tostring(nextMode or ""):lower()
					if normalized ~= "indeterminate" and normalized ~= "determinate" then
						return false, "Invalid mode."
					end
					mode = normalized
					if mode ~= "indeterminate" then
						running = false
						stopRenderLoop(loopState)
					end
					updateBarVisual()
					emitStateChanged(persist ~= false)
					return true, "ok"
				end

				function loadingBar:GetMode()
					return mode
				end

				function loadingBar:SetProgress(nextProgress, persist)
					progress = clampNumber(nextProgress, 0, 1, progress)
					if mode ~= "determinate" then
						mode = "determinate"
						running = false
						stopRenderLoop(loopState)
					end
					updateBarVisual()
					emitStateChanged(persist ~= false)
					return true, "ok"
				end

				function loadingBar:GetProgress()
					return progress
				end

				function loadingBar:SetSpeed(nextSpeed, persist)
					speed = clampNumber(nextSpeed, 0.1, 6, speed)
					emitStateChanged(persist ~= false)
					return true, "ok"
				end

				function loadingBar:SetLabel(text, persist)
					if not showLabel then
						return false, "ShowLabel is disabled."
					end
					customLabel = tostring(text or "")
					updateBarVisual()
					emitStateChanged(persist ~= false)
					return true, "ok"
				end

				function loadingBar:GetPersistValue()
					return getStateSnapshot()
				end

				function loadingBar:Set(value)
					if type(value) ~= "table" then
						return
					end
					if value.mode ~= nil then
						local normalized = tostring(value.mode):lower()
						if normalized == "indeterminate" or normalized == "determinate" then
							mode = normalized
						end
					end
					if value.speed ~= nil then
						speed = clampNumber(value.speed, 0.1, 6, speed)
					end
					if value.chunkScale ~= nil then
						chunkScale = clampNumber(value.chunkScale, 0.1, 0.8, chunkScale)
					end
					if value.progress ~= nil then
						progress = clampNumber(value.progress, 0, 1, progress)
					end
					if value.label ~= nil then
						customLabel = tostring(value.label or "")
					end
					if value.running == true and mode == "indeterminate" then
						running = true
					elseif value.running == false or mode ~= "indeterminate" then
						running = false
					end
					updateBarVisual()
					if mode == "indeterminate" and running == true then
						startRenderLoop(loopState, stepBar)
					else
						stopRenderLoop(loopState)
					end
					emitStateChanged(false)
				end

				function loadingBar:Destroy()
					stopRenderLoop(loopState)
					root:Destroy()
				end

				connectThemeRefresh(function()
					updateBarVisual()
				end)

				resolveElementParentFromSettings(loadingBar, settingsValue)
				updateBarVisual()
				if mode == "indeterminate" and running == true then
					startRenderLoop(loopState, stepBar)
				end
				addExtendedAPI(loadingBar, loadingBar.Name, "LoadingBar", root)
				if Settings.ConfigurationSaving and Settings.ConfigurationSaving.Enabled and loadingBar.Flag then
					self.RayfieldLibrary.Flags[loadingBar.Flag] = loadingBar
				end
				return loadingBar
			end

			-- Divider
			function Tab:CreateDivider()
				local DividerValue = {}
	
				local Divider = self.Elements.Template.Divider:Clone()
				Divider.Visible = true
				Divider.Parent = TabPage
	
				Divider.Divider.BackgroundTransparency = 1
				self.Animation:Create(Divider.Divider, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0.85}):Play()
	
				function DividerValue:Set(Value)
					Divider.Visible = Value
				end
	
				function DividerValue:Destroy()
					Divider:Destroy()
				end
	
				-- Add extended API
				addExtendedAPI(DividerValue, "Divider", "Divider", Divider)
	
				return DividerValue
			end
	
			-- Label
			function Tab:CreateLabel(LabelText, Icon, Color, IgnoreTheme)
				local LabelValue = {}
	
				local Label = self.Elements.Template.Label:Clone()
				Label.Title.Text = LabelText
				Label.Visible = true
				Label.Parent = TabPage
	
				Label.BackgroundColor3 = Color or self.getSelectedTheme().SecondaryElementBackground
				Label.UIStroke.Color = Color or self.getSelectedTheme().SecondaryElementStroke
	
				if Icon then
					if typeof(Icon) == 'string' and self.Icons then
						local asset = self.getIcon(Icon)
	
						Label.Icon.Image = 'rbxassetid://'..asset.id
						Label.Icon.ImageRectOffset = asset.imageRectOffset
						Label.Icon.ImageRectSize = asset.imageRectSize
					else
						Label.Icon.Image = self.getAssetUri(Icon)
					end
				else
					Label.Icon.Image = "rbxassetid://" .. 0
				end
	
				if Icon and Label:FindFirstChild('Icon') then
					Label.Title.Position = UDim2.new(0, 45, 0.5, 0)
					Label.Title.Size = UDim2.new(1, -100, 0, 14)
	
					if Icon then
						if typeof(Icon) == 'string' and self.Icons then
							local asset = self.getIcon(Icon)
	
							Label.Icon.Image = 'rbxassetid://'..asset.id
							Label.Icon.ImageRectOffset = asset.imageRectOffset
							Label.Icon.ImageRectSize = asset.imageRectSize
						else
							Label.Icon.Image = self.getAssetUri(Icon)
						end
					else
						Label.Icon.Image = "rbxassetid://" .. 0
					end
	
					Label.Icon.Visible = true
				end
	
				Label.Icon.ImageTransparency = 1
				Label.BackgroundTransparency = 1
				Label.UIStroke.Transparency = 1
				Label.Title.TextTransparency = 1
	
				self.Animation:Create(Label, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {BackgroundTransparency = Color and 0.8 or 0}):Play()
				self.Animation:Create(Label.UIStroke, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {Transparency = Color and 0.7 or 0}):Play()
				self.Animation:Create(Label.Icon, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {ImageTransparency = 0.2}):Play()
				self.Animation:Create(Label.Title, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {TextTransparency = Color and 0.2 or 0}):Play()	
	
				function LabelValue:Set(NewLabel, Icon, Color)
					Label.Title.Text = NewLabel
	
					if Color then
						Label.BackgroundColor3 = Color or self.getSelectedTheme().SecondaryElementBackground
						Label.UIStroke.Color = Color or self.getSelectedTheme().SecondaryElementStroke
					end
	
					if Icon and Label:FindFirstChild('Icon') then
						Label.Title.Position = UDim2.new(0, 45, 0.5, 0)
						Label.Title.Size = UDim2.new(1, -100, 0, 14)
	
						if Icon then
							if typeof(Icon) == 'string' and self.Icons then
								local asset = self.getIcon(Icon)
	
								Label.Icon.Image = 'rbxassetid://'..asset.id
								Label.Icon.ImageRectOffset = asset.imageRectOffset
								Label.Icon.ImageRectSize = asset.imageRectSize
							else
								Label.Icon.Image = self.getAssetUri(Icon)
							end
						else
							Label.Icon.Image = "rbxassetid://" .. 0
						end
	
						Label.Icon.Visible = true
					end
				end
	
				self.Rayfield.Main:GetPropertyChangedSignal('BackgroundColor3'):Connect(function()
					Label.BackgroundColor3 = IgnoreTheme and (Color or Label.BackgroundColor3) or self.getSelectedTheme().SecondaryElementBackground
					Label.UIStroke.Color = IgnoreTheme and (Color or Label.BackgroundColor3) or self.getSelectedTheme().SecondaryElementStroke
				end)
	
				function LabelValue:Destroy()
					Label:Destroy()
				end
	
				-- Add extended API
				addExtendedAPI(LabelValue, LabelText, "Label", Label)
	
				return LabelValue
			end
	
			-- Paragraph
			function Tab:CreateParagraph(ParagraphSettings)
				local ParagraphValue = {}
	
				local Paragraph = self.Elements.Template.Paragraph:Clone()
				Paragraph.Title.Text = ParagraphSettings.Title
				Paragraph.Content.Text = ParagraphSettings.Content
				Paragraph.Visible = true
				Paragraph.Parent = TabPage
	
				Paragraph.BackgroundTransparency = 1
				Paragraph.UIStroke.Transparency = 1
				Paragraph.Title.TextTransparency = 1
				Paragraph.Content.TextTransparency = 1
	
				Paragraph.BackgroundColor3 = self.getSelectedTheme().SecondaryElementBackground
				Paragraph.UIStroke.Color = self.getSelectedTheme().SecondaryElementStroke
	
				self.Animation:Create(Paragraph, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0}):Play()
				self.Animation:Create(Paragraph.UIStroke, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {Transparency = 0}):Play()
				self.Animation:Create(Paragraph.Title, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {TextTransparency = 0}):Play()
				self.Animation:Create(Paragraph.Content, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {TextTransparency = 0}):Play()
	
				function ParagraphValue:Set(NewParagraphSettings)
					Paragraph.Title.Text = NewParagraphSettings.Title
					Paragraph.Content.Text = NewParagraphSettings.Content
				end
	
				self.Rayfield.Main:GetPropertyChangedSignal('BackgroundColor3'):Connect(function()
					Paragraph.BackgroundColor3 = self.getSelectedTheme().SecondaryElementBackground
					Paragraph.UIStroke.Color = self.getSelectedTheme().SecondaryElementStroke
				end)
	
				function ParagraphValue:Destroy()
					Paragraph:Destroy()
				end
	
				-- Add extended API
				addExtendedAPI(ParagraphValue, ParagraphSettings.Title, "Paragraph", Paragraph)
	
				return ParagraphValue
			end
	
			-- Input
			function Tab:CreateInput(InputSettings)
				local ctx = self
				InputSettings = InputSettings or {}
				if type(InputSettings.Callback) ~= "function" then
					InputSettings.Callback = function() end
				end
				InputSettings.CurrentValue = tostring(InputSettings.CurrentValue or "")

				local Input = self.Elements.Template.Input:Clone()
				Input.Name = InputSettings.Name
				Input.Title.Text = InputSettings.Name
				Input.Visible = true
				Input.Parent = TabPage
	
				Input.BackgroundTransparency = 1
				Input.UIStroke.Transparency = 1
				Input.Title.TextTransparency = 1

				Input.InputFrame.InputBox.Text = InputSettings.CurrentValue

				self.bindTheme(Input.InputFrame, "BackgroundColor3", "InputBackground")
				self.bindTheme(Input.InputFrame.UIStroke, "Color", "InputStroke")
	
				self.Animation:Create(Input, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0}):Play()
				self.Animation:Create(Input.UIStroke, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {Transparency = 0}):Play()
				self.Animation:Create(Input.Title, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {TextTransparency = 0}):Play()	
	
				Input.InputFrame.InputBox.PlaceholderText = InputSettings.PlaceholderText
				local function resizeInputFrame()
					self.Animation:Create(
						Input.InputFrame,
						TweenInfo.new(0.55, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out),
						{Size = UDim2.new(0, Input.InputFrame.InputBox.TextBounds.X + 24, 0, 30)}
					):Play()
				end
				resizeInputFrame()

				local function handleInputCallbackError(response)
					self.Animation:Create(Input, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = Color3.fromRGB(85, 0, 0)}):Play()
					self.Animation:Create(Input.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 1}):Play()
					Input.Title.Text = "Callback Error"
					print("Rayfield | "..InputSettings.Name.." Callback Error " ..tostring(response))
					warn('Check docs.sirius.menu for help with Rayfield specific development.')
					task.wait(0.5)
					Input.Title.Text = InputSettings.Name
					self.Animation:Create(Input, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackground}):Play()
					self.Animation:Create(Input.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 0}):Play()
				end

				local inputSyncToken = registerElementSync({
					name = InputSettings.Name,
					getState = function()
						return tostring(InputSettings.CurrentValue or "")
					end,
					normalize = function(rawText)
						local normalized = rawText
						if elementSync and elementSync.normalize and elementSync.normalize.text then
							normalized = elementSync.normalize.text(rawText, {
								default = "",
								trim = false
							})
						else
							normalized = tostring(rawText or "")
						end
						return normalized, {
							changed = tostring(InputSettings.CurrentValue or "") ~= normalized
						}
					end,
					applyVisual = function(value)
						InputSettings.CurrentValue = value
						local isFocused = false
						local focusOk, focusState = pcall(function()
							return Input.InputFrame.InputBox:IsFocused()
						end)
						if focusOk and focusState then
							isFocused = true
						end
						if not isFocused then
							Input.InputFrame.InputBox.Text = value
						end
						resizeInputFrame()
					end,
					emitCallback = function(value)
						InputSettings.Callback(value)
					end,
					persist = function()
						ctx.SaveConfiguration()
					end,
					isExt = function()
						return InputSettings.Ext == true
					end,
					isAlive = function()
						return Input ~= nil and Input.Parent ~= nil
					end,
					isVisibleContext = function()
						return Input.Visible and Input:IsDescendantOf(TabPage) and self.Elements.UIPageLayout.CurrentPage == TabPage
					end,
					onCallbackError = handleInputCallbackError
				})

				local function commitInput(rawText, commitOptions)
					local options = commitOptions or {}
					if inputSyncToken then
						return commitElementSync(inputSyncToken, rawText, {
							reason = options.reason or "input_update",
							source = options.source or "unknown",
							emitCallback = options.emitCallback,
							persist = options.persist,
							forceCallback = options.forceCallback
						})
					end

					local normalized = tostring(rawText or "")
					InputSettings.CurrentValue = normalized
					Input.InputFrame.InputBox.Text = normalized
					resizeInputFrame()
					local success, response = pcall(function()
						InputSettings.Callback(normalized)
					end)
					if not success then
						handleInputCallbackError(response)
					elseif not InputSettings.Ext then
						ctx.SaveConfiguration()
					end
					return success, {
						normalized = normalized,
						changed = true,
						fallbackApplied = false,
						callbackOk = success
					}
				end

				Input.InputFrame.InputBox.FocusLost:Connect(function()
					commitInput(Input.InputFrame.InputBox.Text, {
						reason = "focus_lost",
						source = "user_input",
						emitCallback = true,
						persist = true,
						forceCallback = true
					})

					if InputSettings.RemoveTextAfterFocusLost then
						Input.InputFrame.InputBox.Text = ""
						resizeInputFrame()
					end
				end)
	
				local inputHoverBindingKey = registerHoverBinding(Input,
					function()
						self.Animation:Create(Input, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackgroundHover}):Play()
					end,
					function()
						self.Animation:Create(Input, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackground}):Play()
					end
				)
	
				Input.InputFrame.InputBox:GetPropertyChangedSignal("Text"):Connect(function()
					resizeInputFrame()
				end)
	
				function InputSettings:Set(text)
					commitInput(text, {
						reason = "set",
						source = "api_set",
						emitCallback = true,
						persist = true,
						forceCallback = true
					})
				end
	
				if Settings.ConfigurationSaving then
					if Settings.ConfigurationSaving.Enabled and InputSettings.Flag then
						self.RayfieldLibrary.Flags[InputSettings.Flag] = InputSettings
					end
				end
	
				self.Rayfield.Main:GetPropertyChangedSignal('BackgroundColor3'):Connect(function()
					Input.InputFrame.BackgroundColor3 = self.getSelectedTheme().InputBackground
					Input.InputFrame.UIStroke.Color = self.getSelectedTheme().InputStroke
				end)
	
				function InputSettings:Destroy()
					Input:Destroy()
				end

				-- Add extended API
				addExtendedAPI(InputSettings, InputSettings.Name, "Input", Input, inputHoverBindingKey, inputSyncToken)

				return InputSettings
			end
	
			-- Dropdown
			function Tab:CreateDropdown(DropdownSettings)
				local ctx = self
				local Dropdown = self.Elements.Template.Dropdown:Clone()
				local dropdownAnimatedOptionLimit = 24
				if type(self.getSetting) == "function" then
					local okLimit, configuredLimit = pcall(self.getSetting, "Performance", "dropdownAnimatedOptionLimit")
					if okLimit and type(configuredLimit) == "number" then
						dropdownAnimatedOptionLimit = math.clamp(math.floor(configuredLimit), 4, 128)
					end
				end
				if self.useMobileSizing then
					dropdownAnimatedOptionLimit = math.min(dropdownAnimatedOptionLimit, 12)
				end
				local function normalizeDropdownOptions(rawOptions)
					local normalized = {}
					if type(rawOptions) ~= "table" then
						if rawOptions ~= nil then
							table.insert(normalized, tostring(rawOptions))
						end
						return normalized
					end
					if #rawOptions > 0 then
						for _, option in ipairs(rawOptions) do
							if option ~= nil then
								table.insert(normalized, tostring(option))
							end
						end
						return normalized
					end
					for _, option in pairs(rawOptions) do
						if option ~= nil then
							table.insert(normalized, tostring(option))
						end
					end
					return normalized
				end

				DropdownSettings.Options = normalizeDropdownOptions(DropdownSettings.Options)
				DropdownSettings.ClearBehavior = tostring(DropdownSettings.ClearBehavior or DropdownSettings.SelectionFallback or "default"):lower()
				if DropdownSettings.ClearBehavior ~= "default" and DropdownSettings.ClearBehavior ~= "none" then
					DropdownSettings.ClearBehavior = "default"
				end
				DropdownSettings.SearchEnabled = DropdownSettings.SearchEnabled == true
				DropdownSettings.SearchPlaceholder = tostring(DropdownSettings.SearchPlaceholder or "Search...")
				DropdownSettings.ResetSearchOnRefresh = DropdownSettings.ResetSearchOnRefresh ~= false
				if type(DropdownSettings.Callback) ~= "function" then
					DropdownSettings.Callback = function() end
				end

				local function containsDropdownOption(optionName)
					for _, option in ipairs(DropdownSettings.Options) do
						if option == optionName then
							return true
						end
					end
					return false
				end

				local function toSelectionArray(rawSelection)
					local normalized = {}
					if rawSelection == nil then
						return normalized
					end

					if type(rawSelection) == "string" then
						table.insert(normalized, rawSelection)
						return normalized
					end

					if type(rawSelection) ~= "table" then
						table.insert(normalized, tostring(rawSelection))
						return normalized
					end

					if #rawSelection > 0 then
						for _, option in ipairs(rawSelection) do
							if option ~= nil then
								table.insert(normalized, tostring(option))
							end
						end
					else
						for _, option in pairs(rawSelection) do
							if option ~= nil then
								table.insert(normalized, tostring(option))
							end
						end
					end

					return normalized
				end

				local function cloneSelection(selection)
					local cloned = {}
					if type(selection) ~= "table" then
						return cloned
					end
					for _, option in ipairs(selection) do
						table.insert(cloned, option)
					end
					return cloned
				end

				local function selectionEquals(leftSelection, rightSelection)
					if type(leftSelection) ~= "table" or type(rightSelection) ~= "table" then
						return false
					end
					if #leftSelection ~= #rightSelection then
						return false
					end
					for index, value in ipairs(leftSelection) do
						if rightSelection[index] ~= value then
							return false
						end
					end
					return true
				end

				local function getDefaultSelection()
					local defaultRaw = DropdownSettings.DefaultSelection
					if defaultRaw == nil then
						defaultRaw = DropdownSettings.DefaultOption
					end

					local defaults = {}
					for _, optionName in ipairs(toSelectionArray(defaultRaw)) do
						if containsDropdownOption(optionName) then
							table.insert(defaults, optionName)
						end
					end

					if not DropdownSettings.MultipleOptions then
						if defaults[1] then
							return { defaults[1] }
						end
						return {}
					end

					return defaults
				end

				local function normalizeSelection(rawSelection, allowDefaultFallback)
					local normalized = {}
					local dedupe = {}

					for _, optionName in ipairs(toSelectionArray(rawSelection)) do
						if containsDropdownOption(optionName) and not dedupe[optionName] then
							dedupe[optionName] = true
							table.insert(normalized, optionName)
						end
					end

					if not DropdownSettings.MultipleOptions and #normalized > 1 then
						normalized = { normalized[1] }
					end

					local fallbackApplied = false
					if allowDefaultFallback and #normalized == 0 and DropdownSettings.ClearBehavior ~= "none" then
						local fallback = getDefaultSelection()
						if #fallback > 0 then
							normalized = fallback
							fallbackApplied = true
						end
					end

					return normalized, fallbackApplied
				end

				local function updateSelectedText()
					if DropdownSettings.MultipleOptions then
						if #DropdownSettings.CurrentOption == 1 then
							Dropdown.Selected.Text = DropdownSettings.CurrentOption[1]
						elseif #DropdownSettings.CurrentOption == 0 then
							Dropdown.Selected.Text = "None"
						else
							Dropdown.Selected.Text = "Various"
						end
					else
						Dropdown.Selected.Text = DropdownSettings.CurrentOption[1] or "None"
					end
				end

				local function updateOptionVisuals(animated)
					local processed = 0
					for _, droption in ipairs(Dropdown.List:GetChildren()) do
						if droption.ClassName == "Frame" and droption.Name ~= "Placeholder" and droption.Name ~= "Template" then
							processed += 1
							local targetColor = table.find(DropdownSettings.CurrentOption, droption.Name) and self.getSelectedTheme().DropdownSelected or self.getSelectedTheme().DropdownUnselected
							if animated and processed <= dropdownAnimatedOptionLimit then
								self.Animation:Create(droption, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {BackgroundColor3 = targetColor}):Play()
							else
								droption.BackgroundColor3 = targetColor
							end
						end
					end
				end

				local function handleSelectionCallbackError(response)
					self.Animation:Create(Dropdown, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = Color3.fromRGB(85, 0, 0)}):Play()
					self.Animation:Create(Dropdown.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 1}):Play()
					Dropdown.Title.Text = "Callback Error"
					print("Rayfield | "..DropdownSettings.Name.." Callback Error " ..tostring(response))
					warn('Check docs.sirius.menu for help with Rayfield specific development.')
					task.wait(0.5)
					Dropdown.Title.Text = DropdownSettings.Name
					self.Animation:Create(Dropdown, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackground}):Play()
					self.Animation:Create(Dropdown.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 0}):Play()
				end

				local function emitSelectionNormalized(reason, fallbackApplied, changed)
					if type(DropdownSettings.OnSelectionNormalized) == "function" then
						local okMeta, metaErr = pcall(DropdownSettings.OnSelectionNormalized, DropdownSettings.CurrentOption, {
							reason = reason,
							fallbackApplied = fallbackApplied,
							changed = changed
						})
						if not okMeta then
							warn("Rayfield | Dropdown OnSelectionNormalized Error " .. tostring(metaErr))
						end
					end
				end

				local dropdownSyncToken = registerElementSync({
					name = DropdownSettings.Name,
					getState = function()
						return cloneSelection(DropdownSettings.CurrentOption)
					end,
					normalize = function(rawSelection, syncMeta)
						local options = (syncMeta and syncMeta.options) or {}
						local normalizedSelection, fallbackApplied = normalizeSelection(rawSelection, options.allowDefaultFallback ~= false)
						return normalizedSelection, {
							changed = not selectionEquals(DropdownSettings.CurrentOption, normalizedSelection),
							fallbackApplied = fallbackApplied
						}
					end,
					applyVisual = function(normalizedSelection, syncMeta)
						DropdownSettings.CurrentOption = cloneSelection(normalizedSelection)
						local animated = syncMeta and syncMeta.options and syncMeta.options.animatedVisuals == true
						updateSelectedText()
						updateOptionVisuals(animated)
						emitSelectionNormalized(
							(syncMeta and syncMeta.reason) or "unknown",
							syncMeta and syncMeta.fallbackApplied == true,
							syncMeta and syncMeta.changed == true
						)
					end,
					emitCallback = function(normalizedSelection)
						DropdownSettings.Callback(cloneSelection(normalizedSelection))
					end,
					persist = function()
						self.SaveConfiguration()
					end,
					isExt = function()
						return DropdownSettings.Ext == true
					end,
					isAlive = function()
						return Dropdown ~= nil and Dropdown.Parent ~= nil
					end,
					isVisibleContext = function()
						return Dropdown.Visible and Dropdown:IsDescendantOf(TabPage) and self.Elements.UIPageLayout.CurrentPage == TabPage
					end,
					onCallbackError = handleSelectionCallbackError
				})

				local function commitSelection(rawSelection, commitOptions)
					local options = commitOptions or {}
					if dropdownSyncToken then
						local callbackOk, result = commitElementSync(dropdownSyncToken, rawSelection, {
							reason = options.reason or "selection_update",
							source = options.source or "unknown",
							emitCallback = options.emitCallback,
							persist = options.persist,
							forceCallback = options.forceCallback,
							allowDefaultFallback = options.allowDefaultFallback,
							animatedVisuals = options.animatedVisuals
						})
						if type(result) == "table" then
							return result.changed == true, result.fallbackApplied == true, callbackOk
						end
						-- Fail-safe: if element-sync pipeline is unavailable, keep dropdown state/visual consistent locally.
					end

					local previousSelection = cloneSelection(DropdownSettings.CurrentOption)
					local normalizedSelection, fallbackApplied = normalizeSelection(rawSelection, options.allowDefaultFallback ~= false)
					DropdownSettings.CurrentOption = normalizedSelection
					local changed = not selectionEquals(previousSelection, normalizedSelection)
					updateSelectedText()
					updateOptionVisuals(options.animatedVisuals == true)
					emitSelectionNormalized(options.reason or "unknown", fallbackApplied, changed)

					local callbackSuccess, response = pcall(function()
						DropdownSettings.Callback(DropdownSettings.CurrentOption)
					end)
					if not callbackSuccess then
						handleSelectionCallbackError(response)
					elseif not DropdownSettings.Ext and options.persist ~= false then
						self.SaveConfiguration()
					end
					return changed, fallbackApplied, callbackSuccess
				end
				if string.find(DropdownSettings.Name,"closed") then
					Dropdown.Name = "Dropdown"
				else
					Dropdown.Name = DropdownSettings.Name
				end
				Dropdown.Title.Text = DropdownSettings.Name
				Dropdown.Visible = true
				Dropdown.Parent = TabPage
	
				Dropdown.Size = UDim2.new(1, -10, 0, 45)
				Dropdown.List.Visible = false
				Dropdown.List.ScrollBarImageTransparency = 1
				local searchQuery = ""
				local searchFrame = nil
				local searchBox = nil
				local initialSelection = DropdownSettings.CurrentOption
				DropdownSettings.CurrentOption = {}
				commitSelection(initialSelection, {
					emitCallback = false,
					persist = false,
					forceCallback = false,
					reason = "initial"
				})

				self.bindTheme(Dropdown.Toggle, "ImageColor3", "TextColor")

				local dropdownThemeConnection = nil

				local function forEachDropdownOption(callback)
					for _, optionObject in ipairs(Dropdown.List:GetChildren()) do
						if optionObject.ClassName == "Frame" and optionObject.Name ~= "Placeholder" and optionObject.Name ~= "Template" then
							callback(optionObject)
						end
					end
				end

				local function optionMatchesSearch(optionName)
					if not DropdownSettings.SearchEnabled then
						return true
					end
					local needle = string.lower(tostring(searchQuery or ""))
					if needle == "" then
						return true
					end
					return string.find(string.lower(tostring(optionName or "")), needle, 1, true) ~= nil
				end

				local function applyDropdownOptionThemeColors(animated)
					local theme = self.getSelectedTheme()
					forEachDropdownOption(function(droption)
						local isSelected = table.find(DropdownSettings.CurrentOption, droption.Name) ~= nil
						local targetColor = isSelected and theme.DropdownSelected or theme.DropdownUnselected
						if animated then
							self.Animation:Create(droption, TweenInfo.new(0.25, Enum.EasingStyle.Exponential), {BackgroundColor3 = targetColor}):Play()
						else
							droption.BackgroundColor3 = targetColor
						end
						if droption:FindFirstChild("UIStroke") then
							droption.UIStroke.Color = theme.ElementStroke
						end
					end)
				end

				local function animateDropdownOptionVisibility(showOptions)
					local processed = 0
					forEachDropdownOption(function(droption)
						if not droption.Visible then
							return
						end
						processed += 1
						local animateOption = processed <= dropdownAnimatedOptionLimit
						local stroke = droption:FindFirstChild("UIStroke")
						local title = droption:FindFirstChild("Title")
						local targetBackgroundTransparency = showOptions and 0 or 1
						local targetStrokeTransparency = showOptions and 0 or 1
						local targetTitleTransparency = showOptions and 0 or 1
						if showOptions and droption.Name == Dropdown.Selected.Text then
							targetStrokeTransparency = 1
						end

						if animateOption then
							self.Animation:Create(droption, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {BackgroundTransparency = targetBackgroundTransparency}):Play()
							if stroke then
								self.Animation:Create(stroke, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {Transparency = targetStrokeTransparency}):Play()
							end
							if title then
								self.Animation:Create(title, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {TextTransparency = targetTitleTransparency}):Play()
							end
						else
							droption.BackgroundTransparency = targetBackgroundTransparency
							if stroke then
								stroke.Transparency = targetStrokeTransparency
							end
							if title then
								title.TextTransparency = targetTitleTransparency
							end
						end
					end)
				end

				local function getVisibleOptionCount()
					local count = 0
					forEachDropdownOption(function(droption)
						if droption.Visible ~= false then
							count += 1
						end
					end)
					return count
				end

				local function applySearchFilter()
					forEachDropdownOption(function(droption)
						droption.Visible = optionMatchesSearch(droption.Name)
					end)
					if Dropdown.List.Visible then
						animateDropdownOptionVisibility(true)
						local visibleCount = getVisibleOptionCount()
						local targetHeight = math.clamp((visibleCount * 30) + (DropdownSettings.SearchEnabled and 70 or 45), 90, 220)
						self.Animation:Create(Dropdown, TweenInfo.new(0.2, Enum.EasingStyle.Exponential), {Size = UDim2.new(1, -10, 0, targetHeight)}):Play()
					end
				end
	
				Dropdown.Toggle.Rotation = 180

				if DropdownSettings.SearchEnabled then
					searchFrame = Instance.new("Frame")
					searchFrame.Name = "SearchFrame"
					searchFrame.BackgroundColor3 = self.getSelectedTheme().InputBackground
					searchFrame.BorderSizePixel = 0
					searchFrame.Position = UDim2.new(0, 6, 0, 44)
					searchFrame.Size = UDim2.new(1, -12, 0, 22)
					searchFrame.Visible = false
					searchFrame.Parent = Dropdown

					local searchCorner = Instance.new("UICorner")
					searchCorner.CornerRadius = UDim.new(0, 5)
					searchCorner.Parent = searchFrame

					local searchStroke = Instance.new("UIStroke")
					searchStroke.Color = self.getSelectedTheme().InputStroke
					searchStroke.Transparency = 0.2
					searchStroke.Parent = searchFrame

					searchBox = Instance.new("TextBox")
					searchBox.Name = "SearchBox"
					searchBox.BackgroundTransparency = 1
					searchBox.ClearTextOnFocus = false
					searchBox.Size = UDim2.new(1, -10, 1, 0)
					searchBox.Position = UDim2.new(0, 6, 0, 0)
					searchBox.TextXAlignment = Enum.TextXAlignment.Left
					searchBox.Font = Enum.Font.Gotham
					searchBox.TextSize = 12
					searchBox.PlaceholderText = DropdownSettings.SearchPlaceholder
					searchBox.TextColor3 = self.getSelectedTheme().TextColor
					searchBox.PlaceholderColor3 = self.getSelectedTheme().PlaceholderColor or self.getSelectedTheme().TextColor
					searchBox.Text = ""
					searchBox.Parent = searchFrame

					searchBox:GetPropertyChangedSignal("Text"):Connect(function()
						searchQuery = tostring(searchBox.Text or "")
						applySearchFilter()
					end)
				end

				Dropdown.Interact.MouseButton1Click:Connect(function()
					self.Animation:Create(Dropdown, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackgroundHover}):Play()
					self.Animation:Create(Dropdown.UIStroke, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {Transparency = 1}):Play()
					task.wait(0.1)
					self.Animation:Create(Dropdown, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackground}):Play()
					self.Animation:Create(Dropdown.UIStroke, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {Transparency = 0}):Play()
					if self.getDebounce() then return end
					if Dropdown.List.Visible then
						self.setDebounce(true)
						if searchFrame then
							searchFrame.Visible = false
						end
						self.Animation:Create(Dropdown, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {Size = UDim2.new(1, -10, 0, 45)}):Play()
						animateDropdownOptionVisibility(false)
						self.Animation:Create(Dropdown.List, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {ScrollBarImageTransparency = 1}):Play()
						self.Animation:Create(Dropdown.Toggle, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {Rotation = 180}):Play()
						task.wait(0.35)
						Dropdown.List.Visible = false
						self.setDebounce(false)
					else
						local visibleCount = math.max(1, getVisibleOptionCount())
						local targetHeight = math.clamp((visibleCount * 30) + (DropdownSettings.SearchEnabled and 70 or 45), 90, 220)
						self.Animation:Create(Dropdown, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {Size = UDim2.new(1, -10, 0, targetHeight)}):Play()
						Dropdown.List.Visible = true
						if searchFrame then
							searchFrame.Visible = true
						end
						self.Animation:Create(Dropdown.List, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {ScrollBarImageTransparency = 0.7}):Play()
						self.Animation:Create(Dropdown.Toggle, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {Rotation = 0}):Play()	
						animateDropdownOptionVisibility(true)
					end
				end)
	
				local dropdownHoverBindingKey = registerHoverBinding(Dropdown,
					function()
						if not Dropdown.List.Visible then
							self.Animation:Create(Dropdown, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackgroundHover}):Play()
						end
					end,
					function()
						self.Animation:Create(Dropdown, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackground}):Play()
					end
				)
	
				local function SetDropdownOptions()
					local listTemplate = Dropdown.List:FindFirstChild("Template")
					if not listTemplate then
						warn("Rayfield | Dropdown template not found for " .. tostring(DropdownSettings.Name))
						return
					end

					for _, optionObject in ipairs(Dropdown.List:GetChildren()) do
						if optionObject.ClassName == "Frame" and optionObject.Name ~= "Placeholder" and optionObject.Name ~= "Template" then
							optionObject:Destroy()
						end
					end

					for _, Option in ipairs(DropdownSettings.Options) do
						local optionName = tostring(Option)
						local DropdownOption = listTemplate:Clone()
						DropdownOption.Name = optionName
						DropdownOption.Title.Text = optionName
						DropdownOption.Parent = Dropdown.List
						DropdownOption.Visible = true
	
						DropdownOption.BackgroundTransparency = 1
						DropdownOption.UIStroke.Transparency = 1
						DropdownOption.Title.TextTransparency = 1
	
						--local Dropdown = Tab:CreateDropdown({
						--	Name = "Dropdown Example",
						--	Options = {"Option 1","Option 2"},
						--	CurrentOption = {"Option 1"},
						--  MultipleOptions = true,
						--	Flag = "Dropdown1",
						--	Callback = function(TableOfOptions)
	
						--	end,
						--})
	
	
						DropdownOption.Interact.ZIndex = 50
						DropdownOption.Interact.MouseButton1Click:Connect(function()
							local nextSelection = cloneSelection(DropdownSettings.CurrentOption)
							local selectedIndex = table.find(nextSelection, optionName)
							local wasSelected = selectedIndex ~= nil

							if not DropdownSettings.MultipleOptions and wasSelected then 
								return
							end

							if selectedIndex then
								table.remove(nextSelection, selectedIndex)
							else
								if not DropdownSettings.MultipleOptions then
									table.clear(nextSelection)
								end
								table.insert(nextSelection, optionName)
								self.Animation:Create(DropdownOption.UIStroke, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {Transparency = 1}):Play()
								self.Animation:Create(DropdownOption, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().DropdownSelected}):Play()
								self.setDebounce(true)
							end

							commitSelection(nextSelection, {
								emitCallback = true,
								persist = true,
								forceCallback = true,
								reason = "option_click",
								animatedVisuals = true
							})

							if not DropdownSettings.MultipleOptions then
								task.wait(0.1)
								if searchFrame then
									searchFrame.Visible = false
								end
								self.Animation:Create(Dropdown, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {Size = UDim2.new(1, -10, 0, 45)}):Play()
								animateDropdownOptionVisibility(false)
								self.Animation:Create(Dropdown.List, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {ScrollBarImageTransparency = 1}):Play()
								self.Animation:Create(Dropdown.Toggle, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {Rotation = 180}):Play()
								task.wait(0.35)
								Dropdown.List.Visible = false
							end
							self.setDebounce(false)
						end)

						DropdownOption.Visible = optionMatchesSearch(optionName)

						DropdownOption.BackgroundColor3 = self.getSelectedTheme().DropdownUnselected
						DropdownOption.UIStroke.Color = self.getSelectedTheme().ElementStroke
					end
				end
				SetDropdownOptions()
				applySearchFilter()
				applyDropdownOptionThemeColors(false)

				dropdownThemeConnection = self.Rayfield.Main:GetPropertyChangedSignal("BackgroundColor3"):Connect(function()
					if not Dropdown or not Dropdown.Parent then
						if dropdownThemeConnection then
							dropdownThemeConnection:Disconnect()
							dropdownThemeConnection = nil
						end
						return
					end
					Dropdown.Toggle.ImageColor3 = self.getSelectedTheme().TextColor
					if not Dropdown.List.Visible then
						Dropdown.BackgroundColor3 = self.getSelectedTheme().ElementBackground
					end
					if searchFrame then
						searchFrame.BackgroundColor3 = self.getSelectedTheme().InputBackground
						local searchStroke = searchFrame:FindFirstChildOfClass("UIStroke")
						if searchStroke then
							searchStroke.Color = self.getSelectedTheme().InputStroke
						end
						if searchBox then
							searchBox.TextColor3 = self.getSelectedTheme().TextColor
							searchBox.PlaceholderColor3 = self.getSelectedTheme().PlaceholderColor or self.getSelectedTheme().TextColor
						end
					end
					applyDropdownOptionThemeColors(false)
				end)
	
				function DropdownSettings:Set(NewOption)
					commitSelection(NewOption, {
						emitCallback = true,
						persist = true,
						forceCallback = true,
						reason = "set",
						animatedVisuals = false
					})
				end
	
				function DropdownSettings:Refresh(optionsTable) -- updates a dropdown with new options from optionsTable
					DropdownSettings.Options = normalizeDropdownOptions(optionsTable)
					if DropdownSettings.SearchEnabled and DropdownSettings.ResetSearchOnRefresh then
						searchQuery = ""
						if searchBox then
							searchBox.Text = ""
						end
					end
					for _, option in Dropdown.List:GetChildren() do
						if option.ClassName == "Frame" and option.Name ~= "Placeholder" and option.Name ~= "Template" then
							option:Destroy()
						end
					end
					Dropdown.List.Visible = false
					Dropdown.Size = UDim2.new(1, -10, 0, 45)
					Dropdown.Toggle.Rotation = 180
					Dropdown.List.ScrollBarImageTransparency = 1
					SetDropdownOptions()
					applySearchFilter()
					commitSelection(DropdownSettings.CurrentOption, {
						emitCallback = true,
						persist = true,
						forceCallback = false,
						reason = "refresh",
						animatedVisuals = false
					})
				end
	
				function DropdownSettings:Clear()
					commitSelection({}, {
						emitCallback = true,
						persist = true,
						forceCallback = true,
						reason = "clear",
						allowDefaultFallback = true,
						animatedVisuals = false
					})
				end

				function DropdownSettings:SetSearchQuery(text)
					if not DropdownSettings.SearchEnabled then
						return false
					end
					searchQuery = tostring(text or "")
					if searchBox then
						searchBox.Text = searchQuery
					end
					applySearchFilter()
					return true
				end

				function DropdownSettings:GetSearchQuery()
					if not DropdownSettings.SearchEnabled then
						return ""
					end
					return tostring(searchQuery or "")
				end

				function DropdownSettings:ClearSearch()
					if not DropdownSettings.SearchEnabled then
						return false
					end
					searchQuery = ""
					if searchBox then
						searchBox.Text = ""
					end
					applySearchFilter()
					return true
				end

				function DropdownSettings:Destroy()
					if dropdownThemeConnection then
						dropdownThemeConnection:Disconnect()
						dropdownThemeConnection = nil
					end
					Dropdown:Destroy()
				end

				-- Add extended API
				addExtendedAPI(DropdownSettings, DropdownSettings.Name, "Dropdown", Dropdown, dropdownHoverBindingKey, dropdownSyncToken)
	
				if Settings.ConfigurationSaving then
					if Settings.ConfigurationSaving.Enabled and DropdownSettings.Flag then
						self.RayfieldLibrary.Flags[DropdownSettings.Flag] = DropdownSettings
					end
				end
	
				return DropdownSettings
			end

			local SequenceLib = self.KeybindSequence

			local function trim(value)
				if type(value) ~= "string" then
					return ""
				end
				local out = value:gsub("^%s+", "")
				out = out:gsub("%s+$", "")
				return out
			end

			local function resolveSequenceRuntimeOptions(sourceSettings)
				local maxSteps = 4
				local stepTimeoutMs = 800

				if SequenceLib and SequenceLib.DEFAULT_MAX_STEPS then
					maxSteps = SequenceLib.DEFAULT_MAX_STEPS
				end
				if SequenceLib and SequenceLib.DEFAULT_STEP_TIMEOUT_MS then
					stepTimeoutMs = SequenceLib.DEFAULT_STEP_TIMEOUT_MS
				end

				if sourceSettings then
					local customMaxSteps = tonumber(sourceSettings.MaxSteps)
					if customMaxSteps and customMaxSteps > 0 then
						maxSteps = math.floor(customMaxSteps)
					end

					local customTimeout = tonumber(sourceSettings.StepTimeoutMs)
					if customTimeout and customTimeout > 0 then
						stepTimeoutMs = math.floor(customTimeout)
					end
				end

				maxSteps = math.clamp(maxSteps, 1, 4)
				stepTimeoutMs = math.max(1, stepTimeoutMs)
				return maxSteps, stepTimeoutMs
			end

			local function normalizeSequenceBinding(rawBinding, sourceSettings)
				if not SequenceLib then
					if rawBinding == nil or tostring(rawBinding) == "" then
						return nil, nil, "sequence_lib_missing"
					end
					local fallback = tostring(rawBinding)
					local split = string.split(fallback, ">")
					local single = split[1]
					if single and single ~= "" then
						fallback = tostring(single)
					end
					return fallback, nil, nil
				end

				local maxSteps, _ = resolveSequenceRuntimeOptions(sourceSettings)
				return SequenceLib.normalize(rawBinding, {
					maxSteps = maxSteps
				})
			end

			local function parseSequenceInput(rawText, sourceSettings)
				if not SequenceLib then
					return normalizeSequenceBinding(rawText, sourceSettings)
				end

				local maxSteps, _ = resolveSequenceRuntimeOptions(sourceSettings)
				return SequenceLib.parseUserInput(rawText, sourceSettings and sourceSettings.ParseInput, {
					maxSteps = maxSteps,
					fallbackToDefault = true
				})
			end

			local function formatSequenceDisplay(canonical, steps, sourceSettings)
				if not canonical or canonical == "" then
					return ""
				end
				if not SequenceLib then
					return tostring(canonical)
				end

				local displaySource = steps
				if type(displaySource) ~= "table" or displaySource[1] == nil then
					displaySource = canonical
				end

				local display = SequenceLib.formatDisplay(displaySource, sourceSettings and sourceSettings.DisplayFormatter, {
					maxSteps = select(1, resolveSequenceRuntimeOptions(sourceSettings))
				})

				if type(display) ~= "string" or display == "" then
					return tostring(canonical)
				end

				return display
			end
	
			-- Keybind
			function Tab:CreateKeybind(KeybindSettings)
				local ctx = self
				local CheckingForKey = false
				local captureSteps = {}
				local captureToken = 0
				local maxSteps, stepTimeoutMs = resolveSequenceRuntimeOptions(KeybindSettings)
				local sequenceMatcher = SequenceLib and SequenceLib.newMatcher({
					maxSteps = maxSteps,
					stepTimeoutMs = stepTimeoutMs
				}) or nil
				local Keybind = self.Elements.Template.Keybind:Clone()
				Keybind.Name = KeybindSettings.Name
				Keybind.Title.Text = KeybindSettings.Name
				Keybind.Visible = true
				Keybind.Parent = TabPage
	
				Keybind.BackgroundTransparency = 1
				Keybind.UIStroke.Transparency = 1
				Keybind.Title.TextTransparency = 1
	
				Keybind.KeybindFrame.BackgroundColor3 = self.getSelectedTheme().InputBackground
				Keybind.KeybindFrame.UIStroke.Color = self.getSelectedTheme().InputStroke
	
				self.Animation:Create(Keybind, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0}):Play()
				self.Animation:Create(Keybind.UIStroke, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {Transparency = 0}):Play()
				self.Animation:Create(Keybind.Title, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {TextTransparency = 0}):Play()	

				if type(KeybindSettings.Callback) ~= "function" then
					KeybindSettings.Callback = function() end
				end

				KeybindSettings.MaxSteps = maxSteps
				KeybindSettings.StepTimeoutMs = stepTimeoutMs

				local activeSteps = nil
				local activeCanonical, parsedSteps = normalizeSequenceBinding(KeybindSettings.CurrentKeybind or "Q", KeybindSettings)
				if not activeCanonical then
					activeCanonical, parsedSteps = normalizeSequenceBinding("Q", KeybindSettings)
				end
				activeSteps = parsedSteps
				KeybindSettings.CurrentKeybind = activeCanonical or "Q"

				local function resizeKeybindFrameToText()
					self.Animation:Create(Keybind.KeybindFrame, TweenInfo.new(0.55, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out), {
						Size = UDim2.new(0, Keybind.KeybindFrame.KeybindBox.TextBounds.X + 24, 0, 30)
					}):Play()
				end

				local function applyBinding(canonical, steps, callOnChange)
					if not canonical then
						return false
					end

					KeybindSettings.CurrentKeybind = canonical
					activeSteps = steps
					Keybind.KeybindFrame.KeybindBox.Text = formatSequenceDisplay(canonical, steps, KeybindSettings)
					resizeKeybindFrameToText()

					if sequenceMatcher then
						sequenceMatcher:setBinding({
							canonical = canonical,
							steps = activeSteps
						})
					end

					if not KeybindSettings.Ext then
						self.SaveConfiguration()
					end

					if callOnChange and KeybindSettings.CallOnChange then
						KeybindSettings.Callback(canonical)
					end
					return true
				end

				local function finalizeCapture(releaseFocus)
					captureToken += 1
					if #captureSteps <= 0 then
						return false
					end

					local candidateCanonical = table.concat(captureSteps, ">")
					captureSteps = {}

					local canonical, steps = normalizeSequenceBinding(candidateCanonical, KeybindSettings)
					if canonical then
						applyBinding(canonical, steps, true)
					else
						Keybind.KeybindFrame.KeybindBox.Text = formatSequenceDisplay(KeybindSettings.CurrentKeybind, activeSteps, KeybindSettings)
						resizeKeybindFrameToText()
					end

					if releaseFocus and Keybind.KeybindFrame.KeybindBox:IsFocused() then
						Keybind.KeybindFrame.KeybindBox:ReleaseFocus()
					end

					return canonical ~= nil
				end

				local function scheduleCaptureFinalize()
					captureToken += 1
					local token = captureToken
					task.delay(stepTimeoutMs / 1000, function()
						if CheckingForKey and token == captureToken then
							finalizeCapture(true)
						end
					end)
				end

				applyBinding(KeybindSettings.CurrentKeybind, activeSteps, false)

				Keybind.KeybindFrame.KeybindBox.Focused:Connect(function()
					CheckingForKey = true
					Keybind.KeybindFrame.KeybindBox.Text = ""
					captureSteps = {}
					captureToken += 1
				end)
				Keybind.KeybindFrame.KeybindBox.FocusLost:Connect(function()
					local typedText = trim(Keybind.KeybindFrame.KeybindBox.Text or "")
					local captureWasActive = CheckingForKey
					CheckingForKey = false
					captureToken += 1

					if captureWasActive and #captureSteps > 0 then
						finalizeCapture(false)
						return
					end

					if typedText ~= "" then
						local canonical, steps = parseSequenceInput(typedText, KeybindSettings)
						if canonical then
							applyBinding(canonical, steps, true)
							return
						end
					end

					Keybind.KeybindFrame.KeybindBox.Text = formatSequenceDisplay(KeybindSettings.CurrentKeybind, activeSteps, KeybindSettings)
					resizeKeybindFrameToText()
				end)
	
				local keybindHoverBindingKey = registerHoverBinding(Keybind,
					function()
						self.Animation:Create(Keybind, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackgroundHover}):Play()
					end,
					function()
						self.Animation:Create(Keybind, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackground}):Play()
					end
				)
	
				local connection = self.UserInputService.InputBegan:Connect(function(input, processed)
					if CheckingForKey then
						if input.UserInputType ~= Enum.UserInputType.Keyboard then
							return
						end

						if input.KeyCode == Enum.KeyCode.Return or input.KeyCode == Enum.KeyCode.KeypadEnter then
							finalizeCapture(true)
							return
						end

						local capturedStep = nil
						if SequenceLib then
							capturedStep = select(1, SequenceLib.captureStepFromInput(input, self.UserInputService))
						elseif input.KeyCode and input.KeyCode ~= Enum.KeyCode.Unknown then
							capturedStep = input.KeyCode.Name
						end

						if capturedStep then
							if #captureSteps < maxSteps then
								table.insert(captureSteps, capturedStep)
							end

							local previewCanonical = table.concat(captureSteps, ">")
							local previewSteps = select(2, normalizeSequenceBinding(previewCanonical, KeybindSettings))
							Keybind.KeybindFrame.KeybindBox.Text = formatSequenceDisplay(previewCanonical, previewSteps, KeybindSettings)
							resizeKeybindFrameToText()

							if #captureSteps >= maxSteps then
								finalizeCapture(true)
							else
								scheduleCaptureFinalize()
							end
						end
					elseif not KeybindSettings.CallOnChange then
						local matched = false
						if sequenceMatcher then
							matched = sequenceMatcher:consume(input, {
								canonical = KeybindSettings.CurrentKeybind,
								steps = activeSteps
							}, self.UserInputService, processed)
						elseif KeybindSettings.CurrentKeybind and not processed then
							matched = input.KeyCode == Enum.KeyCode[KeybindSettings.CurrentKeybind]
						end

						if not matched then
							return
						end

						local Held = true
						local Connection
						Connection = input.Changed:Connect(function(prop)
							if prop == "UserInputState" then
								Connection:Disconnect()
								Held = false
							end
						end)
	
						if not KeybindSettings.HoldToInteract then
							local Success, Response = pcall(KeybindSettings.Callback)
							if not Success then
								self.Animation:Create(Keybind, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = Color3.fromRGB(85, 0, 0)}):Play()
								self.Animation:Create(Keybind.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 1}):Play()
								Keybind.Title.Text = "Callback Error"
								print("Rayfield | "..KeybindSettings.Name.." Callback Error " ..tostring(Response))
								warn('Check docs.sirius.menu for help with Rayfield specific development.')
								task.wait(0.5)
								Keybind.Title.Text = KeybindSettings.Name
								self.Animation:Create(Keybind, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackground}):Play()
								self.Animation:Create(Keybind.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 0}):Play()
							end
						else
							task.wait(0.25)
							if Held then
								local Loop; Loop = self.RunService.Stepped:Connect(function()
									if not Held then
										KeybindSettings.Callback(false) -- maybe pcall this
										Loop:Disconnect()
									else
										KeybindSettings.Callback(true) -- maybe pcall this
									end
								end)
							end
						end
					end
				end)
				table.insert(self.keybindConnections, connection)
				local function removeConnectionFromGlobalList()
					for index = #self.keybindConnections, 1, -1 do
						if self.keybindConnections[index] == connection then
							table.remove(self.keybindConnections, index)
						end
					end
				end

				Keybind.KeybindFrame.KeybindBox:GetPropertyChangedSignal("Text"):Connect(function()
					resizeKeybindFrameToText()
				end)
	
				function KeybindSettings:Set(NewKeybind)
					local canonical, steps = normalizeSequenceBinding(NewKeybind, KeybindSettings)
					if not canonical then
						canonical, steps = parseSequenceInput(tostring(NewKeybind or ""), KeybindSettings)
					end

					if canonical then
						applyBinding(canonical, steps, true)
					else
						Keybind.KeybindFrame.KeybindBox.Text = formatSequenceDisplay(KeybindSettings.CurrentKeybind, activeSteps, KeybindSettings)
						resizeKeybindFrameToText()
					end
				end
	
				if Settings.ConfigurationSaving then
					if Settings.ConfigurationSaving.Enabled and KeybindSettings.Flag then
						self.RayfieldLibrary.Flags[KeybindSettings.Flag] = KeybindSettings
					end
				end
	
				self.Rayfield.Main:GetPropertyChangedSignal('BackgroundColor3'):Connect(function()
					Keybind.KeybindFrame.BackgroundColor3 = self.getSelectedTheme().InputBackground
					Keybind.KeybindFrame.UIStroke.Color = self.getSelectedTheme().InputStroke
				end)
	
				function KeybindSettings:Destroy()
					Keybind:Destroy()
				end
	
				-- Add extended API
				addExtendedAPI(KeybindSettings, KeybindSettings.Name, "Keybind", Keybind, keybindHoverBindingKey)
				local cleanupScopeId = KeybindSettings.GetCleanupScope and KeybindSettings:GetCleanupScope() or KeybindSettings.__CleanupScope
				if cleanupScopeId then
					ownershipTrackConnection(connection, cleanupScopeId)
					ownershipTrackCleanup(removeConnectionFromGlobalList, cleanupScopeId)
				end
	
				return KeybindSettings
			end
	
			-- Toggle
			function Tab:CreateToggle(ToggleSettings)
				local ctx = self
				ToggleSettings = ToggleSettings or {}
				ToggleSettings.Name = ToggleSettings.Name or "Toggle"
				if type(ToggleSettings.Callback) ~= "function" then
					ToggleSettings.Callback = function() end
				end
				ToggleSettings.CurrentValue = ToggleSettings.CurrentValue == true

				local toggleKeybindSettings = ToggleSettings.Keybind
				if type(toggleKeybindSettings) ~= "table" then
					toggleKeybindSettings = {}
				end
				if ToggleSettings.EnableKeybind ~= nil and toggleKeybindSettings.Enabled == nil then
					toggleKeybindSettings.Enabled = ToggleSettings.EnableKeybind
				end
				if ToggleSettings.CurrentKeybind and toggleKeybindSettings.CurrentKeybind == nil then
					toggleKeybindSettings.CurrentKeybind = ToggleSettings.CurrentKeybind
				end
				if ToggleSettings.KeybindDisplayFormatter and toggleKeybindSettings.DisplayFormatter == nil then
					toggleKeybindSettings.DisplayFormatter = ToggleSettings.KeybindDisplayFormatter
				end
				if ToggleSettings.KeybindParseInput and toggleKeybindSettings.ParseInput == nil then
					toggleKeybindSettings.ParseInput = ToggleSettings.KeybindParseInput
				end
				if ToggleSettings.KeybindMaxSteps and toggleKeybindSettings.MaxSteps == nil then
					toggleKeybindSettings.MaxSteps = ToggleSettings.KeybindMaxSteps
				end
				if ToggleSettings.KeybindStepTimeoutMs and toggleKeybindSettings.StepTimeoutMs == nil then
					toggleKeybindSettings.StepTimeoutMs = ToggleSettings.KeybindStepTimeoutMs
				end
				ToggleSettings.Keybind = toggleKeybindSettings

				local keybindEnabled = toggleKeybindSettings.Enabled == true
				local toggleKeybindMaxSteps, toggleKeybindTimeoutMs = resolveSequenceRuntimeOptions(toggleKeybindSettings)
				toggleKeybindSettings.MaxSteps = toggleKeybindMaxSteps
				toggleKeybindSettings.StepTimeoutMs = toggleKeybindTimeoutMs
				toggleKeybindSettings.CurrentKeybind = toggleKeybindSettings.CurrentKeybind or "Q"
				ToggleSettings.CurrentKeybind = toggleKeybindSettings.CurrentKeybind

				local toggleKeybindConnection = nil
				local toggleKeybindMatcher = nil
				local toggleKeybindActiveSteps = nil
				local keybindCapturing = false
				local keybindCaptureSteps = {}
				local keybindCaptureToken = 0
				local suppressNextToggleClick = false
				local toggleKeybindFrame = nil
				local toggleKeybindBox = nil
				local toggleKeybindFlagProxy = nil
	
				local Toggle = self.Elements.Template.Toggle:Clone()
				Toggle.Name = ToggleSettings.Name
				Toggle.Title.Text = ToggleSettings.Name
				Toggle.Visible = true
				Toggle.Parent = TabPage
	
				Toggle.BackgroundTransparency = 1
				Toggle.UIStroke.Transparency = 1
				Toggle.Title.TextTransparency = 1
				self.bindTheme(Toggle.Switch, "BackgroundColor3", "ToggleBackground")
	
				if self.getSelectedTheme() ~= self.RayfieldLibrary.Theme.Default then
					local toggleShadow = Toggle.Switch:FindFirstChild("Shadow")
					if toggleShadow then
						toggleShadow.Visible = false
					end
				end
	
				self.Animation:Create(Toggle, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0}):Play()
				self.Animation:Create(Toggle.UIStroke, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {Transparency = 0}):Play()
				self.Animation:Create(Toggle.Title, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {TextTransparency = 0}):Play()	
	
				local function UpdateToggleColors()
					if ToggleSettings.CurrentValue == true then
						Toggle.Switch.Indicator.UIStroke.Color = self.getSelectedTheme().ToggleEnabledStroke
						Toggle.Switch.Indicator.BackgroundColor3 = self.getSelectedTheme().ToggleEnabled
						Toggle.Switch.UIStroke.Color = self.getSelectedTheme().ToggleEnabledOuterStroke
					else
						Toggle.Switch.Indicator.UIStroke.Color = self.getSelectedTheme().ToggleDisabledStroke
						Toggle.Switch.Indicator.BackgroundColor3 = self.getSelectedTheme().ToggleDisabled
						Toggle.Switch.UIStroke.Color = self.getSelectedTheme().ToggleDisabledOuterStroke
					end
				end

				local function handleToggleCallbackError(response)
					self.Animation:Create(Toggle, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = Color3.fromRGB(85, 0, 0)}):Play()
					self.Animation:Create(Toggle.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 1}):Play()
					Toggle.Title.Text = "Callback Error"
					print("Rayfield | "..ToggleSettings.Name.." Callback Error " ..tostring(response))
					warn('Check docs.sirius.menu for help with Rayfield specific development.')
					task.wait(0.5)
					Toggle.Title.Text = ToggleSettings.Name
					self.Animation:Create(Toggle, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackground}):Play()
					self.Animation:Create(Toggle.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 0}):Play()
				end

				local function applyToggleVisual(nextValue)
					if nextValue == true then
						ToggleSettings.CurrentValue = true
						self.Animation:Create(Toggle, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackgroundHover}):Play()
						self.Animation:Create(Toggle.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 1}):Play()
						self.Animation:Create(Toggle.Switch.Indicator, TweenInfo.new(0.5, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {Position = UDim2.new(1, -20, 0.5, 0)}):Play()
						self.Animation:Create(Toggle.Switch.Indicator, TweenInfo.new(0.4, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {Size = UDim2.new(0,12,0,12)}):Play()
						self.Animation:Create(Toggle.Switch.Indicator.UIStroke, TweenInfo.new(0.55, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out), {Color = self.getSelectedTheme().ToggleEnabledStroke}):Play()
						self.Animation:Create(Toggle.Switch.Indicator, TweenInfo.new(0.8, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out), {BackgroundColor3 = self.getSelectedTheme().ToggleEnabled}):Play()
						self.Animation:Create(Toggle.Switch.UIStroke, TweenInfo.new(0.55, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out), {Color = self.getSelectedTheme().ToggleEnabledOuterStroke}):Play()
						self.Animation:Create(Toggle.Switch.Indicator, TweenInfo.new(0.45, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {Size = UDim2.new(0,17,0,17)}):Play()
						self.Animation:Create(Toggle, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackground}):Play()
						self.Animation:Create(Toggle.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 0}):Play()
					else
						ToggleSettings.CurrentValue = false
						self.Animation:Create(Toggle, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackgroundHover}):Play()
						self.Animation:Create(Toggle.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 1}):Play()
						self.Animation:Create(Toggle.Switch.Indicator, TweenInfo.new(0.45, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {Position = UDim2.new(1, -40, 0.5, 0)}):Play()
						self.Animation:Create(Toggle.Switch.Indicator, TweenInfo.new(0.4, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {Size = UDim2.new(0,12,0,12)}):Play()
						self.Animation:Create(Toggle.Switch.Indicator.UIStroke, TweenInfo.new(0.55, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out), {Color = self.getSelectedTheme().ToggleDisabledStroke}):Play()
						self.Animation:Create(Toggle.Switch.Indicator, TweenInfo.new(0.8, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out), {BackgroundColor3 = self.getSelectedTheme().ToggleDisabled}):Play()
						self.Animation:Create(Toggle.Switch.UIStroke, TweenInfo.new(0.55, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out), {Color = self.getSelectedTheme().ToggleDisabledOuterStroke}):Play()
						self.Animation:Create(Toggle.Switch.Indicator, TweenInfo.new(0.4, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {Size = UDim2.new(0,17,0,17)}):Play()
						self.Animation:Create(Toggle, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackground}):Play()
						self.Animation:Create(Toggle.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 0}):Play()
					end
				end

				local toggleSyncToken = registerElementSync({
					name = ToggleSettings.Name,
					getState = function()
						return ToggleSettings.CurrentValue == true
					end,
					normalize = function(rawValue)
						local normalized = rawValue == true
						if elementSync and elementSync.normalize and elementSync.normalize.boolean then
							normalized = elementSync.normalize.boolean(rawValue)
						end
						return normalized, {
							changed = (ToggleSettings.CurrentValue == true) ~= normalized
						}
					end,
					applyVisual = function(normalized)
						applyToggleVisual(normalized == true)
					end,
					emitCallback = function(normalized)
						if debugX then warn('Running toggle \''..ToggleSettings.Name..'\' (sync commit)') end
						ToggleSettings.Callback(normalized == true)
					end,
					persist = function()
						ctx.SaveConfiguration()
					end,
					isExt = function()
						return ToggleSettings.Ext == true
					end,
					isAlive = function()
						return Toggle ~= nil and Toggle.Parent ~= nil
					end,
					isVisibleContext = function()
						return Toggle.Visible and Toggle:IsDescendantOf(TabPage) and self.Elements.UIPageLayout.CurrentPage == TabPage
					end,
					onCallbackError = handleToggleCallbackError
				})

				local function commitToggleState(rawValue, commitOptions)
					local options = commitOptions or {}
					if toggleSyncToken then
						local callbackOk = commitElementSync(toggleSyncToken, rawValue, {
							reason = options.reason or "toggle_update",
							source = options.source or "unknown",
							emitCallback = options.emitCallback,
							persist = options.persist,
							forceCallback = options.forceCallback
						})
						return callbackOk
					end

					local normalized = rawValue == true
					applyToggleVisual(normalized)
					local success, response = pcall(function()
						ToggleSettings.Callback(ToggleSettings.CurrentValue)
					end)
					if not success then
						handleToggleCallbackError(response)
					elseif not ToggleSettings.Ext then
						ctx.SaveConfiguration()
					end
					return success
				end

				local function formatToggleKeybindDisplay(canonical, steps)
					return formatSequenceDisplay(canonical, steps, toggleKeybindSettings)
				end

				local function resizeToggleKeybindFrame()
					if not (toggleKeybindFrame and toggleKeybindBox) then
						return
					end
					local targetWidth = math.clamp(toggleKeybindBox.TextBounds.X + 24, 56, 190)
					self.Animation:Create(toggleKeybindFrame, TweenInfo.new(0.55, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out), {
						Size = UDim2.new(0, targetWidth, 0, 30)
					}):Play()
				end

				local function applyToggleKeybindBinding(canonical, steps, callOnChange)
					if not canonical then
						return false
					end

					toggleKeybindSettings.CurrentKeybind = canonical
					ToggleSettings.CurrentKeybind = canonical
					toggleKeybindActiveSteps = steps
					if toggleKeybindFlagProxy then
						toggleKeybindFlagProxy.CurrentKeybind = canonical
					end
					if toggleKeybindMatcher then
						toggleKeybindMatcher:setBinding({
							canonical = canonical,
							steps = steps
						})
					end

					if toggleKeybindBox then
						toggleKeybindBox.Text = formatToggleKeybindDisplay(canonical, steps)
						resizeToggleKeybindFrame()
					end

					if callOnChange and toggleKeybindSettings.CallOnChange and type(toggleKeybindSettings.Callback) == "function" then
						pcall(toggleKeybindSettings.Callback, canonical)
					end

					return true
				end

				local function finalizeToggleKeybindCapture(releaseFocus)
					keybindCaptureToken += 1
					if #keybindCaptureSteps <= 0 then
						return false
					end

					local candidateCanonical = table.concat(keybindCaptureSteps, ">")
					keybindCaptureSteps = {}
					local canonical, steps = normalizeSequenceBinding(candidateCanonical, toggleKeybindSettings)
					if canonical then
						applyToggleKeybindBinding(canonical, steps, true)
					elseif toggleKeybindBox then
						toggleKeybindBox.Text = formatToggleKeybindDisplay(toggleKeybindSettings.CurrentKeybind, toggleKeybindActiveSteps)
						resizeToggleKeybindFrame()
					end

					if releaseFocus and toggleKeybindBox and toggleKeybindBox:IsFocused() then
						toggleKeybindBox:ReleaseFocus()
					end

					return canonical ~= nil
				end

				local function scheduleToggleKeybindCaptureFinalize()
					keybindCaptureToken += 1
					local token = keybindCaptureToken
					task.delay(toggleKeybindTimeoutMs / 1000, function()
						if keybindCapturing and token == keybindCaptureToken then
							finalizeToggleKeybindCapture(true)
						end
					end)
				end

				if keybindEnabled then
					local switchWidth = Toggle.Switch.Size.X.Offset
					if switchWidth <= 0 then
						switchWidth = Toggle.Switch.AbsoluteSize.X
					end
					if switchWidth <= 0 then
						switchWidth = 56
					end

					local keybindFrameTemplate = self.Elements.Template.Keybind and self.Elements.Template.Keybind:FindFirstChild("KeybindFrame")
					if keybindFrameTemplate and keybindFrameTemplate:IsA("Frame") then
						toggleKeybindFrame = keybindFrameTemplate:Clone()
					else
						toggleKeybindFrame = Instance.new("Frame")
						toggleKeybindFrame.Name = "ToggleKeybindFrame"
						toggleKeybindFrame.BackgroundTransparency = 0
						local fallbackStroke = Instance.new("UIStroke")
						fallbackStroke.Parent = toggleKeybindFrame
						local fallbackBox = Instance.new("TextBox")
						fallbackBox.Name = "KeybindBox"
						fallbackBox.BackgroundTransparency = 1
						fallbackBox.Size = UDim2.new(1, 0, 1, 0)
						fallbackBox.Parent = toggleKeybindFrame
					end

					toggleKeybindFrame.Name = "ToggleKeybindFrame"
					toggleKeybindFrame.Visible = true
					toggleKeybindFrame.Active = true
					toggleKeybindFrame.Parent = Toggle
					toggleKeybindFrame.AnchorPoint = Vector2.new(1, 0.5)
					toggleKeybindFrame.Position = UDim2.new(1, -(switchWidth + 18), 0.5, 0)
					toggleKeybindFrame.ZIndex = math.max(Toggle.Switch.ZIndex, Toggle.Interact.ZIndex, Toggle.ZIndex) + 2
					self.bindTheme(toggleKeybindFrame, "BackgroundColor3", "InputBackground")

					toggleKeybindBox = toggleKeybindFrame:FindFirstChild("KeybindBox")
					if not (toggleKeybindBox and toggleKeybindBox:IsA("TextBox")) then
						toggleKeybindBox = Instance.new("TextBox")
						toggleKeybindBox.Name = "KeybindBox"
						toggleKeybindBox.BackgroundTransparency = 1
						toggleKeybindBox.Size = UDim2.new(1, 0, 1, 0)
						toggleKeybindBox.Parent = toggleKeybindFrame
					end

					toggleKeybindBox.ClearTextOnFocus = false
					toggleKeybindBox.TextWrapped = false
					toggleKeybindBox.TextXAlignment = Enum.TextXAlignment.Center
					toggleKeybindBox.TextYAlignment = Enum.TextYAlignment.Center
					toggleKeybindBox.ZIndex = toggleKeybindFrame.ZIndex + 1

					local keybindFrameStroke = toggleKeybindFrame:FindFirstChildWhichIsA("UIStroke")
					if keybindFrameStroke then
						self.bindTheme(keybindFrameStroke, "Color", "InputStroke")
					end

					if SequenceLib then
						toggleKeybindMatcher = SequenceLib.newMatcher({
							maxSteps = toggleKeybindMaxSteps,
							stepTimeoutMs = toggleKeybindTimeoutMs
						})
					end

					local initialCanonical, initialSteps = normalizeSequenceBinding(toggleKeybindSettings.CurrentKeybind, toggleKeybindSettings)
					if not initialCanonical then
						initialCanonical, initialSteps = normalizeSequenceBinding("Q", toggleKeybindSettings)
					end
					applyToggleKeybindBinding(initialCanonical, initialSteps, false)

					toggleKeybindFrame.InputBegan:Connect(function(input)
						if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
							suppressNextToggleClick = true
							task.delay(0.2, function()
								suppressNextToggleClick = false
							end)
						end
					end)

					toggleKeybindBox.Focused:Connect(function()
						keybindCapturing = true
						keybindCaptureSteps = {}
						keybindCaptureToken += 1
						toggleKeybindBox.Text = ""
					end)

					toggleKeybindBox.FocusLost:Connect(function()
						local typedText = trim(toggleKeybindBox.Text or "")
						local wasCapturing = keybindCapturing
						keybindCapturing = false
						keybindCaptureToken += 1

						if wasCapturing and #keybindCaptureSteps > 0 then
							finalizeToggleKeybindCapture(false)
							return
						end

						if typedText ~= "" then
							local canonical, steps = parseSequenceInput(typedText, toggleKeybindSettings)
							if canonical then
								applyToggleKeybindBinding(canonical, steps, true)
								return
							end
						end

						toggleKeybindBox.Text = formatToggleKeybindDisplay(toggleKeybindSettings.CurrentKeybind, toggleKeybindActiveSteps)
						resizeToggleKeybindFrame()
					end)

					toggleKeybindBox:GetPropertyChangedSignal("Text"):Connect(function()
						resizeToggleKeybindFrame()
					end)
				end

				-- Reactive Toggle Colors
				local themeValueFolder = self.Main:FindFirstChild("ThemeValues")
				if themeValueFolder then
					local backgroundValue = themeValueFolder:FindFirstChild("Background")
					if backgroundValue then
						backgroundValue.Changed:Connect(UpdateToggleColors)
					end
				end
				
				UpdateToggleColors()
	
				local toggleHoverBindingKey = registerHoverBinding(Toggle,
					function()
						self.Animation:Create(Toggle, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackgroundHover}):Play()
					end,
					function()
						self.Animation:Create(Toggle, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackground}):Play()
					end
				)

				if keybindEnabled then
					toggleKeybindConnection = self.UserInputService.InputBegan:Connect(function(input, processed)
						if keybindCapturing then
							if input.UserInputType ~= Enum.UserInputType.Keyboard then
								return
							end

							if input.KeyCode == Enum.KeyCode.Return or input.KeyCode == Enum.KeyCode.KeypadEnter then
								finalizeToggleKeybindCapture(true)
								return
							end

							local capturedStep = nil
							if SequenceLib then
								capturedStep = select(1, SequenceLib.captureStepFromInput(input, self.UserInputService))
							elseif input.KeyCode and input.KeyCode ~= Enum.KeyCode.Unknown then
								capturedStep = input.KeyCode.Name
							end

							if capturedStep then
								if #keybindCaptureSteps < toggleKeybindMaxSteps then
									table.insert(keybindCaptureSteps, capturedStep)
								end

								local previewCanonical = table.concat(keybindCaptureSteps, ">")
								local previewSteps = select(2, normalizeSequenceBinding(previewCanonical, toggleKeybindSettings))
								if toggleKeybindBox then
									toggleKeybindBox.Text = formatToggleKeybindDisplay(previewCanonical, previewSteps)
									resizeToggleKeybindFrame()
								end

								if #keybindCaptureSteps >= toggleKeybindMaxSteps then
									finalizeToggleKeybindCapture(true)
								else
									scheduleToggleKeybindCaptureFinalize()
								end
							end

							return
						end

						if processed then
							return
						end

						local matched = false
						if toggleKeybindMatcher then
							matched = toggleKeybindMatcher:consume(input, {
								canonical = toggleKeybindSettings.CurrentKeybind,
								steps = toggleKeybindActiveSteps
							}, self.UserInputService, processed)
						elseif toggleKeybindSettings.CurrentKeybind and input.KeyCode then
							matched = input.KeyCode == Enum.KeyCode[toggleKeybindSettings.CurrentKeybind]
						end

						if matched then
							ToggleSettings:Set(not ToggleSettings.CurrentValue)
						end
					end)
					table.insert(self.keybindConnections, toggleKeybindConnection)
				end
				local function removeToggleKeybindConnectionFromGlobalList()
					if not toggleKeybindConnection then
						return
					end
					for index = #self.keybindConnections, 1, -1 do
						if self.keybindConnections[index] == toggleKeybindConnection then
							table.remove(self.keybindConnections, index)
						end
					end
				end
	
				Toggle.Interact.MouseButton1Click:Connect(function()
					if suppressNextToggleClick then
						suppressNextToggleClick = false
						return
					end
					commitToggleState(not ToggleSettings.CurrentValue, {
						reason = "interact_click",
						source = "ui_click",
						emitCallback = true,
						persist = true,
						forceCallback = true
					})
				end)
	
				function ToggleSettings:Set(NewToggleValue)
					if keybindEnabled and (type(NewToggleValue) == "string" or typeof(NewToggleValue) == "EnumItem") then
						local canonical, steps = normalizeSequenceBinding(NewToggleValue, toggleKeybindSettings)
						if not canonical then
							canonical, steps = parseSequenceInput(tostring(NewToggleValue), toggleKeybindSettings)
						end

						if canonical then
							applyToggleKeybindBinding(canonical, steps, true)
							if not ToggleSettings.Ext then
								ctx.SaveConfiguration()
							end
						elseif toggleKeybindBox then
							toggleKeybindBox.Text = formatToggleKeybindDisplay(toggleKeybindSettings.CurrentKeybind, toggleKeybindActiveSteps)
							resizeToggleKeybindFrame()
						end
						return
					end
					commitToggleState(NewToggleValue == true, {
						reason = "set",
						source = "api_set",
						emitCallback = true,
						persist = true,
						forceCallback = true
					})
				end

				function ToggleSettings:Get()
					return ToggleSettings.CurrentValue
				end

				function ToggleSettings:SetKeybind(NewKeybind)
					if not keybindEnabled then
						return false
					end

					local canonical, steps = normalizeSequenceBinding(NewKeybind, toggleKeybindSettings)
					if not canonical then
						canonical, steps = parseSequenceInput(tostring(NewKeybind or ""), toggleKeybindSettings)
					end

					if canonical then
						local applied = applyToggleKeybindBinding(canonical, steps, true)
						if applied and not ToggleSettings.Ext then
							ctx.SaveConfiguration()
						end
						return applied
					end

					if toggleKeybindBox then
						toggleKeybindBox.Text = formatToggleKeybindDisplay(toggleKeybindSettings.CurrentKeybind, toggleKeybindActiveSteps)
						resizeToggleKeybindFrame()
					end
					return false
				end

				function ToggleSettings:GetKeybind()
					return toggleKeybindSettings.CurrentKeybind
				end

				if keybindEnabled and Settings.ConfigurationSaving and Settings.ConfigurationSaving.Enabled and toggleKeybindSettings.Flag then
					toggleKeybindFlagProxy = {
						Type = "Keybind",
						CurrentKeybind = toggleKeybindSettings.CurrentKeybind,
						Set = function(_, newBinding)
							local canonical, steps = normalizeSequenceBinding(newBinding, toggleKeybindSettings)
							if not canonical then
								canonical, steps = parseSequenceInput(tostring(newBinding or ""), toggleKeybindSettings)
							end
							if canonical then
								applyToggleKeybindBinding(canonical, steps, false)
							end
						end
					}
					self.RayfieldLibrary.Flags[toggleKeybindSettings.Flag] = toggleKeybindFlagProxy
				end
	
				if not ToggleSettings.Ext then
					if Settings.ConfigurationSaving then
						if Settings.ConfigurationSaving.Enabled and ToggleSettings.Flag then
							self.RayfieldLibrary.Flags[ToggleSettings.Flag] = ToggleSettings
						end
					end
				end
	
	
				self.Rayfield.Main:GetPropertyChangedSignal('BackgroundColor3'):Connect(function()
					Toggle.Switch.BackgroundColor3 = self.getSelectedTheme().ToggleBackground

					if toggleKeybindFrame then
						toggleKeybindFrame.BackgroundColor3 = self.getSelectedTheme().InputBackground
						local frameStroke = toggleKeybindFrame:FindFirstChildWhichIsA("UIStroke")
						if frameStroke then
							frameStroke.Color = self.getSelectedTheme().InputStroke
						end
					end
	
					if self.getSelectedTheme() ~= self.RayfieldLibrary.Theme.Default then
						local toggleShadow = Toggle.Switch:FindFirstChild("Shadow")
						if toggleShadow then
							toggleShadow.Visible = false
						end
					end
	
					task.wait()
	
					if not ToggleSettings.CurrentValue then
						Toggle.Switch.Indicator.UIStroke.Color = self.getSelectedTheme().ToggleDisabledStroke
						Toggle.Switch.Indicator.BackgroundColor3 = self.getSelectedTheme().ToggleDisabled
						Toggle.Switch.UIStroke.Color = self.getSelectedTheme().ToggleDisabledOuterStroke
					else
						Toggle.Switch.Indicator.UIStroke.Color = self.getSelectedTheme().ToggleEnabledStroke
						Toggle.Switch.Indicator.BackgroundColor3 = self.getSelectedTheme().ToggleEnabled
						Toggle.Switch.UIStroke.Color = self.getSelectedTheme().ToggleEnabledOuterStroke
					end
				end)
	
				function ToggleSettings:Destroy()
					if toggleKeybindConnection then
						toggleKeybindConnection:Disconnect()
						toggleKeybindConnection = nil
					end
					if toggleKeybindSettings.Flag and ctx.RayfieldLibrary and ctx.RayfieldLibrary.Flags then
						if ctx.RayfieldLibrary.Flags[toggleKeybindSettings.Flag] == toggleKeybindFlagProxy then
							ctx.RayfieldLibrary.Flags[toggleKeybindSettings.Flag] = nil
						end
					end
					Toggle:Destroy()
				end
	
				-- Add extended API
				addExtendedAPI(ToggleSettings, ToggleSettings.Name, "Toggle", Toggle, toggleHoverBindingKey, toggleSyncToken)
				local cleanupScopeId = ToggleSettings.GetCleanupScope and ToggleSettings:GetCleanupScope() or ToggleSettings.__CleanupScope
				if cleanupScopeId and toggleKeybindConnection then
					ownershipTrackConnection(toggleKeybindConnection, cleanupScopeId)
					ownershipTrackCleanup(removeToggleKeybindConnectionFromGlobalList, cleanupScopeId)
				end
	
				return ToggleSettings
			end

			function Tab:CreateToggleBind(ToggleSettings)
				ToggleSettings = ToggleSettings or {}
				local keybindSettings = ToggleSettings.Keybind
				if type(keybindSettings) ~= "table" then
					keybindSettings = {}
				end
				keybindSettings.Enabled = true
				ToggleSettings.Keybind = keybindSettings
				return self:CreateToggle(ToggleSettings)
			end

			function Tab:CreateHotToggle(ToggleSettings)
				return self:CreateToggleBind(ToggleSettings)
			end

			function Tab:CreateKeybindToggle(ToggleSettings)
				return self:CreateToggleBind(ToggleSettings)
			end
	
			-- Slider
			function Tab:CreateSlider(SliderSettings)
				local ctx = self
				local SLDragging = false
				SliderSettings = SliderSettings or {}
				if type(SliderSettings.Callback) ~= "function" then
					SliderSettings.Callback = function() end
				end
				SliderSettings.Range = SliderSettings.Range or {0, 100}
				local sliderMin = tonumber(SliderSettings.Range[1]) or 0
				local sliderMax = tonumber(SliderSettings.Range[2]) or 100
				if sliderMax <= sliderMin then
					sliderMax = sliderMin + 1
				end
				SliderSettings.Range = {sliderMin, sliderMax}
				SliderSettings.Increment = tonumber(SliderSettings.Increment) or 1
				if SliderSettings.Increment <= 0 then
					SliderSettings.Increment = 1
				end
				SliderSettings.CurrentValue = math.clamp(tonumber(SliderSettings.CurrentValue) or sliderMin, sliderMin, sliderMax)

				local Slider = self.Elements.Template.Slider:Clone()
				Slider.Name = SliderSettings.Name
				Slider.Title.Text = SliderSettings.Name
				Slider.Visible = true
				Slider.Parent = TabPage
	
				Slider.BackgroundTransparency = 1
				Slider.UIStroke.Transparency = 1
				Slider.Title.TextTransparency = 1
	
				if self.getSelectedTheme() ~= self.RayfieldLibrary.Theme.Default then
					Slider.Main.Shadow.Visible = false
				end
	
				self.bindTheme(Slider.Main, "BackgroundColor3", "SliderBackground")
				self.bindTheme(Slider.Main.UIStroke, "Color", "SliderStroke")
				self.bindTheme(Slider.Main.Progress.UIStroke, "Color", "SliderStroke")
				self.bindTheme(Slider.Main.Progress, "BackgroundColor3", "SliderProgress")
	
				self.Animation:Create(Slider, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0}):Play()
				self.Animation:Create(Slider.UIStroke, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {Transparency = 0}):Play()
				self.Animation:Create(Slider.Title, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {TextTransparency = 0}):Play()	

				local function normalizeSliderValue(rawValue)
					local normalized = tonumber(rawValue)
					if normalized == nil then
						normalized = sliderMin
					end
					if elementSync and elementSync.normalize and elementSync.normalize.numberRange then
						normalized = elementSync.normalize.numberRange(normalized, {
							min = sliderMin,
							max = sliderMax,
							increment = SliderSettings.Increment,
							default = sliderMin
						})
					else
						normalized = math.clamp(normalized, sliderMin, sliderMax)
						normalized = math.floor((normalized / SliderSettings.Increment) + 0.5) * SliderSettings.Increment
						normalized = math.floor((normalized * 10000000) + 0.5) / 10000000
						normalized = math.clamp(normalized, sliderMin, sliderMax)
					end
					return normalized
				end

				local function sliderValueToWidth(value)
					local width = Slider.Main.AbsoluteSize.X
					if width <= 0 then
						return 5
					end
					local ratio = math.clamp((value - sliderMin) / (sliderMax - sliderMin), 0, 1)
					local target = width * ratio
					if ratio > 0 and target < 5 then
						target = 5
					end
					return target
				end

				local function formatSliderValue(value)
					if not SliderSettings.Suffix then
						return tostring(value)
					end
					return tostring(value) .. " " .. SliderSettings.Suffix
				end

				local function handleSliderCallbackError(response)
					self.Animation:Create(Slider, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = Color3.fromRGB(85, 0, 0)}):Play()
					self.Animation:Create(Slider.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 1}):Play()
					Slider.Title.Text = "Callback Error"
					print("Rayfield | "..SliderSettings.Name.." Callback Error " ..tostring(response))
					warn('Check docs.sirius.menu for help with Rayfield specific development.')
					task.wait(0.5)
					Slider.Title.Text = SliderSettings.Name
					self.Animation:Create(Slider, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackground}):Play()
					self.Animation:Create(Slider.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 0}):Play()
				end

				local function applySliderVisual(value, animate)
					local targetWidth = sliderValueToWidth(value)
					if animate then
						self.Animation:Create(Slider.Main.Progress, TweenInfo.new(0.45, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out), {Size = UDim2.new(0, targetWidth, 1, 0)}):Play()
					else
						Slider.Main.Progress.Size = UDim2.new(0, targetWidth, 1, 0)
					end
					Slider.Main.Information.Text = formatSliderValue(value)
					SliderSettings.CurrentValue = value
				end

				local sliderSyncToken = registerElementSync({
					name = SliderSettings.Name,
					getState = function()
						return SliderSettings.CurrentValue
					end,
					normalize = function(rawValue)
						local normalized = normalizeSliderValue(rawValue)
						return normalized, {
							changed = SliderSettings.CurrentValue ~= normalized
						}
					end,
					applyVisual = function(normalized, syncMeta)
						local animate = true
						if syncMeta and syncMeta.options and syncMeta.options.animate == false then
							animate = false
						end
						applySliderVisual(normalized, animate)
					end,
					emitCallback = function(normalized)
						SliderSettings.Callback(normalized)
					end,
					persist = function()
						ctx.SaveConfiguration()
					end,
					isExt = function()
						return SliderSettings.Ext == true
					end,
					isAlive = function()
						return Slider ~= nil and Slider.Parent ~= nil
					end,
					isVisibleContext = function()
						return Slider.Visible and Slider:IsDescendantOf(TabPage) and self.Elements.UIPageLayout.CurrentPage == TabPage
					end,
					onCallbackError = handleSliderCallbackError
				})

				local function commitSliderValue(rawValue, commitOptions)
					local options = commitOptions or {}
					if sliderSyncToken then
						return commitElementSync(sliderSyncToken, rawValue, {
							reason = options.reason or "slider_update",
							source = options.source or "unknown",
							emitCallback = options.emitCallback,
							persist = options.persist,
							forceCallback = options.forceCallback,
							animate = options.animate
						})
					end

					local normalized = normalizeSliderValue(rawValue)
					applySliderVisual(normalized, options.animate ~= false)
					local success, response = pcall(function()
						SliderSettings.Callback(normalized)
					end)
					if not success then
						handleSliderCallbackError(response)
					elseif not SliderSettings.Ext then
						ctx.SaveConfiguration()
					end
					return success
				end

				applySliderVisual(SliderSettings.CurrentValue, false)
	
				local sliderHoverBindingKey = registerHoverBinding(Slider,
					function()
						self.Animation:Create(Slider, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackgroundHover}):Play()
					end,
					function()
						self.Animation:Create(Slider, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackground}):Play()
					end
				)
	
				Slider.Main.Interact.InputBegan:Connect(function(Input)
					if Input.UserInputType == Enum.UserInputType.MouseButton1 or Input.UserInputType == Enum.UserInputType.Touch then 
						self.Animation:Create(Slider.Main.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 1}):Play()
						self.Animation:Create(Slider.Main.Progress.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 1}):Play()
						SLDragging = true 
					end 
				end)
	
				Slider.Main.Interact.InputEnded:Connect(function(Input) 
					if Input.UserInputType == Enum.UserInputType.MouseButton1 or Input.UserInputType == Enum.UserInputType.Touch then 
						self.Animation:Create(Slider.Main.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 0.4}):Play()
						self.Animation:Create(Slider.Main.Progress.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 0.3}):Play()
						SLDragging = false 
					end 
				end)
	
				Slider.Main.Interact.MouseButton1Down:Connect(function(X)
					local Current = Slider.Main.Progress.AbsolutePosition.X + Slider.Main.Progress.AbsoluteSize.X
					local Start = Current
					local Location = X
					local sliderProgressTween = nil
					local sliderProgressTweenInfo = TweenInfo.new(0.45, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out)
					local Loop; Loop = self.RunService.Stepped:Connect(function()
						if SLDragging then
							Location = self.UserInputService:GetMouseLocation().X
							Current = Current + 0.025 * (Location - Start)
	
							if Location < Slider.Main.AbsolutePosition.X then
								Location = Slider.Main.AbsolutePosition.X
							elseif Location > Slider.Main.AbsolutePosition.X + Slider.Main.AbsoluteSize.X then
								Location = Slider.Main.AbsolutePosition.X + Slider.Main.AbsoluteSize.X
							end
	
							if Current < Slider.Main.AbsolutePosition.X + 5 then
								Current = Slider.Main.AbsolutePosition.X + 5
							elseif Current > Slider.Main.AbsolutePosition.X + Slider.Main.AbsoluteSize.X then
								Current = Slider.Main.AbsolutePosition.X + Slider.Main.AbsoluteSize.X
							end
	
							if Current <= Location and (Location - Start) < 0 then
								Start = Location
							elseif Current >= Location and (Location - Start) > 0 then
								Start = Location
							end
							if sliderProgressTween then
								sliderProgressTween:Cancel()
							end
							sliderProgressTween = self.Animation:Create(Slider.Main.Progress, sliderProgressTweenInfo, {Size = UDim2.new(0, Current - Slider.Main.AbsolutePosition.X, 1, 0)})
							sliderProgressTween:Play()
							local NewValue = SliderSettings.Range[1] + (Location - Slider.Main.AbsolutePosition.X) / Slider.Main.AbsoluteSize.X * (SliderSettings.Range[2] - SliderSettings.Range[1])
							NewValue = normalizeSliderValue(NewValue)
							commitSliderValue(NewValue, {
								reason = "drag",
								source = "ui_drag",
								emitCallback = true,
								persist = true,
								forceCallback = false,
								animate = false
							})
						else
							self.Animation:Create(Slider.Main.Progress, TweenInfo.new(0.3, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out), {Size = UDim2.new(0, Location - Slider.Main.AbsolutePosition.X > 5 and Location - Slider.Main.AbsolutePosition.X or 5, 1, 0)}):Play()
							Loop:Disconnect()
						end
					end)
				end)
	
				function SliderSettings:Set(NewVal)
					commitSliderValue(NewVal, {
						reason = "set",
						source = "api_set",
						emitCallback = true,
						persist = true,
						forceCallback = true,
						animate = true
					})
				end
	
				if Settings.ConfigurationSaving then
					if Settings.ConfigurationSaving.Enabled and SliderSettings.Flag then
						self.RayfieldLibrary.Flags[SliderSettings.Flag] = SliderSettings
					end
				end
	
				self.Rayfield.Main:GetPropertyChangedSignal('BackgroundColor3'):Connect(function()
					if self.getSelectedTheme() ~= self.RayfieldLibrary.Theme.Default then
						Slider.Main.Shadow.Visible = false
					end
	
					Slider.Main.BackgroundColor3 = self.getSelectedTheme().SliderBackground
					Slider.Main.UIStroke.Color = self.getSelectedTheme().SliderStroke
					Slider.Main.Progress.UIStroke.Color = self.getSelectedTheme().SliderStroke
					Slider.Main.Progress.BackgroundColor3 = self.getSelectedTheme().SliderProgress
				end)
	
				function SliderSettings:Destroy()
					Slider:Destroy()
				end

				-- Add extended API
				addExtendedAPI(SliderSettings, SliderSettings.Name, "Slider", Slider, sliderHoverBindingKey, sliderSyncToken)

				return SliderSettings
			end

			local function normalizeBarSettings(rawSettings, defaults)
				local settings = rawSettings or {}
				settings.Name = settings.Name or defaults.name
				settings.Range = settings.Range or {0, 100}

				local rangeMin = tonumber(settings.Range[1]) or 0
				local rangeMax = tonumber(settings.Range[2]) or 100
				if rangeMax <= rangeMin then
					rangeMax = rangeMin + 1
				end
				settings.Range = {rangeMin, rangeMax}

				settings.Increment = tonumber(settings.Increment) or 1
				if settings.Increment <= 0 then
					settings.Increment = 1
				end

				local currentValue = tonumber(settings.CurrentValue)
				if currentValue == nil then
					currentValue = rangeMin
				end
				settings.CurrentValue = math.clamp(currentValue, rangeMin, rangeMax)

				if type(settings.Callback) ~= "function" then
					settings.Callback = function() end
				end

				if settings.Draggable == nil then
					settings.Draggable = defaults.draggable
				end

				settings.Type = defaults.typeName
				return settings
			end

			local function createCustomBar(rawSettings, customOptions)
				local ctx = self
				customOptions = customOptions or {}
				local barSettings = normalizeBarSettings(rawSettings, {
					name = customOptions.defaultName or "Bar",
					draggable = customOptions.defaultDraggable ~= false,
					typeName = customOptions.typeName or "Bar"
				})
				local showText = customOptions.showText == true
				local statusMode = customOptions.statusMode == true
				local barMin = barSettings.Range[1]
				local barMax = barSettings.Range[2]
				local barDragging = false

				local Bar = self.Elements.Template.Slider:Clone()
				Bar.Name = barSettings.Name
				Bar.Title.Text = barSettings.Name
				Bar.Visible = true
				Bar.Parent = TabPage

				Bar.BackgroundTransparency = 1
				Bar.UIStroke.Transparency = 1
				Bar.Title.TextTransparency = 1

				local BarMain = Bar.Main
				local BarProgress = BarMain.Progress
				local BarValueLabel = BarMain.Information

				if self.getSelectedTheme() ~= self.RayfieldLibrary.Theme.Default then
					BarMain.Shadow.Visible = false
				end

				self.bindTheme(BarMain, "BackgroundColor3", "SliderBackground")
				self.bindTheme(BarMain.UIStroke, "Color", "SliderStroke")
				self.bindTheme(BarProgress.UIStroke, "Color", "SliderStroke")
				self.bindTheme(BarProgress, "BackgroundColor3", "SliderProgress")

				self.Animation:Create(Bar, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0}):Play()
				self.Animation:Create(Bar.UIStroke, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {Transparency = 0}):Play()
				self.Animation:Create(Bar.Title, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {TextTransparency = 0}):Play()

				if showText then
					BarValueLabel.Visible = true
					if statusMode then
						BarValueLabel.AnchorPoint = Vector2.new(0.5, 0.5)
						BarValueLabel.Position = UDim2.new(0.5, 0, 0.5, 0)
						BarValueLabel.Size = UDim2.new(1, -8, 1, 0)
						BarValueLabel.TextXAlignment = Enum.TextXAlignment.Center
						BarValueLabel.TextYAlignment = Enum.TextYAlignment.Center
						BarValueLabel.ZIndex = BarProgress.ZIndex + 2
						BarValueLabel.TextStrokeTransparency = 0.7
						if barSettings.TextSize then
							BarValueLabel.TextSize = barSettings.TextSize
						end
					end
				else
					BarValueLabel.Visible = false
					BarValueLabel.TextTransparency = 1
				end

				local function ensureCorner(target, radiusPx)
					local corner = target:FindFirstChildWhichIsA("UICorner")
					if not corner then
						corner = Instance.new("UICorner")
						corner.Parent = target
					end
					corner.CornerRadius = UDim.new(0, radiusPx)
				end

				local function applyBarGeometry()
					local desiredHeight = tonumber(barSettings.Height) or tonumber(barSettings.BarHeight)
					if statusMode and not desiredHeight and barSettings.AutoHeight ~= false then
						local textSize = tonumber(barSettings.TextSize) or (BarValueLabel and BarValueLabel.TextSize or 14)
						desiredHeight = math.clamp(math.floor(textSize + 12), 26, 44)
					end

					if desiredHeight then
						desiredHeight = math.max(12, math.floor(desiredHeight))
						local baseYOffset = BarMain.Position.Y.Offset
						if baseYOffset <= 0 then
							baseYOffset = 24
						end
						BarMain.Size = UDim2.new(BarMain.Size.X.Scale, BarMain.Size.X.Offset, 0, desiredHeight)
						Bar.Size = UDim2.new(1, -10, 0, baseYOffset + desiredHeight + 10)
					end

					if statusMode or barSettings.Roundness then
						local roundness = tonumber(barSettings.Roundness)
						if not roundness then
							local sourceHeight = BarMain.Size.Y.Offset
							roundness = math.max(6, math.floor(sourceHeight / 2))
						end
						ensureCorner(BarMain, roundness)
						ensureCorner(BarProgress, roundness)
					end
				end

				applyBarGeometry()

				local function formatBarText(value)
					if not showText then
						return ""
					end

					local percent = ((value - barMin) / (barMax - barMin)) * 100
					if type(barSettings.TextFormatter) == "function" then
						local ok, custom = pcall(barSettings.TextFormatter, value, barMax, percent)
						if ok and custom ~= nil then
							return tostring(custom)
						end
					end

					local defaultText = tostring(value) .. "/" .. tostring(barMax)
					if barSettings.Suffix and tostring(barSettings.Suffix) ~= "" then
						defaultText = defaultText .. " " .. tostring(barSettings.Suffix)
					end
					return defaultText
				end

				local function valueToWidth(value)
					local width = BarMain.AbsoluteSize.X
					if width <= 0 then
						return 0
					end
					local ratio = math.clamp((value - barMin) / (barMax - barMin), 0, 1)
					local result = width * ratio
					if ratio > 0 and result < 5 then
						result = 5
					end
					return result
				end

				local function applyVisualValue(value, animate)
					local targetWidth = valueToWidth(value)
					if animate then
						self.Animation:Create(BarProgress, TweenInfo.new(0.3, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out), {Size = UDim2.new(0, targetWidth, 1, 0)}):Play()
					else
						BarProgress.Size = UDim2.new(0, targetWidth, 1, 0)
					end

					if showText and BarValueLabel then
						BarValueLabel.Text = formatBarText(value)
					end
				end

				local function handleBarCallbackError(response)
					self.Animation:Create(Bar, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = Color3.fromRGB(85, 0, 0)}):Play()
					self.Animation:Create(Bar.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 1}):Play()
					Bar.Title.Text = "Callback Error"
					print("Rayfield | " .. barSettings.Name .. " Callback Error " .. tostring(response))
					warn('Check docs.sirius.menu for help with Rayfield specific development.')
					task.wait(0.5)
					Bar.Title.Text = barSettings.Name
					self.Animation:Create(Bar, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackground}):Play()
					self.Animation:Create(Bar.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 0}):Play()
				end

				local function triggerCallback(nextValue)
					local Success, Response = pcall(function()
						barSettings.Callback(nextValue)
					end)
					if not Success then
						handleBarCallbackError(Response)
					end
					return Success
				end

				local function normalizeValue(rawValue)
					local value = math.clamp(tonumber(rawValue) or barMin, barMin, barMax)
					value = math.floor((value / barSettings.Increment) + 0.5) * barSettings.Increment
					value = math.floor((value * 10000000) + 0.5) / 10000000
					return math.clamp(value, barMin, barMax)
				end

				local barSyncToken = nil
				local function applyBarValue(rawValue, opts)
					opts = opts or {}
					if barSyncToken then
						return commitElementSync(barSyncToken, rawValue, {
							reason = opts.reason or "bar_update",
							source = opts.source or "unknown",
							emitCallback = opts.emitCallback,
							persist = opts.persist,
							forceCallback = opts.forceCallback,
							animate = opts.animate
						})
					end

					local nextValue = normalizeValue(rawValue)
					applyVisualValue(nextValue, opts.animate ~= false)
					local callbackSuccess = triggerCallback(nextValue)
					barSettings.CurrentValue = nextValue
					if callbackSuccess and opts.persist and not barSettings.Ext then
						self.SaveConfiguration()
					end
					return callbackSuccess
				end

				barSyncToken = registerElementSync({
					name = barSettings.Name,
					getState = function()
						return barSettings.CurrentValue
					end,
					normalize = function(rawValue)
						local nextValue = normalizeValue(rawValue)
						return nextValue, {
							changed = barSettings.CurrentValue ~= nextValue
						}
					end,
					applyVisual = function(value, syncMeta)
						local animate = true
						if syncMeta and syncMeta.options and syncMeta.options.animate == false then
							animate = false
						end
						applyVisualValue(value, animate)
						barSettings.CurrentValue = value
					end,
					emitCallback = function(value)
						barSettings.Callback(value)
					end,
					persist = function()
						self.SaveConfiguration()
					end,
					isExt = function()
						return barSettings.Ext == true
					end,
					isAlive = function()
						return Bar ~= nil and Bar.Parent ~= nil
					end,
					isVisibleContext = function()
						return Bar.Visible and Bar:IsDescendantOf(TabPage) and self.Elements.UIPageLayout.CurrentPage == TabPage
					end,
					onCallbackError = handleBarCallbackError
				})

				applyVisualValue(barSettings.CurrentValue, false)
				task.defer(function()
					if Bar and Bar.Parent then
						applyVisualValue(barSettings.CurrentValue, false)
					end
				end)

				local barHoverBindingKey = registerHoverBinding(Bar,
					function()
						self.Animation:Create(Bar, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackgroundHover}):Play()
					end,
					function()
						self.Animation:Create(Bar, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundColor3 = self.getSelectedTheme().ElementBackground}):Play()
					end
				)

				BarMain.Interact.InputBegan:Connect(function(Input)
					if not barSettings.Draggable then
						return
					end
					if Input.UserInputType == Enum.UserInputType.MouseButton1 or Input.UserInputType == Enum.UserInputType.Touch then
						self.Animation:Create(BarMain.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 1}):Play()
						self.Animation:Create(BarProgress.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 1}):Play()
						barDragging = true
					end
				end)

				BarMain.Interact.InputEnded:Connect(function(Input)
					if not barSettings.Draggable then
						return
					end
					if Input.UserInputType == Enum.UserInputType.MouseButton1 or Input.UserInputType == Enum.UserInputType.Touch then
						self.Animation:Create(BarMain.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 0.4}):Play()
						self.Animation:Create(BarProgress.UIStroke, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Transparency = 0.3}):Play()
						barDragging = false
					end
				end)

				BarMain.Interact.MouseButton1Down:Connect(function(mouseX)
					if not barSettings.Draggable then
						return
					end

					local currentX = BarProgress.AbsolutePosition.X + BarProgress.AbsoluteSize.X
					local startX = currentX
					local locationX = mouseX
					local progressTween = nil
					local tweenInfo = TweenInfo.new(0.45, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out)

					local loopConn
					loopConn = self.RunService.Stepped:Connect(function()
						if barDragging then
							locationX = self.UserInputService:GetMouseLocation().X
							currentX = currentX + 0.025 * (locationX - startX)

							local minX = BarMain.AbsolutePosition.X
							local maxX = BarMain.AbsolutePosition.X + BarMain.AbsoluteSize.X

							if locationX < minX then
								locationX = minX
							elseif locationX > maxX then
								locationX = maxX
							end

							if currentX < minX + 5 then
								currentX = minX + 5
							elseif currentX > maxX then
								currentX = maxX
							end

							if (currentX <= locationX and (locationX - startX) < 0) or (currentX >= locationX and (locationX - startX) > 0) then
								startX = locationX
							end

							if progressTween then
								progressTween:Cancel()
							end
							progressTween = self.Animation:Create(BarProgress, tweenInfo, {Size = UDim2.new(0, currentX - minX, 1, 0)})
							progressTween:Play()

							local nextValue = barMin + ((locationX - minX) / math.max(1, BarMain.AbsoluteSize.X)) * (barMax - barMin)
							if barSettings.CurrentValue ~= normalizeValue(nextValue) then
								applyBarValue(nextValue, {animate = false, persist = true})
							end
						else
							self.Animation:Create(BarProgress, TweenInfo.new(0.3, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out), {
								Size = UDim2.new(0, locationX - BarMain.AbsolutePosition.X > 5 and locationX - BarMain.AbsolutePosition.X or 5, 1, 0)
							}):Play()

							if loopConn then
								loopConn:Disconnect()
							end
						end
					end)
				end)

				function barSettings:Set(NewVal)
					applyBarValue(NewVal, {animate = true, persist = true, forceCallback = true})
				end

				function barSettings:Get()
					return barSettings.CurrentValue
				end

				if Settings.ConfigurationSaving then
					if Settings.ConfigurationSaving.Enabled and barSettings.Flag then
						self.RayfieldLibrary.Flags[barSettings.Flag] = barSettings
					end
				end

				self.Rayfield.Main:GetPropertyChangedSignal('BackgroundColor3'):Connect(function()
					if self.getSelectedTheme() ~= self.RayfieldLibrary.Theme.Default then
						BarMain.Shadow.Visible = false
					end

					BarMain.BackgroundColor3 = self.getSelectedTheme().SliderBackground
					BarMain.UIStroke.Color = self.getSelectedTheme().SliderStroke
					BarProgress.UIStroke.Color = self.getSelectedTheme().SliderStroke
					BarProgress.BackgroundColor3 = self.getSelectedTheme().SliderProgress
					if showText and BarValueLabel then
						BarValueLabel.TextColor3 = self.getSelectedTheme().TextColor
					end
				end)

				function barSettings:Destroy()
					Bar:Destroy()
				end

				addExtendedAPI(barSettings, barSettings.Name, customOptions.typeName or "Bar", Bar, barHoverBindingKey, barSyncToken)
				return barSettings
			end

			function Tab:CreateTrackBar(TrackBarSettings)
				return createCustomBar(TrackBarSettings, {
					defaultName = "Track Bar",
					defaultDraggable = true,
					showText = false,
					statusMode = false,
					typeName = "TrackBar"
				})
			end

			function Tab:CreateStatusBar(StatusBarSettings)
				return createCustomBar(StatusBarSettings, {
					defaultName = "Status Bar",
					defaultDraggable = false,
					showText = true,
					statusMode = true,
					typeName = "StatusBar"
				})
			end

			function Tab:CreateDragBar(settings)
				return self:CreateTrackBar(settings)
			end

			function Tab:CreateSliderLite(settings)
				return self:CreateTrackBar(settings)
			end

			function Tab:CreateInfoBar(settings)
				return self:CreateStatusBar(settings)
			end

			function Tab:CreateSliderDisplay(settings)
				return self:CreateStatusBar(settings)
			end
	
			self.Rayfield.Main:GetPropertyChangedSignal('BackgroundColor3'):Connect(function()
				TabButton.UIStroke.Color = self.getSelectedTheme().TabStroke
	
				if self.Elements.UIPageLayout.CurrentPage == TabPage then
					TabButton.BackgroundColor3 = self.getSelectedTheme().TabBackgroundSelected
					TabButton.Image.ImageColor3 = self.getSelectedTheme().SelectedTabTextColor
					TabButton.Title.TextColor3 = self.getSelectedTheme().SelectedTabTextColor
				else
					TabButton.BackgroundColor3 = self.getSelectedTheme().TabBackground
					TabButton.Image.ImageColor3 = self.getSelectedTheme().TabTextColor
					TabButton.Title.TextColor3 = self.getSelectedTheme().TabTextColor
				end
			end)
	
			return Tab
		end

	
	-- Export function
	self.CreateTab = CreateTab
	self.getFirstTab = function() return FirstTab end
	self.getTabRecordByPersistenceId = function(tabId)
		if tabId == nil then
			return nil
		end
		return tabRecordsByPersistenceId[tostring(tabId)]
	end
	self.getTabLayoutOrderByPersistenceId = function(tabId)
		local record = self.getTabRecordByPersistenceId(tabId)
		if not record or not record.TabPage then
			return math.huge
		end
		return tonumber(record.TabPage.LayoutOrder) or math.huge
	end
	self.getCurrentTabPersistenceId = function()
		local currentPage = self.Elements and self.Elements.UIPageLayout and self.Elements.UIPageLayout.CurrentPage
		if not currentPage then
			return nil
		end
		for persistenceId, record in pairs(tabRecordsByPersistenceId) do
			if record and record.TabPage == currentPage then
				return persistenceId
			end
		end
		return nil
	end
	self.activateTabByPersistenceId = function(tabId, ignoreMinimisedCheck)
		local record = self.getTabRecordByPersistenceId(tabId)
		if not record or type(record.Activate) ~= "function" then
			return false
		end
		return record.Activate(ignoreMinimisedCheck == true)
	end
	self.listControlsForFavorites = function(pruneMissing)
		return listControlsForFavorites(pruneMissing == true)
	end
	self.pinControl = function(idOrFlag)
		return pinControl(tostring(idOrFlag or ""))
	end
	self.unpinControl = function(idOrFlag)
		return unpinControl(tostring(idOrFlag or ""))
	end
	self.getPinnedIds = function(pruneMissing)
		return cloneArray(getPinnedIds(pruneMissing == true))
	end
	self.setPinnedIds = function(ids)
		setPinnedIds(ids)
		return true
	end
	self.setPinBadgesVisible = function(visible)
		setPinBadgesVisible(visible ~= false)
		return true
	end
	self.subscribeControlRegistry = function(callback)
		if type(callback) ~= "function" then
			return function() end
		end
		controlRegistrySubscribers[callback] = true
		local unsubscribed = false
		return function()
			if unsubscribed then
				return
			end
			unsubscribed = true
			controlRegistrySubscribers[callback] = nil
		end
	end
	self.getControlRecordById = function(id)
		return getControlRecordById(id)
	end
	
	return self
end

return ElementsModule
]])
put("src/ui/elements/widgets/bootstrap.lua", [[local WidgetBootstrap = {}

local DEFAULT_ROOT = "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
local TRACE_FLAG_KEY = "__RAYFIELD_WIDGET_TRACE"
local TRACE_PREFIX = "[RAYFIELD][WIDGET_BOOTSTRAP]"

local function getSharedUtils()
	if type(_G) == "table" and type(_G.__RayfieldSharedUtils) == "table" then
		return _G.__RayfieldSharedUtils
	end
	return nil
end

local function trim(value)
	local shared = getSharedUtils()
	if shared and type(shared.trim) == "function" then
		return shared.trim(value)
	end
	if type(value) ~= "string" then
		return ""
	end
	local out = value:gsub("^%s+", "")
	out = out:gsub("%s+$", "")
	return out
end

local function shouldTrace(level)
	if level == "error" then
		return true
	end
	return type(_G) == "table" and _G[TRACE_FLAG_KEY] == true
end

function WidgetBootstrap.trace(branchId, level, data)
	local payload = data or {}
	local branch = tostring(branchId or "unknown")
	local stage = tostring(payload.stage or "widgets.bootstrap")
	local moduleName = tostring(payload.module or "unknown")
	local reason = tostring(payload.reason or "n/a")
	local nextAction = tostring(payload.next_action or "n/a")
	local traceLevel = tostring(level or "info")
	local message = string.format(
		"%s branch_id=%s level=%s stage=%s module=%s reason=%s next_action=%s",
		TRACE_PREFIX,
		branch,
		traceLevel,
		stage,
		moduleName,
		reason,
		nextAction
	)

	if shouldTrace(traceLevel) then
		if traceLevel == "error" then
			warn(message)
		else
			print(message)
		end
	end
end

function WidgetBootstrap.fail(code, message, data)
	local payload = data or {}
	local moduleName = tostring(payload.module or "unknown")
	local stage = tostring(payload.stage or "widgets.bootstrap")
	local branch = tostring(payload.branch_id or code or "unknown")
	local reason = tostring(message or "unknown_error")
	local errorCode = tostring(code or "E_UNKNOWN")

	WidgetBootstrap.trace(branch, "error", {
		stage = stage,
		module = moduleName,
		reason = reason,
		next_action = payload.next_action or "stop"
	})

	error(string.format("[%s] %s (module=%s, stage=%s, branch_id=%s)", errorCode, reason, moduleName, stage, branch))
end

local function normalizeRoot(rawRoot)
	local root = trim(rawRoot)
	if root == "" then
		return nil, "root_empty"
	end
	if root:find("%s") then
		return nil, "root_contains_whitespace"
	end
	if not root:match("^https?://") then
		return nil, "root_not_http_url"
	end
	if root:sub(-1) ~= "/" then
		root = root .. "/"
	end
	return root, nil
end

local function normalizeTargetPath(rawTargetPath)
	if type(rawTargetPath) ~= "string" then
		return nil, "target_not_string"
	end
	local path = trim(rawTargetPath)
	path = path:gsub("^/+", "")
	if path == "" then
		return nil, "target_empty"
	end
	return path, nil
end

function WidgetBootstrap.bootstrapWidget(widgetName, targetPath, exportAdapter, options)
	local opts = options or {}
	local moduleName = tostring(widgetName or "unknown_widget")
	local stage = "widgets.bootstrap"
	local expectedType = opts.expectedType or "table"

	WidgetBootstrap.trace("B01_CLIENT_PRESENT", "debug", {
		stage = stage,
		module = moduleName,
		reason = "checking _G.__RayfieldApiClient",
		next_action = "validate_client_contract"
	})
	local client = _G and _G.__RayfieldApiClient
	if not client then
		WidgetBootstrap.fail("E_CLIENT_MISSING", "Rayfield ApiClient is not initialized", {
			branch_id = "B01_CLIENT_PRESENT",
			stage = stage,
			module = moduleName,
			next_action = "stop"
		})
	end

	WidgetBootstrap.trace("B02_CLIENT_CONTRACT", "debug", {
		stage = stage,
		module = moduleName,
		reason = "checking client.fetchAndExecute contract",
		next_action = "resolve_root"
	})
	if type(client.fetchAndExecute) ~= "function" then
		WidgetBootstrap.fail("E_CLIENT_INVALID", "ApiClient.fetchAndExecute must be a function", {
			branch_id = "B02_CLIENT_CONTRACT",
			stage = stage,
			module = moduleName,
			next_action = "stop"
		})
	end

	WidgetBootstrap.trace("B03_ROOT_RESOLVE", "debug", {
		stage = stage,
		module = moduleName,
		reason = "resolving runtime root URL",
		next_action = "build_target_path"
	})
	local rawRoot = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or DEFAULT_ROOT
	local root, rootErr = normalizeRoot(rawRoot)
	if not root then
		WidgetBootstrap.fail("E_ROOT_INVALID", "Invalid runtime root URL: " .. tostring(rootErr), {
			branch_id = "B03_ROOT_RESOLVE",
			stage = stage,
			module = moduleName,
			next_action = "stop"
		})
	end

	WidgetBootstrap.trace("B04_TARGET_BUILD", "debug", {
		stage = stage,
		module = moduleName,
		reason = "building target module URL",
		next_action = "fetch_execute"
	})
	local normalizedTarget, targetErr = normalizeTargetPath(targetPath)
	if not normalizedTarget then
		WidgetBootstrap.fail("E_TARGET_INVALID", "Invalid target module path: " .. tostring(targetErr), {
			branch_id = "B04_TARGET_BUILD",
			stage = stage,
			module = moduleName,
			next_action = "stop"
		})
	end
	local fullPath = root .. normalizedTarget

	WidgetBootstrap.trace("B05_FETCH_EXEC", "debug", {
		stage = stage,
		module = moduleName,
		reason = "fetchAndExecute module",
		next_action = "validate_export"
	})
	local ok, exported = pcall(client.fetchAndExecute, fullPath)
	if not ok then
		WidgetBootstrap.fail("E_FETCH_FAILED", tostring(exported), {
			branch_id = "B05_FETCH_EXEC",
			stage = stage,
			module = moduleName,
			next_action = "stop"
		})
	end

	if type(exportAdapter) ~= "nil" and type(exportAdapter) ~= "function" then
		WidgetBootstrap.fail("E_EXPORT_INVALID", "exportAdapter must be a function when provided", {
			branch_id = "B06_EXPORT_VALIDATE",
			stage = stage,
			module = moduleName,
			next_action = "stop"
		})
	end

	WidgetBootstrap.trace("B06_EXPORT_VALIDATE", "debug", {
		stage = stage,
		module = moduleName,
		reason = "validating exported module",
		next_action = "return_export"
	})
	if type(exportAdapter) == "function" then
		local adaptOk, adapted = pcall(exportAdapter, exported)
		if not adaptOk then
			WidgetBootstrap.fail("E_EXPORT_INVALID", "exportAdapter failed: " .. tostring(adapted), {
				branch_id = "B06_EXPORT_VALIDATE",
				stage = stage,
				module = moduleName,
				next_action = "stop"
			})
		end
		exported = adapted
	end

	if exported == nil then
		WidgetBootstrap.fail("E_EXPORT_INVALID", "module export is nil", {
			branch_id = "B06_EXPORT_VALIDATE",
			stage = stage,
			module = moduleName,
			next_action = "stop"
		})
	end

	if expectedType ~= "any" and type(exported) ~= expectedType then
		WidgetBootstrap.fail("E_EXPORT_INVALID", "Expected export type '" .. tostring(expectedType) .. "', got '" .. type(exported) .. "'", {
			branch_id = "B06_EXPORT_VALIDATE",
			stage = stage,
			module = moduleName,
			next_action = "stop"
		})
	end

	WidgetBootstrap.trace("B07_RETURN", "info", {
		stage = stage,
		module = moduleName,
		reason = "bootstrap completed successfully",
		next_action = "return"
	})
	return exported
end

if _G then
	_G.__RayfieldWidgetBootstrap = WidgetBootstrap
end

return WidgetBootstrap
]])
put("src/ui/elements/widgets/button.lua", [[local bootstrap = _G and _G.__RayfieldWidgetBootstrap
if not bootstrap then
	error("[E_BOOTSTRAP_MISSING] Rayfield widget bootstrap is not initialized")
end
if type(bootstrap) ~= "table" or type(bootstrap.bootstrapWidget) ~= "function" then
	error("[E_BOOTSTRAP_INVALID] Rayfield widget bootstrap contract is invalid")
end

return bootstrap.bootstrapWidget(
	"button",
	"src/ui/elements/widgets/index.lua",
	function(widgetsIndex)
		return {
			name = "button",
			index = widgetsIndex
		}
	end,
	{ expectedType = "table" }
)
]])
put("src/ui/elements/widgets/dropdown.lua", [[local bootstrap = _G and _G.__RayfieldWidgetBootstrap
if not bootstrap then
	error("[E_BOOTSTRAP_MISSING] Rayfield widget bootstrap is not initialized")
end
if type(bootstrap) ~= "table" or type(bootstrap.bootstrapWidget) ~= "function" then
	error("[E_BOOTSTRAP_INVALID] Rayfield widget bootstrap contract is invalid")
end

return bootstrap.bootstrapWidget(
	"dropdown",
	"src/ui/elements/widgets/index.lua",
	function(widgetsIndex)
		return {
			name = "dropdown",
			index = widgetsIndex
		}
	end,
	{ expectedType = "table" }
)
]])
put("src/ui/elements/widgets/extracted.lua", [[local bootstrap = _G and _G.__RayfieldWidgetBootstrap
if not bootstrap then
	error("[E_BOOTSTRAP_MISSING] Rayfield widget bootstrap is not initialized")
end
if type(bootstrap) ~= "table" or type(bootstrap.bootstrapWidget) ~= "function" then
	error("[E_BOOTSTRAP_INVALID] Rayfield widget bootstrap contract is invalid")
end

return bootstrap.bootstrapWidget(
	"extracted",
	"src/ui/elements/widgets/index.lua",
	nil,
	{ expectedType = "table" }
)
]])
put("src/ui/elements/widgets/index.lua", [[local bootstrap = _G and _G.__RayfieldWidgetBootstrap
if not bootstrap then
	error("[E_BOOTSTRAP_MISSING] Rayfield widget bootstrap is not initialized")
end
if type(bootstrap) ~= "table" or type(bootstrap.bootstrapWidget) ~= "function" then
	error("[E_BOOTSTRAP_INVALID] Rayfield widget bootstrap contract is invalid")
end

return bootstrap.bootstrapWidget(
	"widgets.index",
	"src/ui/elements/factory/init.lua",
	nil,
	{ expectedType = "table" }
)
]])
put("src/ui/elements/widgets/input.lua", [[local bootstrap = _G and _G.__RayfieldWidgetBootstrap
if not bootstrap then
	error("[E_BOOTSTRAP_MISSING] Rayfield widget bootstrap is not initialized")
end
if type(bootstrap) ~= "table" or type(bootstrap.bootstrapWidget) ~= "function" then
	error("[E_BOOTSTRAP_INVALID] Rayfield widget bootstrap contract is invalid")
end

return bootstrap.bootstrapWidget(
	"input",
	"src/ui/elements/widgets/index.lua",
	function(widgetsIndex)
		return {
			name = "input",
			index = widgetsIndex
		}
	end,
	{ expectedType = "table" }
)
]])
put("src/ui/elements/widgets/keybind.lua", [[local bootstrap = _G and _G.__RayfieldWidgetBootstrap
if not bootstrap then
	error("[E_BOOTSTRAP_MISSING] Rayfield widget bootstrap is not initialized")
end
if type(bootstrap) ~= "table" or type(bootstrap.bootstrapWidget) ~= "function" then
	error("[E_BOOTSTRAP_INVALID] Rayfield widget bootstrap contract is invalid")
end

return bootstrap.bootstrapWidget(
	"keybind",
	"src/ui/elements/widgets/index.lua",
	function(widgetsIndex)
		return {
			name = "keybind",
			index = widgetsIndex
		}
	end,
	{ expectedType = "table" }
)
]])
put("src/ui/elements/widgets/slider.lua", [[local bootstrap = _G and _G.__RayfieldWidgetBootstrap
if not bootstrap then
	error("[E_BOOTSTRAP_MISSING] Rayfield widget bootstrap is not initialized")
end
if type(bootstrap) ~= "table" or type(bootstrap.bootstrapWidget) ~= "function" then
	error("[E_BOOTSTRAP_INVALID] Rayfield widget bootstrap contract is invalid")
end

return bootstrap.bootstrapWidget(
	"slider",
	"src/ui/elements/widgets/index.lua",
	function(widgetsIndex)
		return {
			name = "slider",
			index = widgetsIndex
		}
	end,
	{ expectedType = "table" }
)
]])
put("src/ui/elements/widgets/toggle.lua", [[local bootstrap = _G and _G.__RayfieldWidgetBootstrap
if not bootstrap then
	error("[E_BOOTSTRAP_MISSING] Rayfield widget bootstrap is not initialized")
end
if type(bootstrap) ~= "table" or type(bootstrap.bootstrapWidget) ~= "function" then
	error("[E_BOOTSTRAP_INVALID] Rayfield widget bootstrap contract is invalid")
end

return bootstrap.bootstrapWidget(
	"toggle",
	"src/ui/elements/widgets/index.lua",
	function(widgetsIndex)
		return {
			name = "toggle",
			index = widgetsIndex
		}
	end,
	{ expectedType = "table" }
)
]])
put("src/ui/notifications.lua", [[local client = _G and _G.__RayfieldApiClient
if not client then
	error("Rayfield ApiClient is not initialized")
end

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
return client.fetchAndExecute(root .. "src/ui/notifications/init.lua")]])
put("src/ui/notifications/init.lua", [[local NotificationsUi = {}

function NotificationsUi.init(ctx)
	return {
		ctx = ctx
	}
end

return NotificationsUi]])
put("src/ui/tabs.lua", [[local client = _G and _G.__RayfieldApiClient
if not client then
	error("Rayfield ApiClient is not initialized")
end

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
return client.fetchAndExecute(root .. "src/ui/tabs/init.lua")]])
put("src/ui/tabs/init.lua", [[local TabsUi = {}

function TabsUi.init(ctx)
	return {
		ctx = ctx
	}
end

return TabsUi]])
put("src/ui/topbar.lua", [[local client = _G and _G.__RayfieldApiClient
if not client then
	error("Rayfield ApiClient is not initialized")
end

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
return client.fetchAndExecute(root .. "src/ui/topbar/init.lua")]])
put("src/ui/topbar/init.lua", [[local TopbarUi = {}

function TopbarUi.init(ctx)
	return {
		ctx = ctx
	}
end

return TopbarUi]])
put("src/ui/window-shell.lua", [[local client = _G and _G.__RayfieldApiClient
if not client then
	error("Rayfield ApiClient is not initialized")
end

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
return client.fetchAndExecute(root .. "src/ui/window/init.lua")]])
put("src/ui/window/init.lua", [[local WindowUi = {}

function WindowUi.init(ctx)
	return {
		ctx = ctx
	}
end

return WindowUi]])

return {
	name = BUNDLE_NAME,
	count = 87,
	bundle = bundle
}
