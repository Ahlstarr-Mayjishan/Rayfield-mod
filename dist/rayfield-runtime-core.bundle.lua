-- AUTO-GENERATED by scripts/build-bundle.lua
local bundle = _G.__RAYFIELD_BUNDLE_SOURCES or {}
_G.__RAYFIELD_BUNDLE_SOURCES = bundle
_G.__RAYFIELD_BUNDLE_MODE = "bundle_first"

local function put(path, source)
	bundle[path] = source
end

local BUNDLE_NAME = "rayfield-runtime-core"

put("Main loader/rayfield-all-in-one.lua", [[local compileString = loadstring or load
if not compileString then
	error("No Lua compiler function available (loadstring/load)")
end

local function compileChunk(source, label)
	if type(source) ~= "string" then
		error("Invalid Lua source for " .. tostring(label) .. ": " .. type(source))
	end
	source = source:gsub("^\239\187\191", "")
	source = source:gsub("^\0+", "")
	local chunk, err = compileString(source)
	if not chunk then
		error("Failed to compile " .. tostring(label) .. ": " .. tostring(err))
	end
	return chunk
end
	
local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
local forwardSource = game:HttpGet(root .. "src/legacy/forward.lua")
if type(forwardSource) == "string" then
	forwardSource = forwardSource:gsub("^\239\187\191", "")
	forwardSource = forwardSource:gsub("^\0+", "")
end
local Forward = compileChunk(forwardSource, "src/legacy/forward.lua")()
return Forward.module("allInOne")
]])
put("Main loader/rayfield-modified.lua", [[local compileString = loadstring or load
if not compileString then
	error("No Lua compiler function available (loadstring/load)")
end

local function formatBootstrapError(code, message)
	return string.format("Rayfield Mod: [%s] %s", tostring(code or "E_BOOTSTRAP"), tostring(message or "Unknown bootstrap error"))
end

local function compileChunk(source, label)
	if type(source) ~= "string" then
		error("Invalid Lua source for " .. tostring(label) .. ": " .. type(source))
	end
	source = source:gsub("^\239\187\191", "")
	source = source:gsub("^\0+", "")
	local chunk, err = compileString(source)
	if not chunk then
		error("Failed to compile " .. tostring(label) .. ": " .. tostring(err))
	end
	return chunk
end

local function fetchSource(url, label)
	local ok, body = pcall(game.HttpGet, game, url)
	if not ok then
		error(formatBootstrapError("E_BOOTSTRAP_FETCH", "Failed to fetch " .. tostring(label) .. ": " .. tostring(body)))
	end
	if type(body) ~= "string" or #body == 0 then
		error(formatBootstrapError("E_BOOTSTRAP_EMPTY", "Empty response for " .. tostring(label)))
	end
	return body
end

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"

local forwardOk, forwardResult = pcall(function()
	local forwardSource = fetchSource(root .. "src/legacy/forward.lua", "src/legacy/forward.lua")
	local Forward = compileChunk(forwardSource, "src/legacy/forward.lua")()
	if type(Forward) ~= "table" or type(Forward.module) ~= "function" then
		error(formatBootstrapError("E_BOOTSTRAP_FORWARD", "Invalid legacy forward contract"))
	end
	return Forward.module("modifiedEntry")
end)

if forwardOk then
	return forwardResult
end

warn(formatBootstrapError("W_BOOTSTRAP_FORWARD_FALLBACK", "Legacy forward failed, trying direct entry fallback."))
warn(formatBootstrapError("W_BOOTSTRAP_FORWARD_REASON", tostring(forwardResult)))

local fallbackSource = fetchSource(root .. "src/entry/rayfield-modified.entry.lua", "src/entry/rayfield-modified.entry.lua")
local fallback = compileChunk(fallbackSource, "src/entry/rayfield-modified.entry.lua")()
return fallback
]])
put("feature/rayfield-all-in-one.lua", [[local compileString = loadstring or load
if not compileString then
	error("No Lua compiler function available (loadstring/load)")
end

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
local Forward = compileString(game:HttpGet(root .. "src/legacy/forward.lua"))()
return Forward.module("allInOne")
]])
put("src/api/cache.lua", [[local Cache = {}

_G.__RayfieldApiModuleCache = _G.__RayfieldApiModuleCache or {}

function Cache.get(key)
	return _G.__RayfieldApiModuleCache[key]
end

function Cache.set(key, value)
	_G.__RayfieldApiModuleCache[key] = value
	return value
end

function Cache.invalidate(key)
	_G.__RayfieldApiModuleCache[key] = nil
end

function Cache.clear()
	table.clear(_G.__RayfieldApiModuleCache)
end

return Cache
]])
put("src/api/client.lua", [[local Client = {}

local DEFAULT_TIMEOUT = 8

local function getBundleTable()
	if type(_G) ~= "table" or type(_G.__RAYFIELD_BUNDLE_SOURCES) ~= "table" then
		return nil
	end
	return _G.__RAYFIELD_BUNDLE_SOURCES
end

local function getBrokenBundleMap()
	if type(_G) ~= "table" then
		return nil
	end
	if type(_G.__RAYFIELD_BUNDLE_BROKEN_PATHS) ~= "table" then
		_G.__RAYFIELD_BUNDLE_BROKEN_PATHS = {}
	end
	return _G.__RAYFIELD_BUNDLE_BROKEN_PATHS
end

local function sanitizeLuaSource(code)
	if type(code) ~= "string" then
		return code
	end
	code = code:gsub("^\239\187\191", "")
	code = code:gsub("^\0+", "")
	return code
end

local function normalizeUrl(url)
	if type(url) ~= "string" or #url == 0 then
		error("Client.request expected non-empty URL string")
	end
	return url
end

local function resolveBundlePath(url)
	local function urlDecode(value)
		return (value:gsub("%%(%x%x)", function(hex)
			return string.char(tonumber(hex, 16))
		end))
	end

	local runtimeRoot = nil
	if type(_G) == "table" and type(_G.__RAYFIELD_RUNTIME_ROOT_URL) == "string" and _G.__RAYFIELD_RUNTIME_ROOT_URL ~= "" then
		runtimeRoot = _G.__RAYFIELD_RUNTIME_ROOT_URL
	end
	if runtimeRoot and url:sub(1, #runtimeRoot) == runtimeRoot then
		return urlDecode(url:sub(#runtimeRoot + 1))
	end

	local githubPath = url:match("^https?://raw%.githubusercontent%.com/[^/]+/[^/]+/[^/]+/(.+)$")
	if githubPath then
		return urlDecode(githubPath)
	end

	return nil
end

local function tryGetBundledSource(url, opts)
	opts = opts or {}
	if opts.noBundle then
		return nil, nil
	end

	local bundle = getBundleTable()
	if not bundle then
		return nil, nil
	end

	local path = resolveBundlePath(url)
	local broken = getBrokenBundleMap()
	if path and broken and broken[path] then
		return nil, path
	end
	if broken and broken[url] then
		return nil, path
	end

	if path then
		local byPath = bundle[path]
		if type(byPath) == "string" and #byPath > 0 then
			return byPath, path
		end
	end

	local byUrl = bundle[url]
	if type(byUrl) == "string" and #byUrl > 0 then
		return byUrl, path
	end

	return nil, path
end

local function resolveSource(url, opts)
	opts = opts or {}
	local bundledSource, bundledPath = tryGetBundledSource(url, opts)
	if bundledSource then
		return bundledSource, true, bundledPath
	end

	local ok, payload = Client.request(url, opts)
	if not ok then
		error(tostring(payload))
	end
	if type(payload) ~= "string" then
		error("Client.fetch expected string payload, got " .. type(payload))
	end
	return payload, false, bundledPath
end

function Client.request(url, opts)
	url = normalizeUrl(url)
	opts = opts or {}
	local timeout = tonumber(opts.timeout) or DEFAULT_TIMEOUT
	local completed = false
	local okResult = false
	local payload = nil

	local worker = task.spawn(function()
		local ok, result = pcall(game.HttpGet, game, url)
		okResult = ok
		payload = result
		completed = true
	end)

	local timeoutThread = task.delay(timeout, function()
		if completed then
			return
		end
		completed = true
		okResult = false
		payload = "Request timed out after " .. tostring(timeout) .. " seconds"
		pcall(task.cancel, worker)
	end)

	while not completed do
		task.wait()
	end

	pcall(task.cancel, timeoutThread)
	return okResult, payload
end

function Client.fetch(url, opts)
	local source = resolveSource(url, opts)
	return source
end

function Client.compile(code)
	if type(code) ~= "string" or #code == 0 then
		error("Client.compile expected non-empty Lua source string")
	end
	code = sanitizeLuaSource(code)
	local compileString = loadstring or load
	if not compileString then
		error("No Lua compiler function available (loadstring/load)")
	end
	local chunk, compileError = compileString(code)
	if not chunk then
		error("Client.compile failed: " .. tostring(compileError))
	end
	return chunk
end

function Client.execute(code)
	return Client.compile(code)()
end

function Client.fetchAndExecute(url, opts)
	opts = opts or {}
	local code, fromBundle, bundlePath = resolveSource(url, opts)
	local okExecute, result = pcall(Client.execute, code)
	if okExecute then
		return result
	end

	if fromBundle then
		local broken = getBrokenBundleMap()
		if broken then
			if bundlePath then
				broken[bundlePath] = true
			end
			broken[url] = true
		end
		local retryOpts = {}
		for key, value in pairs(opts) do
			retryOpts[key] = value
		end
		retryOpts.noBundle = true
		local retryCode = Client.fetch(url, retryOpts)
		return Client.execute(retryCode)
	end

	error(result)
end

if _G then
	_G.__RayfieldApiClient = Client
end

return Client
]])
put("src/api/errors.lua", [[local Errors = {}

function Errors.tagged(code, message)
	local safeCode = tostring(code or "E_UNKNOWN")
	local safeMessage = tostring(message or "Unknown error")
	return string.format("Rayfield Mod: [%s] %s", safeCode, safeMessage)
end

function Errors.moduleLoadError(moduleName, attempts)
	attempts = attempts or {}
	local msg = {Errors.tagged("E_MODULE_LOAD", "Failed to load module '" .. tostring(moduleName) .. "'")}
	for _, attempt in ipairs(attempts) do
		table.insert(msg, " - " .. tostring(attempt))
	end
	return table.concat(msg, "\n")
end

return Errors
]])
put("src/api/loader.lua", [[local DEFAULT_ROOT = "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"

local function normalizeRootUrl(rootUrl)
	if type(rootUrl) ~= "string" or rootUrl == "" then
		return DEFAULT_ROOT
	end
	if rootUrl:sub(-1) ~= "/" then
		return rootUrl .. "/"
	end
	return rootUrl
end

local function compileChunk(source, label)
	local compileString = loadstring or load
	if not compileString then
		error("No Lua compiler function available (loadstring/load)")
	end
	if type(source) == "string" then
		source = source:gsub("^\239\187\191", "")
		source = source:gsub("^\0+", "")
	end
	local chunk, err = compileString(source)
	if not chunk then
		error("Failed to compile " .. tostring(label or "chunk") .. ": " .. tostring(err))
	end
	return chunk
end

local function fetchAndCompile(url, label)
	local source = game:HttpGet(url)
	return compileChunk(source, label or url)()
end

local bootstrapRoot = normalizeRootUrl((_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or DEFAULT_ROOT)
local Resolver = fetchAndCompile(bootstrapRoot .. "src/api/resolver.lua", "src/api/resolver.lua")
local resolveRoot = (Resolver and Resolver.normalizeRuntimeRoot) or normalizeRootUrl
local root = resolveRoot((Resolver and Resolver.getRuntimeRoot and Resolver.getRuntimeRoot()) or bootstrapRoot)

if type(_G) == "table" and type(_G.__RAYFIELD_BUNDLE_SOURCES) == "table" then
	_G.__RAYFIELD_BUNDLE_MODE = _G.__RAYFIELD_BUNDLE_MODE or "bundle_first"
end

local Client = (_G and _G.__RayfieldApiClient)
if not Client then
	Client = fetchAndCompile(root .. "src/api/client.lua", "src/api/client.lua")
	if _G then
		_G.__RayfieldApiClient = Client
	end
end

local function loadApiModule(relativePath)
	return Client.fetchAndExecute(root .. relativePath)
end

local Cache = loadApiModule("src/api/cache.lua")
local Registry = loadApiModule("src/api/registry.lua")
local Errors = loadApiModule("src/api/errors.lua")

local Loader = {}

local function cacheKey(path)
	return tostring(path)
end

local function loadByPath(path)
	local key = cacheKey(path)
	local cached = Cache.get(key)
	if cached ~= nil then
		return cached
	end
	local value = Client.fetchAndExecute(root .. path)
	Cache.set(key, value)
	return value
end

function Loader.load(moduleName, opts)
	opts = opts or {}
	local mapping = Registry[moduleName]
	if not mapping then
		error("Unknown module in registry: " .. tostring(moduleName))
	end

	local attempts = {}

	if opts.tryStudioRequire and Resolver.isStudio() and opts.scriptRef and mapping.studio then
		local required = Resolver.tryRequire(opts.scriptRef, mapping.studio)
		if required ~= nil then
			return required
		end
		table.insert(attempts, "studio require(" .. tostring(mapping.studio) .. ") failed")
	end

	local canonicalPath = mapping.canonical
	local ok, result = pcall(loadByPath, canonicalPath)
	if ok then
		return result
	end
	table.insert(attempts, tostring(canonicalPath) .. ": " .. tostring(result))

	local legacyPath = mapping.legacy
	if opts.allowLegacyFallback ~= false and type(legacyPath) == "string" and legacyPath ~= "" and legacyPath ~= canonicalPath then
		local legacyOk, legacyResult = pcall(loadByPath, legacyPath)
		if legacyOk then
			return legacyResult
		end
		table.insert(attempts, tostring(legacyPath) .. ": " .. tostring(legacyResult))
	end

	error(Errors.moduleLoadError(moduleName, attempts))
end

function Loader.tryLoad(moduleName, opts)
	local ok, result = pcall(Loader.load, moduleName, opts)
	if ok then
		return true, result
	end
	return false, tostring(result)
end

function Loader.loadPath(path)
	return loadByPath(path)
end

function Loader.clearCache()
	Cache.clear()
end

return Loader
]])
put("src/api/registry.lua", [[local function entry(canonical, legacy, studio)
	return {
		canonical = canonical,
		legacy = legacy or canonical,
		studio = studio
	}
end

return {
	theme = entry("src/services/theme.lua", "feature/rayfield-theme.lua", "rayfield-theme"),
	settings = entry("src/services/settings.lua", "feature/rayfield-settings.lua", "rayfield-settings"),
	compatibility = entry("src/services/compatibility.lua", nil, "compatibility"),
	ownershipTracker = entry("src/services/ownership-tracker.lua", nil, "ownership-tracker"),
	elementSync = entry("src/services/element-sync.lua", nil, "element-sync"),
	keybindSequence = entry("src/services/keybind-sequence.lua", nil, "keybind-sequence"),
	layoutPersistence = entry("src/services/layout-persistence.lua", nil, "layout-persistence"),
	viewportVirtualization = entry("src/services/viewport-virtualization.lua", nil, "viewport-virtualization"),
	drag = entry("src/feature/drag/init.lua", "feature/rayfield-drag.lua", "rayfield-drag"),
	uiState = entry("src/core/ui-state.lua", "feature/rayfield-ui-state.lua", "rayfield-ui-state"),
	elements = entry("src/ui/elements/factory/init.lua", "feature/rayfield-elements.lua", "rayfield-elements"),
	elementsExtracted = entry("src/ui/elements/widgets/index.lua", "feature/rayfield-elements-extracted.lua", "rayfield-elements-extracted"),
	widgetsBootstrap = entry("src/ui/elements/widgets/bootstrap.lua", nil, "widgets-bootstrap"),
	config = entry("src/services/config.lua", "feature/rayfield-config.lua", "rayfield-config"),
	utilities = entry("src/services/utilities.lua", "feature/rayfield-utilities.lua", "rayfield-utilities"),
	tabSplit = entry("src/feature/tabsplit/init.lua", "feature/rayfield-tab-split.lua", "rayfield-tab-split"),
	miniWindow = entry("src/feature/mini-window/init.lua", "feature/mini-window-system.lua", "mini-window-system"),
	enhanced = entry("src/feature/enhanced/init.lua", "feature/rayfield-enhanced.lua", "rayfield-enhanced"),
	advanced = entry("src/feature/enhanced/advanced.lua", "feature/rayfield-advanced-features.lua", "rayfield-advanced-features"),
	animationEngine = entry("src/core/animation/engine.lua", nil, "animation-engine"),
	animationPublic = entry("src/core/animation/public.lua", nil, "animation-public"),
	animationSequence = entry("src/core/animation/sequence.lua", nil, "animation-sequence"),
	animationUI = entry("src/core/animation/ui.lua", nil, "animation-ui"),
	animationText = entry("src/core/animation/text.lua", nil, "animation-text"),
	animationEasing = entry("src/core/animation/easing.lua", nil, "animation-easing"),
	animationCleanup = entry("src/core/animation/cleanup.lua", nil, "animation-cleanup"),
	allInOne = entry("src/entry/rayfield-all-in-one.entry.lua", "Main%20loader/rayfield-all-in-one.lua", "rayfield-all-in-one"),
	modifiedEntry = entry("src/entry/rayfield-modified.entry.lua", "Main%20loader/rayfield-modified.lua", "rayfield-modified")
}
]])
put("src/api/resolver.lua", [[local Resolver = {}

local DEFAULT_ROOT = "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"

function Resolver.normalizeRuntimeRoot(rootUrl)
	if type(rootUrl) ~= "string" or rootUrl == "" then
		return DEFAULT_ROOT
	end
	if rootUrl:sub(-1) ~= "/" then
		return rootUrl .. "/"
	end
	return rootUrl
end

function Resolver.getRuntimeRoot()
	if _G and type(_G.__RAYFIELD_RUNTIME_ROOT_URL) == "string" and #_G.__RAYFIELD_RUNTIME_ROOT_URL > 0 then
		return Resolver.normalizeRuntimeRoot(_G.__RAYFIELD_RUNTIME_ROOT_URL)
	end
	return Resolver.normalizeRuntimeRoot(DEFAULT_ROOT)
end

function Resolver.isStudio()
	local ok, runService = pcall(function()
		return game:GetService("RunService")
	end)
	if not ok or not runService then
		return false
	end
	local okStudio, studio = pcall(function()
		return runService:IsStudio()
	end)
	return okStudio and studio or false
end

function Resolver.getCompileString()
	local compileString = loadstring or load
	if not compileString then
		error("No Lua compiler function available (loadstring/load)")
	end
	return compileString
end

function Resolver.tryRequire(scriptRef, moduleName)
	if not scriptRef then
		return nil
	end
	local ok, value = pcall(function()
		return require(scriptRef.Parent[moduleName])
	end)
	if ok then
		return value
	end
	return nil
end

return Resolver
]])
put("src/api/security-adapter.lua", [=[--[[
	Rayfield Security Adapter
	Handles multi-provider key authentication and session token generation.
]]

local SecurityAdapter = {}
local HttpService = game:GetService("HttpService")

local SESSION_TOKEN = nil
local IS_TAMPERED = false

local function trim(value)
	if type(value) ~= "string" then
		return ""
	end
	local out = value:gsub("^%s+", "")
	out = out:gsub("%s+$", "")
	return out
end

local function normalizeKeyList(rawKeys)
	local out = {}
	local seen = {}

	local function push(entry)
		local key = trim(tostring(entry or ""))
		if key == "" or seen[key] then
			return
		end
		seen[key] = true
		table.insert(out, key)
	end

	if type(rawKeys) == "table" then
		if #rawKeys > 0 then
			for _, entry in ipairs(rawKeys) do
				push(entry)
			end
		else
			for _, entry in pairs(rawKeys) do
				push(entry)
			end
		end
	else
		push(rawKeys)
	end

	return out
end

local function readProvidedKey(keySettings)
	if type(keySettings) ~= "table" then
		return ""
	end
	return trim(tostring(
		keySettings.ProvidedKey
		or keySettings.InputKey
		or keySettings.EnteredKey
		or keySettings.CurrentInput
		or ""
	))
end

local function getClientIdSafe()
	local okService, analyticsService = pcall(function()
		return game:GetService("RbxAnalyticsService")
	end)
	if not okService or not analyticsService then
		return "unknown_client"
	end

	local okClientId, clientId = pcall(function()
		return analyticsService:GetClientId()
	end)
	if not okClientId or type(clientId) ~= "string" or clientId == "" then
		return "unknown_client"
	end
	return clientId
end

local function isBypassTamperDetected()
	if type(_G) ~= "table" then
		return false
	end
	return _G.Rayfield_Bypass == true or _G.IsPremiumUser == true
end

function SecurityAdapter.init(ctx)
	local self = {}
	
	-- Session token is intentionally non-secret and runtime-local only.
	-- Real security should be performed by a remote validator.
	local function generateSessionToken(key, hwid)
		local raw = string.format("%s:%s", tostring(key or ""), tostring(hwid or ""))
		local nonce = HttpService:GenerateGUID(false):gsub("%-", ""):sub(1, 8)
		return "RBX-" .. nonce .. "-" .. tostring(#raw)
	end

	local function runCustomValidator(validator, providedKey, settings, hwid)
		local okValidate, isValid, tokenOrErr = pcall(validator, providedKey, settings, hwid)
		if not okValidate then
			return false, "E_VALIDATOR_ERROR:" .. tostring(isValid)
		end
		if isValid ~= true then
			return false, tostring(tokenOrErr or "E_INVALID_KEY")
		end

		if type(tokenOrErr) == "string" and tokenOrErr ~= "" then
			SESSION_TOKEN = tokenOrErr
			return true, SESSION_TOKEN
		end

		SESSION_TOKEN = generateSessionToken(providedKey, hwid)
		return true, SESSION_TOKEN
	end

	local function runAllowlistValidator(allowedKeys, providedKey, hwid)
		for _, allowedKey in ipairs(allowedKeys) do
			if providedKey == allowedKey then
				SESSION_TOKEN = generateSessionToken(providedKey, hwid)
				return true, SESSION_TOKEN
			end
		end
		return false, "E_INVALID_KEY"
	end

	function self.validateKey(settings)
		if not settings or not settings.KeySettings then 
			return false, "E_NO_SETTINGS"
		end
		
		local keySettings = settings.KeySettings
		local hwid = getClientIdSafe()
		local providedKey = readProvidedKey(keySettings)
		if providedKey == "" then
			return false, "E_NO_PROVIDED_KEY"
		end
		
		-- Honey pot check
		if isBypassTamperDetected() then
			IS_TAMPERED = true
			warn("Rayfield | Honey Pot Triggered: Unauthorized Bypass Attempt Detected.")
			return false, "E_TAMPERED_BYPASS"
		end

		local validator = keySettings.Validator
		if type(validator) == "function" then
			return runCustomValidator(validator, providedKey, settings, hwid)
		end

		-- Local allowlist fallback for offline/manual validation.
		local allowedKeys = normalizeKeyList(
			keySettings.AllowedKeys
			or keySettings.ValidKeys
			or keySettings.Keys
			or keySettings.Key
		)
		if #allowedKeys == 0 then
			return false, "E_UNCONFIGURED_VALIDATION"
		end
		return runAllowlistValidator(allowedKeys, providedKey, hwid)
	end

	function self.getSessionToken()
		return SESSION_TOKEN
	end

	function self.isTampered()
		return IS_TAMPERED
	end

	return self
end

return SecurityAdapter
]=])
put("src/core/animation/cleanup.lua", [[local Cleanup = {}

local function safeGet(instance, key)
	local ok, value = pcall(function()
		return instance[key]
	end)
	if ok then
		return true, value
	end
	return false, nil
end

function Cleanup.safeDisconnect(connection)
	if not connection then
		return
	end
	pcall(function()
		connection:Disconnect()
	end)
end

function Cleanup.isAlive(instance)
	return typeof(instance) == "Instance" and instance.Parent ~= nil
end

function Cleanup.isVisibleChain(instance)
	if typeof(instance) ~= "Instance" then
		return false
	end

	local current = instance
	while current do
		local isGuiObject = current:IsA("GuiObject")
		local isLayerCollector = current:IsA("LayerCollector")
		if isGuiObject or isLayerCollector then
			local hasVisible, visible = safeGet(current, "Visible")
			if hasVisible and visible == false then
				return false
			end
		end
		current = current.Parent
	end

	return true
end

function Cleanup.bindDestroy(instance, onRemoved)
	if typeof(instance) ~= "Instance" then
		return function() end
	end

	local removed = false
	local connections = {}

	local function fireOnce()
		if removed then
			return
		end
		removed = true
		if type(onRemoved) == "function" then
			pcall(onRemoved)
		end
	end

	table.insert(connections, instance.AncestryChanged:Connect(function(_, parent)
		if parent == nil then
			fireOnce()
		end
	end))

	local hasDestroying = pcall(function()
		return instance.Destroying
	end)
	if hasDestroying then
		table.insert(connections, instance.Destroying:Connect(function()
			fireOnce()
		end))
	end

	return function()
		for _, connection in ipairs(connections) do
			Cleanup.safeDisconnect(connection)
		end
		table.clear(connections)
	end
end

return Cleanup
]])
put("src/core/animation/easing.lua", [[local Easing = {}

Easing.DefaultInfo = TweenInfo.new(0.25, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out)

Easing.Presets = {
	fast = TweenInfo.new(0.12, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
	normal = TweenInfo.new(0.25, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out),
	slow = TweenInfo.new(0.45, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out),
	bounce = TweenInfo.new(0.35, Enum.EasingStyle.Back, Enum.EasingDirection.Out),
}

function Easing.resolve(info)
	if typeof(info) == "TweenInfo" then
		return info
	end
	if type(info) == "string" then
		return Easing.Presets[info] or Easing.DefaultInfo
	end
	return Easing.DefaultInfo
end

return Easing
]])
put("src/core/animation/engine.lua", [[local Engine = {}
Engine.__index = Engine

local DefaultCleanup = {}
local TRANSITION_PROFILES = {
	Smooth = {
		durationScale = 1.0,
		suppressTextEffects = false
	},
	Snappy = {
		durationScale = 0.75,
		suppressTextEffects = false
	},
	Minimal = {
		durationScale = 0.55,
		suppressTextEffects = false
	},
	Off = {
		durationScale = 0.01,
		suppressTextEffects = true
	}
}

function DefaultCleanup.safeDisconnect(connection)
	if not connection then
		return
	end
	pcall(function()
		connection:Disconnect()
	end)
end

function DefaultCleanup.isAlive(instance)
	return typeof(instance) == "Instance" and instance.Parent ~= nil
end

function DefaultCleanup.isVisibleChain(instance)
	if typeof(instance) ~= "Instance" then
		return false
	end
	local current = instance
	while current do
		if current:IsA("GuiObject") or current:IsA("LayerCollector") then
			local ok, visible = pcall(function()
				return current.Visible
			end)
			if ok and visible == false then
				return false
			end
		end
		current = current.Parent
	end
	return true
end

function DefaultCleanup.bindDestroy(instance, onRemoved)
	if typeof(instance) ~= "Instance" then
		return function() end
	end
	local fired = false
	local connections = {}
	local function fire()
		if fired then
			return
		end
		fired = true
		if type(onRemoved) == "function" then
			pcall(onRemoved)
		end
	end
	table.insert(connections, instance.AncestryChanged:Connect(function(_, parent)
		if parent == nil then
			fire()
		end
	end))
	local hasDestroying = pcall(function()
		return instance.Destroying
	end)
	if hasDestroying then
		table.insert(connections, instance.Destroying:Connect(fire))
	end
	return function()
		for _, connection in ipairs(connections) do
			DefaultCleanup.safeDisconnect(connection)
		end
		table.clear(connections)
	end
end

local function countEntries(t)
	local count = 0
	for _, v in pairs(t) do
		if v ~= nil then
			count = count + 1
		end
	end
	return count
end

local function countTextHandles(handleBuckets)
	local total = 0
	for _, handles in pairs(handleBuckets) do
		if type(handles) == "table" then
			total = total + #handles
		end
	end
	return total
end

local function getGoalKey(goals)
	local keys = {}
	for key in pairs(goals or {}) do
		table.insert(keys, tostring(key))
	end
	table.sort(keys)
	if #keys == 0 then
		return "__default"
	end
	return table.concat(keys, "|")
end

function Engine.new(opts)
	opts = opts or {}
	local tweenService = opts.TweenService or game:GetService("TweenService")
	local runService = opts.RunService or game:GetService("RunService")
	local cleanup = opts.Cleanup or DefaultCleanup

	local self = setmetatable({}, Engine)
	self.TweenService = tweenService
	self.RunService = runService
	self.Cleanup = cleanup
	self.Mode = opts.mode or "raw"
	self._uiSuppressed = false
	self._uiSuppressionProvider = opts.uiSuppressionProvider
	self._activeTweens = setmetatable({}, { __mode = "k" })
	self._cleanupHooks = setmetatable({}, { __mode = "k" })
	self._textHandles = setmetatable({}, { __mode = "k" })
	self._textHeartbeat = nil
	self._transitionProfileName = "Smooth"
	self._transitionProfile = {
		durationScale = TRANSITION_PROFILES.Smooth.durationScale,
		suppressTextEffects = TRANSITION_PROFILES.Smooth.suppressTextEffects
	}
	return self
end

local function cloneProfileSpec(spec)
	return {
		durationScale = tonumber(spec and spec.durationScale) or 1,
		suppressTextEffects = spec and spec.suppressTextEffects == true or false
	}
end

local function resolveProfileName(name)
	if type(name) ~= "string" then
		return nil
	end
	local normalized = string.lower(name)
	if normalized == "smooth" then
		return "Smooth"
	elseif normalized == "snappy" then
		return "Snappy"
	elseif normalized == "minimal" then
		return "Minimal"
	elseif normalized == "off" then
		return "Off"
	end
	return nil
end

function Engine:SetTransitionProfile(profileName, profileSpec)
	local canonicalName = resolveProfileName(profileName)
	if not canonicalName then
		return false, "Invalid transition profile."
	end

	local defaultSpec = TRANSITION_PROFILES[canonicalName]
	local nextSpec = cloneProfileSpec(defaultSpec)
	if type(profileSpec) == "table" then
		if profileSpec.durationScale ~= nil then
			local parsedScale = tonumber(profileSpec.durationScale)
			if parsedScale and parsedScale > 0 then
				nextSpec.durationScale = parsedScale
			end
		end
		if profileSpec.suppressTextEffects ~= nil then
			nextSpec.suppressTextEffects = profileSpec.suppressTextEffects == true
		end
	end

	self._transitionProfileName = canonicalName
	self._transitionProfile = nextSpec
	if nextSpec.suppressTextEffects then
		self:StopAllText()
	end

	return true, canonicalName
end

function Engine:GetTransitionProfile()
	local profile = cloneProfileSpec(self._transitionProfile)
	return self._transitionProfileName, profile
end

function Engine:SetUiSuppressionProvider(provider)
	if type(provider) == "function" then
		self._uiSuppressionProvider = provider
	else
		self._uiSuppressionProvider = nil
	end
end

function Engine:IsUiSuppressed()
	if self._uiSuppressed then
		return true
	end
	if type(self._uiSuppressionProvider) == "function" then
		local ok, result = pcall(self._uiSuppressionProvider)
		if ok and result then
			return true
		end
	end
	return false
end

function Engine:SetUiSuppressed(value)
	self._uiSuppressed = value and true or false
	if self._uiSuppressed then
		self:StopAllText()
	end
end

function Engine:_ensureTweenBucket(instance)
	local bucket = self._activeTweens[instance]
	if bucket then
		return bucket
	end

	bucket = {}
	self._activeTweens[instance] = bucket

	if not self._cleanupHooks[instance] then
		self._cleanupHooks[instance] = self.Cleanup.bindDestroy(instance, function()
			self:CancelObject(instance)
			self:StopTextForObject(instance)
		end)
	end

	return bucket
end

function Engine:_releaseTweenBucketIfEmpty(instance)
	local bucket = self._activeTweens[instance]
	if not bucket or next(bucket) ~= nil then
		return
	end
	self._activeTweens[instance] = nil

	local cleanupHook = self._cleanupHooks[instance]
	if cleanupHook then
		pcall(cleanupHook)
	end
	self._cleanupHooks[instance] = nil
end

function Engine:_trackTween(instance, key, tween, cancelPrevious)
	local bucket = self:_ensureTweenBucket(instance)
	if cancelPrevious and bucket[key] and bucket[key] ~= tween then
		pcall(function()
			bucket[key]:Cancel()
		end)
	end

	bucket[key] = tween
	tween.Completed:Connect(function()
		local activeBucket = self._activeTweens[instance]
		if not activeBucket then
			return
		end
		if activeBucket[key] == tween then
			activeBucket[key] = nil
			self:_releaseTweenBucketIfEmpty(instance)
		end
	end)
end

function Engine:Create(instance, tweenInfo, goals, opts)
	opts = opts or {}
	if typeof(instance) ~= "Instance" then
		return nil
	end
	if typeof(tweenInfo) ~= "TweenInfo" then
		return nil
	end
	if type(goals) ~= "table" then
		return nil
	end

	local scale = tonumber(self._transitionProfile and self._transitionProfile.durationScale) or 1
	if scale <= 0 then
		scale = 1
	end
	local adjustedTweenInfo = tweenInfo
	if scale ~= 1 then
		adjustedTweenInfo = TweenInfo.new(
			math.max(0.01, tweenInfo.Time * scale),
			tweenInfo.EasingStyle,
			tweenInfo.EasingDirection,
			tweenInfo.RepeatCount,
			tweenInfo.Reverses,
			tweenInfo.DelayTime
		)
	end

	local tween = self.TweenService:Create(instance, adjustedTweenInfo, goals)

	if opts.track then
		local key = opts.key
		if key == nil then
			key = getGoalKey(goals)
		end
		self:_trackTween(instance, tostring(key), tween, opts.cancelPrevious ~= false)
	end

	return tween
end

function Engine:Play(instance, tweenInfo, goals, opts)
	local tween = self:Create(instance, tweenInfo, goals, opts)
	if tween then
		tween:Play()
	end
	return tween
end

function Engine:AnimateProperty(instance, property, targetValue, duration, easingStyle, easingDirection, opts)
	if type(property) ~= "string" then
		return nil
	end
	local info = TweenInfo.new(
		duration or 0.5,
		easingStyle or Enum.EasingStyle.Exponential,
		easingDirection or Enum.EasingDirection.Out
	)
	local tween = self:Create(instance, info, { [property] = targetValue }, {
		track = true,
		key = property,
		cancelPrevious = true,
	})
	if tween then
		tween:Play()
	end
	return tween
end

function Engine:GetActiveAnimationCount()
	local count = 0
	for _, bucket in pairs(self._activeTweens) do
		count = count + countEntries(bucket)
	end
	return count
end

function Engine:GetTextHandleCount()
	return countTextHandles(self._textHandles)
end

function Engine:GetRuntimeStats()
	return {
		activeTweens = self:GetActiveAnimationCount(),
		activeTextHandles = self:GetTextHandleCount(),
		heartbeatConnected = self._textHeartbeat ~= nil
	}
end

function Engine:CancelObject(instance)
	local bucket = self._activeTweens[instance]
	if bucket then
		for _, tween in pairs(bucket) do
			if tween then
				pcall(function()
					tween:Cancel()
				end)
			end
		end
		self._activeTweens[instance] = nil
	end

	local cleanupHook = self._cleanupHooks[instance]
	if cleanupHook then
		pcall(cleanupHook)
	end
	self._cleanupHooks[instance] = nil
end

function Engine:CancelAll()
	for instance in pairs(self._activeTweens) do
		self:CancelObject(instance)
	end
end

function Engine:_ensureTextHeartbeat()
	if self._textHeartbeat then
		return
	end
	self._textHeartbeat = self.RunService.Heartbeat:Connect(function()
		self:_tickTextHandles()
	end)
end

function Engine:_maybeReleaseTextHeartbeat()
	for _, handles in pairs(self._textHandles) do
		if handles and #handles > 0 then
			return
		end
	end
	if self._textHeartbeat then
		self.Cleanup.safeDisconnect(self._textHeartbeat)
		self._textHeartbeat = nil
	end
end

function Engine:_tickTextHandles()
	local transitionSuppressed = self._transitionProfile and self._transitionProfile.suppressTextEffects == true
	local suppressed = self:IsUiSuppressed() or transitionSuppressed
	for instance, handles in pairs(self._textHandles) do
		if type(handles) == "table" then
			for i = #handles, 1, -1 do
				local handle = handles[i]
				local running = handle and handle.IsRunning and handle:IsRunning()
				local dead = (not self.Cleanup.isAlive(instance)) or (not self.Cleanup.isVisibleChain(instance))
				if dead or suppressed then
					if handle and handle.Stop then
						pcall(function()
							handle:Stop()
						end)
					end
					table.remove(handles, i)
				elseif not running then
					table.remove(handles, i)
				end
			end
			if #handles == 0 then
				self._textHandles[instance] = nil
			end
		end
	end
	self:_maybeReleaseTextHeartbeat()
end

function Engine:RegisterTextHandle(instance, handle)
	if typeof(instance) ~= "Instance" or not handle then
		return
	end
	if self._transitionProfile and self._transitionProfile.suppressTextEffects == true then
		if handle and handle.Stop then
			pcall(function()
				handle:Stop()
			end)
		end
		return
	end
	local handles = self._textHandles[instance]
	if not handles then
		handles = {}
		self._textHandles[instance] = handles
	end
	table.insert(handles, handle)
	self:_ensureTextHeartbeat()
end

function Engine:UnregisterTextHandle(instance, handle)
	local handles = self._textHandles[instance]
	if not handles then
		return
	end
	for i = #handles, 1, -1 do
		if handles[i] == handle then
			table.remove(handles, i)
		end
	end
	if #handles == 0 then
		self._textHandles[instance] = nil
	end
	self:_maybeReleaseTextHeartbeat()
end

function Engine:StopTextForObject(instance)
	local handles = self._textHandles[instance]
	if not handles then
		return
	end
	for i = #handles, 1, -1 do
		local handle = handles[i]
		if handle and handle.Stop then
			pcall(function()
				handle:Stop()
			end)
		end
	end
	self._textHandles[instance] = nil
	self:_maybeReleaseTextHeartbeat()
end

function Engine:StopAllText()
	for instance in pairs(self._textHandles) do
		self:StopTextForObject(instance)
	end
end

function Engine:Destroy()
	self:StopAllText()
	self:CancelAll()
	self:SetUiSuppressed(true)
	if self._textHeartbeat then
		self.Cleanup.safeDisconnect(self._textHeartbeat)
		self._textHeartbeat = nil
	end
end

return Engine
]])
put("src/core/animation/public.lua", [[local Public = {}

local function newFallbackSequence(engine, target, tweenInfo, goals)
	local sequence = {
		_engine = engine,
		_target = target,
		_info = tweenInfo,
		_goals = goals,
	}

	function sequence:SetInfo(info)
		self._info = info
		return self
	end

	function sequence:To(nextGoals, nextInfo)
		self._goals = nextGoals
		if nextInfo then
			self._info = nextInfo
		end
		return self
	end

	function sequence:Then(nextGoals, nextInfo)
		return self:To(nextGoals, nextInfo)
	end

	function sequence:Wait()
		return self
	end

	function sequence:Play()
		if typeof(self._info) == "TweenInfo" and type(self._goals) == "table" then
			self._engine:Play(self._target, self._info, self._goals)
		end
		return self
	end

	return sequence
end

function Public.createFacade(engine, libs)
	libs = libs or {}
	local SequenceLib = libs.Sequence
	local UILib = libs.UI
	local TextLib = libs.Text

	local function createSequence(target, tweenInfo, goals)
		if SequenceLib and type(SequenceLib.new) == "function" then
			local sequence = SequenceLib.new(engine, target)
			if typeof(tweenInfo) == "TweenInfo" then
				sequence:SetInfo(tweenInfo)
				if type(goals) == "table" then
					sequence:To(goals, tweenInfo)
				end
			end
			return sequence
		end
		return newFallbackSequence(engine, target, tweenInfo, goals)
	end

	local facade = {}
	setmetatable(facade, {
		__call = function(_, target, tweenInfo, goals)
			return createSequence(target, tweenInfo, goals)
		end
	})

	function facade.UI(target)
		if UILib and type(UILib.new) == "function" then
			return UILib.new(engine, target)
		end
		return nil
	end

	function facade.Text(target)
		if TextLib and type(TextLib.new) == "function" then
			return TextLib.new(engine, target)
		end
		return nil
	end

	function facade.Play(target, tweenInfo, goals, opts)
		return engine:Play(target, tweenInfo, goals, opts)
	end

	function facade.Create(target, tweenInfo, goals, opts)
		return engine:Create(target, tweenInfo, goals, opts)
	end

	function facade.StopObject(target)
		engine:CancelObject(target)
		engine:StopTextForObject(target)
	end

	function facade.StopAll()
		engine:CancelAll()
		engine:StopAllText()
	end

	function facade.GetActiveAnimationCount()
		return engine:GetActiveAnimationCount()
	end

	function facade.GetEngine()
		return engine
	end

	return facade
end

function Public.bindToRayfield(rayfieldLibrary, engine, libs)
	local facade = Public.createFacade(engine, libs)
	rayfieldLibrary.Animate = facade
	rayfieldLibrary.GetAnimationEngine = function()
		return engine
	end
	return facade
end

return Public
]])
put("src/core/animation/sequence.lua", [[local Sequence = {}
Sequence.__index = Sequence

local function safeWaitForTween(tween)
	if not tween then
		return
	end
	local okCompleted, completedSignal = pcall(function()
		return tween.Completed
	end)
	if okCompleted and completedSignal then
		pcall(function()
			completedSignal:Wait()
		end)
	end
end

function Sequence.new(engine, target)
	local self = setmetatable({}, Sequence)
	self._engine = engine
	self._target = target
	self._defaultInfo = TweenInfo.new(0.25, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out)
	self._steps = {}
	self._running = false
	self._stopped = false
	self._currentTween = nil
	self._completedCallbacks = {}
	return self
end

function Sequence:SetInfo(tweenInfo)
	if typeof(tweenInfo) == "TweenInfo" then
		self._defaultInfo = tweenInfo
	end
	return self
end

function Sequence:To(goals, tweenInfo, opts)
	if type(goals) == "table" then
		table.insert(self._steps, {
			type = "tween",
			goals = goals,
			info = (typeof(tweenInfo) == "TweenInfo" and tweenInfo) or self._defaultInfo,
			opts = opts or {}
		})
	end
	return self
end

function Sequence:Then(goals, tweenInfo, opts)
	return self:To(goals, tweenInfo, opts)
end

function Sequence:Wait(duration)
	local sec = tonumber(duration) or 0
	if sec < 0 then
		sec = 0
	end
	table.insert(self._steps, {
		type = "wait",
		duration = sec
	})
	return self
end

function Sequence:Call(callback)
	if type(callback) == "function" then
		table.insert(self._steps, {
			type = "callback",
			callback = callback
		})
	end
	return self
end

function Sequence:OnCompleted(callback)
	if type(callback) == "function" then
		table.insert(self._completedCallbacks, callback)
	end
	return self
end

function Sequence:IsRunning()
	return self._running
end

function Sequence:Stop()
	self._stopped = true
	if self._currentTween then
		pcall(function()
			self._currentTween:Cancel()
		end)
		self._currentTween = nil
	end
	return self
end

function Sequence:Play()
	if self._running then
		return self
	end

	self._running = true
	self._stopped = false

	task.spawn(function()
		for _, step in ipairs(self._steps) do
			if self._stopped then
				break
			end

			if step.type == "wait" then
				task.wait(step.duration)
			elseif step.type == "callback" then
				pcall(step.callback, self._engine, self._target)
			elseif step.type == "tween" then
				local tween = self._engine:Create(self._target, step.info, step.goals, step.opts)
				self._currentTween = tween
				if tween then
					tween:Play()
					safeWaitForTween(tween)
				end
				self._currentTween = nil
			end
		end

		self._running = false
		if not self._stopped then
			for _, callback in ipairs(self._completedCallbacks) do
				pcall(callback, self)
			end
		end
	end)

	return self
end

return Sequence
]])
put("src/core/animation/text.lua", [[local Text = {}
Text.__index = Text

local CHARSET = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"

local function randomChar()
	local index = math.random(1, #CHARSET)
	return CHARSET:sub(index, index)
end

local function lerpColor3(a, b, t)
	return Color3.new(
		a.R + (b.R - a.R) * t,
		a.G + (b.G - a.G) * t,
		a.B + (b.B - a.B) * t
	)
end

local function makeLoopHandle(controller, runner)
	local handle = {}
	handle._running = false
	handle._cleanup = nil

	function handle:IsRunning()
		return self._running
	end

	function handle:Stop()
		if not self._running then
			return
		end
		self._running = false
		if type(self._cleanup) == "function" then
			pcall(self._cleanup)
		end
		controller._engine:UnregisterTextHandle(controller._target, self)
	end

	handle._running = true
	task.spawn(function()
		local ok = pcall(runner, handle)
		if not ok then
			handle:Stop()
			return
		end
		if handle._running then
			handle:Stop()
		end
	end)

	controller._engine:RegisterTextHandle(controller._target, handle)
	return handle
end

function Text.new(engine, textObject)
	local self = setmetatable({}, Text)
	self._engine = engine
	self._target = textObject
	return self
end

function Text:_alive()
	return self._engine.Cleanup.isAlive(self._target)
end

function Text:_blocked()
	return self._engine:IsUiSuppressed() or (not self._engine.Cleanup.isVisibleChain(self._target))
end

function Text:Type(text, speed, opts)
	opts = opts or {}
	local finalText = tostring(text or self._target.Text or "")
	local charDelay = tonumber(speed) or 0.03
	local cursor = opts.cursor
	local loop = opts.loop == true

	return makeLoopHandle(self, function(handle)
		repeat
			if not self:_alive() then
				break
			end

			self._target.Text = ""
			for i = 1, #finalText do
				if not handle:IsRunning() or self:_blocked() or not self:_alive() then
					return
				end
				local preview = finalText:sub(1, i)
				if cursor then
					preview = preview .. cursor
				end
				self._target.Text = preview
				task.wait(charDelay)
			end
			self._target.Text = finalText
			if loop then
				task.wait(tonumber(opts.loopDelay) or 0.35)
			end
		until not loop
	end)
end

function Text:Ghosting(text, interval, opts)
	opts = opts or {}
	if text ~= nil then
		self._target.Text = tostring(text)
	end

	local period = tonumber(interval) or 0.85
	local minTransparency = tonumber(opts.minTransparency) or 0.15
	local maxTransparency = tonumber(opts.maxTransparency) or 0.55

	return makeLoopHandle(self, function(handle)
		while handle:IsRunning() do
			if self:_blocked() or not self:_alive() then
				return
			end
			local tweenIn = self._engine:Play(
				self._target,
				TweenInfo.new(period * 0.5, Enum.EasingStyle.Sine, Enum.EasingDirection.Out),
				{ TextTransparency = maxTransparency },
				{ track = true, key = "TextTransparency", cancelPrevious = true }
			)
			if tweenIn then
				tweenIn.Completed:Wait()
			end
			if not handle:IsRunning() then
				return
			end
			local tweenOut = self._engine:Play(
				self._target,
				TweenInfo.new(period * 0.5, Enum.EasingStyle.Sine, Enum.EasingDirection.Out),
				{ TextTransparency = minTransparency },
				{ track = true, key = "TextTransparency", cancelPrevious = true }
			)
			if tweenOut then
				tweenOut.Completed:Wait()
			end
		end
	end)
end

function Text:Scramble(text, duration, opts)
	opts = opts or {}
	local finalText = tostring(text or self._target.Text or "")
	local totalDuration = tonumber(duration) or 0.8
	local tickRate = tonumber(opts.tickRate) or 0.04
	local loop = opts.loop == true

	return makeLoopHandle(self, function(handle)
		repeat
			local startTime = tick()
			while handle:IsRunning() and self:_alive() and (tick() - startTime) < totalDuration do
				if self:_blocked() then
					return
				end
				local progress = math.clamp((tick() - startTime) / totalDuration, 0, 1)
				local fixedCount = math.floor(#finalText * progress)
				local chars = {}
				for i = 1, #finalText do
					if i <= fixedCount then
						chars[i] = finalText:sub(i, i)
					else
						chars[i] = randomChar()
					end
				end
				self._target.Text = table.concat(chars)
				task.wait(tickRate)
			end
			if not handle:IsRunning() then
				return
			end
			self._target.Text = finalText
			if loop then
				task.wait(tonumber(opts.loopDelay) or 0.25)
			end
		until not loop
	end)
end

function Text:Rainbow(cycleSec, opts)
	opts = opts or {}
	local cycle = tonumber(cycleSec) or 2
	local saturation = tonumber(opts.saturation) or 0.85
	local value = tonumber(opts.value) or 1
	local step = tonumber(opts.step) or 0.03
	local start = tick()

	return makeLoopHandle(self, function(handle)
		while handle:IsRunning() do
			if self:_blocked() or not self:_alive() then
				return
			end
			local hue = ((tick() - start) % cycle) / cycle
			self._target.TextColor3 = Color3.fromHSV(hue, saturation, value)
			task.wait(step)
		end
	end)
end

function Text:Glow(color, cycleSec, opts)
	opts = opts or {}
	local baseColor = self._target.TextColor3
	local glowColor = typeof(color) == "Color3" and color or Color3.fromRGB(130, 200, 255)
	local cycle = tonumber(cycleSec) or 1.25
	local step = tonumber(opts.step) or 0.03
	local start = tick()

	return makeLoopHandle(self, function(handle)
		while handle:IsRunning() do
			if self:_blocked() or not self:_alive() then
				return
			end
			local phase = (tick() - start) / cycle
			local alpha = (math.sin(phase * math.pi * 2) + 1) * 0.5
			self._target.TextColor3 = lerpColor3(baseColor, glowColor, alpha)
			task.wait(step)
		end
	end)
end

return Text
]])
put("src/core/animation/ui.lua", [[local UI = {}
UI.__index = UI

function UI.new(engine, target)
	local self = setmetatable({}, UI)
	self._engine = engine
	self._target = target
	return self
end

function UI:_play(info, goals, opts)
	return self._engine:Play(self._target, info, goals, opts)
end

function UI:FadeIn(duration)
	if self._target and self._target:IsA("GuiObject") then
		self._target.Visible = true
	end
	return self:_play(
		TweenInfo.new(duration or 0.25, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out),
		{ BackgroundTransparency = 0 }
	)
end

function UI:FadeOut(duration, hideAfter)
	local tween = self:_play(
		TweenInfo.new(duration or 0.25, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out),
		{ BackgroundTransparency = 1 }
	)
	if tween and hideAfter ~= false and self._target and self._target:IsA("GuiObject") then
		tween.Completed:Connect(function(playbackState)
			if playbackState == Enum.PlaybackState.Completed then
				self._target.Visible = false
			end
		end)
	end
	return tween
end

function UI:Pop(duration, scaleMultiplier)
	if not (self._target and self._target:IsA("GuiObject")) then
		return nil
	end

	local original = self._target.Size
	local multiplier = tonumber(scaleMultiplier) or 1.05
	local targetSize = UDim2.new(
		original.X.Scale * multiplier,
		math.floor(original.X.Offset * multiplier + 0.5),
		original.Y.Scale * multiplier,
		math.floor(original.Y.Offset * multiplier + 0.5)
	)

	local tweenOut = self:_play(
		TweenInfo.new((duration or 0.2) * 0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
		{ Size = targetSize }
	)

	if tweenOut then
		tweenOut.Completed:Connect(function(playbackState)
			if playbackState == Enum.PlaybackState.Completed then
				self:_play(
					TweenInfo.new((duration or 0.2) * 0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
					{ Size = original }
				)
			end
		end)
	end

	return tweenOut
end

function UI:SlideIn(direction, duration)
	if not (self._target and self._target:IsA("GuiObject")) then
		return nil
	end

	local original = self._target.Position
	local from = original
	local moveDirection = (type(direction) == "string" and string.lower(direction)) or "left"

	if moveDirection == "left" then
		from = UDim2.new(-1, 0, original.Y.Scale, original.Y.Offset)
	elseif moveDirection == "right" then
		from = UDim2.new(2, 0, original.Y.Scale, original.Y.Offset)
	elseif moveDirection == "top" then
		from = UDim2.new(original.X.Scale, original.X.Offset, -1, 0)
	else
		from = UDim2.new(original.X.Scale, original.X.Offset, 2, 0)
	end

	self._target.Position = from
	self._target.Visible = true
	return self:_play(
		TweenInfo.new(duration or 0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out),
		{ Position = original }
	)
end

function UI:SlideOut(direction, duration)
	if not (self._target and self._target:IsA("GuiObject")) then
		return nil
	end

	local original = self._target.Position
	local to = original
	local moveDirection = (type(direction) == "string" and string.lower(direction)) or "left"

	if moveDirection == "left" then
		to = UDim2.new(-1, 0, original.Y.Scale, original.Y.Offset)
	elseif moveDirection == "right" then
		to = UDim2.new(2, 0, original.Y.Scale, original.Y.Offset)
	elseif moveDirection == "top" then
		to = UDim2.new(original.X.Scale, original.X.Offset, -1, 0)
	else
		to = UDim2.new(original.X.Scale, original.X.Offset, 2, 0)
	end

	return self:_play(
		TweenInfo.new(duration or 0.28, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out),
		{ Position = to }
	)
end

return UI
]])
put("src/core/bootstrap.lua", [[local Bootstrap = {}

function Bootstrap.createRuntimeContext(overrides)
	overrides = overrides or {}
	return {
		useStudio = overrides.useStudio,
		compileString = overrides.compileString,
		runtimeRootUrl = overrides.runtimeRootUrl,
		services = overrides.services or {}
	}
end

return Bootstrap
]])
put("src/core/constants.lua", [[local Constants = {
	RuntimeRootGlobal = "__RAYFIELD_RUNTIME_ROOT_URL",
	DefaultRuntimeRoot = "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/",
	ManifestVersion = "1.0.0"
}

return Constants
]])
put("src/core/container.lua", [[local Container = {}

function Container.new(seed)
	local registry = seed or {}
	return {
		set = function(_, key, value)
			registry[key] = value
		end,
		get = function(_, key)
			return registry[key]
		end,
		all = function()
			return registry
		end
	}
end

return Container
]])
put("src/core/lifecycle.lua", [[local Lifecycle = {}

function Lifecycle.new()
	local cleanups = {}
	return {
		add = function(_, fn)
			if type(fn) == "function" then
				table.insert(cleanups, fn)
			end
		end,
		destroy = function()
			for i = #cleanups, 1, -1 do
				pcall(cleanups[i])
			end
			table.clear(cleanups)
		end
	}
end

return Lifecycle
]])
put("src/core/runtime-env.lua", [[local RuntimeEnv = {}

local function resolveCompatibility()
	if type(_G) == "table" and type(_G.__RayfieldCompatibility) == "table" then
		return _G.__RayfieldCompatibility
	end

	local client = type(_G) == "table" and _G.__RayfieldApiClient or nil
	if type(client) ~= "table" or type(client.fetchAndExecute) ~= "function" then
		return nil
	end

	local root = (type(_G) == "table" and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
	local ok, compat = pcall(client.fetchAndExecute, root .. "src/services/compatibility.lua")
	if ok and type(compat) == "table" then
		if type(_G) == "table" then
			_G.__RayfieldCompatibility = compat
		end
		return compat
	end

	return nil
end

local function fallbackGetService(name)
	local ok, service = pcall(function()
		return game:GetService(name)
	end)
	if ok and service then
		return service
	end
	return nil
end

function RuntimeEnv.create(overrides)
	overrides = overrides or {}
	local compatibility = overrides.compatibility or resolveCompatibility()
	local getService = fallbackGetService
	if compatibility and type(compatibility.getService) == "function" then
		getService = compatibility.getService
	end

	local runService = overrides.runService or getService("RunService")
	local useStudio = overrides.useStudio
	if useStudio == nil and runService then
		local okStudio, studio = pcall(function()
			return runService:IsStudio()
		end)
		useStudio = okStudio and studio or false
	end
	if useStudio == nil then
		useStudio = false
	end

	return {
		useStudio = useStudio,
		runtimeRootUrl = overrides.runtimeRootUrl or ((_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"),
		compatibility = compatibility,
		services = {
			RunService = runService,
			UserInputService = overrides.userInputService or getService("UserInputService"),
			TweenService = overrides.tweenService or getService("TweenService"),
			HttpService = overrides.httpService or getService("HttpService")
		}
	}
end

return RuntimeEnv
]])
put("src/core/ui-state.lua", [[-- Rayfield UI State Management Module
-- Handles notifications, search, hide/show, minimize/maximize

local UIStateModule = {}

function UIStateModule.init(ctx)
	local self = {}

	-- Inject dependencies
	self.TweenService = ctx.TweenService
	self.Animation = ctx.Animation or ctx.TweenService
	self.Main = ctx.Main
	self.Topbar = ctx.Topbar
	self.TabList = ctx.TabList
	self.Elements = ctx.Elements
	self.Notifications = ctx.Notifications
	self.MPrompt = ctx.MPrompt
	self.dragInteract = ctx.dragInteract
	self.dragBarCosmetic = ctx.dragBarCosmetic
	self.dragBar = ctx.dragBar
	self.dragOffset = ctx.dragOffset
	self.dragOffsetMobile = ctx.dragOffsetMobile
	self.getIcon = ctx.getIcon
	self.getAssetUri = ctx.getAssetUri
	self.getSelectedTheme = ctx.getSelectedTheme
	self.rayfieldDestroyed = ctx.rayfieldDestroyed
	self.getSetting = ctx.getSetting
	self.useMobileSizing = ctx.useMobileSizing
	self.useMobilePrompt = ctx.useMobilePrompt

	-- Module state
	local searchOpen = false
	local Debounce = false
	local Minimised = false
	local Hidden = false
	local expandedSize = self.useMobileSizing and UDim2.new(0, 500, 0, 275) or UDim2.new(0, 500, 0, 475)

	local function clampExpandedOffsets(width, height)
		local clampedWidth = math.max(math.floor(width), 320)
		local clampedHeight = math.max(math.floor(height), self.useMobileSizing and 170 or 220)

		local parentGui = self.Main and self.Main.Parent
		if parentGui and parentGui.AbsoluteSize then
			local viewport = parentGui.AbsoluteSize
			if viewport.X > 0 then
				clampedWidth = math.min(clampedWidth, math.max(320, viewport.X - 24))
			end
			if viewport.Y > 0 then
				local minHeight = self.useMobileSizing and 170 or 220
				clampedHeight = math.min(clampedHeight, math.max(minHeight, viewport.Y - 24))
			end
		end

		return clampedWidth, clampedHeight
	end

	local function normalizeExpandedSize(value)
		if typeof(value) == "UDim2" then
			return value.X.Offset, value.Y.Offset
		end
		if type(value) == "table" then
			local width = tonumber(value.width or value.x or value.X or value.xOffset)
			local height = tonumber(value.height or value.y or value.Y or value.yOffset)
			if width and height then
				return width, height
			end
		end
		return nil, nil
	end

	local function getExpandedSize()
		return expandedSize
	end

	local function setExpandedSize(nextSize)
		local width, height = normalizeExpandedSize(nextSize)
		if not width or not height then
			return false
		end
		width, height = clampExpandedOffsets(width, height)
		expandedSize = UDim2.fromOffset(width, height)
		return true
	end

	local function applyExpandedSizeToFrames()
		local targetSize = getExpandedSize()
		if self.Main then
			self.Main.Size = targetSize
		end
		if self.Topbar then
			self.Topbar.Size = UDim2.fromOffset(targetSize.X.Offset, 45)
		end
	end

	local function clampMainToViewport()
		if not (self.Main and self.Main.Parent and self.Main.Parent.AbsoluteSize) then
			return
		end
		local parentSize = self.Main.Parent.AbsoluteSize
		local mainPosition = self.Main.AbsolutePosition
		local mainSize = self.Main.AbsoluteSize

		local clampedX = math.clamp(mainPosition.X, 0, math.max(0, parentSize.X - mainSize.X))
		local clampedY = math.clamp(mainPosition.Y, 0, math.max(0, parentSize.Y - mainSize.Y))
		local deltaX = clampedX - mainPosition.X
		local deltaY = clampedY - mainPosition.Y
		if deltaX ~= 0 or deltaY ~= 0 then
			self.Main.Position = UDim2.new(
				self.Main.Position.X.Scale,
				self.Main.Position.X.Offset + deltaX,
				self.Main.Position.Y.Scale,
				self.Main.Position.Y.Offset + deltaY
			)
		end
	end

	-- Forward declare functions
	local closeSearch

	local function playTween(instance, tweenInfo, properties)
		if instance then
			self.Animation:Create(instance, tweenInfo, properties):Play()
		end
	end

	local TAB_BUTTON_TWEEN = TweenInfo.new(0.3, Enum.EasingStyle.Exponential)
	local TAB_VISUAL_PRESETS = {
		hidden = { background = 1, image = 1, text = 1, stroke = 1 },
		selected = { background = 0, image = 0, text = 0, stroke = 1 },
		idle = { background = 0.7, image = 0.2, text = 0.2, stroke = 0.5 }
	}

	local function forEachTabButton(callback)
		if not self.TabList then
			return
		end
		for _, tabbtn in ipairs(self.TabList:GetChildren()) do
			if tabbtn.ClassName == "Frame" and tabbtn.Name ~= "Placeholder" then
				callback(tabbtn)
			end
		end
	end

	local function applyTabButtonVisual(tabbtn, visual)
		if not (tabbtn and visual) then
			return
		end
		playTween(tabbtn, TAB_BUTTON_TWEEN, {BackgroundTransparency = visual.background})
		playTween(tabbtn:FindFirstChild("Title"), TAB_BUTTON_TWEEN, {TextTransparency = visual.text})
		playTween(tabbtn:FindFirstChild("Image"), TAB_BUTTON_TWEEN, {ImageTransparency = visual.image})
		playTween(tabbtn:FindFirstChild("UIStroke"), TAB_BUTTON_TWEEN, {Transparency = visual.stroke})
	end

	local function isCurrentTabButton(tabbtn)
		return tostring(self.Elements.UIPageLayout.CurrentPage) == tabbtn.Title.Text
	end

	local function animateTabButtonsHidden(interactVisible)
		forEachTabButton(function(tabbtn)
			local interact = tabbtn:FindFirstChild("Interact")
			if interact and interactVisible ~= nil then
				interact.Visible = interactVisible
			end
			applyTabButtonVisual(tabbtn, TAB_VISUAL_PRESETS.hidden)
		end)
	end

	local function animateTabButtonsByCurrentPage(interactVisible)
		forEachTabButton(function(tabbtn)
			local interact = tabbtn:FindFirstChild("Interact")
			if interact and interactVisible ~= nil then
				interact.Visible = interactVisible
			end
			applyTabButtonVisual(tabbtn, isCurrentTabButton(tabbtn) and TAB_VISUAL_PRESETS.selected or TAB_VISUAL_PRESETS.idle)
		end)
	end

	local function forEachElementFrame(callback)
		if not self.Elements then
			return
		end
		for _, tab in ipairs(self.Elements:GetChildren()) do
			if tab.Name ~= "Template" and tab.ClassName == "ScrollingFrame" and tab.Name ~= "Placeholder" then
				for _, element in ipairs(tab:GetChildren()) do
					if element.ClassName == "Frame" and element.Name ~= "SectionSpacing" and element.Name ~= "Placeholder" then
						callback(element)
					end
				end
			end
		end
	end

	local function setElementChildrenVisible(element, visible)
		for _, child in ipairs(element:GetChildren()) do
			if child.ClassName == "Frame"
				or child.ClassName == "TextLabel"
				or child.ClassName == "TextBox"
				or child.ClassName == "ImageButton"
				or child.ClassName == "ImageLabel" then
				child.Visible = visible
			end
		end
	end

	local function applyElementFrameState(element, collapsed)
		local targetTitleTransparency = collapsed and 1 or 0.4
		local targetDividerTransparency = collapsed and 1 or 0.85
		local targetBackgroundTransparency = collapsed and 1 or 0
		local targetStrokeTransparency = collapsed and 1 or 0

		if element.Name == "SectionTitle" or element.Name == "SearchTitle-fsefsefesfsefesfesfThanks" then
			playTween(element:FindFirstChild("Title"), TAB_BUTTON_TWEEN, {TextTransparency = targetTitleTransparency})
		elseif element.Name == "Divider" then
			playTween(element:FindFirstChild("Divider"), TAB_BUTTON_TWEEN, {BackgroundTransparency = targetDividerTransparency})
		else
			playTween(element, TAB_BUTTON_TWEEN, {BackgroundTransparency = targetBackgroundTransparency})
			playTween(element:FindFirstChild("UIStroke"), TAB_BUTTON_TWEEN, {Transparency = targetStrokeTransparency})
			playTween(element:FindFirstChild("Title"), TAB_BUTTON_TWEEN, {TextTransparency = targetBackgroundTransparency})
		end

		setElementChildrenVisible(element, not collapsed)
	end

	local function animateElementFramesCollapsed(collapsed)
		forEachElementFrame(function(element)
			applyElementFrameState(element, collapsed == true)
		end)
	end

	-- Extract code starts here

	local function Notify(data) -- action e.g open messages
		task.spawn(function()
			data = type(data) == "table" and data or {}
			if self.rayfieldDestroyed() then
				return
			end
			if not (self.Notifications and self.Notifications.Parent) then
				return
			end
	
			local template = self.Notifications:FindFirstChild("Template")
			local listLayout = self.Notifications:FindFirstChildOfClass("UIListLayout")
			if not (template and template:IsA("Frame") and listLayout) then
				return
			end
	
			-- Notification Object Creation
			local newNotification = template:Clone()
			newNotification.Name = data.Title or 'No Title Provided'
			newNotification.Parent = self.Notifications
			newNotification.LayoutOrder = #self.Notifications:GetChildren()
			newNotification.Visible = false
	
			local function isNotificationValid()
				return not self.rayfieldDestroyed()
					and newNotification
					and newNotification.Parent
					and self.Notifications
					and self.Notifications.Parent
					and listLayout
					and listLayout.Parent == self.Notifications
			end
	
			-- Set Data
			newNotification.Title.Text = data.Title or "Unknown Title"
			newNotification.Description.Text = data.Content or "Unknown Content"
	
			if data.Image then
				if typeof(data.Image) == 'string' and self.getIcon then
					local iconSuccess, asset = pcall(self.getIcon, data.Image)
					if iconSuccess and asset then
						newNotification.Icon.Image = 'rbxassetid://' .. tostring(asset.id or 0)
						newNotification.Icon.ImageRectOffset = asset.imageRectOffset or Vector2.new(0, 0)
						newNotification.Icon.ImageRectSize = asset.imageRectSize or Vector2.new(0, 0)
					else
						newNotification.Icon.Image = self.getAssetUri(data.Image)
					end
				else
					newNotification.Icon.Image = self.getAssetUri(data.Image)
				end
			else
				newNotification.Icon.Image = "rbxassetid://" .. 0
			end
	
			-- Set initial transparency values
	
			newNotification.Title.TextColor3 = self.getSelectedTheme().TextColor
			newNotification.Description.TextColor3 = self.getSelectedTheme().TextColor
			newNotification.BackgroundColor3 = self.getSelectedTheme().Background
			newNotification.UIStroke.Color = self.getSelectedTheme().TextColor
			newNotification.Icon.ImageColor3 = self.getSelectedTheme().TextColor
	
			newNotification.BackgroundTransparency = 1
			newNotification.Title.TextTransparency = 1
			newNotification.Description.TextTransparency = 1
			newNotification.UIStroke.Transparency = 1
			newNotification.Shadow.ImageTransparency = 1
			newNotification.Size = UDim2.new(1, 0, 0, 800)
			newNotification.Icon.ImageTransparency = 1
			newNotification.Icon.BackgroundTransparency = 1
	
			task.wait()
			if not isNotificationValid() then
				if newNotification and newNotification.Parent then
					newNotification:Destroy()
				end
				return
			end
	
			newNotification.Visible = true
	
			if data.Actions then
				warn('Rayfield | Not seeing your actions in notifications?')
				print("Notification Actions are being sunset for now, keep up to date on when they're back in the discord. (sirius.menu/discord)")
			end
	
			-- Calculate textbounds and set initial values
			local bounds = {newNotification.Title.TextBounds.Y, newNotification.Description.TextBounds.Y}
			local listPadding = -(listLayout.Padding.Offset)
			newNotification.Size = UDim2.new(1, -60, 0, listPadding)
	
			newNotification.Icon.Size = UDim2.new(0, 32, 0, 32)
			newNotification.Icon.Position = UDim2.new(0, 20, 0.5, 0)
	
			self.Animation:Create(newNotification, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Size = UDim2.new(1, 0, 0, math.max(bounds[1] + bounds[2] + 31, 60))}):Play()
	
			task.wait(0.15)
			self.Animation:Create(newNotification, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0.45}):Play()
			self.Animation:Create(newNotification.Title, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {TextTransparency = 0}):Play()
	
			task.wait(0.05)
	
			self.Animation:Create(newNotification.Icon, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {ImageTransparency = 0}):Play()
	
			task.wait(0.05)
			self.Animation:Create(newNotification.Description, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {TextTransparency = 0.35}):Play()
			self.Animation:Create(newNotification.UIStroke, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {Transparency = 0.95}):Play()
			self.Animation:Create(newNotification.Shadow, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {ImageTransparency = 0.82}):Play()
	
			local waitDuration = math.min(math.max((#newNotification.Description.Text * 0.1) + 2.5, 3), 10)
			task.wait(data.Duration or waitDuration)
			if not isNotificationValid() then
				if newNotification and newNotification.Parent then
					newNotification:Destroy()
				end
				return
			end
	
			newNotification.Icon.Visible = false
			self.Animation:Create(newNotification, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {BackgroundTransparency = 1}):Play()
			self.Animation:Create(newNotification.UIStroke, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {Transparency = 1}):Play()
			self.Animation:Create(newNotification.Shadow, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {ImageTransparency = 1}):Play()
			self.Animation:Create(newNotification.Title, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
			self.Animation:Create(newNotification.Description, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
	
			self.Animation:Create(newNotification, TweenInfo.new(1, Enum.EasingStyle.Exponential), {Size = UDim2.new(1, -90, 0, 0)}):Play()
	
			task.wait(1)
			if not isNotificationValid() then
				if newNotification and newNotification.Parent then
					newNotification:Destroy()
				end
				return
			end
	
			self.Animation:Create(newNotification, TweenInfo.new(1, Enum.EasingStyle.Exponential), {Size = UDim2.new(1, -90, 0, listPadding)}):Play()
	
			newNotification.Visible = false
			newNotification:Destroy()
		end)
	end
	
	local function openSearch()
		searchOpen = true
	
		self.Main.Search.BackgroundTransparency = 1
		self.Main.Search.Shadow.ImageTransparency = 1
		self.Main.Search.Input.TextTransparency = 1
		self.Main.Search.Search.ImageTransparency = 1
		self.Main.Search.UIStroke.Transparency = 1
		self.Main.Search.Size = UDim2.new(1, 0, 0, 80)
		self.Main.Search.Position = UDim2.new(0.5, 0, 0, 70)
	
		self.Main.Search.Input.Interactable = true
	
		self.Main.Search.Visible = true
	
		animateTabButtonsHidden(false)
	
		self.Main.Search.Input:CaptureFocus()
		self.Animation:Create(self.Main.Search.Shadow, TweenInfo.new(0.05, Enum.EasingStyle.Quint), {ImageTransparency = 0.95}):Play()
		self.Animation:Create(self.Main.Search, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {Position = UDim2.new(0.5, 0, 0, 57), BackgroundTransparency = 0.9}):Play()
		self.Animation:Create(self.Main.Search.UIStroke, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {Transparency = 0.8}):Play()
		self.Animation:Create(self.Main.Search.Input, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {TextTransparency = 0.2}):Play()
		self.Animation:Create(self.Main.Search.Search, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {ImageTransparency = 0.5}):Play()
		self.Animation:Create(self.Main.Search, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {Size = UDim2.new(1, -35, 0, 35)}):Play()
	end
	
	local function closeSearch()
		searchOpen = false
	
		self.Animation:Create(self.Main.Search, TweenInfo.new(0.35, Enum.EasingStyle.Quint), {BackgroundTransparency = 1, Size = UDim2.new(1, -55, 0, 30)}):Play()
		self.Animation:Create(self.Main.Search.Search, TweenInfo.new(0.15, Enum.EasingStyle.Quint), {ImageTransparency = 1}):Play()
		self.Animation:Create(self.Main.Search.Shadow, TweenInfo.new(0.15, Enum.EasingStyle.Quint), {ImageTransparency = 1}):Play()
		self.Animation:Create(self.Main.Search.UIStroke, TweenInfo.new(0.15, Enum.EasingStyle.Quint), {Transparency = 1}):Play()
		self.Animation:Create(self.Main.Search.Input, TweenInfo.new(0.15, Enum.EasingStyle.Quint), {TextTransparency = 1}):Play()
	
		animateTabButtonsByCurrentPage(true)
	
		self.Main.Search.Input.Text = ''
		self.Main.Search.Input.Interactable = false
	end
	
	local function Hide(notify)
		if self.MPrompt then
			self.MPrompt.Title.TextColor3 = Color3.fromRGB(255, 255, 255)
			self.MPrompt.Position = UDim2.new(0.5, 0, 0, -50)
			self.MPrompt.Size = UDim2.new(0, 40, 0, 10)
			self.MPrompt.BackgroundTransparency = 1
			self.MPrompt.Title.TextTransparency = 1
			self.MPrompt.Visible = true
		end
	
		task.spawn(closeSearch)
	
		Debounce = true
		if notify then
			if self.useMobilePrompt then
				Notify({Title = "Interface Hidden", Content = "The interface has been hidden, you can unhide the interface by tapping 'Show'.", Duration = 7, Image = 4400697855})
			else
				Notify({Title = "Interface Hidden", Content = "The interface has been hidden, you can unhide the interface by tapping " .. tostring(self.getSetting("General", "rayfieldOpen")) .. ".", Duration = 7, Image = 4400697855})
			end
		end

		playTween(self.Main, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {Size = UDim2.new(0, 470, 0, 0)})
		playTween(self.Main, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {BackgroundTransparency = 1})
		playTween(self.Topbar, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {Size = UDim2.new(0, 470, 0, 45)})
		playTween(self.Topbar, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {BackgroundTransparency = 1})
		playTween(self.Topbar and self.Topbar:FindFirstChild("Divider"), TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {BackgroundTransparency = 1})
		playTween(self.Topbar and self.Topbar:FindFirstChild("CornerRepair"), TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {BackgroundTransparency = 1})
		playTween(self.Topbar and self.Topbar:FindFirstChild("Title"), TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {TextTransparency = 1})
		playTween(self.Main and self.Main:FindFirstChild("Shadow") and self.Main.Shadow:FindFirstChild("Image"), TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {ImageTransparency = 1})
		playTween(self.Topbar and self.Topbar:FindFirstChild("UIStroke"), TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {Transparency = 1})
		playTween(self.dragBarCosmetic, TweenInfo.new(0.25, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {BackgroundTransparency = 1})
	
		if self.useMobilePrompt and self.MPrompt then
			self.Animation:Create(self.MPrompt, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {Size = UDim2.new(0, 120, 0, 30), Position = UDim2.new(0.5, 0, 0, 20), BackgroundTransparency = 0.3}):Play()
			self.Animation:Create(self.MPrompt.Title, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {TextTransparency = 0.3}):Play()
		end
	
		if self.Topbar then
			for _, TopbarButton in ipairs(self.Topbar:GetChildren()) do
				if TopbarButton.ClassName == "ImageButton" then
					playTween(TopbarButton, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {ImageTransparency = 1})
				end
			end
		end
	
		animateTabButtonsHidden(nil)
	
		if self.dragInteract then
			self.dragInteract.Visible = false
		end
	
		animateElementFramesCollapsed(true)
	
		task.wait(0.5)
		self.Main.Visible = false
		Debounce = false
	end
	
	local function Maximise()
		Debounce = true
		if self.Topbar and self.Topbar:FindFirstChild("ChangeSize") then
			self.Topbar.ChangeSize.Image = "rbxassetid://" .. 10137941941
		end
	
		playTween(self.Topbar and self.Topbar:FindFirstChild("UIStroke"), TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {Transparency = 1})
		playTween(self.Main and self.Main:FindFirstChild("Shadow") and self.Main.Shadow:FindFirstChild("Image"), TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {ImageTransparency = 0.6})
		playTween(self.Topbar and self.Topbar:FindFirstChild("CornerRepair"), TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0})
		playTween(self.Topbar and self.Topbar:FindFirstChild("Divider"), TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0})
		playTween(self.dragBarCosmetic, TweenInfo.new(0.25, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {BackgroundTransparency = 0.7})
		playTween(self.Main, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {Size = getExpandedSize()})
		playTween(self.Topbar, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {Size = UDim2.fromOffset(getExpandedSize().X.Offset, 45)})
		if self.TabList then
			self.TabList.Visible = true
		end
		task.wait(0.2)
	
		if self.Elements then
			self.Elements.Visible = true
		end
	
		animateElementFramesCollapsed(false)
	
		task.wait(0.1)
	
		animateTabButtonsByCurrentPage(nil)
	
		task.wait(0.5)
		Debounce = false
	end
	
	
	local function Unhide()
		Debounce = true
		self.Main.Position = UDim2.new(0.5, 0, 0.5, 0)
		self.Main.Visible = true
		playTween(self.Main, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {Size = getExpandedSize()})
		playTween(self.Topbar, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {Size = UDim2.fromOffset(getExpandedSize().X.Offset, 45)})
		playTween(self.Main and self.Main:FindFirstChild("Shadow") and self.Main.Shadow:FindFirstChild("Image"), TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {ImageTransparency = 0.6})
		playTween(self.Main, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0})
		playTween(self.Topbar, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0})
		playTween(self.Topbar and self.Topbar:FindFirstChild("Divider"), TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0})
		playTween(self.Topbar and self.Topbar:FindFirstChild("CornerRepair"), TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0})
		playTween(self.Topbar and self.Topbar:FindFirstChild("Title"), TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {TextTransparency = 0})
	
		if self.MPrompt then
			self.Animation:Create(self.MPrompt, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {Size = UDim2.new(0, 40, 0, 10), Position = UDim2.new(0.5, 0, 0, -50), BackgroundTransparency = 1}):Play()
			self.Animation:Create(self.MPrompt.Title, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
	
			task.spawn(function()
				task.wait(0.5)
				self.MPrompt.Visible = false
			end)
		end
	
		if Minimised then
			task.spawn(Maximise)
		end
	
		if self.dragBar then
			self.dragBar.Position = self.useMobileSizing
				and UDim2.new(0.5, 0, 0.5, self.dragOffsetMobile)
				or UDim2.new(0.5, 0, 0.5, self.dragOffset)
		end
	
		if self.dragInteract then
			self.dragInteract.Visible = true
		end
	
		if self.Topbar then
			for _, TopbarButton in ipairs(self.Topbar:GetChildren()) do
				if TopbarButton.ClassName == "ImageButton" then
					if TopbarButton.Name == 'Icon' then
						playTween(TopbarButton, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {ImageTransparency = 0})
					else
						playTween(TopbarButton, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {ImageTransparency = 0.8})
					end
				end
			end
		end
	
		animateTabButtonsByCurrentPage(nil)
	
		animateElementFramesCollapsed(false)
	
		playTween(self.dragBarCosmetic, TweenInfo.new(0.25, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {BackgroundTransparency = 0.5})
	
		task.wait(0.5)
		Minimised = false
		Debounce = false
	end
	
	local function Minimise()
		Debounce = true
		if self.Topbar and self.Topbar:FindFirstChild("ChangeSize") then
			self.Topbar.ChangeSize.Image = "rbxassetid://" .. 11036884234
		end
	
		if self.Topbar and self.Topbar:FindFirstChild("UIStroke") then
			self.Topbar.UIStroke.Color = self.getSelectedTheme().ElementStroke
		end
	
		task.spawn(closeSearch)
	
		animateTabButtonsHidden(nil)
	
		animateElementFramesCollapsed(true)
	
		playTween(self.dragBarCosmetic, TweenInfo.new(0.25, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {BackgroundTransparency = 1})
		playTween(self.Topbar and self.Topbar:FindFirstChild("UIStroke"), TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {Transparency = 0})
		playTween(self.Main and self.Main:FindFirstChild("Shadow") and self.Main.Shadow:FindFirstChild("Image"), TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {ImageTransparency = 1})
		playTween(self.Topbar and self.Topbar:FindFirstChild("CornerRepair"), TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {BackgroundTransparency = 1})
		playTween(self.Topbar and self.Topbar:FindFirstChild("Divider"), TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {BackgroundTransparency = 1})
		playTween(self.Main, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {Size = UDim2.new(0, 495, 0, 45)})
		playTween(self.Topbar, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {Size = UDim2.new(0, 495, 0, 45)})
	
		task.wait(0.3)
	
		if self.Elements then
			self.Elements.Visible = false
		end
		if self.TabList then
			self.TabList.Visible = false
		end
	
		task.wait(0.2)
		Debounce = false
	end

	local function getLayoutSnapshot()
		local currentExpanded = getExpandedSize()
		return {
			position = {
				xScale = self.Main.Position.X.Scale,
				xOffset = self.Main.Position.X.Offset,
				yScale = self.Main.Position.Y.Scale,
				yOffset = self.Main.Position.Y.Offset
			},
			expandedSize = {
				xOffset = currentExpanded.X.Offset,
				yOffset = currentExpanded.Y.Offset
			},
			minimized = Minimised == true,
			hidden = Hidden == true
		}
	end

	local function applyLayoutSnapshot(layout)
		if type(layout) ~= "table" then
			return false
		end

		local expanded = layout.expandedSize
		if type(expanded) == "table" then
			setExpandedSize({
				xOffset = tonumber(expanded.xOffset) or tonumber(expanded.width),
				yOffset = tonumber(expanded.yOffset) or tonumber(expanded.height)
			})
		end

		applyExpandedSizeToFrames()

		local position = layout.position
		if type(position) == "table" then
			local xScale = tonumber(position.xScale) or self.Main.Position.X.Scale
			local xOffset = tonumber(position.xOffset) or self.Main.Position.X.Offset
			local yScale = tonumber(position.yScale) or self.Main.Position.Y.Scale
			local yOffset = tonumber(position.yOffset) or self.Main.Position.Y.Offset
			self.Main.Position = UDim2.new(xScale, xOffset, yScale, yOffset)
			clampMainToViewport()
		end

		local targetHidden = layout.hidden == true
		local targetMinimized = layout.minimized == true
		if targetHidden then
			Hidden = true
			Minimised = false
			self.Main.Visible = false
			if self.Elements then
				self.Elements.Visible = false
			end
			if self.TabList then
				self.TabList.Visible = false
			end
		elseif targetMinimized then
			Hidden = false
			Minimised = true
			self.Main.Visible = true
			self.Main.Size = UDim2.fromOffset(495, 45)
			self.Topbar.Size = UDim2.fromOffset(495, 45)
			if self.Elements then
				self.Elements.Visible = false
			end
			if self.TabList then
				self.TabList.Visible = false
			end
		else
			Hidden = false
			Minimised = false
			self.Main.Visible = true
			if self.Elements then
				self.Elements.Visible = true
			end
			if self.TabList then
				self.TabList.Visible = true
			end
			applyExpandedSizeToFrames()
		end

		return true
	end

	-- Export functions
	self.Notify = Notify
	self.openSearch = openSearch
	self.closeSearch = closeSearch
	self.Hide = Hide
	self.Unhide = Unhide
	self.Maximise = Maximise
	self.Minimise = Minimise
	self.getSearchOpen = function() return searchOpen end
	self.getDebounce = function() return Debounce end
	self.setDebounce = function(value) Debounce = value end
	self.getMinimised = function() return Minimised end
	self.setMinimised = function(value) Minimised = value end
	self.getHidden = function() return Hidden end
	self.setHidden = function(value) Hidden = value end
	self.getExpandedSize = getExpandedSize
	self.setExpandedSize = setExpandedSize
	self.getLayoutSnapshot = getLayoutSnapshot
	self.applyLayoutSnapshot = applyLayoutSnapshot
	
	return self
end

return UIStateModule
]])
put("src/core/window-controller.lua", [[local WindowController = {}

local function loadByPath(path)
	local client = _G and _G.__RayfieldApiClient
	if not client then
		error("Rayfield ApiClient is not initialized")
	end
	local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
	return client.fetchAndExecute(root .. path)
end

function WindowController.run(_runtime)
	return loadByPath("src/entry/rayfield-modified.runtime.lua")
end

return WindowController
]])
put("src/entry/module-map.lua", [[local function row(canonical, legacy, extraLegacy)
	local output = {
		canonical,
		legacy or canonical
	}
	if extraLegacy and extraLegacy ~= "" then
		table.insert(output, extraLegacy)
	end
	return output
end

return {
	theme = row("src/services/theme.lua", "feature/rayfield-theme.lua"),
	settings = row("src/services/settings.lua", "feature/rayfield-settings.lua"),
	compatibility = row("src/services/compatibility.lua"),
	ownershipTracker = row("src/services/ownership-tracker.lua"),
	elementSync = row("src/services/element-sync.lua"),
	keybindSequence = row("src/services/keybind-sequence.lua"),
	layoutPersistence = row("src/services/layout-persistence.lua"),
	viewportVirtualization = row("src/services/viewport-virtualization.lua"),
	config = row("src/services/config.lua", "feature/rayfield-config.lua"),
	utilities = row("src/services/utilities.lua", "feature/rayfield-utilities.lua"),
	uiState = row("src/core/ui-state.lua", "feature/rayfield-ui-state.lua"),
	elements = row("src/ui/elements/factory/init.lua", "feature/rayfield-elements.lua"),
	elementsExtracted = row("src/ui/elements/widgets/index.lua", "feature/rayfield-elements-extracted.lua"),
	widgetsBootstrap = row("src/ui/elements/widgets/bootstrap.lua"),
	drag = row("src/feature/drag/init.lua", "feature/rayfield-drag.lua"),
	tabSplit = row("src/feature/tabsplit/init.lua", "feature/rayfield-tab-split.lua"),
	miniWindow = row("src/feature/mini-window/init.lua", "feature/mini-window-system.lua"),
	enhanced = row("src/feature/enhanced/init.lua", "feature/rayfield-enhanced.lua"),
	advanced = row("src/feature/enhanced/advanced.lua", "feature/rayfield-advanced-features.lua"),
	animationEngine = row("src/core/animation/engine.lua"),
	animationPublic = row("src/core/animation/public.lua"),
	animationSequence = row("src/core/animation/sequence.lua"),
	animationUI = row("src/core/animation/ui.lua"),
	animationText = row("src/core/animation/text.lua"),
	animationEasing = row("src/core/animation/easing.lua"),
	animationCleanup = row("src/core/animation/cleanup.lua"),
	allInOne = row("src/entry/rayfield-all-in-one.entry.lua", "Main%20loader/rayfield-all-in-one.lua", "feature/rayfield-all-in-one.lua"),
	modifiedEntry = row("src/entry/rayfield-modified.entry.lua", "Main%20loader/rayfield-modified.lua")
}
]])
put("src/entry/rayfield-all-in-one.entry.lua", [=[--[[
	Rayfield Enhanced V2 - All-in-One Loader

	===========================================
	DUAL-EXECUTION BEHAVIOR (Improvement 3)
	===========================================

	This loader has two different behaviors depending on how it's called:

	1. FIRST EXECUTION (Auto-Execute Mode):
	   - When loaded for the first time (_G.RayfieldAllInOneLoaded is nil/false)
	   - Automatically loads Rayfield based on CONFIG.AUTO_MODE setting
	   - Exports loaded UI to _G.Rayfield and _G.RayfieldUI
	   - Returns loader table by default (safer for executors that freeze on large return values)
	   - Sets _G.RayfieldAllInOneLoaded = true to track state

	   Example:
	     local loader = loadstring(game:HttpGet('...'))()
	     -- UI is exported globally:
	     local Window = _G.Rayfield:CreateWindow({...})

	2. SUBSEQUENT EXECUTIONS (Loader Table Mode):
	   - When loaded again (_G.RayfieldAllInOneLoaded is true)
	   - Returns the AllInOne loader table with all methods
	   - Does NOT auto-execute to prevent duplicate loading
	   - Allows manual control via loader.loadBase(), loader.loadEnhanced(), etc.

	   Example:
	     local loader = loadstring(game:HttpGet('...'))()
	     -- loader is the AllInOne table with methods
	     local UI = loader.loadEnhanced()

	To control this behavior:
	   - Set AUTO_EXECUTE = false in CONFIG (or configure({autoExecute = false}))
	     to disable auto-execution
	   - Set AUTO_EXECUTE_RETURN (or configure({autoExecuteReturn = "ui"/"loader"/"none"}))
	     to control what first execution returns
	   - Reset _G.RayfieldAllInOneLoaded = nil to force auto-execution again

	===========================================

	Usage:
		loadstring(game:HttpGet('https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/Main%20loader/rayfield-all-in-one.lua'))()

	Hoc nu host trn Pastebin:
		loadstring(game:HttpGet('https://pastebin.com/raw/YOUR_CODE'))()
]]

local AllInOne = {}
local compileString = loadstring or load
if not compileString then
	error("No Lua compiler function available (loadstring/load)")
end
local HttpService = game:GetService("HttpService")

local function compileChunk(source, label)
	if type(source) ~= "string" then
		error("Invalid Lua source for " .. tostring(label) .. ": " .. type(source))
	end
	source = source:gsub("^\239\187\191", "")
	source = source:gsub("^\0+", "")
	local chunk, err = compileString(source)
	if not chunk then
		error("Failed to compile " .. tostring(label) .. ": " .. tostring(err))
	end
	return chunk
end

local MODULE_ROOT_URL = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
_G.__RAYFIELD_RUNTIME_ROOT_URL = MODULE_ROOT_URL
local apiClientSource = game:HttpGet(MODULE_ROOT_URL .. "src/api/client.lua")
local ApiClient = compileChunk(apiClientSource, "src/api/client.lua")()
if _G then
	_G.__RayfieldApiClient = ApiClient
end

-- ============================================
-- CONFIGURATION
-- ============================================

local CONFIG = {
	-- URLs ca cc modules (thay bng URLs tht ca bn)
	BASE_URL = "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/",
	
	-- Hoc dng Pastebin
	USE_PASTEBIN = false,
	PASTEBIN_CODES = {
		base = "XXXXXXXX",
		enhanced = "YYYYYYYY",
		advanced = "ZZZZZZZZ"
	},
	
	-- Cache modules  trnh load li
	CACHE_ENABLED = true,
	
	-- Auto mode selection
	AUTO_MODE = "enhanced", -- "base", "enhanced", "advanced"

	-- Auto execute on first load (set false for loader-table only behavior)
	AUTO_EXECUTE = true,

	-- Return mode for first auto-execution:
	-- "loader" = return AllInOne (recommended)
	-- "ui" = return UI table from quickSetup
	-- "none" = return nil
	AUTO_EXECUTE_RETURN = "loader",

	-- Auto reload when GitHub has a new commit
	AUTO_RELOAD_ENABLED = true,
	AUTO_RELOAD_INTERVAL = 120, -- seconds
	AUTO_RELOAD_REPO = "Ahlstarr-Mayjishan/Rayfield-mod",
	AUTO_RELOAD_BRANCH = "main",
	AUTO_RELOAD_CLEAR_CACHE = true,
	
	-- Default settings
	DEFAULT_SETTINGS = {
		errorThreshold = 5,
		rateLimit = 10,
		autoCleanup = true
	}
}

-- ============================================
-- CACHE SYSTEM
-- ============================================

_G.RayfieldCache = _G.RayfieldCache or {}

local function getCached(key)
	if CONFIG.CACHE_ENABLED and _G.RayfieldCache[key] then
		print(" [Rayfield] Using cached:", key)
		return _G.RayfieldCache[key]
	end
	return nil
end

local function setCache(key, value)
	if CONFIG.CACHE_ENABLED then
		_G.RayfieldCache[key] = value
	end
end

local function getCacheKey(name, url)
	return tostring(name) .. "|" .. tostring(url)
end

local function isCachedModuleUsable(name, moduleValue)
	if type(moduleValue) ~= "table" then
		return false
	end

	-- Base module holds live GUI refs; if destroyed, force reload instead of reusing stale cache.
	if name == "base" then
		if type(moduleValue.CreateWindow) ~= "function" then
			return false
		end
		if type(moduleValue.IsDestroyed) == "function" then
			local ok, destroyed = pcall(moduleValue.IsDestroyed, moduleValue)
			if ok and destroyed then
				return false
			end
		end
	end

	return true
end

-- ============================================
-- MODULE LOADER
-- ============================================

local function loadModule(name, url)
	local cacheKey = getCacheKey(name, url)

	-- Check cache
	local cached = getCached(cacheKey)
	if cached then
		if isCachedModuleUsable(name, cached) then
			return cached
		end
		_G.RayfieldCache[cacheKey] = nil
		print(" [Rayfield] Cache invalidated:", cacheKey)
	end
	
	print(" [Rayfield] Loading:", name)
	
	local success, result = pcall(function()
		return ApiClient.fetchAndExecute(url)
	end)
	
	if not success then
		error(" Failed to load " .. name .. ": " .. tostring(result))
	end
	
	-- Cache result
	setCache(cacheKey, result)
	
	print(" [Rayfield] Loaded:", name)
	return result
end

-- ============================================
-- URL BUILDER
-- ============================================

local function getModuleUrl(moduleName)
	if CONFIG.USE_PASTEBIN then
		local code = CONFIG.PASTEBIN_CODES[moduleName]
		if not code then
			error("No Pastebin code for: " .. moduleName)
		end
		return "https://pastebin.com/raw/" .. code
	else
		local fileNames = {
			base = "Main%20loader/rayfield-modified.lua",
			enhanced = "src/entry/rayfield-enhanced.entry.lua",
			advanced = "src/feature/enhanced/advanced.lua"
		}
		return CONFIG.BASE_URL .. fileNames[moduleName]
	end
end

-- ============================================
-- AUTO RELOAD (COMMIT WATCHER)
-- ============================================

_G.RayfieldAllInOneAutoReloadState = _G.RayfieldAllInOneAutoReloadState or {
	running = false,
	reloading = false,
	token = 0,
	lastCommit = nil,
	lastReloadAt = nil,
	onReload = nil
}
local AutoReloadState = _G.RayfieldAllInOneAutoReloadState

local function shortCommit(commit)
	if type(commit) ~= "string" then
		return "unknown"
	end
	return string.sub(commit, 1, 7)
end

local function resolveRepoBranch()
	local repo = CONFIG.AUTO_RELOAD_REPO
	local branch = CONFIG.AUTO_RELOAD_BRANCH

	if (not repo or repo == "") and type(CONFIG.BASE_URL) == "string" then
		local owner, repoName, parsedBranch = string.match(CONFIG.BASE_URL, "raw%.githubusercontent%.com/([^/]+)/([^/]+)/([^/]+)/")
		if owner and repoName then
			repo = owner .. "/" .. repoName
			if not branch or branch == "" then
				branch = parsedBranch or "main"
			end
		end
	end

	if not branch or branch == "" then
		branch = "main"
	end

	return repo, branch
end

local function fetchLatestCommit()
	if CONFIG.USE_PASTEBIN then
		return nil, "auto reload only supports GitHub source"
	end

	local repo, branch = resolveRepoBranch()
	if not repo or repo == "" then
		return nil, "cannot resolve repository for auto reload"
	end

	local stamp = tostring(math.floor(os.clock() * 1000))
	local url = "https://api.github.com/repos/" .. repo .. "/commits/" .. branch .. "?_=" .. stamp

	local okHttp, body = pcall(function()
		return game:HttpGet(url)
	end)
	if not okHttp then
		return nil, tostring(body)
	end

	local okDecode, payload = pcall(function()
		return HttpService:JSONDecode(body)
	end)
	if not okDecode or type(payload) ~= "table" then
		return nil, "failed to decode GitHub response"
	end

	if type(payload.sha) ~= "string" or payload.sha == "" then
		return nil, "commit sha missing from response"
	end

	return payload.sha
end

local function exportCurrentUI(ui)
	if not ui or type(ui) ~= "table" then
		return
	end
	AllInOne.currentUI = ui
	_G.RayfieldUI = ui
	_G.Rayfield = ui.Rayfield
end

local function reloadForNewCommit(newCommit)
	if AutoReloadState.reloading then
		return false, "reload is already in progress"
	end

	AutoReloadState.reloading = true
	local previousRayfield = _G.Rayfield
	local previousUI = AllInOne.currentUI or _G.RayfieldUI
	local mode = (previousUI and previousUI.mode) or CONFIG.AUTO_MODE

	if CONFIG.AUTO_RELOAD_CLEAR_CACHE then
		AllInOne.clearCache()
	end

	local okLoad, reloadedUI = pcall(AllInOne.quickSetup, {
		mode = mode,
		errorThreshold = CONFIG.DEFAULT_SETTINGS.errorThreshold,
		rateLimit = CONFIG.DEFAULT_SETTINGS.rateLimit,
		autoCleanup = CONFIG.DEFAULT_SETTINGS.autoCleanup
	})

	if not okLoad then
		AutoReloadState.reloading = false
		return false, "reload failed: " .. tostring(reloadedUI)
	end

	if previousRayfield and previousRayfield ~= reloadedUI.Rayfield and type(previousRayfield.Destroy) == "function" then
		pcall(function()
			previousRayfield:Destroy()
		end)
	end

	exportCurrentUI(reloadedUI)
	AutoReloadState.lastCommit = newCommit or AutoReloadState.lastCommit
	AutoReloadState.lastReloadAt = os.time()

	if type(AutoReloadState.onReload) == "function" then
		pcall(AutoReloadState.onReload, reloadedUI, previousUI, newCommit)
	end

	AutoReloadState.reloading = false
	return true
end

local function stopAutoReloadWatcher(silent)
	AutoReloadState.running = false
	AutoReloadState.token = (AutoReloadState.token or 0) + 1
	if not silent then
		print(" [Rayfield] Auto reload stopped")
	end
end

local function startAutoReloadWatcher()
	if not CONFIG.AUTO_RELOAD_ENABLED then
		return false, "auto reload is disabled"
	end
	if CONFIG.USE_PASTEBIN then
		return false, "auto reload requires GitHub source"
	end
	if AutoReloadState.running then
		return true
	end

	local interval = tonumber(CONFIG.AUTO_RELOAD_INTERVAL) or 120
	if interval < 30 then
		interval = 30
	end
	CONFIG.AUTO_RELOAD_INTERVAL = interval

	local repo, branch = resolveRepoBranch()
	if not repo or repo == "" then
		return false, "cannot resolve repository"
	end

	AutoReloadState.running = true
	AutoReloadState.token = (AutoReloadState.token or 0) + 1
	local token = AutoReloadState.token

	local initialCommit, initialError = fetchLatestCommit()
	if initialCommit then
		AutoReloadState.lastCommit = initialCommit
		print(" [Rayfield] Auto reload watching " .. repo .. "@" .. branch .. " (" .. shortCommit(initialCommit) .. ")")
	elseif initialError then
		warn(" [Rayfield] Auto reload initial check failed: " .. tostring(initialError))
	end

	task.spawn(function()
		while AutoReloadState.running and AutoReloadState.token == token do
			task.wait(interval)
			if not AutoReloadState.running or AutoReloadState.token ~= token then
				break
			end

			local latestCommit, err = fetchLatestCommit()
			if latestCommit then
				local knownCommit = AutoReloadState.lastCommit
				if knownCommit and knownCommit ~= latestCommit then
					print(" [Rayfield] New commit detected: " .. shortCommit(knownCommit) .. " -> " .. shortCommit(latestCommit))
					local okReload, reloadError = reloadForNewCommit(latestCommit)
					if okReload then
						print(" [Rayfield] UI reloaded from latest commit (" .. shortCommit(latestCommit) .. ")")
					else
						warn(" [Rayfield] Auto reload failed: " .. tostring(reloadError))
					end
				elseif not knownCommit then
					AutoReloadState.lastCommit = latestCommit
				end
			elseif err then
				warn(" [Rayfield] Auto reload check failed: " .. tostring(err))
			end
		end
	end)

	return true
end

local function startAutoReloadWatcherAsync(errorPrefix)
	task.spawn(function()
		local okStart, errStart = startAutoReloadWatcher()
		if not okStart and errStart then
			warn((errorPrefix or " [Rayfield] Auto reload start failed: ") .. tostring(errStart))
		end
	end)
end

-- ============================================
-- LOAD FUNCTIONS
-- ============================================

function AllInOne.loadBase()
	print("\n")
	print(" Rayfield All-in-One: Base Mode")
	print("")
	
	local Rayfield = loadModule("base", getModuleUrl("base"))
	
	print(" Ready: Base UI")
	print("\n")
	
	return {
		Rayfield = Rayfield,
		mode = "base"
	}
end

function AllInOne.loadEnhanced()
	print("\n")
	print(" Rayfield All-in-One: Enhanced Mode")
	print("")
	
	local Rayfield = loadModule("base", getModuleUrl("base"))
	local Enhancement = loadModule("enhanced", getModuleUrl("enhanced"))
	
	local EnhancedRayfield, ErrorMgr, GC, RemoteProt, LeakDetector, Profiler = 
		Enhancement.createEnhancedRayfield(Rayfield)
	
	print(" Ready: Base + Enhanced V2")
	print("\n")
	
	return {
		Rayfield = EnhancedRayfield,
		ErrorManager = ErrorMgr,
		GarbageCollector = GC,
		RemoteProtection = RemoteProt,
		MemoryLeakDetector = LeakDetector,
		Profiler = Profiler,
		Enhancement = Enhancement,
		mode = "enhanced"
	}
end

function AllInOne.loadAdvanced()
	print("\n")
	print(" Rayfield All-in-One: Advanced Mode")
	print("")
	
	local Rayfield = loadModule("base", getModuleUrl("base"))
	local Enhancement = loadModule("enhanced", getModuleUrl("enhanced"))
	local Advanced = loadModule("advanced", getModuleUrl("advanced"))
	
	local EnhancedRayfield, ErrorMgr, GC, RemoteProt, LeakDetector, Profiler = 
		Enhancement.createEnhancedRayfield(Rayfield)
	
	print(" Ready: Full Stack (Base + Enhanced + Advanced)")
	print("\n")
	
	return {
		Rayfield = EnhancedRayfield,
		ErrorManager = ErrorMgr,
		GarbageCollector = GC,
		RemoteProtection = RemoteProt,
		MemoryLeakDetector = LeakDetector,
		Profiler = Profiler,
		Enhancement = Enhancement,
		Advanced = Advanced,
		StatePersistence = Advanced.StatePersistence,
		mode = "advanced"
	}
end

function AllInOne.loadAll()
	return AllInOne.loadAdvanced()
end

-- ============================================
-- QUICK SETUP
-- ============================================

function AllInOne.quickSetup(config)
	config = config or {}
	local mode = config.mode or CONFIG.AUTO_MODE
	
	local UI
	if mode == "base" then
		UI = AllInOne.loadBase()
	elseif mode == "enhanced" then
		UI = AllInOne.loadEnhanced()
	elseif mode == "advanced" or mode == "all" then
		UI = AllInOne.loadAdvanced()
	else
		error("Invalid mode: " .. tostring(mode))
	end
	
	-- Apply settings
	if UI.ErrorManager then
		if config.errorThreshold then
			UI.ErrorManager.errorThreshold = config.errorThreshold
		end
		if config.rateLimit then
			UI.ErrorManager.defaultRateLimit = config.rateLimit
		end
	end
	
	if UI.GarbageCollector and config.autoCleanup then
		UI.GarbageCollector.autoCleanupInterval = config.cleanupInterval or 60
	end

	AllInOne.currentUI = UI

	if CONFIG.AUTO_RELOAD_ENABLED and not AutoReloadState.running then
		startAutoReloadWatcherAsync(" [Rayfield] Auto reload is enabled but failed to start: ")
	end
	
	return UI
end

-- ============================================
-- CONFIGURE
-- ============================================

function AllInOne.configure(config)
	if config.baseUrl then
		CONFIG.BASE_URL = config.baseUrl
	end
	
	if config.usePastebin ~= nil then
		CONFIG.USE_PASTEBIN = config.usePastebin
	end
	
	if config.pastebinCodes then
		for k, v in pairs(config.pastebinCodes) do
			CONFIG.PASTEBIN_CODES[k] = v
		end
	end
	
	if config.cacheEnabled ~= nil then
		CONFIG.CACHE_ENABLED = config.cacheEnabled
	end
	
	if config.autoMode then
		CONFIG.AUTO_MODE = config.autoMode
	end

	if config.autoExecute ~= nil then
		CONFIG.AUTO_EXECUTE = config.autoExecute
	end

	if config.autoExecuteReturn then
		local mode = tostring(config.autoExecuteReturn):lower()
		if mode == "loader" or mode == "ui" or mode == "none" then
			CONFIG.AUTO_EXECUTE_RETURN = mode
		else
			warn(" [Rayfield] Invalid autoExecuteReturn: " .. tostring(config.autoExecuteReturn) .. " (use 'loader', 'ui', or 'none')")
		end
	end

	if config.autoReload ~= nil then
		CONFIG.AUTO_RELOAD_ENABLED = config.autoReload and true or false
	end

	if config.autoReloadEnabled ~= nil then
		CONFIG.AUTO_RELOAD_ENABLED = config.autoReloadEnabled and true or false
	end

	if config.autoReloadInterval ~= nil then
		local interval = tonumber(config.autoReloadInterval)
		if interval and interval > 0 then
			CONFIG.AUTO_RELOAD_INTERVAL = interval
		else
			warn(" [Rayfield] Invalid autoReloadInterval: " .. tostring(config.autoReloadInterval))
		end
	end

	if config.autoReloadRepo then
		CONFIG.AUTO_RELOAD_REPO = tostring(config.autoReloadRepo)
	end

	if config.autoReloadBranch then
		CONFIG.AUTO_RELOAD_BRANCH = tostring(config.autoReloadBranch)
	end

	if config.autoReloadClearCache ~= nil then
		CONFIG.AUTO_RELOAD_CLEAR_CACHE = config.autoReloadClearCache and true or false
	end

	if config.autoReloadCallback ~= nil then
		if type(config.autoReloadCallback) == "function" then
			AutoReloadState.onReload = config.autoReloadCallback
		else
			warn(" [Rayfield] autoReloadCallback must be a function")
		end
	end

	if CONFIG.AUTO_RELOAD_ENABLED then
		if AutoReloadState.running then
			stopAutoReloadWatcher(true)
		end
		local okStart, errStart = startAutoReloadWatcher()
		if not okStart and errStart then
			warn(" [Rayfield] Auto reload start failed: " .. tostring(errStart))
		end
	else
		stopAutoReloadWatcher(true)
	end
	
	print(" [Rayfield] Configuration updated")
end

-- ============================================
-- UTILITIES
-- ============================================

function AllInOne.clearCache()
	_G.RayfieldCache = {}
	if type(_G.__RayfieldApiModuleCache) == "table" then
		table.clear(_G.__RayfieldApiModuleCache)
	end
	print(" [Rayfield] Cache cleared")
end

function AllInOne.checkForUpdates()
	local latestCommit, err = fetchLatestCommit()
	if not latestCommit then
		return {
			ok = false,
			error = err
		}
	end

	local currentCommit = AutoReloadState.lastCommit
	return {
		ok = true,
		latestCommit = latestCommit,
		currentCommit = currentCommit,
		hasUpdate = currentCommit ~= nil and latestCommit ~= currentCommit
	}
end

function AllInOne.reloadNow()
	local latestCommit, err = fetchLatestCommit()
	if not latestCommit then
		return false, "cannot fetch latest commit: " .. tostring(err)
	end
	local okReload, errReload = reloadForNewCommit(latestCommit)
	return okReload, errReload
end

function AllInOne.startAutoReload()
	CONFIG.AUTO_RELOAD_ENABLED = true
	return startAutoReloadWatcher()
end

function AllInOne.stopAutoReload()
	CONFIG.AUTO_RELOAD_ENABLED = false
	stopAutoReloadWatcher()
end

function AllInOne.setAutoReloadCallback(callback)
	if callback ~= nil and type(callback) ~= "function" then
		error("auto reload callback must be a function or nil")
	end
	AutoReloadState.onReload = callback
end

function AllInOne.info()
	print("\n")
	print(" Rayfield All-in-One Loader")
	print("")
	print("Version: 2.1.0")
	print("Cache Enabled:", CONFIG.CACHE_ENABLED)
	print("Auto Mode:", CONFIG.AUTO_MODE)
	print("Auto Execute:", CONFIG.AUTO_EXECUTE)
	print("Auto Execute Return:", CONFIG.AUTO_EXECUTE_RETURN)
	print("Auto Reload:", CONFIG.AUTO_RELOAD_ENABLED)
	print("Auto Reload Interval:", CONFIG.AUTO_RELOAD_INTERVAL)
	print("Auto Reload Repo:", CONFIG.AUTO_RELOAD_REPO .. "@" .. CONFIG.AUTO_RELOAD_BRANCH)
	print("Last Seen Commit:", AutoReloadState.lastCommit and shortCommit(AutoReloadState.lastCommit) or "n/a")
	print("\nCached Modules:")
	for name, _ in pairs(_G.RayfieldCache) do
		print("  ", name)
	end
	print("\nAvailable Modes:")
	print("   loadBase() - Base UI only")
	print("   loadEnhanced() - Base + Enhanced V2")
	print("   loadAdvanced() - Full Stack")
	print("   loadAll() - Same as loadAdvanced()")
	print("   quickSetup({mode = 'enhanced'}) - Quick setup")
	print("   startAutoReload() / stopAutoReload()")
	print("   checkForUpdates() / reloadNow()")
	print("\n")
end

-- ============================================
-- AUTO EXECUTE
-- ============================================

-- Improvement 3: Dual-execution behavior with clear documentation
-- First execution: Auto-loads UI and returns per CONFIG.AUTO_EXECUTE_RETURN
-- Subsequent executions: Returns AllInOne loader table (manual control)
if CONFIG.AUTO_EXECUTE and not _G.RayfieldAllInOneLoaded then
	_G.RayfieldAllInOneLoaded = true

	print("\n")
	print(" Rayfield All-in-One Auto-Loading")
	print("")
	print("Mode:", CONFIG.AUTO_MODE)
	print("\n")

	-- Auto load theo config
	local UI = AllInOne.quickSetup({
		mode = CONFIG.AUTO_MODE,
		errorThreshold = CONFIG.DEFAULT_SETTINGS.errorThreshold,
		rateLimit = CONFIG.DEFAULT_SETTINGS.rateLimit,
		autoCleanup = CONFIG.DEFAULT_SETTINGS.autoCleanup
	})

	-- Export to global
	_G.Rayfield = UI.Rayfield
	_G.RayfieldUI = UI
	AllInOne.currentUI = UI

	print(" [Rayfield] Auto-loaded successfully!")
	print("Access via: _G.Rayfield or _G.RayfieldUI")
	print("Return mode:", CONFIG.AUTO_EXECUTE_RETURN, "\n")

	-- Return lightweight loader by default to avoid executor freeze on large return objects
	if CONFIG.AUTO_EXECUTE_RETURN == "ui" then
		return UI
	elseif CONFIG.AUTO_EXECUTE_RETURN == "none" then
		return nil
	end
	return AllInOne
end

-- Return loader table on subsequent executions (allows manual control)
return AllInOne
]=])
put("src/entry/rayfield-enhanced.entry.lua", [[local compileString = loadstring or load
if not compileString then
	error("No Lua compiler function available (loadstring/load)")
end

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
local Client = compileString(game:HttpGet(root .. "src/api/client.lua"))()
if _G then
	_G.__RayfieldApiClient = Client
end
return Client.fetchAndExecute(root .. "src/feature/enhanced/init.lua")
]])
put("src/entry/rayfield-modified.entry.lua", [[-- Canonical entry orchestrator for Rayfield modified runtime

local client = _G and _G.__RayfieldApiClient
if not client then
	local compileString = loadstring or load
	if not compileString then
		error("No Lua compiler function available (loadstring/load)")
	end

	local function compileChunk(source, label)
		if type(source) ~= "string" then
			error("Invalid Lua source for " .. tostring(label) .. ": " .. type(source))
		end
		source = source:gsub("^\239\187\191", "")
		source = source:gsub("^\0+", "")
		local chunk, err = compileString(source)
		if not chunk then
			error("Failed to compile " .. tostring(label) .. ": " .. tostring(err))
		end
		return chunk
	end

	local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
	local clientSource = game:HttpGet(root .. "src/api/client.lua")
	client = compileChunk(clientSource, "src/api/client.lua")()
	if _G then
		_G.__RayfieldApiClient = client
	end
end

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"

-- Force fresh module graph per bootstrap run to avoid stale API module cache
-- when users rerun scripts in the same executor session.
pcall(function()
	local cache = client.fetchAndExecute(root .. "src/api/cache.lua")
	if cache and type(cache.clear) == "function" then
		cache.clear()
	end
end)

local RuntimeEnv = client.fetchAndExecute(root .. "src/core/runtime-env.lua")
local WindowController = client.fetchAndExecute(root .. "src/core/window-controller.lua")

-- Initialize UI orchestration modules so they are part of the canonical graph.
-- The runtime implementation still lives in rayfield-modified.runtime.lua for full compatibility.
local WindowUi = client.fetchAndExecute(root .. "src/ui/window/init.lua")
local TopbarUi = client.fetchAndExecute(root .. "src/ui/topbar/init.lua")
local TabsUi = client.fetchAndExecute(root .. "src/ui/tabs/init.lua")
local NotificationsUi = client.fetchAndExecute(root .. "src/ui/notifications/init.lua")

local runtime = RuntimeEnv.create()
WindowUi.init(runtime)
TopbarUi.init(runtime)
TabsUi.init(runtime)
NotificationsUi.init(runtime)

return WindowController.run(runtime)
]])
put("src/entry/rayfield-modified.runtime.lua", [=[--[[

	Rayfield Interface Suite
	by Sirius

	shlex  | Designing + Programming
	iRay   | Programming
	Max    | Programming
	Damian | Programming

	Modified Version with Extended API:
	- Element:Destroy() - Remove elements after creation
	- Element:Show() / :Hide() - Toggle element visibility
	- Element:SetVisible(bool) - Set visibility programmatically
	- Tab:Clear() - Remove all elements in tab
	- Section:Clear() - Remove all elements in section
	- Tab:GetElements() - Get list of all elements
	- Tab:FindElement(name) - Find element by name
	- Element:GetParent() - Get parent tab/section
	- Dropdown:Clear() visual fix - Updates UI immediately

]]

if debugX then
	warn('Initialising Rayfield')
end

local Compatibility = nil
local function getService(name)
	return game:GetService(name)
end

-- Loads and executes a function hosted on a remote URL. Cancels the request if the requested URL takes too long to respond.
-- Errors with the function are caught and logged to the output
local function loadWithTimeout(url: string, timeout: number?): ...any
	assert(type(url) == "string", "Expected string, got " .. type(url))
	timeout = timeout or 5
	local requestCompleted = false
	local success, result = false, nil

	local requestThread = task.spawn(function()
		local fetchSuccess, fetchResult = pcall(game.HttpGet, game, url) -- game:HttpGet(url)
		-- Handle executor/network edge-cases where fetchResult can be nil/non-string.
		if not fetchSuccess then
			success, result = false, tostring(fetchResult or "HTTP request failed")
			requestCompleted = true
			return
		end

		if type(fetchResult) ~= "string" then
			success, result = false, "Invalid HTTP response type: " .. type(fetchResult)
			requestCompleted = true
			return
		end

		-- If the request succeeds but content is empty, surface a readable error.
		if #fetchResult == 0 then
			success, result = false, "Empty response"
			requestCompleted = true
			return
		end
		local content = fetchResult -- Fetched content

		-- Improvement 2: Validate content before passing to loadstring
		if type(content) ~= "string" then
			success, result = false, "Invalid content type: expected string, got " .. type(content)
			requestCompleted = true
			return
		end

		if #content == 0 then
			success, result = false, "Content is empty"
			requestCompleted = true
			return
		end

		local execSuccess, execResult = pcall(function()
			return loadstring(content)()
		end)
		success, result = execSuccess, execResult
		requestCompleted = true
	end)

	local timeoutThread = task.delay(timeout, function()
		if not requestCompleted then
			warn("Request for " .. url .. " timed out after " .. tostring(timeout) .. " seconds")
			task.cancel(requestThread)
			result = "Request timed out"
			requestCompleted = true
		end
	end)

	-- Wait for completion or timeout
	while not requestCompleted do
		task.wait()
	end
	-- Cancel timeout thread if still running when request completes
	if coroutine.status(timeoutThread) ~= "dead" then
		task.cancel(timeoutThread)
	end
	if not success then
		warn("Failed to process " .. tostring(url) .. ": " .. tostring(result))
	end
	return if success then result else nil
end

local requestsDisabled = true --getgenv and getgenv().DISABLE_RAYFIELD_REQUESTS
local InterfaceBuild = '3K3W'
local Release = "Build 1.68"
local RayfieldFolder = "Rayfield"
local ConfigurationFolder = RayfieldFolder.."/Configurations"
local ConfigurationExtension = ".rfld"
local settingsTable = {
	General = {
		-- if needs be in order just make getSetting(name)
		rayfieldOpen = {Type = 'bind', Value = 'K', Name = 'Rayfield Keybind'},
		-- buildwarnings
		-- rayfieldprompts

	},
	System = {
		usageAnalytics = {Type = 'toggle', Value = true, Name = 'Anonymised Analytics'},
	}
}

local HttpService = getService('HttpService')
local RunService = getService('RunService')

-- Environment Check
local useStudio = RunService:IsStudio() or false

local prompt = useStudio and require(script.Parent.prompt) or loadWithTimeout('https://raw.githubusercontent.com/SiriusSoftwareLtd/Sirius/refs/heads/request/prompt.lua')
local requestFunc = (syn and syn.request) or (fluxus and fluxus.request) or (http and http.request) or http_request or request

-- Validate prompt loaded correctly
if not prompt and not useStudio then
	warn("Failed to load prompt library, using fallback")
	prompt = {
		create = function() end -- No-op fallback
	}
end


-- The function below provides a safe alternative for calling error-prone functions
-- Especially useful for filesystem function (writefile, makefolder, etc.)
local function callSafely(func, ...)
	if func then
		local success, result = pcall(func, ...)
		if not success then
			warn("Rayfield | Function failed with error: ", result)
			return false
		else
			return result
		end
	end
end

-- Ensures a folder exists by creating it if needed
local function ensureFolder(folderPath)
	if isfolder and not callSafely(isfolder, folderPath) then
		callSafely(makefolder, folderPath)
	end
end

if debugX then
	warn('Now Loading Settings Configuration')
end

-- Note: Settings functions will be initialized after modules are loaded

if debugX then
	warn('Settings Loaded')
end

local analyticsLib
local sendReport = function(ev_n, sc_n) warn("Failed to load report function") end
if not requestsDisabled then
	if debugX then
		warn('Querying Settings for Reporter Information')
	end	
	analyticsLib = loadWithTimeout("https://analytics.sirius.menu/script")
	if not analyticsLib then
		warn("Failed to load analytics reporter")
		analyticsLib = nil
	elseif analyticsLib and type(analyticsLib.load) == "function" then
		analyticsLib:load()
	else
		warn("Analytics library loaded but missing load function")
		analyticsLib = nil
	end
	sendReport = function(ev_n, sc_n)
		if not (type(analyticsLib) == "table" and type(analyticsLib.isLoaded) == "function" and analyticsLib:isLoaded()) then
			warn("Analytics library not loaded")
			return
		end
		if useStudio then
			print('Sending Analytics')
		else
			if debugX then warn('Reporting Analytics') end
			analyticsLib:report(
				{
					["name"] = ev_n,
					["script"] = {["name"] = sc_n, ["version"] = Release}
				},
				{
					["version"] = InterfaceBuild
				}
			)
			if debugX then warn('Finished Report') end
		end
	end
	local shouldReportExecution = false
	if type(cachedSettings) == "table" then
		shouldReportExecution = (next(cachedSettings) == nil) or (cachedSettings.System and cachedSettings.System.usageAnalytics and cachedSettings.System.usageAnalytics.Value)
	elseif cachedSettings == nil then
		shouldReportExecution = true
	end

	if shouldReportExecution then
		sendReport("execution", "Rayfield")
	end
end

local promptUser = 2

if promptUser == 1 and prompt and type(prompt.create) == "function" then
	prompt.create(
		'Be cautious when running scripts',
	    [[Please be careful when running scripts from unknown developers. This script has already been ran.

<font transparency='0.3'>Some scripts may steal your items or in-game goods.</font>]],
		'Okay',
		'',
		function()

		end
	)
end

if debugX then
	warn('Moving on to continue initialisation')
end

local RayfieldLibrary = {
	Flags = {},
	Theme = {}
}

-- Compatibility wrapper for loadstring (some executors use different names)
local compileString = loadstring or load
if not compileString then
	error("No Lua compiler function available (loadstring/load). Your executor may not support dynamic code loading.")
end

-- Load external modules through shared API loader
local MODULE_ROOT_URL = "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
_G.__RAYFIELD_RUNTIME_ROOT_URL = MODULE_ROOT_URL

local ApiClient = compileString(game:HttpGet(MODULE_ROOT_URL .. "src/api/client.lua"))()
local function fetchExecuteSafely(path)
	local ok, result = pcall(ApiClient.fetchAndExecute, MODULE_ROOT_URL .. path)
	if ok then
		return true, result
	end
	return false, tostring(result)
end

local okCompatibility, compatibilityResult = fetchExecuteSafely("src/services/compatibility.lua")
if okCompatibility and type(compatibilityResult) == "table" then
	Compatibility = compatibilityResult
else
	warn("Rayfield Mod: [W_BOOTSTRAP_COMPAT] Failed to load compatibility service; using fallback compatibility.")
	if not okCompatibility then
		warn("Rayfield Mod: [W_BOOTSTRAP_COMPAT_REASON] " .. tostring(compatibilityResult))
	end
	Compatibility = {
		getService = function(name)
			return game:GetService(name)
		end,
		getCompileString = function()
			return compileString
		end,
		protectAndParent = function(gui, preferredContainer, opts)
			local inStudio = opts and opts.useStudio
			if inStudio then
				return nil
			end
			local okCore, core = pcall(function()
				return game:GetService("CoreGui")
			end)
			if okCore and core then
				gui.Parent = core
				return core
			end
			return nil
		end,
		dedupeGuiByName = function()
			return
		end
	}
end
if _G then
	_G.__RayfieldCompatibility = Compatibility
end
if type(Compatibility.getService) == "function" then
	getService = Compatibility.getService
end
if type(Compatibility.getCompileString) == "function" then
	compileString = Compatibility.getCompileString()
end

local okWidgetBootstrap, widgetBootstrapResult = fetchExecuteSafely("src/ui/elements/widgets/bootstrap.lua")
local WidgetBootstrap = okWidgetBootstrap and widgetBootstrapResult or nil
if type(WidgetBootstrap) ~= "table" or type(WidgetBootstrap.bootstrapWidget) ~= "function" then
	warn("Rayfield Mod: [W_BOOTSTRAP_WIDGETS] Failed to load widget bootstrap; using fallback widget loader.")
	if not okWidgetBootstrap then
		warn("Rayfield Mod: [W_BOOTSTRAP_WIDGETS_REASON] " .. tostring(widgetBootstrapResult))
	end
	WidgetBootstrap = {
		bootstrapWidget = function(widgetName, targetPath, exportAdapter, opts)
			local moduleValue = ApiClient.fetchAndExecute(MODULE_ROOT_URL .. tostring(targetPath))
			if opts and opts.expectedType and type(moduleValue) ~= opts.expectedType then
				error("Rayfield Mod: [E_WIDGET_BOOTSTRAP] " .. tostring(widgetName) .. " expected " .. tostring(opts.expectedType) .. ", got " .. type(moduleValue))
			end
			if type(exportAdapter) == "function" then
				return exportAdapter(moduleValue)
			end
			return moduleValue
		end
	}
end
if _G then
	_G.__RayfieldWidgetBootstrap = WidgetBootstrap
end
local okApiLoader, apiLoaderResult = fetchExecuteSafely("src/api/loader.lua")
if not okApiLoader then
	error("Rayfield Mod: [E_BOOTSTRAP_LOADER] Failed to load API loader: " .. tostring(apiLoaderResult))
end
local ApiLoader = apiLoaderResult
if type(ApiLoader) ~= "table" or type(ApiLoader.load) ~= "function" then
	error("Rayfield Mod: [E_BOOTSTRAP_LOADER] Invalid API loader contract")
end

local function getScriptRef()
	local scriptRef = nil
	pcall(function()
		scriptRef = script
	end)
	return scriptRef
end

local function loadModule(moduleName)
	local opts = {
		tryStudioRequire = useStudio,
		scriptRef = getScriptRef(),
		allowLegacyFallback = true
	}
	if type(ApiLoader.tryLoad) == "function" then
		return ApiLoader.tryLoad(moduleName, opts)
	end
	local ok, result = pcall(ApiLoader.load, moduleName, opts)
	if ok then
		return true, result
	end
	return false, tostring(result)
end

local function formatLoaderError(code, message)
	return string.format("Rayfield Mod: [%s] %s", tostring(code or "E_LOADER"), tostring(message or "Unknown loader error"))
end

local function requireModule(moduleName, hint)
	local ok, result = loadModule(moduleName)
	if ok then
		return result
	end
	local reason = tostring(result)
	if hint then
		reason = tostring(hint) .. "\n" .. reason
	end
	error(formatLoaderError("E_REQUIRED_MODULE", "Failed to load required module '" .. tostring(moduleName) .. "'.\n" .. reason))
end

local loaderDiagnostics = {
	optionalFailed = {},
	notified = false,
	performanceProfile = nil
}
if _G then
	_G.__RAYFIELD_LOADER_DIAGNOSTICS = loaderDiagnostics
end

local function optionalModule(moduleName, fallbackModule, hint)
	local ok, result = loadModule(moduleName)
	if ok then
		return result
	end
	table.insert(loaderDiagnostics.optionalFailed, {
		module = moduleName,
		error = tostring(result)
	})
	local message = "Optional module '" .. tostring(moduleName) .. "' failed to load. Using fallback."
	if hint then
		message = message .. " " .. tostring(hint)
	end
	warn(formatLoaderError("W_OPTIONAL_MODULE", message .. " | " .. tostring(result)))
	return fallbackModule
end

local function maybeNotifyLoaderFallback()
	if loaderDiagnostics.notified or #loaderDiagnostics.optionalFailed == 0 then
		return
	end
	loaderDiagnostics.notified = true
	local moduleNames = {}
	for _, item in ipairs(loaderDiagnostics.optionalFailed) do
		table.insert(moduleNames, tostring(item.module))
	end
	local message = "Loaded with fallback modules: " .. table.concat(moduleNames, ", ")
	if type(RayfieldLibrary.Notify) == "function" then
		pcall(function()
			RayfieldLibrary:Notify({
				Title = "Rayfield Loader",
				Content = message,
				Duration = 8
			})
		end)
	else
		warn(formatLoaderError("W_OPTIONAL_MODULE", message))
	end
end

local FallbackElementSyncModule = {
	init = function()
		return nil
	end
}

local FallbackOwnershipTrackerModule = {
	init = function()
		local function noopReturnFalse()
			return false
		end
		local function noopReturnNil()
			return nil
		end
		return {
			createScope = function(scopeId)
				return tostring(scopeId or "")
			end,
			makeScopeId = function(kind, id)
				return tostring(kind or "scope") .. ":" .. tostring(id or "")
			end,
			claimInstance = noopReturnFalse,
			trackConnection = noopReturnFalse,
			trackTask = noopReturnFalse,
			trackCleanup = noopReturnFalse,
			cleanupScope = noopReturnFalse,
			cleanupByInstance = noopReturnFalse,
			cleanupSession = noopReturnFalse,
			getStats = function()
				return {
					scopes = 0,
					instances = 0,
					connections = 0,
					tasks = 0,
					cleanups = 0
				}
			end,
			getSignature = noopReturnNil
		}
	end
}

local FallbackDragModule = {
	init = function()
		local function noop() end
		return {
			makeElementDetachable = function()
				return nil
			end,
			setLayoutDirtyCallback = noop,
			getLayoutSnapshot = function()
				return {}
			end,
			applyLayoutSnapshot = function()
				return false
			end
		}
	end
}

local FallbackTabSplitModule = {
	init = function()
		local function noop() end
		return {
			registerTab = noop,
			unregisterTab = noop,
			splitTab = function() return false end,
			dockTab = function() return false end,
			layoutPanels = noop,
			syncHidden = noop,
			syncMinimized = noop,
			setLayoutDirtyCallback = noop,
			getLayoutSnapshot = function() return {} end,
			applyLayoutSnapshot = function() return false end,
			destroy = noop
		}
	end
}

local FallbackLayoutPersistenceModule = {
	init = function()
		local function noop() end
		return {
			registerProvider = noop,
			unregisterProvider = noop,
			getLayoutSnapshot = function() return nil end,
			applyLayoutSnapshot = function() return false end,
			markDirty = noop,
			flush = noop,
			isApplying = function() return false end,
			isDirty = function() return false end
		}
	end
}

local FallbackViewportVirtualizationModule = {
	init = function()
		local function noopReturnFalse()
			return false
		end
		local function noopReturnNil()
			return nil
		end
		return {
			registerHost = noopReturnFalse,
			unregisterHost = noopReturnFalse,
			refreshHost = noopReturnFalse,
			setHostSuppressed = noopReturnFalse,
			registerElement = noopReturnNil,
			unregisterElement = noopReturnFalse,
			moveElementToHost = noopReturnFalse,
			setElementBusy = noopReturnFalse,
			notifyElementHostChanged = noopReturnFalse,
			getStats = function()
				return {
					hosts = 0,
					elements = 0,
					sleeping = 0
				}
			end,
			destroy = function() end
		}
	end
}

local ThemeModule = requireModule("theme")
-- Load utilities early so shared helpers are registered globally before other services initialize.
local UtilitiesModuleLib = requireModule("utilities")
local SettingsModuleLib = requireModule("settings")
local OwnershipTrackerModuleLib = optionalModule("ownershipTracker", FallbackOwnershipTrackerModule, "Scoped ownership cleanup will run in compatibility mode.")
local ElementSyncModuleLib = optionalModule("elementSync", FallbackElementSyncModule, "Element state sync will run in compatibility mode.")
local KeybindSequenceLib = requireModule("keybindSequence")
local DragModuleLib = optionalModule("drag", FallbackDragModule, "Detach/reorder advanced drag features are disabled for this session.")
local UIStateModuleLib = requireModule("uiState")
local ElementsModuleLib = requireModule("elements")
local ConfigModuleLib = requireModule("config")
local LayoutPersistenceModuleLib = optionalModule("layoutPersistence", FallbackLayoutPersistenceModule, "Layout persistence is disabled for this session.")
local ViewportVirtualizationModuleLib = optionalModule("viewportVirtualization", FallbackViewportVirtualizationModule, "Viewport virtualization is disabled for this session.")
local TabSplitModuleLib = optionalModule("tabSplit", FallbackTabSplitModule, "Tab split features are disabled for this session.")
local AnimationEngineLib = requireModule("animationEngine")
local AnimationPublicLib = requireModule("animationPublic")
local AnimationSequenceLib = requireModule("animationSequence")
local AnimationUILib = requireModule("animationUI")
local AnimationTextLib = requireModule("animationText")
local AnimationCleanupLib = requireModule("animationCleanup")

-- Services
local UserInputService = getService("UserInputService")
local TweenService = getService("TweenService")
local Players = getService("Players")
local CoreGui = getService("CoreGui")

local AnimationEngine = AnimationEngineLib.new({
	TweenService = TweenService,
	RunService = RunService,
	Cleanup = AnimationCleanupLib,
	mode = "raw"
})
local Animation = AnimationEngine
local RayfieldAnimate = AnimationPublicLib.bindToRayfield(RayfieldLibrary, AnimationEngine, {
	Sequence = AnimationSequenceLib,
	UI = AnimationUILib,
	Text = AnimationTextLib
})
if _G then
	_G.__RayfieldSharedAnimationEngine = AnimationEngine
	_G.__RayfieldSharedAnimateFacade = RayfieldAnimate
end

-- Interface Management

local Rayfield
if useStudio then
	Rayfield = script.Parent:FindFirstChild('Rayfield')
else
	-- Try to load GUI from Roblox asset
	local success, result = pcall(function()
		return game:GetObjects("rbxassetid://10804731440")[1]
	end)

	if success and result then
		Rayfield = result
	else
		-- Fallback: Some executors don't support game:GetObjects()
		warn("Rayfield | game:GetObjects() failed. Your executor may not support loading GUI assets.")
		warn("Rayfield | Error: " .. tostring(result))
		error("Unable to load Rayfield GUI. Your executor may not support game:GetObjects(). Try using a different executor or loading from a local file.")
	end
end

if not Rayfield then
	error("Rayfield GUI failed to load. Please check your executor compatibility.")
end

local buildAttempts = 0
local correctBuild = false
local warned
local globalLoaded
local rayfieldDestroyed = false -- True when RayfieldLibrary:Destroy() is called

repeat
	if Rayfield:FindFirstChild('Build') and Rayfield.Build.Value == InterfaceBuild then
		correctBuild = true
		break
	end

	correctBuild = false

	if not warned then
		warn('Rayfield | Build Mismatch')
		print('Rayfield may encounter issues as you are running an incompatible interface version ('.. ((Rayfield:FindFirstChild('Build') and Rayfield.Build.Value) or 'No Build') ..').\n\nThis version of Rayfield is intended for interface build '..InterfaceBuild..'.')
		warned = true
	end

	local oldRayfield = Rayfield
	if useStudio then
		Rayfield = script.Parent:FindFirstChild('Rayfield')
	else
		local success, result = pcall(function()
			return game:GetObjects("rbxassetid://10804731440")[1]
		end)
		if success and result then
			Rayfield = result
		else
			warn("Rayfield | Failed to reload GUI on retry: " .. tostring(result))
			break
		end
	end

	if oldRayfield and not useStudio then
		oldRayfield:Destroy()
	end

	buildAttempts = buildAttempts + 1
until buildAttempts >= 2

Rayfield.Enabled = false

local rayfieldContainer = nil
if Compatibility and type(Compatibility.protectAndParent) == "function" then
	rayfieldContainer = Compatibility.protectAndParent(Rayfield, nil, {
		useStudio = useStudio
	})
elseif not useStudio then
	Rayfield.Parent = CoreGui
	rayfieldContainer = CoreGui
end

if Compatibility and type(Compatibility.dedupeGuiByName) == "function" then
	Compatibility.dedupeGuiByName(rayfieldContainer, Rayfield.Name, Rayfield, "-Old")
elseif not useStudio and rayfieldContainer then
	for _, Interface in ipairs(rayfieldContainer:GetChildren()) do
		if Interface.Name == Rayfield.Name and Interface ~= Rayfield then
			Interface.Enabled = false
			Interface.Name = "Rayfield-Old"
		end
	end
end


local minSize = Vector2.new(1024, 768)
local useMobileSizing
local useMobilePrompt = false

if Rayfield.AbsoluteSize.X < minSize.X and Rayfield.AbsoluteSize.Y < minSize.Y then
	useMobileSizing = true
end

if UserInputService.TouchEnabled then
	useMobilePrompt = true
end


-- Object Variables

local Main = Rayfield.Main
if not Main then
	error("Rayfield GUI structure error: Main container not found. The GUI asset may be corrupted or incompatible.")
end

local MPrompt = Rayfield:FindFirstChild('Prompt')
local Topbar = Main.Topbar
local Elements = Main.Elements
local LoadingFrame = Main.LoadingFrame
local TabList = Main.TabList

-- Validate critical GUI components
if not Elements then
	error("Rayfield GUI structure error: Elements container not found. The GUI asset may be corrupted.")
end
if not Elements:FindFirstChild('Template') then
	error("Rayfield GUI structure error: Elements.Template not found. The GUI asset may be corrupted.")
end
if not TabList then
	error("Rayfield GUI structure error: TabList container not found. The GUI asset may be corrupted.")
end

local dragBar = Rayfield:FindFirstChild('Drag')
local dragInteract = dragBar and dragBar.Interact or nil
local dragBarCosmetic = dragBar and dragBar.Drag or nil

local dragOffset = 255
local dragOffsetMobile = 150

Rayfield.DisplayOrder = 100
LoadingFrame.Version.Text = Release

-- Thanks to Latte Softworks for the Lucide integration for Roblox
local Icons = useStudio and require(script.Parent.icons) or loadWithTimeout('https://raw.githubusercontent.com/SiriusSoftwareLtd/Rayfield/refs/heads/main/icons.lua')

-- Variables
local CFileName = nil
local CEnabled = false
local Minimised = false
local Hidden = false
local Debounce = false
local searchOpen = false
local Notifications = Rayfield.Notifications
local ElementsSystem = nil
local ElementSyncSystem = nil
local OwnershipSystem = nil
local keybindConnections = {} -- For storing keybind connections to disconnect when Rayfield is destroyed
local layoutConnections = {}
local LayoutPersistenceSystem = nil
local ViewportVirtualizationSystem = nil
local layoutSavingEnabled = false
local layoutDebounceMs = 300
local detachPathEnabled = true
local activePerformanceProfile = {
	enabled = false,
	requestedMode = "normal",
	resolvedMode = "normal",
	aggressive = false,
	disableDetach = false,
	disableTabSplit = false,
	disableAnimations = false,
	appliedFields = {}
}
local ExperienceState = {
	uiPreset = "Comfort",
	transitionProfile = "Smooth",
	onboardingSuppressed = false,
	favoritesTab = nil,
	favoritesTabWindow = nil,
	onboardingOverlay = nil,
	onboardingRendered = false,
	themeStudioState = {
		baseTheme = "Default",
		useCustom = false,
		customThemePacked = {}
	}
}
local experienceSuppressPromoPrompts = false
local favoritesRegistryUnsubscribe = nil
local uiToggleKeybindMatcher = KeybindSequenceLib.newMatcher({
	maxSteps = 4,
	stepTimeoutMs = 800
})
local cachedUiToggleKeybindRaw = nil
local cachedUiToggleKeybindSpec = nil

local function initializeOwnershipTracking()
	local okInit, trackerOrErr = pcall(OwnershipTrackerModuleLib.init, {
		owner = "rayfield-mod",
		scopePrefix = "rayfield",
		HttpService = HttpService,
		getRootGui = function()
			return Rayfield
		end
	})
	if not okInit or type(trackerOrErr) ~= "table" then
		warn("Rayfield Mod: [W_OWNERSHIP_INIT] Failed to initialize ownership tracker: " .. tostring(trackerOrErr))
		return nil
	end

	local tracker = trackerOrErr
	local runtimeScope = "runtime:root"
	local hotkeyScope = "runtime:hotkeys"
	local layoutScope = "runtime:layout"

	if type(tracker.createScope) == "function" then
		pcall(tracker.createScope, runtimeScope, {
			kind = "runtime"
		})
		pcall(tracker.createScope, hotkeyScope, {
			kind = "runtime_hotkeys"
		})
		pcall(tracker.createScope, layoutScope, {
			kind = "runtime_layout"
		})
	end
	if type(tracker.claimInstance) == "function" then
		pcall(tracker.claimInstance, Rayfield, runtimeScope, { node = "RayfieldRoot" })
		pcall(tracker.claimInstance, Main, runtimeScope, { node = "Main" })
		pcall(tracker.claimInstance, Topbar, runtimeScope, { node = "Topbar" })
		pcall(tracker.claimInstance, Elements, runtimeScope, { node = "Elements" })
		pcall(tracker.claimInstance, TabList, runtimeScope, { node = "TabList" })
		pcall(tracker.claimInstance, Notifications, runtimeScope, { node = "Notifications" })
	end

	if _G then
		_G.__RayfieldOwnership = tracker
	end
	return tracker
end

OwnershipSystem = initializeOwnershipTracking()

local function resolveUiToggleKeybindSpec(rawBinding)
	if rawBinding == cachedUiToggleKeybindRaw and cachedUiToggleKeybindSpec then
		return cachedUiToggleKeybindSpec
	end

	local canonical, steps = KeybindSequenceLib.normalize(rawBinding, {
		maxSteps = 4
	})
	if not canonical then
		cachedUiToggleKeybindRaw = nil
		cachedUiToggleKeybindSpec = nil
		return nil
	end

	cachedUiToggleKeybindRaw = rawBinding
	cachedUiToggleKeybindSpec = {
		canonical = canonical,
		steps = steps
	}
	return cachedUiToggleKeybindSpec
end

local function cleanupLayoutConnections()
	for _, connection in ipairs(layoutConnections) do
		if connection then
			connection:Disconnect()
		end
	end
	table.clear(layoutConnections)
end

local function markLayoutDirty(scope, reason)
	if LayoutPersistenceSystem and type(LayoutPersistenceSystem.markDirty) == "function" then
		LayoutPersistenceSystem.markDirty((scope or "layout") .. ":" .. (reason or "update"))
	end
end

AnimationEngine:SetUiSuppressionProvider(function()
	return Hidden == true or Minimised == true or rayfieldDestroyed == true
end)

-- Initialize Theme Module
local ThemeSystem = ThemeModule.init({
	Rayfield = Rayfield,
	Main = Main,
	Topbar = Topbar,
	Elements = Elements,
	Notifications = Notifications,
	Icons = Icons
})

local bindTheme = ThemeSystem.bindTheme

-- Apply Reactive Theme to Main UI (with nil guards for UI structure resilience)
bindTheme(Main, "BackgroundColor3", "Background")
bindTheme(Topbar, "BackgroundColor3", "Topbar")

local cornerRepair = Topbar:FindFirstChild("CornerRepair")
if cornerRepair then
	bindTheme(cornerRepair, "BackgroundColor3", "Topbar")
end

local shadow = Main:FindFirstChild("Shadow")
if shadow and shadow:FindFirstChild("Image") then
	bindTheme(shadow.Image, "ImageColor3", "Shadow")
end

if Topbar:FindFirstChild("ChangeSize") then
	bindTheme(Topbar.ChangeSize, "ImageColor3", "TextColor")
end
if Topbar:FindFirstChild("Hide") then
	bindTheme(Topbar.Hide, "ImageColor3", "TextColor")
end
if Topbar:FindFirstChild("Search") then
	bindTheme(Topbar.Search, "ImageColor3", "TextColor")
end

if Topbar:FindFirstChild('Settings') then
	bindTheme(Topbar.Settings, "ImageColor3", "TextColor")
	if Topbar:FindFirstChild('Divider') then
		bindTheme(Topbar.Divider, "BackgroundColor3", "ElementStroke")
	end
end

-- Search UI Reactive (guarded)
local searchFrame = Main:FindFirstChild("Search")
if searchFrame then
	bindTheme(searchFrame, "BackgroundColor3", "TextColor")
	if searchFrame:FindFirstChild("Shadow") then
		bindTheme(searchFrame.Shadow, "ImageColor3", "TextColor")
	end
	if searchFrame:FindFirstChild("Search") then
		bindTheme(searchFrame.Search, "ImageColor3", "TextColor")
	end
	if searchFrame:FindFirstChild("Input") then
		bindTheme(searchFrame.Input, "PlaceholderColor3", "TextColor")
	end
	if searchFrame:FindFirstChild("UIStroke") then
		bindTheme(searchFrame.UIStroke, "Color", "SecondaryElementStroke")
	end
end

-- Initialize Settings Module
local SettingsSystem = SettingsModuleLib.init({
	RayfieldFolder = RayfieldFolder,
	ConfigurationExtension = ConfigurationExtension,
	HttpService = HttpService,
	useStudio = useStudio,
	callSafely = callSafely,
	Topbar = Topbar,
	TabList = TabList,
	Elements = Elements
})

-- Initialize Configuration Module
local ConfigSystem = ConfigModuleLib.init({
	HttpService = HttpService,
	TweenService = TweenService,
	Animation = Animation,
	RayfieldLibrary = RayfieldLibrary,
	callSafely = callSafely,
	ConfigurationFolder = ConfigurationFolder,
	ConfigurationExtension = ConfigurationExtension,
	getCFileName = function() return CFileName end,
	getCEnabled = function() return CEnabled end,
	getGlobalLoaded = function() return globalLoaded end,
	getLayoutSnapshot = function()
		if LayoutPersistenceSystem and type(LayoutPersistenceSystem.getLayoutSnapshot) == "function" then
			return LayoutPersistenceSystem.getLayoutSnapshot()
		end
		return nil
	end,
	applyLayoutSnapshot = function(layoutData)
		if LayoutPersistenceSystem and type(LayoutPersistenceSystem.applyLayoutSnapshot) == "function" then
			return LayoutPersistenceSystem.applyLayoutSnapshot(layoutData)
		end
		return false
	end,
	getElementsSystem = function()
		return ElementsSystem
	end,
	layoutKey = "__rayfield_layout",
	useStudio = useStudio,
	debugX = debugX
})

-- Initialize Utilities Module (will be fully initialized after UI elements are created)
local UtilitiesSystem = nil -- Initialized later after UI elements exist

-- Expose theme definitions to RayfieldLibrary
RayfieldLibrary.Theme = ThemeModule.Themes

-- Use theme system's selected theme
local SelectedTheme = ThemeSystem.SelectedTheme

-- Theme helpers
local function ChangeTheme(Theme)
	ThemeSystem.ChangeTheme(Theme)
	SelectedTheme = ThemeSystem.SelectedTheme
end

local function getIcon(name)
	return ThemeSystem.getIcon(name)
end

-- Settings wrapper functions
local function getSetting(category, name)
	return SettingsSystem.getSetting(category, name)
end

local function overrideSetting(category, name, value)
	return SettingsSystem.overrideSetting(category, name, value)
end

local function saveSettings()
	return SettingsSystem.saveSettings()
end

local function updateSetting(category, setting, value)
	return SettingsSystem.updateSetting(category, setting, value)
end

local function setSettingValue(category, setting, value, persist)
	if SettingsSystem and type(SettingsSystem.setSettingValue) == "function" then
		return SettingsSystem.setSettingValue(category, setting, value, persist)
	end
	return false, "Settings system unavailable."
end

local function loadSettings()
	return SettingsSystem.loadSettings()
end

local function createSettings(window)
	return SettingsSystem.createSettings(window)
end

-- Local settings references
local settingsTable = SettingsSystem.settingsTable
local settingsCreated = SettingsSystem.settingsCreated
local settingsInitialized = SettingsSystem.settingsInitialized
local overriddenSettings = SettingsSystem.overriddenSettings
local cachedSettings = SettingsSystem.cachedSettings

-- Call initial loadSettings
loadSettings()

-- If requests/analytics have been disabled by developer, set the user-facing setting to false as well
if requestsDisabled then
	overrideSetting("System", "usageAnalytics", false)
end

-- Initialize Drag Module
local DragSystem = DragModuleLib.init({
	UserInputService = UserInputService,
	TweenService = TweenService,
	Animation = Animation,
	RunService = RunService,
	HttpService = HttpService,
	Main = Main,
	Topbar = Topbar,
	Elements = Elements,
	Rayfield = Rayfield,
	Icons = Icons,
	getIcon = getIcon,
	getAssetUri = getAssetUri,
	getSelectedTheme = function() return SelectedTheme end,
	getSetting = getSetting,
	useMobileSizing = useMobileSizing,
	getDetachEnabled = function()
		return detachPathEnabled
	end,
	rayfieldDestroyed = function() return rayfieldDestroyed end,
	onLayoutDirty = function(scope, reason)
		markLayoutDirty(scope, reason)
	end,
	getViewportVirtualization = function()
		return ViewportVirtualizationSystem
	end,
	ElementSync = {
		resync = function(token, reason)
			if ElementSyncSystem and type(ElementSyncSystem.resync) == "function" then
				return ElementSyncSystem.resync(token, reason)
			end
			return false
		end
	}
})

-- Detach helper wrapper
local function makeElementDetachable(guiObject, elementName, elementType)
	if detachPathEnabled == false then
		return nil
	end
	return DragSystem.makeElementDetachable(guiObject, elementName, elementType)
end

-- Initialize UI State Module
local UIStateSystem = UIStateModuleLib.init({
	TweenService = TweenService,
	Animation = Animation,
	Main = Main,
	Topbar = Topbar,
	TabList = TabList,
	Elements = Elements,
	Notifications = Notifications,
	MPrompt = MPrompt,
	dragInteract = dragInteract,
	dragBarCosmetic = dragBarCosmetic,
	dragBar = dragBar,
	dragOffset = dragOffset,
	dragOffsetMobile = dragOffsetMobile,
	getIcon = getIcon,
	getAssetUri = getAssetUri,
	getSelectedTheme = function() return SelectedTheme end,
	rayfieldDestroyed = function() return rayfieldDestroyed end,
	getSetting = getSetting,
	useMobileSizing = useMobileSizing,
	useMobilePrompt = useMobilePrompt
})

local TabSplitSystem = nil

-- Wrapper functions for UI State
local function openSearch()
	UIStateSystem.openSearch()
	searchOpen = UIStateSystem.getSearchOpen()
end

local function closeSearch()
	UIStateSystem.closeSearch()
	searchOpen = UIStateSystem.getSearchOpen()
end

local function Hide(notify)
	UIStateSystem.Hide(notify)
	Hidden = UIStateSystem.getHidden()
	Debounce = UIStateSystem.getDebounce()
	AnimationEngine:SetUiSuppressed(Hidden or Minimised or rayfieldDestroyed)
	if TabSplitSystem then
		TabSplitSystem.syncHidden(Hidden)
		TabSplitSystem.syncMinimized(Minimised)
	end
	markLayoutDirty("main", "hide")
end

local function Unhide()
	UIStateSystem.Unhide()
	Hidden = UIStateSystem.getHidden()
	Minimised = UIStateSystem.getMinimised()
	Debounce = UIStateSystem.getDebounce()
	AnimationEngine:SetUiSuppressed(Hidden or Minimised or rayfieldDestroyed)
	if TabSplitSystem then
		TabSplitSystem.syncHidden(Hidden)
		TabSplitSystem.syncMinimized(Minimised)
	end
	markLayoutDirty("main", "unhide")
end

local function Maximise()
	UIStateSystem.Maximise()
	Minimised = UIStateSystem.getMinimised()
	Debounce = UIStateSystem.getDebounce()
	AnimationEngine:SetUiSuppressed(Hidden or Minimised or rayfieldDestroyed)
	if TabSplitSystem then
		TabSplitSystem.syncMinimized(Minimised)
	end
	markLayoutDirty("main", "maximise")
end

local function Minimise()
	UIStateSystem.Minimise()
	Minimised = UIStateSystem.getMinimised()
	Debounce = UIStateSystem.getDebounce()
	AnimationEngine:SetUiSuppressed(Hidden or Minimised or rayfieldDestroyed)
	if TabSplitSystem then
		TabSplitSystem.syncMinimized(Minimised)
	end
	markLayoutDirty("main", "minimise")
end

-- Converts ID to asset URI. Returns rbxassetid://0 if ID is not a number
local function getAssetUri(id: any): string
	return UtilitiesSystem and UtilitiesSystem.getAssetUri(id, Icons) or ("rbxassetid://" .. (type(id) == "number" and id or 0))
end

local function makeDraggable(object, dragObject, enableTaptic, tapticOffset)
	if UtilitiesSystem then
		UtilitiesSystem.makeDraggable(object, dragObject, enableTaptic, tapticOffset)
	else
		warn("Rayfield | UtilitiesSystem not initialized yet")
	end
end

-- Note: Old makeDraggable implementation moved to rayfield-utilities.lua module

-- Note: Drag/Detach system code has been moved to rayfield-drag.lua module

-- Configuration wrapper functions
local function PackColor(Color)
	return ConfigSystem.PackColor(Color)
end

local function UnpackColor(Color)
	return ConfigSystem.UnpackColor(Color)
end

local function LoadConfiguration(Configuration)
	return ConfigSystem.LoadConfiguration(Configuration)
end

local function SaveConfiguration()
	return ConfigSystem.SaveConfiguration()
end

local SHARE_CODE_PREFIX = "RFSC1:"
local SHARE_PAYLOAD_VERSION = 1
local SHARE_PAYLOAD_TYPE = "rayfield_share"
local BASE64_ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"

local activeShareCode = ""
local activeSharePayload = nil

local function trimString(value)
	value = tostring(value or "")
	value = value:gsub("^%s+", "")
	value = value:gsub("%s+$", "")
	return value
end

local function fallbackBase64Encode(input)
	local source = tostring(input or "")
	local bits = source:gsub(".", function(character)
		local byteValue = string.byte(character)
		local chunk = ""
		for index = 8, 1, -1 do
			if byteValue % (2 ^ index) - byteValue % (2 ^ (index - 1)) > 0 then
				chunk = chunk .. "1"
			else
				chunk = chunk .. "0"
			end
		end
		return chunk
	end)

	local paddedBits = bits .. "0000"
	local encoded = paddedBits:gsub("%d%d%d?%d?%d?%d?", function(chunk)
		if #chunk < 6 then
			return ""
		end
		local value = 0
		for index = 1, 6 do
			if chunk:sub(index, index) == "1" then
				value += 2 ^ (6 - index)
			end
		end
		return BASE64_ALPHABET:sub(value + 1, value + 1)
	end)

	return encoded .. ({ "", "==", "=" })[#source % 3 + 1]
end

local function fallbackBase64Decode(input)
	local source = tostring(input or "")
	source = source:gsub("%s+", "")
	source = source:gsub("[^" .. BASE64_ALPHABET .. "=]", "")

	local bits = source:gsub(".", function(character)
		if character == "=" then
			return ""
		end
		local index = BASE64_ALPHABET:find(character, 1, true)
		if not index then
			return ""
		end
		local value = index - 1
		local chunk = ""
		for bit = 6, 1, -1 do
			if value % (2 ^ bit) - value % (2 ^ (bit - 1)) > 0 then
				chunk = chunk .. "1"
			else
				chunk = chunk .. "0"
			end
		end
		return chunk
	end)

	return bits:gsub("%d%d%d?%d?%d?%d?%d?%d?", function(chunk)
		if #chunk ~= 8 then
			return ""
		end
		local value = 0
		for index = 1, 8 do
			if chunk:sub(index, index) == "1" then
				value += 2 ^ (8 - index)
			end
		end
		return string.char(value)
	end)
end

local function encodeBase64(input)
	if HttpService and type(HttpService.Base64Encode) == "function" then
		local okEncoded, encoded = pcall(HttpService.Base64Encode, HttpService, input)
		if okEncoded and type(encoded) == "string" then
			return true, encoded
		end
	end

	local okFallback, encoded = pcall(fallbackBase64Encode, input)
	if not okFallback then
		return false, tostring(encoded)
	end
	return true, encoded
end

local function decodeBase64(input)
	if HttpService and type(HttpService.Base64Decode) == "function" then
		local okDecoded, decoded = pcall(HttpService.Base64Decode, HttpService, input)
		if okDecoded and type(decoded) == "string" then
			return true, decoded
		end
	end

	local okFallback, decoded = pcall(fallbackBase64Decode, input)
	if not okFallback then
		return false, tostring(decoded)
	end
	return true, decoded
end

local function buildGeneratedAtStamp()
	local okDate, value = pcall(function()
		return os.date("!%Y-%m-%dT%H:%M:%SZ")
	end)
	if okDate and type(value) == "string" then
		return value
	end
	local okTick, tickValue = pcall(function()
		return tostring(math.floor((tick and tick() or 0) * 1000))
	end)
	if okTick and type(tickValue) == "string" then
		return tickValue
	end
	return "unknown"
end

local function validateSharePayload(payload)
	if type(payload) ~= "table" then
		return false, "Share code payload is invalid."
	end
	if payload.type ~= SHARE_PAYLOAD_TYPE then
		return false, "Share code payload type is invalid."
	end
	if tonumber(payload.version) ~= SHARE_PAYLOAD_VERSION then
		return false, "Share code version is unsupported."
	end
	if type(payload.configuration) ~= "table" then
		return false, "Share code is missing configuration data."
	end
	if type(payload.internalSettings) ~= "table" then
		return false, "Share code is missing internal settings data."
	end
	return true
end

local function setActiveSharePayload(code, payload)
	activeShareCode = tostring(code or "")
	activeSharePayload = payload
	if SettingsSystem and type(SettingsSystem.setShareCodeInputValue) == "function" then
		pcall(SettingsSystem.setShareCodeInputValue, activeShareCode)
	end
end

local function encodeSharePayload(payload)
	local okJson, jsonOrErr = pcall(function()
		return HttpService:JSONEncode(payload)
	end)
	if not okJson or type(jsonOrErr) ~= "string" then
		return nil, "Failed to encode share payload."
	end

	local okBase64, encodedOrErr = encodeBase64(jsonOrErr)
	if not okBase64 then
		return nil, "Failed to encode share payload as Base64."
	end

	return SHARE_CODE_PREFIX .. encodedOrErr
end

local function decodeShareCode(code)
	local normalized = trimString(code)
	if normalized == "" then
		return false, "Share code cannot be empty."
	end
	if normalized:sub(1, #SHARE_CODE_PREFIX) ~= SHARE_CODE_PREFIX then
		return false, "Share code prefix is invalid."
	end

	local encodedBody = normalized:sub(#SHARE_CODE_PREFIX + 1):gsub("%s+", "")
	if encodedBody == "" then
		return false, "Share code payload is empty."
	end

	local okDecode, decodedOrErr = decodeBase64(encodedBody)
	if not okDecode or type(decodedOrErr) ~= "string" then
		return false, "Share code Base64 payload is invalid."
	end

	local okJson, payloadOrErr = pcall(function()
		return HttpService:JSONDecode(decodedOrErr)
	end)
	if not okJson or type(payloadOrErr) ~= "table" then
		return false, "Share code JSON payload is invalid."
	end

	return true, SHARE_CODE_PREFIX .. encodedBody, payloadOrErr
end

local function notifyShareCodeStatus(success, message)
	if not UIStateSystem or type(UIStateSystem.Notify) ~= "function" then
		return
	end
	local content = tostring(message or "")
	if content == "" then
		if success then
			content = "Share code operation completed."
		else
			content = "Share code operation failed."
		end
	end
	pcall(UIStateSystem.Notify, {
		Title = "Rayfield Share Code",
		Content = content,
		Image = success and 4483362458 or 4384402990
	})
end

function RayfieldLibrary:ImportCode(code)
	local okDecode, canonicalOrMessage, payload = decodeShareCode(code)
	if not okDecode then
		return false, tostring(canonicalOrMessage)
	end

	local validPayload, payloadMessage = validateSharePayload(payload)
	if not validPayload then
		return false, tostring(payloadMessage)
	end

	setActiveSharePayload(canonicalOrMessage, payload)
	return true, "Share code imported."
end

function RayfieldLibrary:ImportSettings()
	if type(activeSharePayload) ~= "table" then
		return false, "No active share code. Import code first."
	end

	local validPayload, payloadMessage = validateSharePayload(activeSharePayload)
	if not validPayload then
		return false, tostring(payloadMessage)
	end

	if not ConfigSystem or type(ConfigSystem.ImportConfigurationData) ~= "function" then
		return false, "Configuration import is unavailable."
	end
	if not SettingsSystem or type(SettingsSystem.ImportInternalSettingsData) ~= "function" then
		return false, "Internal settings import is unavailable."
	end

	local okConfig, configSuccess, configDetail = pcall(ConfigSystem.ImportConfigurationData, activeSharePayload.configuration)
	if not okConfig then
		return false, "Failed to apply configuration data: " .. tostring(configSuccess)
	end
	if configSuccess ~= true then
		return false, tostring(configDetail or "Failed to apply configuration data.")
	end

	local okInternal, internalSuccess, internalDetail = pcall(SettingsSystem.ImportInternalSettingsData, activeSharePayload.internalSettings)
	if not okInternal then
		return false, "Failed to apply internal settings: " .. tostring(internalSuccess)
	end
	if internalSuccess ~= true then
		return false, tostring(internalDetail or "Failed to apply internal settings.")
	end

	local persistenceWarnings = {}
	if ConfigSystem and type(ConfigSystem.SaveConfigurationForced) == "function" then
		local okPersistConfig, persistedConfig = pcall(ConfigSystem.SaveConfigurationForced)
		if not okPersistConfig or persistedConfig == false then
			table.insert(persistenceWarnings, "configuration")
		end
	end

	if SettingsSystem and type(SettingsSystem.saveSettings) == "function" then
		local okPersistSettings, persistedSettings = pcall(SettingsSystem.saveSettings)
		if not okPersistSettings or persistedSettings == false then
			table.insert(persistenceWarnings, "internal settings")
		end
	end

	if #persistenceWarnings > 0 then
		return true, "Share settings applied, but persistence failed for: " .. table.concat(persistenceWarnings, ", ") .. "."
	end

	local changedConfiguration = configDetail == true
	local appliedInternalCount = tonumber(internalDetail) or 0
	if changedConfiguration or appliedInternalCount > 0 then
		return true, "Share settings applied."
	end

	return true, "Share settings were already up to date."
end

function RayfieldLibrary:ExportSettings()
	if not ConfigSystem or type(ConfigSystem.ExportConfigurationData) ~= "function" then
		return nil, "Configuration export is unavailable."
	end
	if not SettingsSystem or type(SettingsSystem.ExportInternalSettingsData) ~= "function" then
		return nil, "Internal settings export is unavailable."
	end

	local okConfig, configurationData = pcall(ConfigSystem.ExportConfigurationData)
	if not okConfig or type(configurationData) ~= "table" then
		return nil, "Failed to collect configuration data."
	end

	local okSettings, internalSettingsData = pcall(SettingsSystem.ExportInternalSettingsData)
	if not okSettings or type(internalSettingsData) ~= "table" then
		return nil, "Failed to collect internal settings data."
	end

	local payload = {
		type = SHARE_PAYLOAD_TYPE,
		version = SHARE_PAYLOAD_VERSION,
		configuration = configurationData,
		internalSettings = internalSettingsData,
		meta = {
			generatedAt = buildGeneratedAtStamp(),
			interfaceBuild = InterfaceBuild,
			release = Release
		}
	}

	local encodedCode, encodedErr = encodeSharePayload(payload)
	if type(encodedCode) ~= "string" then
		return nil, tostring(encodedErr or "Failed to export share code.")
	end

	setActiveSharePayload(encodedCode, payload)
	return encodedCode, "ok"
end

function RayfieldLibrary:CopyShareCode(suppressNotify)
	local shouldNotify = suppressNotify ~= true

	if type(activeShareCode) ~= "string" or activeShareCode == "" then
		local message = "No active share code. Export or import a code first."
		if shouldNotify then
			notifyShareCodeStatus(false, message)
		end
		return false, message
	end

	local clipboardWriter = nil
	if type(setclipboard) == "function" then
		clipboardWriter = setclipboard
	elseif type(toclipboard) == "function" then
		clipboardWriter = toclipboard
	end

	if type(clipboardWriter) ~= "function" then
		if SettingsSystem and type(SettingsSystem.setShareCodeInputValue) == "function" then
			pcall(SettingsSystem.setShareCodeInputValue, activeShareCode)
		end
		local message = "Clipboard is unavailable. Share code was placed in the Share Code input."
		if shouldNotify then
			notifyShareCodeStatus(false, message)
		end
		return false, message
	end

	local okCopy, copyErr = pcall(clipboardWriter, activeShareCode)
	if not okCopy then
		if SettingsSystem and type(SettingsSystem.setShareCodeInputValue) == "function" then
			pcall(SettingsSystem.setShareCodeInputValue, activeShareCode)
		end
		local message = "Failed to copy share code: " .. tostring(copyErr)
		if shouldNotify then
			notifyShareCodeStatus(false, message)
		end
		return false, message
	end

	local message = "Share code copied to clipboard."
	if shouldNotify then
		notifyShareCodeStatus(true, message)
	end
	return true, message
end

if SettingsSystem and type(SettingsSystem.setShareCodeHandlers) == "function" then
	SettingsSystem.setShareCodeHandlers({
		importCode = function(code)
			local ok, message = RayfieldLibrary:ImportCode(code)
			return ok, message
		end,
		importSettings = function()
			local ok, message = RayfieldLibrary:ImportSettings()
			return ok, message
		end,
		exportSettings = function()
			local code, message = RayfieldLibrary:ExportSettings()
			return code, message
		end,
		copyShareCode = function()
			local ok, message = RayfieldLibrary:CopyShareCode(true)
			return ok, message
		end,
		getActiveShareCode = function()
			return activeShareCode
		end,
		notify = function(success, message)
			notifyShareCodeStatus(success == true, message)
		end
	})
end

local UI_PRESET_NAMES = {
	Compact = true,
	Comfort = true,
	Focus = true
}
local TRANSITION_PROFILE_NAMES = {
	Minimal = true,
	Smooth = true,
	Snappy = true,
	Off = true
}
local THEME_STUDIO_KEYS = {}
for themeKey in pairs(ThemeModule.Themes.Default or {}) do
	table.insert(THEME_STUDIO_KEYS, themeKey)
end
table.sort(THEME_STUDIO_KEYS)

local function cloneValue(value)
	if type(value) ~= "table" then
		return value
	end
	local out = {}
	for key, nested in pairs(value) do
		out[cloneValue(key)] = cloneValue(nested)
	end
	return out
end

local function cloneArray(values)
	local out = {}
	if type(values) ~= "table" then
		return out
	end
	for index, value in ipairs(values) do
		out[index] = value
	end
	return out
end

local function normalizePresetName(name)
	if type(name) ~= "string" then
		return nil
	end
	local normalized = string.lower(name)
	if normalized == "compact" then
		return "Compact"
	elseif normalized == "comfort" then
		return "Comfort"
	elseif normalized == "focus" then
		return "Focus"
	end
	return nil
end

local function normalizeTransitionProfileName(name)
	if type(name) ~= "string" then
		return nil
	end
	local normalized = string.lower(name)
	if normalized == "minimal" then
		return "Minimal"
	elseif normalized == "smooth" then
		return "Smooth"
	elseif normalized == "snappy" then
		return "Snappy"
	elseif normalized == "off" then
		return "Off"
	end
	return nil
end

local function color3ToPacked(color)
	if typeof(color) ~= "Color3" then
		return nil
	end
	return {
		R = math.floor(color.R * 255 + 0.5),
		G = math.floor(color.G * 255 + 0.5),
		B = math.floor(color.B * 255 + 0.5)
	}
end

local function packedToColor3(packed)
	if type(packed) ~= "table" then
		return nil
	end
	local r = tonumber(packed.R)
	local g = tonumber(packed.G)
	local b = tonumber(packed.B)
	if not (r and g and b) then
		return nil
	end
	return Color3.fromRGB(math.clamp(math.floor(r + 0.5), 0, 255), math.clamp(math.floor(g + 0.5), 0, 255), math.clamp(math.floor(b + 0.5), 0, 255))
end

local function listThemeNames()
	local names = {}
	for themeName in pairs(ThemeModule.Themes or {}) do
		table.insert(names, themeName)
	end
	table.sort(names)
	return names
end

local function getMainScale()
	if not Main then
		return nil
	end
	local existing = Main:FindFirstChild("RayfieldMainScale")
	if existing and existing:IsA("UIScale") then
		return existing
	end
	local scale = Instance.new("UIScale")
	scale.Name = "RayfieldMainScale"
	scale.Scale = 1
	scale.Parent = Main
	return scale
end

local function setTransitionProfileInternal(name, persist)
	local canonical = normalizeTransitionProfileName(name)
	if not canonical then
		return false, "Invalid transition profile."
	end
	if not TRANSITION_PROFILE_NAMES[canonical] then
		return false, "Invalid transition profile."
	end
	if not AnimationEngine or type(AnimationEngine.SetTransitionProfile) ~= "function" then
		return false, "Animation engine unavailable."
	end

	local okSet, resultOrErr = AnimationEngine:SetTransitionProfile(canonical)
	if not okSet then
		return false, tostring(resultOrErr or "Failed to apply transition profile.")
	end

	ExperienceState.transitionProfile = canonical
	if persist ~= false then
		setSettingValue("Appearance", "transitionProfile", canonical, true)
	end
	return true, "Transition profile set to " .. canonical .. "."
end

local function setUIPresetInternal(name, persist)
	local canonical = normalizePresetName(name)
	if not canonical then
		return false, "Invalid UI preset."
	end
	if not UI_PRESET_NAMES[canonical] then
		return false, "Invalid UI preset."
	end

	local uiScale = getMainScale()
	if uiScale then
		if canonical == "Compact" then
			uiScale.Scale = 0.93
		else
			uiScale.Scale = 1.0
		end
	end

	local topbarSearch = Topbar and Topbar:FindFirstChild("Search")
	if topbarSearch then
		topbarSearch.Visible = canonical ~= "Focus"
		if canonical == "Focus" and searchOpen then
			pcall(closeSearch)
		end
	end

	experienceSuppressPromoPrompts = canonical == "Focus"
	ExperienceState.uiPreset = canonical

	local defaultTransitionByPreset = {
		Compact = "Snappy",
		Comfort = "Smooth",
		Focus = "Minimal"
	}
	local transitionName = defaultTransitionByPreset[canonical] or "Smooth"
	setTransitionProfileInternal(transitionName, persist ~= false)

	if persist ~= false then
		setSettingValue("Appearance", "uiPreset", canonical, true)
	end

	return true, "UI preset set to " .. canonical .. "."
end

local function buildThemeStudioTheme(baseThemeName, packedOverrides)
	local baseTheme = ThemeModule.Themes[baseThemeName] or ThemeModule.Themes.Default or {}
	local out = {}
	for themeKey, value in pairs(baseTheme) do
		out[themeKey] = value
	end

	if type(packedOverrides) == "table" then
		for themeKey, packedColor in pairs(packedOverrides) do
			local color = packedToColor3(packedColor)
			if color and out[themeKey] ~= nil then
				out[themeKey] = color
			end
		end
	end
	return out
end

local function getThemeStudioColor(themeKey)
	if type(themeKey) ~= "string" or themeKey == "" then
		return nil
	end
	local packed = ExperienceState.themeStudioState.customThemePacked[themeKey]
	if packed then
		local unpacked = packedToColor3(packed)
		if unpacked then
			return unpacked
		end
	end
	local baseThemeName = ExperienceState.themeStudioState.baseTheme
	local baseTheme = ThemeModule.Themes[baseThemeName] or ThemeModule.Themes.Default
	return baseTheme and baseTheme[themeKey] or nil
end

local function applyThemeStudioState(persist)
	local baseThemeName = ExperienceState.themeStudioState.baseTheme
	local useCustom = ExperienceState.themeStudioState.useCustom == true
	if not ThemeModule.Themes[baseThemeName] then
		baseThemeName = "Default"
		ExperienceState.themeStudioState.baseTheme = baseThemeName
	end

	if useCustom then
		local customTheme = buildThemeStudioTheme(baseThemeName, ExperienceState.themeStudioState.customThemePacked)
		ChangeTheme(customTheme)
	else
		ChangeTheme(baseThemeName)
	end

	if persist ~= false then
		setSettingValue("ThemeStudio", "baseTheme", ExperienceState.themeStudioState.baseTheme, false)
		setSettingValue("ThemeStudio", "useCustom", ExperienceState.themeStudioState.useCustom == true, false)
		setSettingValue("ThemeStudio", "customThemePacked", cloneValue(ExperienceState.themeStudioState.customThemePacked), true)
	end

	return true, "Theme studio state applied."
end

local function setThemeStudioBaseTheme(name, persist)
	local themeName = tostring(name or "")
	if not ThemeModule.Themes[themeName] then
		return false, "Theme not found."
	end
	ExperienceState.themeStudioState.baseTheme = themeName
	return applyThemeStudioState(persist ~= false)
end

local function setThemeStudioUseCustom(value, persist)
	ExperienceState.themeStudioState.useCustom = value == true
	return applyThemeStudioState(persist ~= false)
end

local function setThemeStudioColor(themeKey, color)
	if type(themeKey) ~= "string" or themeKey == "" then
		return false, "Theme key is invalid."
	end
	if typeof(color) ~= "Color3" then
		return false, "Color must be Color3."
	end
	if (ThemeModule.Themes.Default or {})[themeKey] == nil then
		return false, "Unknown theme key."
	end
	ExperienceState.themeStudioState.customThemePacked[themeKey] = color3ToPacked(color)
	ExperienceState.themeStudioState.useCustom = true
	return applyThemeStudioState(false)
end

local function resetThemeStudioState(persist)
	ExperienceState.themeStudioState.useCustom = false
	ExperienceState.themeStudioState.customThemePacked = {}
	return applyThemeStudioState(persist ~= false)
end

local function refreshFavoritesSettingsPersistence()
	if ElementsSystem and type(ElementsSystem.getPinnedIds) == "function" then
		local pinnedIds = ElementsSystem.getPinnedIds(true)
		setSettingValue("Favorites", "pinnedIds", cloneArray(pinnedIds), true)
	end
end

local function highlightFavoriteControl(record)
	if not record or not record.GuiObject or not record.GuiObject.Parent then
		return
	end
	local guiObject = record.GuiObject
	local okColor, originalColor = pcall(function()
		return guiObject.BackgroundColor3
	end)
	if not okColor then
		return
	end
	local targetColor = (SelectedTheme and SelectedTheme.SliderProgress) or originalColor
	Animation:Create(guiObject, TweenInfo.new(0.14, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundColor3 = targetColor}):Play()
	task.delay(0.22, function()
		if guiObject and guiObject.Parent then
			Animation:Create(guiObject, TweenInfo.new(0.22, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundColor3 = originalColor}):Play()
		end
	end)
end

local function renderFavoritesTab()
	local favoritesTab = ExperienceState.favoritesTab
	if not favoritesTab or type(favoritesTab.Clear) ~= "function" then
		return false
	end

	favoritesTab:Clear()
	favoritesTab:CreateSection("Pinned Controls")

	if not ElementsSystem or type(ElementsSystem.listControlsForFavorites) ~= "function" then
		favoritesTab:CreateLabel("Control registry unavailable.")
		return false
	end

	local controls = ElementsSystem.listControlsForFavorites(true)
	local pinnedControls = {}
	for _, control in ipairs(controls) do
		if control.pinned == true then
			table.insert(pinnedControls, control)
		end
	end

	if #pinnedControls <= 0 then
		favoritesTab:CreateLabel("No pinned controls yet.")
		return true
	end

	for _, control in ipairs(pinnedControls) do
		favoritesTab:CreateButton({
			Name = string.format("[%s] %s", tostring(control.type or "Element"), tostring(control.name or control.id)),
			Callback = function()
				if ElementsSystem and type(ElementsSystem.activateTabByPersistenceId) == "function" then
					ElementsSystem.activateTabByPersistenceId(control.tabId, true)
				end
				if ElementsSystem and type(ElementsSystem.getControlRecordById) == "function" then
					local record = ElementsSystem.getControlRecordById(control.id)
					highlightFavoriteControl(record)
				end
			end
		})
	end

	return true
end

local function ensureFavoritesTab(windowRef)
	if not windowRef then
		return nil, "Window unavailable."
	end
	if ExperienceState.favoritesTab and ExperienceState.favoritesTabWindow == windowRef then
		return ExperienceState.favoritesTab
	end
	ExperienceState.favoritesTabWindow = windowRef
	ExperienceState.favoritesTab = windowRef:CreateTab("Favorites", 0)
	renderFavoritesTab()
	return ExperienceState.favoritesTab
end

local function openFavoritesTab(windowRef)
	local favoritesTab, err = ensureFavoritesTab(windowRef or ExperienceState.favoritesTabWindow)
	if not favoritesTab then
		return false, tostring(err or "Unable to create Favorites tab.")
	end
	if type(favoritesTab.GetInternalRecord) == "function" and ElementsSystem and type(ElementsSystem.activateTabByPersistenceId) == "function" then
		local okRecord, record = pcall(favoritesTab.GetInternalRecord, favoritesTab)
		if okRecord and record and record.PersistenceId then
			ElementsSystem.activateTabByPersistenceId(record.PersistenceId, true)
		end
	end
	return true, "Favorites tab opened."
end

local function ensureOnboardingOverlay()
	if ExperienceState.onboardingOverlay and ExperienceState.onboardingOverlay.Root and ExperienceState.onboardingOverlay.Root.Parent then
		return ExperienceState.onboardingOverlay
	end
	if not Main then
		return nil
	end

	local overlay = Instance.new("Frame")
	overlay.Name = "ExperienceOnboardingOverlay"
	overlay.Size = UDim2.new(1, 0, 1, 0)
	overlay.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	overlay.BackgroundTransparency = 0.28
	overlay.Visible = false
	overlay.ZIndex = 80
	overlay.Parent = Main

	local panel = Instance.new("Frame")
	panel.Name = "Panel"
	panel.AnchorPoint = Vector2.new(0.5, 0.5)
	panel.Position = UDim2.new(0.5, 0, 0.5, 0)
	panel.Size = UDim2.new(0, 360, 0, 220)
	panel.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
	panel.BackgroundTransparency = 0.08
	panel.ZIndex = 81
	panel.Parent = overlay

	local panelCorner = Instance.new("UICorner")
	panelCorner.CornerRadius = UDim.new(0, 12)
	panelCorner.Parent = panel

	local title = Instance.new("TextLabel")
	title.Name = "Title"
	title.BackgroundTransparency = 1
	title.Size = UDim2.new(1, -24, 0, 28)
	title.Position = UDim2.new(0, 12, 0, 10)
	title.Font = Enum.Font.GothamBold
	title.TextSize = 18
	title.TextXAlignment = Enum.TextXAlignment.Left
	title.TextColor3 = Color3.fromRGB(245, 245, 245)
	title.ZIndex = 82
	title.Parent = panel

	local body = Instance.new("TextLabel")
	body.Name = "Body"
	body.BackgroundTransparency = 1
	body.Size = UDim2.new(1, -24, 0, 90)
	body.Position = UDim2.new(0, 12, 0, 46)
	body.Font = Enum.Font.Gotham
	body.TextSize = 14
	body.TextWrapped = true
	body.TextXAlignment = Enum.TextXAlignment.Left
	body.TextYAlignment = Enum.TextYAlignment.Top
	body.TextColor3 = Color3.fromRGB(220, 220, 220)
	body.ZIndex = 82
	body.Parent = panel

	local stepLabel = Instance.new("TextLabel")
	stepLabel.Name = "Step"
	stepLabel.BackgroundTransparency = 1
	stepLabel.Size = UDim2.new(1, -24, 0, 20)
	stepLabel.Position = UDim2.new(0, 12, 1, -86)
	stepLabel.Font = Enum.Font.Gotham
	stepLabel.TextSize = 12
	stepLabel.TextXAlignment = Enum.TextXAlignment.Left
	stepLabel.TextColor3 = Color3.fromRGB(180, 180, 180)
	stepLabel.ZIndex = 82
	stepLabel.Parent = panel

	local checkbox = Instance.new("TextButton")
	checkbox.Name = "DontShowAgain"
	checkbox.BackgroundTransparency = 1
	checkbox.Size = UDim2.new(1, -24, 0, 22)
	checkbox.Position = UDim2.new(0, 12, 1, -62)
	checkbox.Font = Enum.Font.Gotham
	checkbox.TextSize = 13
	checkbox.TextXAlignment = Enum.TextXAlignment.Left
	checkbox.TextColor3 = Color3.fromRGB(220, 220, 220)
	checkbox.ZIndex = 82
	checkbox.AutoButtonColor = false
	checkbox.Parent = panel

	local nextButton = Instance.new("TextButton")
	nextButton.Name = "Next"
	nextButton.AnchorPoint = Vector2.new(1, 1)
	nextButton.Position = UDim2.new(1, -12, 1, -12)
	nextButton.Size = UDim2.new(0, 88, 0, 30)
	nextButton.Font = Enum.Font.GothamBold
	nextButton.TextSize = 13
	nextButton.TextColor3 = Color3.fromRGB(245, 245, 245)
	nextButton.BackgroundColor3 = Color3.fromRGB(60, 120, 210)
	nextButton.ZIndex = 82
	nextButton.Parent = panel

	local nextCorner = Instance.new("UICorner")
	nextCorner.CornerRadius = UDim.new(0, 8)
	nextCorner.Parent = nextButton

	local closeButton = Instance.new("TextButton")
	closeButton.Name = "Close"
	closeButton.AnchorPoint = Vector2.new(0, 1)
	closeButton.Position = UDim2.new(0, 12, 1, -12)
	closeButton.Size = UDim2.new(0, 88, 0, 30)
	closeButton.Font = Enum.Font.GothamBold
	closeButton.TextSize = 13
	closeButton.Text = "Close"
	closeButton.TextColor3 = Color3.fromRGB(235, 235, 235)
	closeButton.BackgroundColor3 = Color3.fromRGB(58, 58, 58)
	closeButton.ZIndex = 82
	closeButton.Parent = panel

	local closeCorner = Instance.new("UICorner")
	closeCorner.CornerRadius = UDim.new(0, 8)
	closeCorner.Parent = closeButton

	local steps = {
		{
			title = "Welcome to Rayfield",
			body = "Use the topbar to search controls, open settings, and manage window state."
		},
		{
			title = "Favorites and Presets",
			body = "Pin your frequently used controls and switch presets to quickly change UI behavior."
		},
		{
			title = "Share and Theme Studio",
			body = "Export/import share codes and use Theme Studio for live visual customization."
		}
	}
	local state = {
		step = 1,
		dontShowAgain = false
	}

	local function render()
		local active = steps[state.step] or steps[1]
		title.Text = tostring(active.title or "Welcome")
		body.Text = tostring(active.body or "")
		stepLabel.Text = string.format("Step %d/%d", state.step, #steps)
		checkbox.Text = string.format("%s Don't show this again", state.dontShowAgain and "[x]" or "[ ]")
		nextButton.Text = state.step >= #steps and "Done" or "Next"
	end

	checkbox.MouseButton1Click:Connect(function()
		state.dontShowAgain = not state.dontShowAgain
		render()
	end)
	closeButton.MouseButton1Click:Connect(function()
		overlay.Visible = false
		if state.dontShowAgain then
			RayfieldLibrary:SetOnboardingSuppressed(true)
		end
	end)
	nextButton.MouseButton1Click:Connect(function()
		if state.step >= #steps then
			overlay.Visible = false
			if state.dontShowAgain then
				RayfieldLibrary:SetOnboardingSuppressed(true)
			end
			return
		end
		state.step += 1
		render()
	end)

	ExperienceState.onboardingOverlay = {
		Root = overlay,
		State = state,
		Render = render
	}
	render()
	return ExperienceState.onboardingOverlay
end

local function restoreExperienceStateFromSettings(windowRef)
	local transition = getSetting("Appearance", "transitionProfile") or ExperienceState.transitionProfile
	setTransitionProfileInternal(transition, false)

	local preset = getSetting("Appearance", "uiPreset") or ExperienceState.uiPreset
	setUIPresetInternal(preset, false)

	local baseTheme = getSetting("ThemeStudio", "baseTheme")
	if type(baseTheme) == "string" and ThemeModule.Themes[baseTheme] then
		ExperienceState.themeStudioState.baseTheme = baseTheme
	end
	ExperienceState.themeStudioState.useCustom = getSetting("ThemeStudio", "useCustom") == true

	local packedTheme = getSetting("ThemeStudio", "customThemePacked")
	if type(packedTheme) == "table" then
		ExperienceState.themeStudioState.customThemePacked = cloneValue(packedTheme)
	end
	applyThemeStudioState(false)

	if ElementsSystem and type(ElementsSystem.setPinBadgesVisible) == "function" then
		local showBadges = getSetting("Favorites", "showPinBadges")
		ElementsSystem.setPinBadgesVisible(showBadges ~= false)
	end
	if ElementsSystem and type(ElementsSystem.setPinnedIds) == "function" then
		local pinnedIds = getSetting("Favorites", "pinnedIds")
		if type(pinnedIds) == "table" then
			ElementsSystem.setPinnedIds(cloneArray(pinnedIds))
		end
	end

	local pinnedControls = ElementsSystem and ElementsSystem.getPinnedIds and ElementsSystem.getPinnedIds(true) or {}
	if type(pinnedControls) == "table" and #pinnedControls > 0 then
		ensureFavoritesTab(windowRef)
		renderFavoritesTab()
	end

	ExperienceState.onboardingSuppressed = getSetting("Onboarding", "suppressed") == true
end

function RayfieldLibrary:SetTransitionProfile(name)
	return setTransitionProfileInternal(name, true)
end

function RayfieldLibrary:GetTransitionProfile()
	return ExperienceState.transitionProfile
end

function RayfieldLibrary:SetUIPreset(name)
	return setUIPresetInternal(name, true)
end

function RayfieldLibrary:GetUIPreset()
	return ExperienceState.uiPreset
end

function RayfieldLibrary:ListControls()
	if not ElementsSystem or type(ElementsSystem.listControlsForFavorites) ~= "function" then
		return {}
	end
	return ElementsSystem.listControlsForFavorites(true)
end

function RayfieldLibrary:PinControl(idOrFlag)
	if not ElementsSystem or type(ElementsSystem.pinControl) ~= "function" then
		return false, "Control registry unavailable."
	end
	local ok, message = ElementsSystem.pinControl(tostring(idOrFlag or ""))
	if ok then
		refreshFavoritesSettingsPersistence()
		if ExperienceState.favoritesTabWindow then
			ensureFavoritesTab(ExperienceState.favoritesTabWindow)
		end
		renderFavoritesTab()
	end
	return ok, message
end

function RayfieldLibrary:UnpinControl(idOrFlag)
	if not ElementsSystem or type(ElementsSystem.unpinControl) ~= "function" then
		return false, "Control registry unavailable."
	end
	local ok, message = ElementsSystem.unpinControl(tostring(idOrFlag or ""))
	if ok then
		refreshFavoritesSettingsPersistence()
		renderFavoritesTab()
	end
	return ok, message
end

function RayfieldLibrary:GetPinnedControls()
	if not ElementsSystem or type(ElementsSystem.getPinnedIds) ~= "function" then
		return {}
	end
	return ElementsSystem.getPinnedIds(true)
end

function RayfieldLibrary:SetOnboardingSuppressed(value)
	ExperienceState.onboardingSuppressed = value == true
	setSettingValue("Onboarding", "suppressed", ExperienceState.onboardingSuppressed, true)
	return true, ExperienceState.onboardingSuppressed and "Onboarding suppressed." or "Onboarding enabled."
end

function RayfieldLibrary:IsOnboardingSuppressed()
	return ExperienceState.onboardingSuppressed == true
end

function RayfieldLibrary:ShowOnboarding(force)
	if ExperienceState.onboardingSuppressed and force ~= true then
		return false, "Onboarding is suppressed."
	end
	local overlayRef = ensureOnboardingOverlay()
	if not overlayRef or not overlayRef.Root then
		return false, "Onboarding UI unavailable."
	end
	overlayRef.State.step = 1
	overlayRef.State.dontShowAgain = false
	overlayRef.Render()
	overlayRef.Root.Visible = true
	ExperienceState.onboardingRendered = true
	return true, "Onboarding shown."
end

function RayfieldLibrary:GetThemeStudioState()
	return {
		baseTheme = ExperienceState.themeStudioState.baseTheme,
		useCustom = ExperienceState.themeStudioState.useCustom == true,
		customThemePacked = cloneValue(ExperienceState.themeStudioState.customThemePacked)
	}
end

function RayfieldLibrary:ApplyThemeStudioTheme(themeOrName)
	if type(themeOrName) == "string" then
		return setThemeStudioBaseTheme(themeOrName, true)
	end
	if type(themeOrName) ~= "table" then
		return false, "Theme input must be a theme name or table."
	end

	local nextPacked = {}
	for _, key in ipairs(THEME_STUDIO_KEYS) do
		local value = themeOrName[key]
		if typeof(value) == "Color3" then
			nextPacked[key] = color3ToPacked(value)
		elseif type(value) == "table" then
			local packed = packedToColor3(value)
			if packed then
				nextPacked[key] = color3ToPacked(packed)
			end
		end
	end
	ExperienceState.themeStudioState.customThemePacked = nextPacked
	ExperienceState.themeStudioState.useCustom = true
	return applyThemeStudioState(true)
end

function RayfieldLibrary:ResetThemeStudio()
	return resetThemeStudioState(true)
end

local function notifyExperienceStatus(success, message)
	if UIStateSystem and type(UIStateSystem.Notify) == "function" then
		pcall(UIStateSystem.Notify, {
			Title = "Rayfield Experience",
			Content = tostring(message or ""),
			Image = success and 4483362458 or 4384402990
		})
	elseif success ~= true then
		warn("Rayfield | " .. tostring(message or "UI experience operation failed."))
	end
end

if SettingsSystem and type(SettingsSystem.setExperienceHandlers) == "function" then
	SettingsSystem.setExperienceHandlers({
		setUIPreset = function(name)
			return RayfieldLibrary:SetUIPreset(name)
		end,
		setTransitionProfile = function(name)
			return RayfieldLibrary:SetTransitionProfile(name)
		end,
		listControls = function(pruneMissing)
			if ElementsSystem and type(ElementsSystem.listControlsForFavorites) == "function" then
				return ElementsSystem.listControlsForFavorites(pruneMissing == true)
			end
			return {}
		end,
		pinControl = function(id)
			return RayfieldLibrary:PinControl(id)
		end,
		unpinControl = function(id)
			return RayfieldLibrary:UnpinControl(id)
		end,
		setPinBadgesVisible = function(visible)
			if ElementsSystem and type(ElementsSystem.setPinBadgesVisible) == "function" then
				ElementsSystem.setPinBadgesVisible(visible ~= false)
				setSettingValue("Favorites", "showPinBadges", visible ~= false, true)
				return true, "Pin badge visibility updated."
			end
			return false, "Pin badge controller unavailable."
		end,
		openFavoritesTab = function()
			return openFavoritesTab(ExperienceState.favoritesTabWindow)
		end,
		showOnboarding = function(force)
			return RayfieldLibrary:ShowOnboarding(force == true)
		end,
		getThemeNames = function()
			return listThemeNames()
		end,
		getThemeStudioKeys = function()
			return cloneArray(THEME_STUDIO_KEYS)
		end,
		getThemeStudioColor = function(themeKey)
			return getThemeStudioColor(themeKey)
		end,
		setThemeStudioBaseTheme = function(themeName)
			local ok, message = setThemeStudioBaseTheme(themeName, true)
			if ok then
				setSettingValue("ThemeStudio", "baseTheme", ExperienceState.themeStudioState.baseTheme, true)
			end
			return ok, message
		end,
		setThemeStudioUseCustom = function(value)
			local ok, message = setThemeStudioUseCustom(value == true, true)
			if ok then
				setSettingValue("ThemeStudio", "useCustom", ExperienceState.themeStudioState.useCustom == true, true)
			end
			return ok, message
		end,
		setThemeStudioColor = function(themeKey, color)
			local ok, message = setThemeStudioColor(themeKey, color)
			if ok then
				setSettingValue("ThemeStudio", "customThemePacked", cloneValue(ExperienceState.themeStudioState.customThemePacked), false)
				setSettingValue("ThemeStudio", "useCustom", true, true)
			end
			return ok, message
		end,
		applyThemeStudioDraft = function()
			local ok, message = applyThemeStudioState(true)
			if ok then
				setSettingValue("ThemeStudio", "baseTheme", ExperienceState.themeStudioState.baseTheme, false)
				setSettingValue("ThemeStudio", "useCustom", ExperienceState.themeStudioState.useCustom == true, false)
				setSettingValue("ThemeStudio", "customThemePacked", cloneValue(ExperienceState.themeStudioState.customThemePacked), true)
			end
			return ok, message
		end,
		resetThemeStudio = function()
			local ok, message = resetThemeStudioState(true)
			if ok then
				setSettingValue("ThemeStudio", "useCustom", false, false)
				setSettingValue("ThemeStudio", "customThemePacked", {}, true)
			end
			return ok, message
		end,
		notify = function(success, message)
			notifyExperienceStatus(success == true, message)
		end
	})
end

-- Note: UI State Management (Notify, Search, Hide/Minimize) moved to rayfield-ui-state.lua module

-- Wrapper for RayfieldLibrary:Notify
function RayfieldLibrary:Notify(data)
	return UIStateSystem.Notify(data)
end

local function ensureOwnershipSystem()
	if not OwnershipSystem then
		return false, "Ownership tracker is unavailable."
	end
	return true
end

local function sanitizeScopeName(rawName)
	local value = tostring(rawName or "")
	value = value:gsub("^%s+", "")
	value = value:gsub("%s+$", "")
	value = value:gsub("[%s/\\]+", "_")
	value = value:gsub("[^%w_%-:]", "")
	if value == "" then
		local okGuid, guid = pcall(function()
			return HttpService:GenerateGUID(false)
		end)
		if okGuid and type(guid) == "string" and guid ~= "" then
			value = guid
		else
			value = tostring(math.floor(os.clock() * 100000))
		end
	end
	return value
end

function RayfieldLibrary:CreateFeatureScope(name)
	local okOwnership, ownershipErr = ensureOwnershipSystem()
	if not okOwnership then
		return nil, ownershipErr
	end

	local normalizedName = sanitizeScopeName(name or "feature")
	local scopeId = "feature:" .. normalizedName
	if type(OwnershipSystem.createScope) == "function" then
		pcall(OwnershipSystem.createScope, scopeId, {
			kind = "feature",
			name = normalizedName
		})
	end
	return scopeId, "ok"
end

function RayfieldLibrary:TrackFeatureConnection(scopeId, connection)
	local okOwnership, ownershipErr = ensureOwnershipSystem()
	if not okOwnership then
		return false, ownershipErr
	end
	if type(scopeId) ~= "string" or scopeId == "" then
		return false, "Invalid scopeId."
	end
	if not connection then
		return false, "Invalid connection."
	end
	if type(OwnershipSystem.trackConnection) ~= "function" then
		return false, "Ownership tracker does not support connection tracking."
	end
	local okTrack, tracked = pcall(OwnershipSystem.trackConnection, connection, scopeId)
	if not okTrack then
		return false, tostring(tracked)
	end
	if tracked ~= true then
		return false, "Failed to track connection."
	end
	return true, "ok"
end

function RayfieldLibrary:TrackFeatureTask(scopeId, taskHandle)
	local okOwnership, ownershipErr = ensureOwnershipSystem()
	if not okOwnership then
		return false, ownershipErr
	end
	if type(scopeId) ~= "string" or scopeId == "" then
		return false, "Invalid scopeId."
	end
	if taskHandle == nil then
		return false, "Invalid task handle."
	end
	if type(OwnershipSystem.trackTask) ~= "function" then
		return false, "Ownership tracker does not support task tracking."
	end
	local okTrack, tracked = pcall(OwnershipSystem.trackTask, taskHandle, scopeId)
	if not okTrack then
		return false, tostring(tracked)
	end
	if tracked ~= true then
		return false, "Failed to track task."
	end
	return true, "ok"
end

function RayfieldLibrary:TrackFeatureInstance(scopeId, instance, metadata)
	local okOwnership, ownershipErr = ensureOwnershipSystem()
	if not okOwnership then
		return false, ownershipErr
	end
	if type(scopeId) ~= "string" or scopeId == "" then
		return false, "Invalid scopeId."
	end
	if typeof(instance) ~= "Instance" then
		return false, "Invalid instance."
	end
	if type(OwnershipSystem.claimInstance) ~= "function" then
		return false, "Ownership tracker does not support instance tracking."
	end
	local okClaim, claimResult = pcall(OwnershipSystem.claimInstance, instance, scopeId, metadata)
	if not okClaim then
		return false, tostring(claimResult)
	end
	if claimResult ~= true then
		return false, "Failed to track instance."
	end
	return true, "ok"
end

function RayfieldLibrary:TrackFeatureCleanup(scopeId, cleanupFn)
	local okOwnership, ownershipErr = ensureOwnershipSystem()
	if not okOwnership then
		return false, ownershipErr
	end
	if type(scopeId) ~= "string" or scopeId == "" then
		return false, "Invalid scopeId."
	end
	if type(cleanupFn) ~= "function" then
		return false, "cleanupFn must be a function."
	end
	if type(OwnershipSystem.trackCleanup) ~= "function" then
		return false, "Ownership tracker does not support cleanup callbacks."
	end
	local okTrack, trackResult = pcall(OwnershipSystem.trackCleanup, cleanupFn, scopeId)
	if not okTrack then
		return false, tostring(trackResult)
	end
	if trackResult ~= true then
		return false, "Failed to track cleanup callback."
	end
	return true, "ok"
end

function RayfieldLibrary:CleanupFeatureScope(scopeId, destroyInstances)
	local okOwnership, ownershipErr = ensureOwnershipSystem()
	if not okOwnership then
		return false, ownershipErr
	end
	if type(scopeId) ~= "string" or scopeId == "" then
		return false, "Invalid scopeId."
	end
	if type(OwnershipSystem.cleanupScope) ~= "function" then
		return false, "Ownership tracker does not support scope cleanup."
	end
	local okCleanup, cleanupResult = pcall(OwnershipSystem.cleanupScope, scopeId, {
		destroyInstances = destroyInstances == true,
		clearAttributes = true
	})
	if not okCleanup then
		return false, tostring(cleanupResult)
	end
	if cleanupResult ~= true then
		return false, "Scope was not found."
	end
	return true, "ok"
end

function RayfieldLibrary:GetFeatureCleanupStats()
	local okOwnership, _ = ensureOwnershipSystem()
	if not okOwnership then
		return {
			scopes = 0,
			instances = 0,
			connections = 0,
			tasks = 0,
			cleanups = 0
		}
	end
	if type(OwnershipSystem.getStats) ~= "function" then
		return {
			scopes = 0,
			instances = 0,
			connections = 0,
			tasks = 0,
			cleanups = 0
		}
	end
	local okStats, stats = pcall(OwnershipSystem.getStats)
	if not okStats or type(stats) ~= "table" then
		return {
			scopes = 0,
			instances = 0,
			connections = 0,
			tasks = 0,
			cleanups = 0
		}
	end
	return stats
end

function RayfieldLibrary:GetRuntimeDiagnostics()
	local animationStats = {}
	if AnimationEngine and type(AnimationEngine.GetRuntimeStats) == "function" then
		local ok, stats = pcall(function()
			return AnimationEngine:GetRuntimeStats()
		end)
		if ok and type(stats) == "table" then
			animationStats = stats
		end
	end

	local activeTweens = animationStats.activeTweens
	if type(activeTweens) ~= "number" and AnimationEngine and type(AnimationEngine.GetActiveAnimationCount) == "function" then
		local ok, value = pcall(function()
			return AnimationEngine:GetActiveAnimationCount()
		end)
		activeTweens = ok and value or 0
	end

	local activeTextHandles = animationStats.activeTextHandles
	if type(activeTextHandles) ~= "number" and AnimationEngine and type(AnimationEngine.GetTextHandleCount) == "function" then
		local ok, value = pcall(function()
			return AnimationEngine:GetTextHandleCount()
		end)
		activeTextHandles = ok and value or 0
	end

	local themeBindings = { objectsBound = 0, propertiesBound = 0 }
	if ThemeSystem and type(ThemeSystem.GetBindingStats) == "function" then
		local ok, stats = pcall(function()
			return ThemeSystem.GetBindingStats()
		end)
		if ok and type(stats) == "table" then
			themeBindings = {
				objectsBound = tonumber(stats.objectsBound) or 0,
				propertiesBound = tonumber(stats.propertiesBound) or 0
			}
		end
	end

	local ownershipStats = {
		scopes = 0,
		instances = 0,
		connections = 0,
		tasks = 0,
		cleanups = 0
	}
	if OwnershipSystem and type(OwnershipSystem.getStats) == "function" then
		local okOwnershipStats, stats = pcall(OwnershipSystem.getStats)
		if okOwnershipStats and type(stats) == "table" then
			ownershipStats = {
				scopes = tonumber(stats.scopes) or 0,
				instances = tonumber(stats.instances) or 0,
				connections = tonumber(stats.connections) or 0,
				tasks = tonumber(stats.tasks) or 0,
				cleanups = tonumber(stats.cleanups) or 0
			}
		end
	end

	return {
		activeTweens = tonumber(activeTweens) or 0,
		activeTextHandles = tonumber(activeTextHandles) or 0,
		themeBindings = themeBindings,
		ownership = ownershipStats,
		rayfieldVisible = not Hidden,
		rayfieldMinimized = Minimised == true,
		rayfieldDestroyed = rayfieldDestroyed == true,
		performanceProfile = {
			enabled = activePerformanceProfile.enabled == true,
			requestedMode = activePerformanceProfile.requestedMode,
			resolvedMode = activePerformanceProfile.resolvedMode,
			aggressive = activePerformanceProfile.aggressive == true,
			disableDetach = activePerformanceProfile.disableDetach == true,
			disableTabSplit = activePerformanceProfile.disableTabSplit == true,
			disableAnimations = activePerformanceProfile.disableAnimations == true
		}
	}
end

local function shallowArrayCopy(input)
	local out = {}
	if type(input) ~= "table" then
		return out
	end
	for index, value in ipairs(input) do
		out[index] = value
	end
	return out
end

local function normalizeProfileMode(mode)
	if type(mode) ~= "string" then
		return "auto"
	end
	local normalized = string.lower(mode)
	if normalized == "auto" or normalized == "potato" or normalized == "mobile" or normalized == "normal" then
		return normalized
	end
	return "auto"
end

local function mergeTable(target, source)
	if type(source) ~= "table" then
		return
	end
	if type(target) ~= "table" then
		return
	end
	for key, value in pairs(source) do
		if type(value) == "table" then
			if type(target[key]) ~= "table" then
				target[key] = {}
			end
			mergeTable(target[key], value)
		else
			target[key] = value
		end
	end
end

local function applyPresetFillNil(target, preset, appliedFields, pathPrefix)
	if type(target) ~= "table" or type(preset) ~= "table" then
		return
	end
	for key, value in pairs(preset) do
		local path = pathPrefix and (pathPrefix .. "." .. tostring(key)) or tostring(key)
		if type(value) == "table" then
			local existing = target[key]
			if existing == nil then
				target[key] = {}
				existing = target[key]
			end
			if type(existing) == "table" then
				applyPresetFillNil(existing, value, appliedFields, path)
			end
		else
			if target[key] == nil then
				target[key] = value
				table.insert(appliedFields, path)
			end
		end
	end
end

local function buildLowSpecPreset(resolvedMode, aggressive, profileSettings)
	local isLowSpecMode = resolvedMode == "potato" or resolvedMode == "mobile"
	local disableDetach = profileSettings.DisableDetach
	if disableDetach == nil then
		disableDetach = aggressive and isLowSpecMode
	end
	local disableTabSplit = profileSettings.DisableTabSplit
	if disableTabSplit == nil then
		disableTabSplit = aggressive and isLowSpecMode
	end
	local disableAnimations = profileSettings.DisableAnimations
	if disableAnimations == nil then
		disableAnimations = aggressive and isLowSpecMode
	end

	local preset = {}
	if isLowSpecMode then
		preset.DisableRayfieldPrompts = true
		preset.DisableBuildWarnings = true
		preset.ViewportVirtualization = {
			Enabled = true,
			AlwaysOn = true,
			FullSuspend = true,
			FadeOnScroll = false,
			DisableFadeDuringResize = true
		}

		if resolvedMode == "potato" then
			preset.ViewportVirtualization.OverscanPx = 80
			preset.ViewportVirtualization.UpdateHz = 20
			preset.ViewportVirtualization.ResizeDebounceMs = 120
		elseif resolvedMode == "mobile" then
			preset.ViewportVirtualization.OverscanPx = 100
			preset.ViewportVirtualization.UpdateHz = 24
			preset.ViewportVirtualization.ResizeDebounceMs = 100
		end
	end

	if disableAnimations then
		preset.ViewportVirtualization = preset.ViewportVirtualization or {}
		preset.ViewportVirtualization.FadeOnScroll = false
		preset.ViewportVirtualization.DisableFadeDuringResize = true
	end

	if disableTabSplit then
		preset.EnableTabSplit = false
	end

	if type(profileSettings.ViewportVirtualization) == "table" then
		preset.ViewportVirtualization = preset.ViewportVirtualization or {}
		mergeTable(preset.ViewportVirtualization, profileSettings.ViewportVirtualization)
	end

	return preset, {
		disableDetach = disableDetach == true,
		disableTabSplit = disableTabSplit == true,
		disableAnimations = disableAnimations == true,
		aggressive = aggressive == true
	}
end

local function resolvePerformanceProfile(Settings, runtimeCtx)
	local resolved = {
		enabled = false,
		requestedMode = "normal",
		resolvedMode = "normal",
		aggressive = false,
		disableDetach = false,
		disableTabSplit = false,
		disableAnimations = false,
		appliedFields = {}
	}
	local profile = Settings and Settings.PerformanceProfile
	if type(profile) ~= "table" or profile.Enabled ~= true then
		return resolved
	end

	resolved.enabled = true
	local requestedMode = normalizeProfileMode(profile.Mode or "auto")
	resolved.requestedMode = requestedMode

	local resolvedMode = requestedMode
	if requestedMode == "auto" then
		if runtimeCtx and runtimeCtx.touchEnabled == true then
			resolvedMode = "mobile"
		else
			resolvedMode = "potato"
		end
	end
	resolved.resolvedMode = resolvedMode

	local aggressive = profile.Aggressive ~= false
	local preset, flags = buildLowSpecPreset(resolvedMode, aggressive, profile)
	applyPresetFillNil(Settings, preset, resolved.appliedFields)

	resolved.aggressive = flags.aggressive
	resolved.disableDetach = flags.disableDetach
	resolved.disableTabSplit = flags.disableTabSplit
	resolved.disableAnimations = flags.disableAnimations
	if type(Settings.EnableTabSplit) == "boolean" then
		resolved.disableTabSplit = Settings.EnableTabSplit == false
	end

	return resolved
end

local function applySystemOverridesForProfile(profile)
	local lowSpecActive = type(profile) == "table" and profile.enabled == true and profile.resolvedMode ~= "normal"
	local disableAnimations = type(profile) == "table" and profile.disableAnimations == true
	if lowSpecActive or disableAnimations then
		overrideSetting("System", "reducedEffects", true)
		overrideSetting("System", "performanceMode", true)
	else
		overrideSetting("System", "reducedEffects", nil)
		overrideSetting("System", "performanceMode", nil)
	end

	if lowSpecActive then
		overrideSetting("System", "usageAnalytics", false)
	elseif not requestsDisabled then
		overrideSetting("System", "usageAnalytics", nil)
	end
end

-- Note: saveSettings, updateSetting, and createSettings are now handled by SettingsModule

function RayfieldLibrary:CreateWindow(Settings)
	Settings = type(Settings) == "table" and Settings or {}
	local runtimeCtx = {
		touchEnabled = UserInputService and UserInputService.TouchEnabled == true
	}
	local resolvedPerformanceProfile = resolvePerformanceProfile(Settings, runtimeCtx)
	activePerformanceProfile = resolvedPerformanceProfile
	detachPathEnabled = resolvedPerformanceProfile.disableDetach ~= true
	applySystemOverridesForProfile(resolvedPerformanceProfile)
	ExperienceState.onboardingRendered = false
	local fastLoadEnabled = Settings.FastLoad ~= false
	if resolvedPerformanceProfile.disableAnimations == true then
		fastLoadEnabled = true
	end
	local startupTimeScale = fastLoadEnabled and 0.2 or 1
	if resolvedPerformanceProfile.disableAnimations == true then
		startupTimeScale = 0.08
	end

	local function waitForStartup(seconds)
		local duration = tonumber(seconds) or 0
		if duration <= 0 then
			return
		end
		local scaled = duration * startupTimeScale
		if scaled > 0 then
			task.wait(scaled)
		end
	end

	local function startupTweenDuration(seconds)
		local duration = tonumber(seconds) or 0
		if duration <= 0 then
			return 0
		end
		if startupTimeScale >= 1 then
			return duration
		end
		return math.max(0.04, duration * startupTimeScale)
	end

	if type(loaderDiagnostics) == "table" then
		loaderDiagnostics.performanceProfile = {
			enabled = resolvedPerformanceProfile.enabled == true,
			requestedMode = resolvedPerformanceProfile.requestedMode,
			resolvedMode = resolvedPerformanceProfile.resolvedMode,
			aggressive = resolvedPerformanceProfile.aggressive == true,
			disableDetach = resolvedPerformanceProfile.disableDetach == true,
			disableTabSplit = resolvedPerformanceProfile.disableTabSplit == true,
			disableAnimations = resolvedPerformanceProfile.disableAnimations == true,
			appliedFields = shallowArrayCopy(resolvedPerformanceProfile.appliedFields)
		}
	end

	if Rayfield:FindFirstChild('Loading') then
		if getgenv and not getgenv().rayfieldCached then
			Rayfield.Enabled = true
			Rayfield.Loading.Visible = true

			waitForStartup(1.4)
			Rayfield.Loading.Visible = false
		end
	end

	if getgenv then getgenv().rayfieldCached = true end

	if not correctBuild and not Settings.DisableBuildWarnings then
		task.delay(3, 
			function() 
				RayfieldLibrary:Notify({Title = 'Build Mismatch', Content = 'Rayfield may encounter issues as you are running an incompatible interface version ('.. ((Rayfield:FindFirstChild('Build') and Rayfield.Build.Value) or 'No Build') ..').\n\nThis version of Rayfield is intended for interface build '..InterfaceBuild..'.\n\nTry rejoining and then run the script twice.', Image = 4335487866, Duration = 15})		
			end)
	end

	if Settings.ToggleUIKeybind then -- Can either be a string, sequence, or an Enum.KeyCode
		local canonical, _, normalizeErr = KeybindSequenceLib.normalize(Settings.ToggleUIKeybind, {
			maxSteps = 4
		})
		assert(canonical, "ToggleUIKeybind must be a valid keybind/sequence: " .. tostring(normalizeErr))
		overrideSetting("General", "rayfieldOpen", canonical)
		cachedUiToggleKeybindRaw = nil
		cachedUiToggleKeybindSpec = nil
		uiToggleKeybindMatcher:reset()
	end

	ensureFolder(RayfieldFolder)

	-- Attempt to report an event to analytics
	if not requestsDisabled then
		sendReport("window_created", Settings.Name or "Unknown")
	end
	local Passthrough = false
	Topbar.Title.Text = Settings.Name

	Main.Size = UDim2.new(0, 420, 0, 100)
	Main.Visible = true
	Main.BackgroundTransparency = 1
	if Main:FindFirstChild('Notice') then Main.Notice.Visible = false end
	Main.Shadow.Image.ImageTransparency = 1

	LoadingFrame.Title.TextTransparency = 1
	LoadingFrame.Subtitle.TextTransparency = 1

	if Settings.ShowText then
		MPrompt.Title.Text = 'Show '..Settings.ShowText
	end

	LoadingFrame.Version.TextTransparency = 1
	LoadingFrame.Title.Text = Settings.LoadingTitle or "Rayfield"
	LoadingFrame.Subtitle.Text = Settings.LoadingSubtitle or "Interface Suite"

	if Settings.LoadingTitle ~= "Rayfield Interface Suite" then
		LoadingFrame.Version.Text = "Rayfield UI"
	end

	if Settings.Icon and Settings.Icon ~= 0 and Topbar:FindFirstChild('Icon') then
		Topbar.Icon.Visible = true
		Topbar.Title.Position = UDim2.new(0, 47, 0.5, 0)

		if Settings.Icon then
			if typeof(Settings.Icon) == 'string' and Icons then
				local asset = getIcon(Settings.Icon)

				Topbar.Icon.Image = 'rbxassetid://'..asset.id
				Topbar.Icon.ImageRectOffset = asset.imageRectOffset
				Topbar.Icon.ImageRectSize = asset.imageRectSize
			else
				Topbar.Icon.Image = getAssetUri(Settings.Icon)
			end
		else
			Topbar.Icon.Image = "rbxassetid://" .. 0
		end
	end

	if dragBar then
		dragBar.Visible = false
		dragBarCosmetic.BackgroundTransparency = 1
		dragBar.Visible = true
	end

	if Settings.Theme then
		local success, result = pcall(ChangeTheme, Settings.Theme)
		if not success then
			local success, result2 = pcall(ChangeTheme, 'Default')
			if not success then
				warn('CRITICAL ERROR - NO DEFAULT THEME')
				print(result2)
			end
			warn('issue rendering theme. no theme on file')
			print(result)
		end
	end

	Topbar.Visible = false
	TabList.Visible = false
	Elements.Visible = false
	LoadingFrame.Visible = true

	-- Improvement 1: Disable notification loop by default to reduce resource usage
	-- Users can explicitly set DisableRayfieldPrompts = false to enable notifications
	if Settings.DisableRayfieldPrompts == nil then
		Settings.DisableRayfieldPrompts = true -- Default to disabled
	end

	-- Tab split settings
	if Settings.EnableTabSplit == nil then
		Settings.EnableTabSplit = true
	end
	if type(Settings.TabSplitHoldDuration) ~= "number" or Settings.TabSplitHoldDuration <= 0 then
		Settings.TabSplitHoldDuration = 3
	end
	if Settings.AllowSettingsTabSplit == nil then
		Settings.AllowSettingsTabSplit = false
	end
	if Settings.MaxSplitTabs ~= nil then
		local maxSplitTabs = tonumber(Settings.MaxSplitTabs)
		if maxSplitTabs and maxSplitTabs >= 1 then
			Settings.MaxSplitTabs = math.floor(maxSplitTabs)
		else
			Settings.MaxSplitTabs = nil
		end
	end

	if type(Settings.ViewportVirtualization) ~= "table" then
		Settings.ViewportVirtualization = {}
	end
	local viewportSettings = Settings.ViewportVirtualization
	if viewportSettings.Enabled == nil then
		viewportSettings.Enabled = true
	end
	if viewportSettings.AlwaysOn == nil then
		viewportSettings.AlwaysOn = true
	end
	if viewportSettings.FullSuspend == nil then
		viewportSettings.FullSuspend = true
	end
	if viewportSettings.OverscanPx == nil then
		viewportSettings.OverscanPx = 120
	end
	if viewportSettings.UpdateHz == nil then
		viewportSettings.UpdateHz = 30
	end
	if viewportSettings.FadeOnScroll == nil then
		viewportSettings.FadeOnScroll = true
	end
	if viewportSettings.DisableFadeDuringResize == nil then
		viewportSettings.DisableFadeDuringResize = true
	end
	if viewportSettings.ResizeDebounceMs == nil then
		viewportSettings.ResizeDebounceMs = 100
	end
	if viewportSettings.MinElementsToActivate == nil then
		viewportSettings.MinElementsToActivate = 0
	end

	if not Settings.DisableRayfieldPrompts then
		task.spawn(function()
			while true do
				task.wait(math.random(180, 600))
				if experienceSuppressPromoPrompts then
					continue
				end
				RayfieldLibrary:Notify({
					Title = "Rayfield Interface",
					Content = "Enjoying this UI library? Find it at sirius.menu/discord",
					Duration = 7,
					Image = 4370033185,
				})
			end
		end)
	end

	pcall(function()
		if type(Settings.ConfigurationSaving) ~= "table" then
			Settings.ConfigurationSaving = {}
		end
		if not Settings.ConfigurationSaving.FileName then
			Settings.ConfigurationSaving.FileName = tostring(game.PlaceId)
		end

		if Settings.ConfigurationSaving.Enabled == nil then
			Settings.ConfigurationSaving.Enabled = false
		end

		CFileName = Settings.ConfigurationSaving.FileName
		ConfigurationFolder = Settings.ConfigurationSaving.FolderName or ConfigurationFolder
		CEnabled = Settings.ConfigurationSaving.Enabled
		if type(Settings.ConfigurationSaving.Layout) ~= "table" then
			Settings.ConfigurationSaving.Layout = {}
		end
		local layoutConfig = Settings.ConfigurationSaving.Layout
		if layoutConfig.Enabled == nil then
			layoutSavingEnabled = CEnabled == true
		else
			layoutSavingEnabled = layoutConfig.Enabled == true and CEnabled == true
		end
		local configuredDebounce = tonumber(layoutConfig.DebounceMs)
		if configuredDebounce and configuredDebounce >= 50 then
			layoutDebounceMs = math.floor(configuredDebounce)
		else
			layoutDebounceMs = 300
		end
		layoutConfig.Enabled = layoutSavingEnabled
		layoutConfig.DebounceMs = layoutDebounceMs

		if Settings.ConfigurationSaving.Enabled then
			ensureFolder(ConfigurationFolder)
		end
	end)

	-- Initialize Utilities Module now that UI elements exist
	UtilitiesSystem = UtilitiesModuleLib.init({
		TweenService = TweenService,
		Animation = Animation,
		RunService = RunService,
		UserInputService = UserInputService,
		getService = getService,
		Main = Main,
		Rayfield = Rayfield,
		dragBar = dragBar,
		dragBarCosmetic = dragBarCosmetic,
		getHidden = function() return Hidden end,
		useMobileSizing = useMobileSizing,
		Hide = Hide,
		Unhide = Unhide,
		getDebounce = function() return Debounce end,
		setRayfieldDestroyed = function(val) rayfieldDestroyed = val end,
		keybindConnections = keybindConnections
	})

	makeDraggable(Main, Topbar, false, {dragOffset, dragOffsetMobile})
	if dragBar then dragBar.Position = useMobileSizing and UDim2.new(0.5, 0, 0.5, dragOffsetMobile) or UDim2.new(0.5, 0, 0.5, dragOffset) makeDraggable(Main, dragInteract, true, {dragOffset, dragOffsetMobile}) end

	for _, TabButton in ipairs(TabList:GetChildren()) do
		if TabButton.ClassName == "Frame" and TabButton.Name ~= "Placeholder" then
			TabButton.BackgroundTransparency = 1
			TabButton.Title.TextTransparency = 1
			TabButton.Image.ImageTransparency = 1
			TabButton.UIStroke.Transparency = 1
		end
	end

	if Settings.Discord and Settings.Discord.Enabled and not useStudio then
		ensureFolder(RayfieldFolder.."/Discord Invites")

		if callSafely(isfile, RayfieldFolder.."/Discord Invites".."/"..Settings.Discord.Invite..ConfigurationExtension) then
			if requestFunc then
				pcall(function()
					requestFunc({
						Url = 'http://127.0.0.1:6463/rpc?v=1',
						Method = 'POST',
						Headers = {
							['Content-Type'] = 'application/json',
							Origin = 'https://discord.com'
						},
						Body = HttpService:JSONEncode({
							cmd = 'INVITE_BROWSER',
							nonce = HttpService:GenerateGUID(false),
							args = {code = Settings.Discord.Invite}
						})
					})
				end)
			end

			if Settings.Discord.RememberJoins then -- We do logic this way so if the developer changes this setting, the user still won't be prompted, only new users
				callSafely(writefile, RayfieldFolder.."/Discord Invites".."/"..Settings.Discord.Invite..ConfigurationExtension,"Rayfield RememberJoins is true for this invite, this invite will not ask you to join again")
			end
		end
	end

	if (Settings.KeySystem) then
		if not Settings.KeySettings then
			Passthrough = true
			return
		end

		ensureFolder(RayfieldFolder.."/Key System")

		if typeof(Settings.KeySettings.Key) == "string" then Settings.KeySettings.Key = {Settings.KeySettings.Key} end

		if Settings.KeySettings.GrabKeyFromSite then
			for i, Key in ipairs(Settings.KeySettings.Key) do
				local Success, Response = pcall(function()
					Settings.KeySettings.Key[i] = tostring(game:HttpGet(Key):gsub("[\n\r]", " "))
					Settings.KeySettings.Key[i] = string.gsub(Settings.KeySettings.Key[i], " ", "")
				end)
				if not Success then
					print("Rayfield | "..Key.." Error " ..tostring(Response))
					warn('Check docs.sirius.menu for help with Rayfield specific development.')
				end
			end
		end

		if not Settings.KeySettings.FileName then
			Settings.KeySettings.FileName = "No file name specified"
		end

		if callSafely(isfile, RayfieldFolder.."/Key System".."/"..Settings.KeySettings.FileName..ConfigurationExtension) then
			for _, MKey in ipairs(Settings.KeySettings.Key) do
				local savedKeys = callSafely(readfile, RayfieldFolder.."/Key System".."/"..Settings.KeySettings.FileName..ConfigurationExtension)
				if savedKeys and string.find(savedKeys, MKey) then
					Passthrough = true
				end
			end
		end

		if not Passthrough then
			local AttemptsRemaining = math.random(2, 5)
			Rayfield.Enabled = false
			local KeyUI = useStudio and script.Parent:FindFirstChild('Key') or game:GetObjects("rbxassetid://11380036235")[1]

			KeyUI.Enabled = true

			local keyUiContainer = nil
			if Compatibility and type(Compatibility.protectAndParent) == "function" then
				keyUiContainer = Compatibility.protectAndParent(KeyUI, nil, {
					useStudio = useStudio
				})
			elseif not useStudio then
				KeyUI.Parent = CoreGui
				keyUiContainer = CoreGui
			end

			if Compatibility and type(Compatibility.dedupeGuiByName) == "function" then
				Compatibility.dedupeGuiByName(keyUiContainer, KeyUI.Name, KeyUI, "-Old")
			elseif not useStudio and keyUiContainer then
				for _, Interface in ipairs(keyUiContainer:GetChildren()) do
					if Interface.Name == KeyUI.Name and Interface ~= KeyUI then
						Interface.Enabled = false
						Interface.Name = "KeyUI-Old"
					end
				end
			end

			local KeyMain = KeyUI.Main
			KeyMain.Title.Text = Settings.KeySettings.Title or Settings.Name
			KeyMain.Subtitle.Text = Settings.KeySettings.Subtitle or "Key System"
			KeyMain.NoteMessage.Text = Settings.KeySettings.Note or "No instructions"

			KeyMain.Size = UDim2.new(0, 467, 0, 175)
			KeyMain.BackgroundTransparency = 1
			KeyMain.Shadow.Image.ImageTransparency = 1
			KeyMain.Title.TextTransparency = 1
			KeyMain.Subtitle.TextTransparency = 1
			KeyMain.KeyNote.TextTransparency = 1
			KeyMain.Input.BackgroundTransparency = 1
			KeyMain.Input.UIStroke.Transparency = 1
			KeyMain.Input.InputBox.TextTransparency = 1
			KeyMain.NoteTitle.TextTransparency = 1
			KeyMain.NoteMessage.TextTransparency = 1
			KeyMain.Hide.ImageTransparency = 1

			Animation:Create(KeyMain, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0}):Play()
			Animation:Create(KeyMain, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Size = UDim2.new(0, 500, 0, 187)}):Play()
			Animation:Create(KeyMain.Shadow.Image, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {ImageTransparency = 0.5}):Play()
			task.wait(0.05)
			Animation:Create(KeyMain.Title, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {TextTransparency = 0}):Play()
			Animation:Create(KeyMain.Subtitle, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {TextTransparency = 0}):Play()
			task.wait(0.05)
			Animation:Create(KeyMain.KeyNote, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {TextTransparency = 0}):Play()
			Animation:Create(KeyMain.Input, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0}):Play()
			Animation:Create(KeyMain.Input.UIStroke, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {Transparency = 0}):Play()
			Animation:Create(KeyMain.Input.InputBox, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {TextTransparency = 0}):Play()
			task.wait(0.05)
			Animation:Create(KeyMain.NoteTitle, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {TextTransparency = 0}):Play()
			Animation:Create(KeyMain.NoteMessage, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {TextTransparency = 0}):Play()
			task.wait(0.15)
			Animation:Create(KeyMain.Hide, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {ImageTransparency = 0.3}):Play()


			KeyUI.Main.Input.InputBox.FocusLost:Connect(function()
				if #KeyUI.Main.Input.InputBox.Text == 0 then return end
				local KeyFound = false
				local FoundKey = ''
				for _, MKey in ipairs(Settings.KeySettings.Key) do
					--if string.find(KeyMain.Input.InputBox.Text, MKey) then
					--	KeyFound = true
					--	FoundKey = MKey
					--end


					-- stricter key check
					if KeyMain.Input.InputBox.Text == MKey then
						KeyFound = true
						FoundKey = MKey
					end
				end
				if KeyFound then 
					Animation:Create(KeyMain, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundTransparency = 1}):Play()
					Animation:Create(KeyMain, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Size = UDim2.new(0, 467, 0, 175)}):Play()
					Animation:Create(KeyMain.Shadow.Image, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {ImageTransparency = 1}):Play()
					Animation:Create(KeyMain.Title, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
					Animation:Create(KeyMain.Subtitle, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
					Animation:Create(KeyMain.KeyNote, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
					Animation:Create(KeyMain.Input, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {BackgroundTransparency = 1}):Play()
					Animation:Create(KeyMain.Input.UIStroke, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {Transparency = 1}):Play()
					Animation:Create(KeyMain.Input.InputBox, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
					Animation:Create(KeyMain.NoteTitle, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
					Animation:Create(KeyMain.NoteMessage, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
					Animation:Create(KeyMain.Hide, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {ImageTransparency = 1}):Play()
					task.wait(0.51)
					Passthrough = true
					KeyMain.Visible = false
					if Settings.KeySettings.SaveKey then
						callSafely(writefile, RayfieldFolder.."/Key System".."/"..Settings.KeySettings.FileName..ConfigurationExtension, FoundKey)
						RayfieldLibrary:Notify({Title = "Key System", Content = "The key for this script has been saved successfully.", Image = 3605522284})
					end
				else
					if AttemptsRemaining == 0 then
						Animation:Create(KeyMain, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundTransparency = 1}):Play()
						Animation:Create(KeyMain, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Size = UDim2.new(0, 467, 0, 175)}):Play()
						Animation:Create(KeyMain.Shadow.Image, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {ImageTransparency = 1}):Play()
						Animation:Create(KeyMain.Title, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
						Animation:Create(KeyMain.Subtitle, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
						Animation:Create(KeyMain.KeyNote, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
						Animation:Create(KeyMain.Input, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {BackgroundTransparency = 1}):Play()
						Animation:Create(KeyMain.Input.UIStroke, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {Transparency = 1}):Play()
						Animation:Create(KeyMain.Input.InputBox, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
						Animation:Create(KeyMain.NoteTitle, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
						Animation:Create(KeyMain.NoteMessage, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
						Animation:Create(KeyMain.Hide, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {ImageTransparency = 1}):Play()
						task.wait(0.45)
						Players.LocalPlayer:Kick("No Attempts Remaining")
						game:Shutdown()
					end
					KeyMain.Input.InputBox.Text = ""
					AttemptsRemaining = AttemptsRemaining - 1
					Animation:Create(KeyMain, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Size = UDim2.new(0, 467, 0, 175)}):Play()
					Animation:Create(KeyMain, TweenInfo.new(0.4, Enum.EasingStyle.Elastic), {Position = UDim2.new(0.495,0,0.5,0)}):Play()
					task.wait(0.1)
					Animation:Create(KeyMain, TweenInfo.new(0.4, Enum.EasingStyle.Elastic), {Position = UDim2.new(0.505,0,0.5,0)}):Play()
					task.wait(0.1)
					Animation:Create(KeyMain, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {Position = UDim2.new(0.5,0,0.5,0)}):Play()
					Animation:Create(KeyMain, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Size = UDim2.new(0, 500, 0, 187)}):Play()
				end
			end)

			KeyMain.Hide.MouseButton1Click:Connect(function()
				Animation:Create(KeyMain, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundTransparency = 1}):Play()
				Animation:Create(KeyMain, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Size = UDim2.new(0, 467, 0, 175)}):Play()
				Animation:Create(KeyMain.Shadow.Image, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {ImageTransparency = 1}):Play()
				Animation:Create(KeyMain.Title, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
				Animation:Create(KeyMain.Subtitle, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
				Animation:Create(KeyMain.KeyNote, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
				Animation:Create(KeyMain.Input, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {BackgroundTransparency = 1}):Play()
				Animation:Create(KeyMain.Input.UIStroke, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {Transparency = 1}):Play()
				Animation:Create(KeyMain.Input.InputBox, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
				Animation:Create(KeyMain.NoteTitle, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
				Animation:Create(KeyMain.NoteMessage, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
				Animation:Create(KeyMain.Hide, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {ImageTransparency = 1}):Play()
				task.wait(0.51)
				RayfieldLibrary:Destroy()
				KeyUI:Destroy()
			end)
		else
			Passthrough = true
		end
	end
	if Settings.KeySystem then
		repeat task.wait() until Passthrough
	end

	Notifications.Template.Visible = false
	Notifications.Visible = true
	Rayfield.Enabled = true

	waitForStartup(0.5)
	Animation:Create(Main, TweenInfo.new(startupTweenDuration(0.7), Enum.EasingStyle.Exponential), {BackgroundTransparency = 0}):Play()
	Animation:Create(Main.Shadow.Image, TweenInfo.new(startupTweenDuration(0.7), Enum.EasingStyle.Exponential), {ImageTransparency = 0.6}):Play()
	waitForStartup(0.1)
	Animation:Create(LoadingFrame.Title, TweenInfo.new(startupTweenDuration(0.7), Enum.EasingStyle.Exponential), {TextTransparency = 0}):Play()
	waitForStartup(0.05)
	Animation:Create(LoadingFrame.Subtitle, TweenInfo.new(startupTweenDuration(0.7), Enum.EasingStyle.Exponential), {TextTransparency = 0}):Play()
	waitForStartup(0.05)
	Animation:Create(LoadingFrame.Version, TweenInfo.new(startupTweenDuration(0.7), Enum.EasingStyle.Exponential), {TextTransparency = 0}):Play()


	Elements.Template.LayoutOrder = 100000
	Elements.Template.Visible = false

	Elements.UIPageLayout.FillDirection = Enum.FillDirection.Horizontal
	TabList.Template.Visible = false

	-- Tab
	local FirstTab = false
	local Window = {}
	ExperienceState.favoritesTabWindow = Window
	ExperienceState.favoritesTab = nil

	-- Recreate tab split system per-window setup to keep references fresh
	if TabSplitSystem and TabSplitSystem.destroy then
		TabSplitSystem.destroy()
		TabSplitSystem = nil
	end

	if ViewportVirtualizationSystem and type(ViewportVirtualizationSystem.destroy) == "function" then
		pcall(ViewportVirtualizationSystem.destroy)
	end
	ViewportVirtualizationSystem = ViewportVirtualizationModuleLib.init({
		Settings = Settings.ViewportVirtualization,
		RunService = RunService,
		TweenService = TweenService,
		UserInputService = UserInputService,
		AnimationEngine = AnimationEngine,
		RootGui = Rayfield,
		warn = function(message)
			warn("Rayfield | ViewportVirtualization " .. tostring(message))
		end
	})
	if _G then
		_G.__RayfieldViewportVirtualization = ViewportVirtualizationSystem
	end

	-- Initialize Elements Module
	if ElementSyncSystem and ElementSyncSystem.destroy then
		ElementSyncSystem.destroy()
	end
	ElementSyncSystem = ElementSyncModuleLib.init({
		warn = function(message)
			warn("Rayfield | ElementSync " .. tostring(message))
		end
	})

	ElementsSystem = ElementsModuleLib.init({
		TweenService = TweenService,
		Animation = Animation,
		RunService = RunService,
		UserInputService = UserInputService,
		HttpService = HttpService,
		Main = Main,
		Topbar = Topbar,
		TabList = TabList,
		Elements = Elements,
		Rayfield = Rayfield,
		RayfieldLibrary = RayfieldLibrary,
		Icons = Icons,
		getIcon = getIcon,
		getAssetUri = getAssetUri,
		getSelectedTheme = function() return SelectedTheme end,
		rayfieldDestroyed = function() return rayfieldDestroyed end,
		getMinimised = function() return Minimised end,
		getSetting = getSetting,
		getInternalSetting = function(category, setting)
			return getSetting(category, setting)
		end,
		setInternalSetting = function(category, setting, value, persist)
			return setSettingValue(category, setting, value, persist)
		end,
		bindTheme = bindTheme,
		SaveConfiguration = SaveConfiguration,
		makeElementDetachable = makeElementDetachable,
		KeybindSequence = KeybindSequenceLib,
		keybindConnections = keybindConnections,
		getDebounce = function() return Debounce end,
		setDebounce = function(val) Debounce = val end,
		useMobileSizing = useMobileSizing,
		ElementSync = ElementSyncSystem,
		ViewportVirtualization = ViewportVirtualizationSystem,
		ResourceOwnership = OwnershipSystem,
		Settings = Settings
	})
	if favoritesRegistryUnsubscribe then
		pcall(favoritesRegistryUnsubscribe)
		favoritesRegistryUnsubscribe = nil
	end
	if ElementsSystem and type(ElementsSystem.subscribeControlRegistry) == "function" then
		favoritesRegistryUnsubscribe = ElementsSystem.subscribeControlRegistry(function(reason)
			if reason == "pin" or reason == "unpin" or reason == "set_pinned_ids" or reason == "control_removed" then
				refreshFavoritesSettingsPersistence()
			end
			if reason == "pin" and ExperienceState.favoritesTabWindow then
				ensureFavoritesTab(ExperienceState.favoritesTabWindow)
			end
			renderFavoritesTab()
		end)
	end

	TabSplitSystem = TabSplitModuleLib.init({
		UserInputService = UserInputService,
		RunService = RunService,
		TweenService = TweenService,
		Animation = Animation,
		HttpService = HttpService,
		Rayfield = Rayfield,
		Main = Main,
		Topbar = Topbar,
		TabList = TabList,
		Elements = Elements,
		getSelectedTheme = function() return SelectedTheme end,
		rayfieldDestroyed = function() return rayfieldDestroyed end,
		useMobileSizing = useMobileSizing,
		Notify = function(data)
			RayfieldLibrary:Notify(data)
		end,
		getBlockedState = function()
			return Debounce or searchOpen
		end,
		onLayoutDirty = function(scope, reason)
			markLayoutDirty(scope, reason)
		end,
		ViewportVirtualization = ViewportVirtualizationSystem,
		enabled = Settings.EnableTabSplit,
		holdDuration = Settings.TabSplitHoldDuration,
		allowSettingsSplit = Settings.AllowSettingsTabSplit,
		maxSplitTabs = Settings.MaxSplitTabs
	})
	TabSplitSystem.syncHidden(Hidden)
	TabSplitSystem.syncMinimized(Minimised)

	if LayoutPersistenceSystem and type(LayoutPersistenceSystem.flush) == "function" then
		LayoutPersistenceSystem.flush("window_recreate")
	end
	LayoutPersistenceSystem = LayoutPersistenceModuleLib.init({
		layoutKey = "__rayfield_layout",
		version = 1,
		getEnabled = function()
			return layoutSavingEnabled == true and CEnabled == true
		end,
		getDebounceMs = function()
			return layoutDebounceMs
		end,
		requestSave = function()
			return SaveConfiguration()
		end
	})
	LayoutPersistenceSystem.registerProvider("main", {
		order = 10,
		snapshot = function()
			if UIStateSystem and type(UIStateSystem.getLayoutSnapshot) == "function" then
				return UIStateSystem.getLayoutSnapshot()
			end
			return nil
		end,
		apply = function(section)
			if UIStateSystem and type(UIStateSystem.applyLayoutSnapshot) == "function" then
				UIStateSystem.applyLayoutSnapshot(section)
			end
		end
	})
	LayoutPersistenceSystem.registerProvider("split", {
		order = 20,
		snapshot = function()
			if TabSplitSystem and type(TabSplitSystem.getLayoutSnapshot) == "function" then
				return TabSplitSystem.getLayoutSnapshot()
			end
			return nil
		end,
		apply = function(section)
			if TabSplitSystem and type(TabSplitSystem.applyLayoutSnapshot) == "function" then
				TabSplitSystem.applyLayoutSnapshot(section)
			end
		end
	})
	LayoutPersistenceSystem.registerProvider("floating", {
		order = 30,
		snapshot = function()
			if DragSystem and type(DragSystem.getLayoutSnapshot) == "function" then
				return DragSystem.getLayoutSnapshot()
			end
			return nil
		end,
		apply = function(section)
			if DragSystem and type(DragSystem.applyLayoutSnapshot) == "function" then
				DragSystem.applyLayoutSnapshot(section)
			end
		end
	})

	if type(ConfigSystem.setLayoutHandlers) == "function" then
		ConfigSystem.setLayoutHandlers(
			function()
				if LayoutPersistenceSystem and type(LayoutPersistenceSystem.getLayoutSnapshot) == "function" then
					return LayoutPersistenceSystem.getLayoutSnapshot()
				end
				return nil
			end,
			function(layoutData)
				if LayoutPersistenceSystem and type(LayoutPersistenceSystem.applyLayoutSnapshot) == "function" then
					return LayoutPersistenceSystem.applyLayoutSnapshot(layoutData)
				end
				return false
			end,
			"__rayfield_layout"
		)
	end

	if DragSystem and type(DragSystem.setLayoutDirtyCallback) == "function" then
		DragSystem.setLayoutDirtyCallback(function(scope, reason)
			markLayoutDirty(scope, reason)
		end)
	end

	if TabSplitSystem and type(TabSplitSystem.setLayoutDirtyCallback) == "function" then
		TabSplitSystem.setLayoutDirtyCallback(function(scope, reason)
			markLayoutDirty(scope, reason)
		end)
	end

	cleanupLayoutConnections()
	if layoutSavingEnabled and CEnabled then
		table.insert(layoutConnections, Main:GetPropertyChangedSignal("Position"):Connect(function()
			markLayoutDirty("main", "position")
		end))
		table.insert(layoutConnections, Main:GetPropertyChangedSignal("Size"):Connect(function()
			if UIStateSystem
				and type(UIStateSystem.setExpandedSize) == "function"
				and type(UIStateSystem.getMinimised) == "function"
				and type(UIStateSystem.getHidden) == "function"
				and not UIStateSystem.getMinimised()
				and not UIStateSystem.getHidden() then
				UIStateSystem.setExpandedSize(Main.Size)
			end
			markLayoutDirty("main", "size")
		end))
	end

	-- Wrapper for Window:CreateTab
	function Window:CreateTab(Name, Image, Ext)
		local tab = ElementsSystem.CreateTab(Name, Image, Ext)
		FirstTab = ElementsSystem.getFirstTab()
		if TabSplitSystem and tab and tab.GetInternalRecord then
			local ok, tabRecord = pcall(function()
				return tab:GetInternalRecord()
			end)
			if ok and tabRecord then
				TabSplitSystem.registerTab(tabRecord)
			end
		end
		return tab
	end

	local function playStartupAnimation()
		Elements.Visible = true

		waitForStartup(1.1)
		Animation:Create(Main, TweenInfo.new(startupTweenDuration(0.7), Enum.EasingStyle.Exponential, Enum.EasingDirection.InOut), {Size = UDim2.new(0, 390, 0, 90)}):Play()
		waitForStartup(0.3)
		Animation:Create(LoadingFrame.Title, TweenInfo.new(startupTweenDuration(0.2), Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
		Animation:Create(LoadingFrame.Subtitle, TweenInfo.new(startupTweenDuration(0.2), Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
		Animation:Create(LoadingFrame.Version, TweenInfo.new(startupTweenDuration(0.2), Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
		waitForStartup(0.1)
		Animation:Create(Main, TweenInfo.new(startupTweenDuration(0.6), Enum.EasingStyle.Exponential, Enum.EasingDirection.Out), {Size = useMobileSizing and UDim2.new(0, 500, 0, 275) or UDim2.new(0, 500, 0, 475)}):Play()
		Animation:Create(Main.Shadow.Image, TweenInfo.new(startupTweenDuration(0.5), Enum.EasingStyle.Exponential), {ImageTransparency = 0.6}):Play()

		local topbarDivider = Topbar:FindFirstChild("Divider")
		local topbarCornerRepair = Topbar:FindFirstChild("CornerRepair")
		local topbarTitle = Topbar:FindFirstChild("Title")
		local topbarSearch = Topbar:FindFirstChild("Search")
		local topbarSettings = Topbar:FindFirstChild("Settings")
		local topbarChangeSize = Topbar:FindFirstChild("ChangeSize")
		local topbarHide = Topbar:FindFirstChild("Hide")

		Topbar.BackgroundTransparency = 1
		if topbarDivider then
			topbarDivider.Size = UDim2.new(0, 0, 0, 1)
			topbarDivider.BackgroundColor3 = SelectedTheme.ElementStroke
		end
		if topbarCornerRepair then
			topbarCornerRepair.BackgroundTransparency = 1
		end
		if topbarTitle then
			topbarTitle.TextTransparency = 1
		end
		if topbarSearch then
			topbarSearch.ImageTransparency = 1
		end
		if topbarSettings then
			topbarSettings.ImageTransparency = 1
		end
		if topbarChangeSize then
			topbarChangeSize.ImageTransparency = 1
		end
		if topbarHide then
			topbarHide.ImageTransparency = 1
		end

		waitForStartup(0.5)
		Topbar.Visible = true
		TabList.Visible = true
		Animation:Create(Topbar, TweenInfo.new(startupTweenDuration(0.7), Enum.EasingStyle.Exponential), {BackgroundTransparency = 0}):Play()
		if topbarCornerRepair then
			Animation:Create(topbarCornerRepair, TweenInfo.new(startupTweenDuration(0.7), Enum.EasingStyle.Exponential), {BackgroundTransparency = 0}):Play()
		end
		waitForStartup(0.1)
		if topbarDivider then
			Animation:Create(topbarDivider, TweenInfo.new(startupTweenDuration(1), Enum.EasingStyle.Exponential), {Size = UDim2.new(1, 0, 0, 1)}):Play()
		end
		if topbarTitle then
			Animation:Create(topbarTitle, TweenInfo.new(startupTweenDuration(0.6), Enum.EasingStyle.Exponential), {TextTransparency = 0}):Play()
		end
		waitForStartup(0.05)
		if topbarSearch then
			Animation:Create(topbarSearch, TweenInfo.new(startupTweenDuration(0.6), Enum.EasingStyle.Exponential), {ImageTransparency = 0.8}):Play()
		end
		waitForStartup(0.05)
		if topbarSettings then
			Animation:Create(topbarSettings, TweenInfo.new(startupTweenDuration(0.6), Enum.EasingStyle.Exponential), {ImageTransparency = 0.8}):Play()
			waitForStartup(0.05)
		end
		if topbarChangeSize then
			Animation:Create(topbarChangeSize, TweenInfo.new(startupTweenDuration(0.6), Enum.EasingStyle.Exponential), {ImageTransparency = 0.8}):Play()
			waitForStartup(0.05)
		end
		if topbarHide then
			Animation:Create(topbarHide, TweenInfo.new(startupTweenDuration(0.6), Enum.EasingStyle.Exponential), {ImageTransparency = 0.8}):Play()
		end
		waitForStartup(0.3)

		if dragBar and dragBarCosmetic then
			Animation:Create(dragBarCosmetic, TweenInfo.new(startupTweenDuration(0.6), Enum.EasingStyle.Exponential), {BackgroundTransparency = 0.7}):Play()
		end

		LoadingFrame.Visible = false
		Topbar.Visible = true
		TabList.Visible = true
		Elements.Visible = true
	end

	function Window.ModifyTheme(NewTheme)
		local success = pcall(ChangeTheme, NewTheme)
		if not success then
			RayfieldLibrary:Notify({Title = 'Unable to Change Theme', Content = 'We are unable find a theme on file.', Image = 4400704299})
		else
			RayfieldLibrary:Notify({Title = 'Theme Changed', Content = 'Successfully changed theme to '..(typeof(NewTheme) == 'string' and NewTheme or 'Custom Theme')..'.', Image = 4483362748})
		end
	end

	local success, result = pcall(function()
		createSettings(Window)
	end)

	if not success then warn('Rayfield had an issue creating settings.') end

	local function restoreExperienceStateSafely()
		local okRestore, restoreErr = pcall(function()
			restoreExperienceStateFromSettings(Window)
		end)
		if not okRestore then
			warn("Rayfield | Failed to restore experience settings: " .. tostring(restoreErr))
		end
	end
	restoreExperienceStateSafely()
	task.delay(0.9, restoreExperienceStateSafely)

	local startupSuccess, startupResult = pcall(function()
		playStartupAnimation()
	end)
	if not startupSuccess then
		warn("Rayfield had an issue during startup animation: " .. tostring(startupResult))
		LoadingFrame.Visible = false
		Topbar.Visible = true
		TabList.Visible = true
		Elements.Visible = true
	end

	maybeNotifyLoaderFallback()

	task.delay(1.1, function()
		if not ExperienceState.onboardingRendered and not ExperienceState.onboardingSuppressed then
			RayfieldLibrary:ShowOnboarding(false)
		end
	end)

	return Window
end

local function setVisibility(visibility: boolean, notify: boolean?)
	if UtilitiesSystem then
		UtilitiesSystem.setVisibility(visibility, notify)
		Hidden = not visibility
		if TabSplitSystem then
			TabSplitSystem.syncHidden(Hidden)
		end
		markLayoutDirty("main", visibility and "set_visible_true" or "set_visible_false")
	end
end

function RayfieldLibrary:SetVisibility(visibility: boolean)
	setVisibility(visibility, false)
end

function RayfieldLibrary:IsVisible(): boolean
	return not Hidden
end

local hideHotkeyConnection -- Has to be initialized here since the connection is made later in the script
function RayfieldLibrary:Destroy()
	AnimationEngine:SetUiSuppressed(true)
	detachPathEnabled = true
	activePerformanceProfile = {
		enabled = false,
		requestedMode = "normal",
		resolvedMode = "normal",
		aggressive = false,
		disableDetach = false,
		disableTabSplit = false,
		disableAnimations = false,
		appliedFields = {}
	}
	cleanupLayoutConnections()
	if LayoutPersistenceSystem and type(LayoutPersistenceSystem.flush) == "function" then
		pcall(LayoutPersistenceSystem.flush, "destroy")
	end
	-- Cleanup theme connections to prevent memory leaks on reload
	if ThemeSystem and ThemeSystem.cleanup then
		ThemeSystem.cleanup()
	end
	if TabSplitSystem and TabSplitSystem.destroy then
		TabSplitSystem.destroy()
		TabSplitSystem = nil
	end
	if favoritesRegistryUnsubscribe then
		pcall(favoritesRegistryUnsubscribe)
		favoritesRegistryUnsubscribe = nil
	end
	if OwnershipSystem and type(OwnershipSystem.cleanupSession) == "function" then
		pcall(OwnershipSystem.cleanupSession, {
			destroyInstances = false,
			clearAttributes = true,
			sweepRoot = false
		})
	end
	if UtilitiesSystem then
		UtilitiesSystem.destroy(hideHotkeyConnection)
	end
	if AnimationEngine and AnimationEngine.Destroy then
		AnimationEngine:Destroy()
	end
	if ElementSyncSystem and ElementSyncSystem.destroy then
		ElementSyncSystem.destroy()
		ElementSyncSystem = nil
	end
	if ViewportVirtualizationSystem and type(ViewportVirtualizationSystem.destroy) == "function" then
		pcall(ViewportVirtualizationSystem.destroy)
		ViewportVirtualizationSystem = nil
	end
	if _G then
		_G.__RayfieldViewportVirtualization = nil
		_G.__RayfieldOwnership = nil
	end
	if ExperienceState.onboardingOverlay and ExperienceState.onboardingOverlay.Root and ExperienceState.onboardingOverlay.Root.Parent then
		ExperienceState.onboardingOverlay.Root:Destroy()
	end
	ExperienceState.onboardingOverlay = nil
	ExperienceState.favoritesTab = nil
	ExperienceState.favoritesTabWindow = nil
	ExperienceState.onboardingRendered = false
	experienceSuppressPromoPrompts = false
	LayoutPersistenceSystem = nil

	-- Reset global runtime/cache flags so the next execution reloads a fresh UI tree.
	pcall(function()
		if getgenv then
			local env = getgenv()
			env.rayfieldCached = nil
		end
	end)
	_G.Rayfield = nil
	_G.RayfieldUI = nil
	_G.RayfieldAllInOneLoaded = nil
	if type(_G.RayfieldCache) == "table" then
		table.clear(_G.RayfieldCache)
	end
	if type(_G.__RayfieldApiModuleCache) == "table" then
		table.clear(_G.__RayfieldApiModuleCache)
	end
	OwnershipSystem = nil
end

function RayfieldLibrary:IsDestroyed(): boolean
	if rayfieldDestroyed then
		return true
	end
	local ok, parent = pcall(function()
		return Rayfield.Parent
	end)
	return (not ok) or parent == nil
end

Topbar.ChangeSize.MouseButton1Click:Connect(function()
	if Debounce then return end
	if Minimised then
		Minimised = false
		Maximise()
	else
		Minimised = true
		Minimise()
	end
end)

Main.Search.Input:GetPropertyChangedSignal('Text'):Connect(function()
	if #Main.Search.Input.Text > 0 then
		if not Elements.UIPageLayout.CurrentPage:FindFirstChild('SearchTitle-fsefsefesfsefesfesfThanks') then 
			local searchTitle = Elements.Template.SectionTitle:Clone()
			searchTitle.Parent = Elements.UIPageLayout.CurrentPage
			searchTitle.Name = 'SearchTitle-fsefsefesfsefesfesfThanks'
			searchTitle.LayoutOrder = -100
			searchTitle.Title.Text = "Results from '"..Elements.UIPageLayout.CurrentPage.Name.."'"
			searchTitle.Visible = true
		end
	else
		local searchTitle = Elements.UIPageLayout.CurrentPage:FindFirstChild('SearchTitle-fsefsefesfsefesfesfThanks')

		if searchTitle then
			searchTitle:Destroy()
		end
	end

	for _, element in ipairs(Elements.UIPageLayout.CurrentPage:GetChildren()) do
		if element.ClassName ~= 'UIListLayout' and element.Name ~= 'Placeholder' and element.Name ~= 'SearchTitle-fsefsefesfsefesfesfThanks' then
			if element.Name == 'SectionTitle' then
				if #Main.Search.Input.Text == 0 then
					element.Visible = true
				else
					element.Visible = false
				end
			else
				if string.lower(element.Name):find(string.lower(Main.Search.Input.Text), 1, true) then
					element.Visible = true
				else
					element.Visible = false
				end
			end
		end
	end
end)

Main.Search.Input.FocusLost:Connect(function(enterPressed)
	if #Main.Search.Input.Text == 0 and searchOpen then
		task.wait(0.12)
		closeSearch()
	end
end)

Topbar.Search.MouseButton1Click:Connect(function()
	task.spawn(function()
		if searchOpen then
			closeSearch()
		else
			openSearch()
		end
	end)
end)

if Topbar:FindFirstChild('Settings') then
	Topbar.Settings.MouseButton1Click:Connect(function()
		task.spawn(function()
			for _, OtherTabButton in ipairs(TabList:GetChildren()) do
				if OtherTabButton.Name ~= "Template" and OtherTabButton.ClassName == "Frame" and OtherTabButton ~= TabButton and OtherTabButton.Name ~= "Placeholder" then
					Animation:Create(OtherTabButton, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {BackgroundColor3 = SelectedTheme.TabBackground}):Play()
					Animation:Create(OtherTabButton.Title, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {TextColor3 = SelectedTheme.TabTextColor}):Play()
					Animation:Create(OtherTabButton.Image, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {ImageColor3 = SelectedTheme.TabTextColor}):Play()
					Animation:Create(OtherTabButton, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0.7}):Play()
					Animation:Create(OtherTabButton.Title, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {TextTransparency = 0.2}):Play()
					Animation:Create(OtherTabButton.Image, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {ImageTransparency = 0.2}):Play()
					Animation:Create(OtherTabButton.UIStroke, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {Transparency = 0.5}):Play()
				end
			end

			local settingsPage = Elements:FindFirstChild("Rayfield Settings")
			if settingsPage then
				Elements.UIPageLayout:JumpTo(settingsPage)
			else
				RayfieldLibrary:Notify({
					Title = "Settings Tab",
					Content = "Settings tab is currently split. Dock it back to open from topbar.",
					Duration = 3
				})
			end
		end)
	end)

end


Topbar.Hide.MouseButton1Click:Connect(function()
	setVisibility(Hidden, not useMobileSizing)
end)

hideHotkeyConnection = UserInputService.InputBegan:Connect(function(input, processed)
	if processed then
		return
	end

	local currentBinding = getSetting("General", "rayfieldOpen")
	local uiBindingSpec = resolveUiToggleKeybindSpec(currentBinding)
	if not uiBindingSpec then
		return
	end

	local matched = uiToggleKeybindMatcher:consume(input, uiBindingSpec, UserInputService, processed)
	if matched then
		if Debounce then return end
		if Hidden then
			Hidden = false
			Unhide()
		else
			Hidden = true
			Hide()
		end
	end
end)
if OwnershipSystem and type(OwnershipSystem.trackConnection) == "function" then
	pcall(OwnershipSystem.trackConnection, hideHotkeyConnection, "runtime:hotkeys")
end

if MPrompt then
	MPrompt.Interact.MouseButton1Click:Connect(function()
		if Debounce then return end
		if Hidden then
			Hidden = false
			Unhide()
		end
	end)
end

for _, TopbarButton in ipairs(Topbar:GetChildren()) do
	if TopbarButton.ClassName == "ImageButton" and TopbarButton.Name ~= 'Icon' then
		TopbarButton.MouseEnter:Connect(function()
			Animation:Create(TopbarButton, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {ImageTransparency = 0}):Play()
		end)

		TopbarButton.MouseLeave:Connect(function()
			Animation:Create(TopbarButton, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {ImageTransparency = 0.8}):Play()
		end)
	end
end


function RayfieldLibrary:LoadConfiguration()
	local config

	if debugX then
		warn('Loading Configuration')
	end

	if useStudio then
		config = [[{"Toggle1adwawd":true,"ColorPicker1awd":{"B":255,"G":255,"R":255},"Slider1dawd":100,"ColorPicfsefker1":{"B":255,"G":255,"R":255},"Slidefefsr1":80,"dawdawd":"","Input1":"hh","Keybind1":"B","Dropdown1":["Ocean"]}]]
	end

	if CEnabled then
		local notified
		local loaded

		local success, result = pcall(function()
			if useStudio and config then
				loaded = LoadConfiguration(config)
				return
			end

			if isfile then 
				if callSafely(isfile, ConfigurationFolder .. "/" .. CFileName .. ConfigurationExtension) then
					loaded = LoadConfiguration(callSafely(readfile, ConfigurationFolder .. "/" .. CFileName .. ConfigurationExtension))
				end
			else
				notified = true
				RayfieldLibrary:Notify({Title = "Rayfield Configurations", Content = "We couldn't enable Configuration Saving as you are not using software with filesystem support.", Image = 4384402990})
			end
		end)

		if success and loaded and not notified then
			RayfieldLibrary:Notify({Title = "Rayfield Configurations", Content = "The configuration file for this script has been loaded from a previous session.", Image = 4384403532})
		elseif not success and not notified then
			warn('Rayfield Configurations Error | '..tostring(result))
			RayfieldLibrary:Notify({Title = "Rayfield Configurations", Content = "We've encountered an issue loading your configuration correctly.\n\nCheck the Developer Console for more information.", Image = 4384402990})
		end
	end

	globalLoaded = true
end



if useStudio then
	-- run w/ studio
	-- Feel free to place your own script here to see how it'd work in Roblox Studio before running it on your execution software.


	--local Window = RayfieldLibrary:CreateWindow({
	--	Name = "Rayfield Example Window",
	--	LoadingTitle = "Rayfield Interface Suite",
	--	Theme = 'Default',
	--	Icon = 0,
	--	LoadingSubtitle = "by Sirius",
	--	ConfigurationSaving = {
	--		Enabled = true,
	--		FolderName = nil, -- Create a custom folder for your hub/game
	--		FileName = "Big Hub52"
	--	},
	--	Discord = {
	--		Enabled = false,
	--		Invite = "noinvitelink", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ABCD would be ABCD
	--		RememberJoins = true -- Set this to false to make them join the discord every time they load it up
	--	},
	--	KeySystem = false, -- Set this to true to use our key system
	--	KeySettings = {
	--		Title = "Untitled",
	--		Subtitle = "Key System",
	--		Note = "No method of obtaining the key is provided",
	--		FileName = "Key", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
	--		SaveKey = true, -- The user's key will be saved, but if you change the key, they will be unable to use your script
	--		GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
	--		Key = {"Hello"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
	--	}
	--})

	--local Tab = Window:CreateTab("Tab Example", 'key-round') -- Title, Image
	--local Tab2 = Window:CreateTab("Tab Example 2", 4483362458) -- Title, Image

	--local Section = Tab2:CreateSection("Section")


	--local ColorPicker = Tab2:CreateColorPicker({
	--	Name = "Color Picker",
	--	Color = Color3.fromRGB(255,255,255),
	--	Flag = "ColorPicfsefker1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	--	Callback = function(Value)
	--		-- The function that takes place every time the color picker is moved/changed
	--		-- The variable (Value) is a Color3fromRGB value based on which color is selected
	--	end
	--})

	--local Slider = Tab2:CreateSlider({
	--	Name = "Slider Example",
	--	Range = {0, 100},
	--	Increment = 10,
	--	Suffix = "Bananas",
	--	CurrentValue = 40,
	--	Flag = "Slidefefsr1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	--	Callback = function(Value)
	--		-- The function that takes place when the slider changes
	--		-- The variable (Value) is a number which correlates to the value the slider is currently at
	--	end,
	--})

	--local Input = Tab2:CreateInput({
	--	Name = "Input Example",
	--	CurrentValue = '',
	--	PlaceholderText = "Input Placeholder",
	--	Flag = 'dawdawd',
	--	RemoveTextAfterFocusLost = false,
	--	Callback = function(Text)
	--		-- The function that takes place when the input is changed
	--		-- The variable (Text) is a string for the value in the text box
	--	end,
	--})


	----RayfieldLibrary:Notify({Title = "Rayfield Interface", Content = "Welcome to Rayfield. These - are the brand new notification design for Rayfield, with custom sizing and Rayfield calculated wait times.", Image = 4483362458})

	--local Section = Tab:CreateSection("Section Example")

	--local Button = Tab:CreateButton({
	--	Name = "Change Theme",
	--	Callback = function()
	--		-- The function that takes place when the button is pressed
	--		Window.ModifyTheme('DarkBlue')
	--	end,
	--})

	--local Toggle = Tab:CreateToggle({
	--	Name = "Toggle Example",
	--	CurrentValue = false,
	--	Flag = "Toggle1adwawd", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	--	Callback = function(Value)
	--		-- The function that takes place when the toggle is pressed
	--		-- The variable (Value) is a boolean on whether the toggle is true or false
	--	end,
	--})

	--local ColorPicker = Tab:CreateColorPicker({
	--	Name = "Color Picker",
	--	Color = Color3.fromRGB(255,255,255),
	--	Flag = "ColorPicker1awd", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	--	Callback = function(Value)
	--		-- The function that takes place every time the color picker is moved/changed
	--		-- The variable (Value) is a Color3fromRGB value based on which color is selected
	--	end
	--})

	--local Slider = Tab:CreateSlider({
	--	Name = "Slider Example",
	--	Range = {0, 100},
	--	Increment = 10,
	--	Suffix = "Bananas",
	--	CurrentValue = 40,
	--	Flag = "Slider1dawd", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	--	Callback = function(Value)
	--		-- The function that takes place when the slider changes
	--		-- The variable (Value) is a number which correlates to the value the slider is currently at
	--	end,
	--})

	--local Input = Tab:CreateInput({
	--	Name = "Input Example",
	--	CurrentValue = "Helo",
	--	PlaceholderText = "Adaptive Input",
	--	RemoveTextAfterFocusLost = false,
	--	Flag = 'Input1',
	--	Callback = function(Text)
	--		-- The function that takes place when the input is changed
	--		-- The variable (Text) is a string for the value in the text box
	--	end,
	--})

	--local thoptions = {}
	--for themename, theme in pairs(RayfieldLibrary.Theme) do
	--	table.insert(thoptions, themename)
	--end

	--local Dropdown = Tab:CreateDropdown({
	--	Name = "Theme",
	--	Options = thoptions,
	--	CurrentOption = {"Default"},
	--	MultipleOptions = false,
	--	Flag = "Dropdown1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	--	Callback = function(Options)
	--		--Window.ModifyTheme(Options[1])
	--		-- The function that takes place when the selected option is changed
	--		-- The variable (Options) is a table of strings for the current selected options
	--	end,
	--})


	--Window.ModifyTheme({
	--	TextColor = Color3.fromRGB(50, 55, 60),
	--	Background = Color3.fromRGB(240, 245, 250),
	--	Topbar = Color3.fromRGB(215, 225, 235),
	--	Shadow = Color3.fromRGB(200, 210, 220),

	--	NotificationBackground = Color3.fromRGB(210, 220, 230),
	--	NotificationActionsBackground = Color3.fromRGB(225, 230, 240),

	--	TabBackground = Color3.fromRGB(200, 210, 220),
	--	TabStroke = Color3.fromRGB(180, 190, 200),
	--	TabBackgroundSelected = Color3.fromRGB(175, 185, 200),
	--	TabTextColor = Color3.fromRGB(50, 55, 60),
	--	SelectedTabTextColor = Color3.fromRGB(30, 35, 40),

	--	ElementBackground = Color3.fromRGB(210, 220, 230),
	--	ElementBackgroundHover = Color3.fromRGB(220, 230, 240),
	--	SecondaryElementBackground = Color3.fromRGB(200, 210, 220),
	--	ElementStroke = Color3.fromRGB(190, 200, 210),
	--	SecondaryElementStroke = Color3.fromRGB(180, 190, 200),

	--	SliderBackground = Color3.fromRGB(200, 220, 235),  -- Lighter shade
	--	SliderProgress = Color3.fromRGB(70, 130, 180),
	--	SliderStroke = Color3.fromRGB(150, 180, 220),

	--	ToggleBackground = Color3.fromRGB(210, 220, 230),
	--	ToggleEnabled = Color3.fromRGB(70, 160, 210),
	--	ToggleDisabled = Color3.fromRGB(180, 180, 180),
	--	ToggleEnabledStroke = Color3.fromRGB(60, 150, 200),
	--	ToggleDisabledStroke = Color3.fromRGB(140, 140, 140),
	--	ToggleEnabledOuterStroke = Color3.fromRGB(100, 120, 140),
	--	ToggleDisabledOuterStroke = Color3.fromRGB(120, 120, 130),

	--	DropdownSelected = Color3.fromRGB(220, 230, 240),
	--	DropdownUnselected = Color3.fromRGB(200, 210, 220),

	--	InputBackground = Color3.fromRGB(220, 230, 240),
	--	InputStroke = Color3.fromRGB(180, 190, 200),
	--	PlaceholderColor = Color3.fromRGB(150, 150, 150)
	--})

	--local Keybind = Tab:CreateKeybind({
	--	Name = "Keybind Example",
	--	CurrentKeybind = "Q",
	--	HoldToInteract = false,
	--	Flag = "Keybind1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	--	Callback = function(Keybind)
	--		-- The function that takes place when the keybind is pressed
	--		-- The variable (Keybind) is a boolean for whether the keybind is being held or not (HoldToInteract needs to be true)
	--	end,
	--})

	--local Label = Tab:CreateLabel("Label Example")

	--local Label2 = Tab:CreateLabel("Warning", 4483362458, Color3.fromRGB(255, 159, 49),  true)

	--local Paragraph = Tab:CreateParagraph({Title = "Paragraph Example", Content = "Paragraph ExampleParagraph ExampleParagraph ExampleParagraph ExampleParagraph ExampleParagraph ExampleParagraph ExampleParagraph ExampleParagraph ExampleParagraph ExampleParagraph ExampleParagraph ExampleParagraph ExampleParagraph Example"})
end

if CEnabled and Main:FindFirstChild('Notice') then
	Main.Notice.BackgroundTransparency = 1
	Main.Notice.Title.TextTransparency = 1
	Main.Notice.Size = UDim2.new(0, 0, 0, 0)
	Main.Notice.Position = UDim2.new(0.5, 0, 0, -100)
	Main.Notice.Visible = true


	Animation:Create(Main.Notice, TweenInfo.new(0.5, Enum.EasingStyle.Exponential, Enum.EasingDirection.InOut), {Size = UDim2.new(0, 280, 0, 35), Position = UDim2.new(0.5, 0, 0, -50), BackgroundTransparency = 0.5}):Play()
	Animation:Create(Main.Notice.Title, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {TextTransparency = 0.1}):Play()
end
-- AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA why :(
--if not useStudio then
--	task.spawn(loadWithTimeout, "https://raw.githubusercontent.com/SiriusSoftwareLtd/Sirius/refs/heads/request/boost.lua")
--end

task.delay(4, function()
	RayfieldLibrary.LoadConfiguration()
	if Main:FindFirstChild('Notice') and Main.Notice.Visible then
		Animation:Create(Main.Notice, TweenInfo.new(0.5, Enum.EasingStyle.Exponential, Enum.EasingDirection.InOut), {Size = UDim2.new(0, 100, 0, 25), Position = UDim2.new(0.5, 0, 0, -100), BackgroundTransparency = 1}):Play()
		Animation:Create(Main.Notice.Title, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()

		task.wait(0.5)
		Main.Notice.Visible = false
	end
end)

return RayfieldLibrary
]=])
put("src/services/compatibility.lua", [[local Compatibility = {}

local DEFAULT_RUNTIME_ROOT = "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"

local function safePcall(fn, ...)
	local ok, result = pcall(fn, ...)
	if ok then
		return result
	end
	return nil
end

function Compatibility.getCompileString()
	local compileString = loadstring or load
	if not compileString then
		error("No Lua compiler function available (loadstring/load)")
	end
	return compileString
end

function Compatibility.getRuntimeRoot()
	if type(_G) == "table" and type(_G.__RAYFIELD_RUNTIME_ROOT_URL) == "string" and _G.__RAYFIELD_RUNTIME_ROOT_URL ~= "" then
		return _G.__RAYFIELD_RUNTIME_ROOT_URL
	end
	return DEFAULT_RUNTIME_ROOT
end

function Compatibility.getService(name)
	local service = safePcall(function()
		return game:GetService(name)
	end)
	if not service then
		return nil
	end

	if type(cloneref) == "function" then
		local ref = safePcall(cloneref, service)
		if ref then
			return ref
		end
	end

	return service
end

function Compatibility.tryGetHui()
	if type(gethui) == "function" then
		local hui = safePcall(gethui)
		if hui then
			return hui
		end
	end
	return nil
end

function Compatibility.protectGui(guiObject)
	if not guiObject then
		return false
	end

	if type(syn) == "table" and type(syn.protect_gui) == "function" then
		local ok = safePcall(syn.protect_gui, guiObject)
		return ok ~= nil
	end

	if type(protectgui) == "function" then
		local ok = safePcall(protectgui, guiObject)
		return ok ~= nil
	end

	if type(secure_call) == "function" and type(protect_gui) == "function" then
		local ok = safePcall(secure_call, protect_gui, guiObject)
		return ok ~= nil
	end

	return false
end

function Compatibility.getGuiContainer(useStudio, preferredContainer)
	if preferredContainer then
		return preferredContainer
	end

	local coreGui = Compatibility.getService("CoreGui")
	if useStudio then
		return coreGui
	end

	local hui = Compatibility.tryGetHui()
	if hui then
		return hui
	end

	if coreGui then
		local robloxGui = safePcall(function()
			return coreGui:FindFirstChild("RobloxGui")
		end)
		if robloxGui then
			return robloxGui
		end
	end

	return coreGui
end

function Compatibility.protectAndParent(guiObject, preferredContainer, options)
	if not guiObject then
		return nil
	end

	options = options or {}
	local useStudio = options.useStudio == true
	local container = Compatibility.getGuiContainer(useStudio, preferredContainer)

	if not useStudio and not Compatibility.tryGetHui() then
		Compatibility.protectGui(guiObject)
	end

	if container then
		guiObject.Parent = container
	end

	return container
end

function Compatibility.dedupeGuiByName(container, guiName, keepInstance, oldNameSuffix)
	if not (container and guiName) then
		return 0
	end

	local renamedCount = 0
	local suffix = oldNameSuffix or "-Old"
	for _, child in ipairs(container:GetChildren()) do
		if child ~= keepInstance and child.Name == guiName then
			local okEnable = pcall(function()
				child.Enabled = false
			end)
			if not okEnable then
				-- Ignore non-LayerCollector instances sharing same name.
			end
			child.Name = guiName .. suffix
			renamedCount += 1
		end
	end

	return renamedCount
end

if type(_G) == "table" then
	_G.__RayfieldCompatibility = Compatibility
end

return Compatibility

]])
put("src/services/input-dispatcher.lua", [[local Dispatcher = {}

function Dispatcher.new(UserInputService)
	local changed = {}
	local ended = {}
	local conChanged = UserInputService.InputChanged:Connect(function(input)
		for _, cb in pairs(changed) do
			cb(input)
		end
	end)
	local conEnded = UserInputService.InputEnded:Connect(function(input)
		for _, cb in pairs(ended) do
			cb(input)
		end
	end)

	return {
		register = function(_, id, onChanged, onEnded)
			if onChanged then changed[id] = onChanged end
			if onEnded then ended[id] = onEnded end
		end,
		unregister = function(_, id)
			changed[id] = nil
			ended[id] = nil
		end,
		destroy = function()
			table.clear(changed)
			table.clear(ended)
			conChanged:Disconnect()
			conEnded:Disconnect()
		end
	}
end

return Dispatcher
]])
put("src/services/logger.lua", [[local Logger = {}

function Logger.new(config)
	config = config or {}
	local enabled = config.enabled == true
	local prefix = config.prefix or "[Rayfield]"
	return {
		info = function(_, ...)
			if enabled then
				print(prefix, ...)
			end
		end,
		warn = function(_, ...)
			if enabled then
				warn(prefix, ...)
			end
		end
	}
end

return Logger
]])

return {
	name = BUNDLE_NAME,
	count = 32,
	bundle = bundle
}
