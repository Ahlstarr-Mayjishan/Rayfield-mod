-- AUTO-GENERATED by scripts/build-bundle.lua
local bundle = _G.__RAYFIELD_BUNDLE_SOURCES or {}
_G.__RAYFIELD_BUNDLE_SOURCES = bundle
_G.__RAYFIELD_BUNDLE_MODE = "bundle_first"

local function put(path, source)
    bundle[path] = source
end

local BUNDLE_NAME = "rayfield-runtime-core"

put("feature/rayfield-all-in-one.lua", [[local compileString = loadstring or load
if not compileString then
	error("No Lua compiler function available (loadstring/load)")
end

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
local Forward = compileString(game:HttpGet(root .. "src/legacy/forward.lua"))()
return Forward.module("allInOne")
]])
put("Main loader/rayfield-all-in-one.lua", [[local compileString = loadstring or load
if not compileString then
	error("No Lua compiler function available (loadstring/load)")
end

local function compileChunk(source, label)
	if type(source) ~= "string" then
		error("Invalid Lua source for " .. tostring(label) .. ": " .. type(source))
	end
	source = source:gsub("^\239\187\191", "")
	source = source:gsub("^\0+", "")
	local chunk, err = compileString(source)
	if not chunk then
		error("Failed to compile " .. tostring(label) .. ": " .. tostring(err))
	end
	return chunk
end
	
local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
local forwardSource = game:HttpGet(root .. "src/legacy/forward.lua")
if type(forwardSource) == "string" then
	forwardSource = forwardSource:gsub("^\239\187\191", "")
	forwardSource = forwardSource:gsub("^\0+", "")
end
local Forward = compileChunk(forwardSource, "src/legacy/forward.lua")()
return Forward.module("allInOne")
]])
put("Main loader/rayfield-modified.lua", [[local compileString = loadstring or load
if not compileString then
	error("No Lua compiler function available (loadstring/load)")
end

local function compileChunk(source, label)
	if type(source) ~= "string" then
		error("Invalid Lua source for " .. tostring(label) .. ": " .. type(source))
	end
	source = source:gsub("^\239\187\191", "")
	source = source:gsub("^\0+", "")
	local chunk, err = compileString(source)
	if not chunk then
		error("Failed to compile " .. tostring(label) .. ": " .. tostring(err))
	end
	return chunk
end
	
local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
local forwardSource = game:HttpGet(root .. "src/legacy/forward.lua")
if type(forwardSource) == "string" then
	forwardSource = forwardSource:gsub("^\239\187\191", "")
	forwardSource = forwardSource:gsub("^\0+", "")
end
local Forward = compileChunk(forwardSource, "src/legacy/forward.lua")()
return Forward.module("modifiedEntry")
]])
put("src/api/cache.lua", [[local Cache = {}

_G.__RayfieldApiModuleCache = _G.__RayfieldApiModuleCache or {}

function Cache.get(key)
	return _G.__RayfieldApiModuleCache[key]
end

function Cache.set(key, value)
	_G.__RayfieldApiModuleCache[key] = value
	return value
end

function Cache.invalidate(key)
	_G.__RayfieldApiModuleCache[key] = nil
end

function Cache.clear()
	table.clear(_G.__RayfieldApiModuleCache)
end

return Cache
]])
put("src/api/client.lua", [[local Client = {}

local DEFAULT_TIMEOUT = 8

local function getBundleTable()
	if type(_G) ~= "table" or type(_G.__RAYFIELD_BUNDLE_SOURCES) ~= "table" then
		return nil
	end
	return _G.__RAYFIELD_BUNDLE_SOURCES
end

local function getBrokenBundleMap()
	if type(_G) ~= "table" then
		return nil
	end
	if type(_G.__RAYFIELD_BUNDLE_BROKEN_PATHS) ~= "table" then
		_G.__RAYFIELD_BUNDLE_BROKEN_PATHS = {}
	end
	return _G.__RAYFIELD_BUNDLE_BROKEN_PATHS
end

local function sanitizeLuaSource(code)
	if type(code) ~= "string" then
		return code
	end
	code = code:gsub("^\239\187\191", "")
	code = code:gsub("^\0+", "")
	return code
end

local function normalizeUrl(url)
	if type(url) ~= "string" or #url == 0 then
		error("Client.request expected non-empty URL string")
	end
	return url
end

local function resolveBundlePath(url)
	local function urlDecode(value)
		return (value:gsub("%%(%x%x)", function(hex)
			return string.char(tonumber(hex, 16))
		end))
	end

	local runtimeRoot = nil
	if type(_G) == "table" and type(_G.__RAYFIELD_RUNTIME_ROOT_URL) == "string" and _G.__RAYFIELD_RUNTIME_ROOT_URL ~= "" then
		runtimeRoot = _G.__RAYFIELD_RUNTIME_ROOT_URL
	end
	if runtimeRoot and url:sub(1, #runtimeRoot) == runtimeRoot then
		return urlDecode(url:sub(#runtimeRoot + 1))
	end

	local githubPath = url:match("^https?://raw%.githubusercontent%.com/[^/]+/[^/]+/[^/]+/(.+)$")
	if githubPath then
		return urlDecode(githubPath)
	end

	return nil
end

local function tryGetBundledSource(url, opts)
	opts = opts or {}
	if opts.noBundle then
		return nil, nil
	end

	local bundle = getBundleTable()
	if not bundle then
		return nil, nil
	end

	local path = resolveBundlePath(url)
	local broken = getBrokenBundleMap()
	if path and broken and broken[path] then
		return nil, path
	end

	if path then
		local byPath = bundle[path]
		if type(byPath) == "string" and #byPath > 0 then
			return byPath, path
		end
	end

	local byUrl = bundle[url]
	if type(byUrl) == "string" and #byUrl > 0 then
		return byUrl, path
	end

	return nil, path
end

local function resolveSource(url, opts)
	opts = opts or {}
	local bundledSource, bundledPath = tryGetBundledSource(url, opts)
	if bundledSource then
		return bundledSource, true, bundledPath
	end

	local ok, payload = Client.request(url, opts)
	if not ok then
		error(tostring(payload))
	end
	if type(payload) ~= "string" then
		error("Client.fetch expected string payload, got " .. type(payload))
	end
	return payload, false, bundledPath
end

function Client.request(url, opts)
	url = normalizeUrl(url)
	opts = opts or {}
	local timeout = tonumber(opts.timeout) or DEFAULT_TIMEOUT
	local completed = false
	local okResult = false
	local payload = nil

	local worker = task.spawn(function()
		local ok, result = pcall(game.HttpGet, game, url)
		okResult = ok
		payload = result
		completed = true
	end)

	local timeoutThread = task.delay(timeout, function()
		if completed then
			return
		end
		completed = true
		okResult = false
		payload = "Request timed out after " .. tostring(timeout) .. " seconds"
		pcall(task.cancel, worker)
	end)

	while not completed do
		task.wait()
	end

	pcall(task.cancel, timeoutThread)
	return okResult, payload
end

function Client.fetch(url, opts)
	local source = resolveSource(url, opts)
	return source
end

function Client.compile(code)
	if type(code) ~= "string" or #code == 0 then
		error("Client.compile expected non-empty Lua source string")
	end
	code = sanitizeLuaSource(code)
	local compileString = loadstring or load
	if not compileString then
		error("No Lua compiler function available (loadstring/load)")
	end
	return compileString(code)
end

function Client.execute(code)
	return Client.compile(code)()
end

function Client.fetchAndExecute(url, opts)
	opts = opts or {}
	local code, fromBundle, bundlePath = resolveSource(url, opts)
	local okExecute, result = pcall(Client.execute, code)
	if okExecute then
		return result
	end

	if fromBundle then
		local broken = getBrokenBundleMap()
		if broken and bundlePath then
			broken[bundlePath] = true
		end
		local retryOpts = {}
		for key, value in pairs(opts) do
			retryOpts[key] = value
		end
		retryOpts.noBundle = true
		local retryCode = Client.fetch(url, retryOpts)
		return Client.execute(retryCode)
	end

	error(result)
end

if _G then
	_G.__RayfieldApiClient = Client
end

return Client
]])
put("src/api/errors.lua", [[local Errors = {}

function Errors.moduleLoadError(moduleName, attempts)
	attempts = attempts or {}
	local msg = {"Rayfield module load failed: " .. tostring(moduleName)}
	for _, attempt in ipairs(attempts) do
		table.insert(msg, " - " .. tostring(attempt))
	end
	return table.concat(msg, "\n")
end

return Errors
]])
put("src/api/loader.lua", [[local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"

if type(_G) == "table" and type(_G.__RAYFIELD_BUNDLE_SOURCES) == "table" then
	_G.__RAYFIELD_BUNDLE_MODE = _G.__RAYFIELD_BUNDLE_MODE or "bundle_first"
end

local Client = (_G and _G.__RayfieldApiClient)
if not Client then
	local compileString = loadstring or load
	if not compileString then
		error("No Lua compiler function available (loadstring/load)")
	end
	Client = compileString(game:HttpGet(root .. "src/api/client.lua"))()
	if _G then
		_G.__RayfieldApiClient = Client
	end
end

local function loadApiModule(relativePath)
	return Client.fetchAndExecute(root .. relativePath)
end

local Cache = loadApiModule("src/api/cache.lua")
local Resolver = loadApiModule("src/api/resolver.lua")
local Registry = loadApiModule("src/api/registry.lua")
local Errors = loadApiModule("src/api/errors.lua")

local Loader = {}

local function cacheKey(path)
	return tostring(path)
end

local function loadByPath(path)
	local key = cacheKey(path)
	local cached = Cache.get(key)
	if cached ~= nil then
		return cached
	end
	local value = Client.fetchAndExecute(root .. path)
	Cache.set(key, value)
	return value
end

function Loader.load(moduleName, opts)
	opts = opts or {}
	local mapping = Registry[moduleName]
	if not mapping then
		error("Unknown module in registry: " .. tostring(moduleName))
	end

	local attempts = {}

	if opts.tryStudioRequire and Resolver.isStudio() and opts.scriptRef and mapping.studio then
		local required = Resolver.tryRequire(opts.scriptRef, mapping.studio)
		if required ~= nil then
			return required
		end
		table.insert(attempts, "studio require(" .. tostring(mapping.studio) .. ") failed")
	end

	local canonicalPath = mapping.canonical
	local ok, result = pcall(loadByPath, canonicalPath)
	if ok then
		return result
	end
	table.insert(attempts, tostring(canonicalPath) .. ": " .. tostring(result))

	error(Errors.moduleLoadError(moduleName, attempts))
end

function Loader.loadPath(path)
	return loadByPath(path)
end

function Loader.clearCache()
	Cache.clear()
end

return Loader
]])
put("src/api/registry.lua", [[return {
	theme = { canonical = "src/services/theme.lua", legacy = "feature/rayfield-theme.lua", studio = "rayfield-theme" },
	settings = { canonical = "src/services/settings.lua", legacy = "feature/rayfield-settings.lua", studio = "rayfield-settings" },
	elementSync = { canonical = "src/services/element-sync.lua", legacy = "src/services/element-sync.lua", studio = "element-sync" },
	keybindSequence = { canonical = "src/services/keybind-sequence.lua", legacy = "src/services/keybind-sequence.lua", studio = "keybind-sequence" },
	drag = { canonical = "src/feature/drag/init.lua", legacy = "feature/rayfield-drag.lua", studio = "rayfield-drag" },
	uiState = { canonical = "src/core/ui-state.lua", legacy = "feature/rayfield-ui-state.lua", studio = "rayfield-ui-state" },
	elements = { canonical = "src/ui/elements/factory/init.lua", legacy = "feature/rayfield-elements.lua", studio = "rayfield-elements" },
	elementsExtracted = { canonical = "src/ui/elements/widgets/index.lua", legacy = "feature/rayfield-elements-extracted.lua", studio = "rayfield-elements-extracted" },
	widgetsBootstrap = { canonical = "src/ui/elements/widgets/bootstrap.lua", legacy = "src/ui/elements/widgets/bootstrap.lua", studio = "widgets-bootstrap" },
	config = { canonical = "src/services/config.lua", legacy = "feature/rayfield-config.lua", studio = "rayfield-config" },
	utilities = { canonical = "src/services/utilities.lua", legacy = "feature/rayfield-utilities.lua", studio = "rayfield-utilities" },
	tabSplit = { canonical = "src/feature/tabsplit/init.lua", legacy = "feature/rayfield-tab-split.lua", studio = "rayfield-tab-split" },
	miniWindow = { canonical = "src/feature/mini-window/init.lua", legacy = "feature/mini-window-system.lua", studio = "mini-window-system" },
	enhanced = { canonical = "src/feature/enhanced/init.lua", legacy = "feature/rayfield-enhanced.lua", studio = "rayfield-enhanced" },
	advanced = { canonical = "src/feature/enhanced/advanced.lua", legacy = "feature/rayfield-advanced-features.lua", studio = "rayfield-advanced-features" },
	animationEngine = { canonical = "src/core/animation/engine.lua", legacy = "src/core/animation/engine.lua", studio = "animation-engine" },
	animationPublic = { canonical = "src/core/animation/public.lua", legacy = "src/core/animation/public.lua", studio = "animation-public" },
	animationSequence = { canonical = "src/core/animation/sequence.lua", legacy = "src/core/animation/sequence.lua", studio = "animation-sequence" },
	animationUI = { canonical = "src/core/animation/ui.lua", legacy = "src/core/animation/ui.lua", studio = "animation-ui" },
	animationText = { canonical = "src/core/animation/text.lua", legacy = "src/core/animation/text.lua", studio = "animation-text" },
	animationEasing = { canonical = "src/core/animation/easing.lua", legacy = "src/core/animation/easing.lua", studio = "animation-easing" },
	animationCleanup = { canonical = "src/core/animation/cleanup.lua", legacy = "src/core/animation/cleanup.lua", studio = "animation-cleanup" },
	allInOne = { canonical = "src/entry/rayfield-all-in-one.entry.lua", legacy = "Main%20loader/rayfield-all-in-one.lua", studio = "rayfield-all-in-one" },
	modifiedEntry = { canonical = "src/entry/rayfield-modified.entry.lua", legacy = "Main%20loader/rayfield-modified.lua", studio = "rayfield-modified" }
}
]])
put("src/api/resolver.lua", [[local Resolver = {}

local DEFAULT_ROOT = "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"

function Resolver.getRuntimeRoot()
	if _G and type(_G.__RAYFIELD_RUNTIME_ROOT_URL) == "string" and #_G.__RAYFIELD_RUNTIME_ROOT_URL > 0 then
		return _G.__RAYFIELD_RUNTIME_ROOT_URL
	end
	return DEFAULT_ROOT
end

function Resolver.isStudio()
	local ok, runService = pcall(function()
		return game:GetService("RunService")
	end)
	if not ok or not runService then
		return false
	end
	local okStudio, studio = pcall(function()
		return runService:IsStudio()
	end)
	return okStudio and studio or false
end

function Resolver.getCompileString()
	local compileString = loadstring or load
	if not compileString then
		error("No Lua compiler function available (loadstring/load)")
	end
	return compileString
end

function Resolver.tryRequire(scriptRef, moduleName)
	if not scriptRef then
		return nil
	end
	local ok, value = pcall(function()
		return require(scriptRef.Parent[moduleName])
	end)
	if ok then
		return value
	end
	return nil
end

return Resolver
]])
put("src/core/animation/cleanup.lua", [[local Cleanup = {}

local function safeGet(instance, key)
	local ok, value = pcall(function()
		return instance[key]
	end)
	if ok then
		return true, value
	end
	return false, nil
end

function Cleanup.safeDisconnect(connection)
	if not connection then
		return
	end
	pcall(function()
		connection:Disconnect()
	end)
end

function Cleanup.isAlive(instance)
	return typeof(instance) == "Instance" and instance.Parent ~= nil
end

function Cleanup.isVisibleChain(instance)
	if typeof(instance) ~= "Instance" then
		return false
	end

	local current = instance
	while current do
		local isGuiObject = current:IsA("GuiObject")
		local isLayerCollector = current:IsA("LayerCollector")
		if isGuiObject or isLayerCollector then
			local hasVisible, visible = safeGet(current, "Visible")
			if hasVisible and visible == false then
				return false
			end
		end
		current = current.Parent
	end

	return true
end

function Cleanup.bindDestroy(instance, onRemoved)
	if typeof(instance) ~= "Instance" then
		return function() end
	end

	local removed = false
	local connections = {}

	local function fireOnce()
		if removed then
			return
		end
		removed = true
		if type(onRemoved) == "function" then
			pcall(onRemoved)
		end
	end

	table.insert(connections, instance.AncestryChanged:Connect(function(_, parent)
		if parent == nil then
			fireOnce()
		end
	end))

	local hasDestroying = pcall(function()
		return instance.Destroying
	end)
	if hasDestroying then
		table.insert(connections, instance.Destroying:Connect(function()
			fireOnce()
		end))
	end

	return function()
		for _, connection in ipairs(connections) do
			Cleanup.safeDisconnect(connection)
		end
		table.clear(connections)
	end
end

return Cleanup
]])
put("src/core/animation/easing.lua", [[local Easing = {}

Easing.DefaultInfo = TweenInfo.new(0.25, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out)

Easing.Presets = {
	fast = TweenInfo.new(0.12, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
	normal = TweenInfo.new(0.25, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out),
	slow = TweenInfo.new(0.45, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out),
	bounce = TweenInfo.new(0.35, Enum.EasingStyle.Back, Enum.EasingDirection.Out),
}

function Easing.resolve(info)
	if typeof(info) == "TweenInfo" then
		return info
	end
	if type(info) == "string" then
		return Easing.Presets[info] or Easing.DefaultInfo
	end
	return Easing.DefaultInfo
end

return Easing
]])
put("src/core/animation/engine.lua", [[local Engine = {}
Engine.__index = Engine

local DefaultCleanup = {}

function DefaultCleanup.safeDisconnect(connection)
	if not connection then
		return
	end
	pcall(function()
		connection:Disconnect()
	end)
end

function DefaultCleanup.isAlive(instance)
	return typeof(instance) == "Instance" and instance.Parent ~= nil
end

function DefaultCleanup.isVisibleChain(instance)
	if typeof(instance) ~= "Instance" then
		return false
	end
	local current = instance
	while current do
		if current:IsA("GuiObject") or current:IsA("LayerCollector") then
			local ok, visible = pcall(function()
				return current.Visible
			end)
			if ok and visible == false then
				return false
			end
		end
		current = current.Parent
	end
	return true
end

function DefaultCleanup.bindDestroy(instance, onRemoved)
	if typeof(instance) ~= "Instance" then
		return function() end
	end
	local fired = false
	local connections = {}
	local function fire()
		if fired then
			return
		end
		fired = true
		if type(onRemoved) == "function" then
			pcall(onRemoved)
		end
	end
	table.insert(connections, instance.AncestryChanged:Connect(function(_, parent)
		if parent == nil then
			fire()
		end
	end))
	local hasDestroying = pcall(function()
		return instance.Destroying
	end)
	if hasDestroying then
		table.insert(connections, instance.Destroying:Connect(fire))
	end
	return function()
		for _, connection in ipairs(connections) do
			DefaultCleanup.safeDisconnect(connection)
		end
		table.clear(connections)
	end
end

local function countEntries(t)
	local count = 0
	for _, v in pairs(t) do
		if v ~= nil then
			count = count + 1
		end
	end
	return count
end

local function getGoalKey(goals)
	local keys = {}
	for key in pairs(goals or {}) do
		table.insert(keys, tostring(key))
	end
	table.sort(keys)
	if #keys == 0 then
		return "__default"
	end
	return table.concat(keys, "|")
end

function Engine.new(opts)
	opts = opts or {}
	local tweenService = opts.TweenService or game:GetService("TweenService")
	local runService = opts.RunService or game:GetService("RunService")
	local cleanup = opts.Cleanup or DefaultCleanup

	local self = setmetatable({}, Engine)
	self.TweenService = tweenService
	self.RunService = runService
	self.Cleanup = cleanup
	self.Mode = opts.mode or "raw"
	self._uiSuppressed = false
	self._uiSuppressionProvider = opts.uiSuppressionProvider
	self._activeTweens = setmetatable({}, { __mode = "k" })
	self._cleanupHooks = setmetatable({}, { __mode = "k" })
	self._textHandles = setmetatable({}, { __mode = "k" })
	self._textHeartbeat = nil
	return self
end

function Engine:SetUiSuppressionProvider(provider)
	if type(provider) == "function" then
		self._uiSuppressionProvider = provider
	else
		self._uiSuppressionProvider = nil
	end
end

function Engine:IsUiSuppressed()
	if self._uiSuppressed then
		return true
	end
	if type(self._uiSuppressionProvider) == "function" then
		local ok, result = pcall(self._uiSuppressionProvider)
		if ok and result then
			return true
		end
	end
	return false
end

function Engine:SetUiSuppressed(value)
	self._uiSuppressed = value and true or false
	if self._uiSuppressed then
		self:StopAllText()
	end
end

function Engine:_ensureTweenBucket(instance)
	local bucket = self._activeTweens[instance]
	if bucket then
		return bucket
	end

	bucket = {}
	self._activeTweens[instance] = bucket

	if not self._cleanupHooks[instance] then
		self._cleanupHooks[instance] = self.Cleanup.bindDestroy(instance, function()
			self:CancelObject(instance)
			self:StopTextForObject(instance)
		end)
	end

	return bucket
end

function Engine:_releaseTweenBucketIfEmpty(instance)
	local bucket = self._activeTweens[instance]
	if not bucket or next(bucket) ~= nil then
		return
	end
	self._activeTweens[instance] = nil

	local cleanupHook = self._cleanupHooks[instance]
	if cleanupHook then
		pcall(cleanupHook)
	end
	self._cleanupHooks[instance] = nil
end

function Engine:_trackTween(instance, key, tween, cancelPrevious)
	local bucket = self:_ensureTweenBucket(instance)
	if cancelPrevious and bucket[key] and bucket[key] ~= tween then
		pcall(function()
			bucket[key]:Cancel()
		end)
	end

	bucket[key] = tween
	tween.Completed:Connect(function()
		local activeBucket = self._activeTweens[instance]
		if not activeBucket then
			return
		end
		if activeBucket[key] == tween then
			activeBucket[key] = nil
			self:_releaseTweenBucketIfEmpty(instance)
		end
	end)
end

function Engine:Create(instance, tweenInfo, goals, opts)
	opts = opts or {}
	if typeof(instance) ~= "Instance" then
		return nil
	end
	if typeof(tweenInfo) ~= "TweenInfo" then
		return nil
	end
	if type(goals) ~= "table" then
		return nil
	end

	local tween = self.TweenService:Create(instance, tweenInfo, goals)

	if opts.track then
		local key = opts.key
		if key == nil then
			key = getGoalKey(goals)
		end
		self:_trackTween(instance, tostring(key), tween, opts.cancelPrevious ~= false)
	end

	return tween
end

function Engine:Play(instance, tweenInfo, goals, opts)
	local tween = self:Create(instance, tweenInfo, goals, opts)
	if tween then
		tween:Play()
	end
	return tween
end

function Engine:AnimateProperty(instance, property, targetValue, duration, easingStyle, easingDirection, opts)
	if type(property) ~= "string" then
		return nil
	end
	local info = TweenInfo.new(
		duration or 0.5,
		easingStyle or Enum.EasingStyle.Exponential,
		easingDirection or Enum.EasingDirection.Out
	)
	local tween = self:Create(instance, info, { [property] = targetValue }, {
		track = true,
		key = property,
		cancelPrevious = true,
	})
	if tween then
		tween:Play()
	end
	return tween
end

function Engine:GetActiveAnimationCount()
	local count = 0
	for _, bucket in pairs(self._activeTweens) do
		count = count + countEntries(bucket)
	end
	return count
end

function Engine:CancelObject(instance)
	local bucket = self._activeTweens[instance]
	if bucket then
		for _, tween in pairs(bucket) do
			if tween then
				pcall(function()
					tween:Cancel()
				end)
			end
		end
		self._activeTweens[instance] = nil
	end

	local cleanupHook = self._cleanupHooks[instance]
	if cleanupHook then
		pcall(cleanupHook)
	end
	self._cleanupHooks[instance] = nil
end

function Engine:CancelAll()
	for instance in pairs(self._activeTweens) do
		self:CancelObject(instance)
	end
end

function Engine:_ensureTextHeartbeat()
	if self._textHeartbeat then
		return
	end
	self._textHeartbeat = self.RunService.Heartbeat:Connect(function()
		self:_tickTextHandles()
	end)
end

function Engine:_maybeReleaseTextHeartbeat()
	for _, handles in pairs(self._textHandles) do
		if handles and #handles > 0 then
			return
		end
	end
	if self._textHeartbeat then
		self.Cleanup.safeDisconnect(self._textHeartbeat)
		self._textHeartbeat = nil
	end
end

function Engine:_tickTextHandles()
	local suppressed = self:IsUiSuppressed()
	for instance, handles in pairs(self._textHandles) do
		if type(handles) == "table" then
			for i = #handles, 1, -1 do
				local handle = handles[i]
				local running = handle and handle.IsRunning and handle:IsRunning()
				local dead = (not self.Cleanup.isAlive(instance)) or (not self.Cleanup.isVisibleChain(instance))
				if dead or suppressed then
					if handle and handle.Stop then
						pcall(function()
							handle:Stop()
						end)
					end
					table.remove(handles, i)
				elseif not running then
					table.remove(handles, i)
				end
			end
			if #handles == 0 then
				self._textHandles[instance] = nil
			end
		end
	end
	self:_maybeReleaseTextHeartbeat()
end

function Engine:RegisterTextHandle(instance, handle)
	if typeof(instance) ~= "Instance" or not handle then
		return
	end
	local handles = self._textHandles[instance]
	if not handles then
		handles = {}
		self._textHandles[instance] = handles
	end
	table.insert(handles, handle)
	self:_ensureTextHeartbeat()
end

function Engine:UnregisterTextHandle(instance, handle)
	local handles = self._textHandles[instance]
	if not handles then
		return
	end
	for i = #handles, 1, -1 do
		if handles[i] == handle then
			table.remove(handles, i)
		end
	end
	if #handles == 0 then
		self._textHandles[instance] = nil
	end
	self:_maybeReleaseTextHeartbeat()
end

function Engine:StopTextForObject(instance)
	local handles = self._textHandles[instance]
	if not handles then
		return
	end
	for i = #handles, 1, -1 do
		local handle = handles[i]
		if handle and handle.Stop then
			pcall(function()
				handle:Stop()
			end)
		end
	end
	self._textHandles[instance] = nil
	self:_maybeReleaseTextHeartbeat()
end

function Engine:StopAllText()
	for instance in pairs(self._textHandles) do
		self:StopTextForObject(instance)
	end
end

function Engine:Destroy()
	self:StopAllText()
	self:CancelAll()
	self:SetUiSuppressed(true)
	if self._textHeartbeat then
		self.Cleanup.safeDisconnect(self._textHeartbeat)
		self._textHeartbeat = nil
	end
end

return Engine
]])
put("src/core/animation/public.lua", [[local Public = {}

local function newFallbackSequence(engine, target, tweenInfo, goals)
	local sequence = {
		_engine = engine,
		_target = target,
		_info = tweenInfo,
		_goals = goals,
	}

	function sequence:SetInfo(info)
		self._info = info
		return self
	end

	function sequence:To(nextGoals, nextInfo)
		self._goals = nextGoals
		if nextInfo then
			self._info = nextInfo
		end
		return self
	end

	function sequence:Then(nextGoals, nextInfo)
		return self:To(nextGoals, nextInfo)
	end

	function sequence:Wait()
		return self
	end

	function sequence:Play()
		if typeof(self._info) == "TweenInfo" and type(self._goals) == "table" then
			self._engine:Play(self._target, self._info, self._goals)
		end
		return self
	end

	return sequence
end

function Public.createFacade(engine, libs)
	libs = libs or {}
	local SequenceLib = libs.Sequence
	local UILib = libs.UI
	local TextLib = libs.Text

	local function createSequence(target, tweenInfo, goals)
		if SequenceLib and type(SequenceLib.new) == "function" then
			local sequence = SequenceLib.new(engine, target)
			if typeof(tweenInfo) == "TweenInfo" then
				sequence:SetInfo(tweenInfo)
				if type(goals) == "table" then
					sequence:To(goals, tweenInfo)
				end
			end
			return sequence
		end
		return newFallbackSequence(engine, target, tweenInfo, goals)
	end

	local facade = {}
	setmetatable(facade, {
		__call = function(_, target, tweenInfo, goals)
			return createSequence(target, tweenInfo, goals)
		end
	})

	function facade.UI(target)
		if UILib and type(UILib.new) == "function" then
			return UILib.new(engine, target)
		end
		return nil
	end

	function facade.Text(target)
		if TextLib and type(TextLib.new) == "function" then
			return TextLib.new(engine, target)
		end
		return nil
	end

	function facade.Play(target, tweenInfo, goals, opts)
		return engine:Play(target, tweenInfo, goals, opts)
	end

	function facade.Create(target, tweenInfo, goals, opts)
		return engine:Create(target, tweenInfo, goals, opts)
	end

	function facade.StopObject(target)
		engine:CancelObject(target)
		engine:StopTextForObject(target)
	end

	function facade.StopAll()
		engine:CancelAll()
		engine:StopAllText()
	end

	function facade.GetActiveAnimationCount()
		return engine:GetActiveAnimationCount()
	end

	function facade.GetEngine()
		return engine
	end

	return facade
end

function Public.bindToRayfield(rayfieldLibrary, engine, libs)
	local facade = Public.createFacade(engine, libs)
	rayfieldLibrary.Animate = facade
	rayfieldLibrary.GetAnimationEngine = function()
		return engine
	end
	return facade
end

return Public
]])
put("src/core/animation/sequence.lua", [[local Sequence = {}
Sequence.__index = Sequence

local function safeWaitForTween(tween)
	if not tween then
		return
	end
	local okCompleted, completedSignal = pcall(function()
		return tween.Completed
	end)
	if okCompleted and completedSignal then
		pcall(function()
			completedSignal:Wait()
		end)
	end
end

function Sequence.new(engine, target)
	local self = setmetatable({}, Sequence)
	self._engine = engine
	self._target = target
	self._defaultInfo = TweenInfo.new(0.25, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out)
	self._steps = {}
	self._running = false
	self._stopped = false
	self._currentTween = nil
	self._completedCallbacks = {}
	return self
end

function Sequence:SetInfo(tweenInfo)
	if typeof(tweenInfo) == "TweenInfo" then
		self._defaultInfo = tweenInfo
	end
	return self
end

function Sequence:To(goals, tweenInfo, opts)
	if type(goals) == "table" then
		table.insert(self._steps, {
			type = "tween",
			goals = goals,
			info = (typeof(tweenInfo) == "TweenInfo" and tweenInfo) or self._defaultInfo,
			opts = opts or {}
		})
	end
	return self
end

function Sequence:Then(goals, tweenInfo, opts)
	return self:To(goals, tweenInfo, opts)
end

function Sequence:Wait(duration)
	local sec = tonumber(duration) or 0
	if sec < 0 then
		sec = 0
	end
	table.insert(self._steps, {
		type = "wait",
		duration = sec
	})
	return self
end

function Sequence:Call(callback)
	if type(callback) == "function" then
		table.insert(self._steps, {
			type = "callback",
			callback = callback
		})
	end
	return self
end

function Sequence:OnCompleted(callback)
	if type(callback) == "function" then
		table.insert(self._completedCallbacks, callback)
	end
	return self
end

function Sequence:IsRunning()
	return self._running
end

function Sequence:Stop()
	self._stopped = true
	if self._currentTween then
		pcall(function()
			self._currentTween:Cancel()
		end)
		self._currentTween = nil
	end
	return self
end

function Sequence:Play()
	if self._running then
		return self
	end

	self._running = true
	self._stopped = false

	task.spawn(function()
		for _, step in ipairs(self._steps) do
			if self._stopped then
				break
			end

			if step.type == "wait" then
				task.wait(step.duration)
			elseif step.type == "callback" then
				pcall(step.callback, self._engine, self._target)
			elseif step.type == "tween" then
				local tween = self._engine:Create(self._target, step.info, step.goals, step.opts)
				self._currentTween = tween
				if tween then
					tween:Play()
					safeWaitForTween(tween)
				end
				self._currentTween = nil
			end
		end

		self._running = false
		if not self._stopped then
			for _, callback in ipairs(self._completedCallbacks) do
				pcall(callback, self)
			end
		end
	end)

	return self
end

return Sequence
]])
put("src/core/animation/text.lua", [[local Text = {}
Text.__index = Text

local CHARSET = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"

local function randomChar()
	local index = math.random(1, #CHARSET)
	return CHARSET:sub(index, index)
end

local function lerpColor3(a, b, t)
	return Color3.new(
		a.R + (b.R - a.R) * t,
		a.G + (b.G - a.G) * t,
		a.B + (b.B - a.B) * t
	)
end

local function makeLoopHandle(controller, runner)
	local handle = {}
	handle._running = false
	handle._cleanup = nil

	function handle:IsRunning()
		return self._running
	end

	function handle:Stop()
		if not self._running then
			return
		end
		self._running = false
		if type(self._cleanup) == "function" then
			pcall(self._cleanup)
		end
		controller._engine:UnregisterTextHandle(controller._target, self)
	end

	handle._running = true
	task.spawn(function()
		local ok = pcall(runner, handle)
		if not ok then
			handle:Stop()
			return
		end
		if handle._running then
			handle:Stop()
		end
	end)

	controller._engine:RegisterTextHandle(controller._target, handle)
	return handle
end

function Text.new(engine, textObject)
	local self = setmetatable({}, Text)
	self._engine = engine
	self._target = textObject
	return self
end

function Text:_alive()
	return self._engine.Cleanup.isAlive(self._target)
end

function Text:_blocked()
	return self._engine:IsUiSuppressed() or (not self._engine.Cleanup.isVisibleChain(self._target))
end

function Text:Type(text, speed, opts)
	opts = opts or {}
	local finalText = tostring(text or self._target.Text or "")
	local charDelay = tonumber(speed) or 0.03
	local cursor = opts.cursor
	local loop = opts.loop == true

	return makeLoopHandle(self, function(handle)
		repeat
			if not self:_alive() then
				break
			end

			self._target.Text = ""
			for i = 1, #finalText do
				if not handle:IsRunning() or self:_blocked() or not self:_alive() then
					return
				end
				local preview = finalText:sub(1, i)
				if cursor then
					preview = preview .. cursor
				end
				self._target.Text = preview
				task.wait(charDelay)
			end
			self._target.Text = finalText
			if loop then
				task.wait(tonumber(opts.loopDelay) or 0.35)
			end
		until not loop
	end)
end

function Text:Ghosting(text, interval, opts)
	opts = opts or {}
	if text ~= nil then
		self._target.Text = tostring(text)
	end

	local period = tonumber(interval) or 0.85
	local minTransparency = tonumber(opts.minTransparency) or 0.15
	local maxTransparency = tonumber(opts.maxTransparency) or 0.55

	return makeLoopHandle(self, function(handle)
		while handle:IsRunning() do
			if self:_blocked() or not self:_alive() then
				return
			end
			local tweenIn = self._engine:Play(
				self._target,
				TweenInfo.new(period * 0.5, Enum.EasingStyle.Sine, Enum.EasingDirection.Out),
				{ TextTransparency = maxTransparency },
				{ track = true, key = "TextTransparency", cancelPrevious = true }
			)
			if tweenIn then
				tweenIn.Completed:Wait()
			end
			if not handle:IsRunning() then
				return
			end
			local tweenOut = self._engine:Play(
				self._target,
				TweenInfo.new(period * 0.5, Enum.EasingStyle.Sine, Enum.EasingDirection.Out),
				{ TextTransparency = minTransparency },
				{ track = true, key = "TextTransparency", cancelPrevious = true }
			)
			if tweenOut then
				tweenOut.Completed:Wait()
			end
		end
	end)
end

function Text:Scramble(text, duration, opts)
	opts = opts or {}
	local finalText = tostring(text or self._target.Text or "")
	local totalDuration = tonumber(duration) or 0.8
	local tickRate = tonumber(opts.tickRate) or 0.04
	local loop = opts.loop == true

	return makeLoopHandle(self, function(handle)
		repeat
			local startTime = tick()
			while handle:IsRunning() and self:_alive() and (tick() - startTime) < totalDuration do
				if self:_blocked() then
					return
				end
				local progress = math.clamp((tick() - startTime) / totalDuration, 0, 1)
				local fixedCount = math.floor(#finalText * progress)
				local chars = {}
				for i = 1, #finalText do
					if i <= fixedCount then
						chars[i] = finalText:sub(i, i)
					else
						chars[i] = randomChar()
					end
				end
				self._target.Text = table.concat(chars)
				task.wait(tickRate)
			end
			if not handle:IsRunning() then
				return
			end
			self._target.Text = finalText
			if loop then
				task.wait(tonumber(opts.loopDelay) or 0.25)
			end
		until not loop
	end)
end

function Text:Rainbow(cycleSec, opts)
	opts = opts or {}
	local cycle = tonumber(cycleSec) or 2
	local saturation = tonumber(opts.saturation) or 0.85
	local value = tonumber(opts.value) or 1
	local step = tonumber(opts.step) or 0.03
	local start = tick()

	return makeLoopHandle(self, function(handle)
		while handle:IsRunning() do
			if self:_blocked() or not self:_alive() then
				return
			end
			local hue = ((tick() - start) % cycle) / cycle
			self._target.TextColor3 = Color3.fromHSV(hue, saturation, value)
			task.wait(step)
		end
	end)
end

function Text:Glow(color, cycleSec, opts)
	opts = opts or {}
	local baseColor = self._target.TextColor3
	local glowColor = typeof(color) == "Color3" and color or Color3.fromRGB(130, 200, 255)
	local cycle = tonumber(cycleSec) or 1.25
	local step = tonumber(opts.step) or 0.03
	local start = tick()

	return makeLoopHandle(self, function(handle)
		while handle:IsRunning() do
			if self:_blocked() or not self:_alive() then
				return
			end
			local phase = (tick() - start) / cycle
			local alpha = (math.sin(phase * math.pi * 2) + 1) * 0.5
			self._target.TextColor3 = lerpColor3(baseColor, glowColor, alpha)
			task.wait(step)
		end
	end)
end

return Text
]])
put("src/core/animation/ui.lua", [[local UI = {}
UI.__index = UI

function UI.new(engine, target)
	local self = setmetatable({}, UI)
	self._engine = engine
	self._target = target
	return self
end

function UI:_play(info, goals, opts)
	return self._engine:Play(self._target, info, goals, opts)
end

function UI:FadeIn(duration)
	if self._target and self._target:IsA("GuiObject") then
		self._target.Visible = true
	end
	return self:_play(
		TweenInfo.new(duration or 0.25, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out),
		{ BackgroundTransparency = 0 }
	)
end

function UI:FadeOut(duration, hideAfter)
	local tween = self:_play(
		TweenInfo.new(duration or 0.25, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out),
		{ BackgroundTransparency = 1 }
	)
	if tween and hideAfter ~= false and self._target and self._target:IsA("GuiObject") then
		tween.Completed:Connect(function(playbackState)
			if playbackState == Enum.PlaybackState.Completed then
				self._target.Visible = false
			end
		end)
	end
	return tween
end

function UI:Pop(duration, scaleMultiplier)
	if not (self._target and self._target:IsA("GuiObject")) then
		return nil
	end

	local original = self._target.Size
	local multiplier = tonumber(scaleMultiplier) or 1.05
	local targetSize = UDim2.new(
		original.X.Scale * multiplier,
		math.floor(original.X.Offset * multiplier + 0.5),
		original.Y.Scale * multiplier,
		math.floor(original.Y.Offset * multiplier + 0.5)
	)

	local tweenOut = self:_play(
		TweenInfo.new((duration or 0.2) * 0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
		{ Size = targetSize }
	)

	if tweenOut then
		tweenOut.Completed:Connect(function(playbackState)
			if playbackState == Enum.PlaybackState.Completed then
				self:_play(
					TweenInfo.new((duration or 0.2) * 0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
					{ Size = original }
				)
			end
		end)
	end

	return tweenOut
end

function UI:SlideIn(direction, duration)
	if not (self._target and self._target:IsA("GuiObject")) then
		return nil
	end

	local original = self._target.Position
	local from = original
	local moveDirection = (type(direction) == "string" and string.lower(direction)) or "left"

	if moveDirection == "left" then
		from = UDim2.new(-1, 0, original.Y.Scale, original.Y.Offset)
	elseif moveDirection == "right" then
		from = UDim2.new(2, 0, original.Y.Scale, original.Y.Offset)
	elseif moveDirection == "top" then
		from = UDim2.new(original.X.Scale, original.X.Offset, -1, 0)
	else
		from = UDim2.new(original.X.Scale, original.X.Offset, 2, 0)
	end

	self._target.Position = from
	self._target.Visible = true
	return self:_play(
		TweenInfo.new(duration or 0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out),
		{ Position = original }
	)
end

function UI:SlideOut(direction, duration)
	if not (self._target and self._target:IsA("GuiObject")) then
		return nil
	end

	local original = self._target.Position
	local to = original
	local moveDirection = (type(direction) == "string" and string.lower(direction)) or "left"

	if moveDirection == "left" then
		to = UDim2.new(-1, 0, original.Y.Scale, original.Y.Offset)
	elseif moveDirection == "right" then
		to = UDim2.new(2, 0, original.Y.Scale, original.Y.Offset)
	elseif moveDirection == "top" then
		to = UDim2.new(original.X.Scale, original.X.Offset, -1, 0)
	else
		to = UDim2.new(original.X.Scale, original.X.Offset, 2, 0)
	end

	return self:_play(
		TweenInfo.new(duration or 0.28, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out),
		{ Position = to }
	)
end

return UI
]])
put("src/core/bootstrap.lua", [[local Bootstrap = {}

function Bootstrap.createRuntimeContext(overrides)
	overrides = overrides or {}
	return {
		useStudio = overrides.useStudio,
		compileString = overrides.compileString,
		runtimeRootUrl = overrides.runtimeRootUrl,
		services = overrides.services or {}
	}
end

return Bootstrap
]])
put("src/core/constants.lua", [[local Constants = {
	RuntimeRootGlobal = "__RAYFIELD_RUNTIME_ROOT_URL",
	DefaultRuntimeRoot = "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/",
	ManifestVersion = "1.0.0"
}

return Constants
]])
put("src/core/container.lua", [[local Container = {}

function Container.new(seed)
	local registry = seed or {}
	return {
		set = function(_, key, value)
			registry[key] = value
		end,
		get = function(_, key)
			return registry[key]
		end,
		all = function()
			return registry
		end
	}
end

return Container
]])
put("src/core/lifecycle.lua", [[local Lifecycle = {}

function Lifecycle.new()
	local cleanups = {}
	return {
		add = function(_, fn)
			if type(fn) == "function" then
				table.insert(cleanups, fn)
			end
		end,
		destroy = function()
			for i = #cleanups, 1, -1 do
				pcall(cleanups[i])
			end
			table.clear(cleanups)
		end
	}
end

return Lifecycle
]])
put("src/core/runtime-env.lua", [[local RuntimeEnv = {}

local function resolveCompatibility()
	if type(_G) == "table" and type(_G.__RayfieldCompatibility) == "table" then
		return _G.__RayfieldCompatibility
	end

	local client = type(_G) == "table" and _G.__RayfieldApiClient or nil
	if type(client) ~= "table" or type(client.fetchAndExecute) ~= "function" then
		return nil
	end

	local root = (type(_G) == "table" and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
	local ok, compat = pcall(client.fetchAndExecute, root .. "src/services/compatibility.lua")
	if ok and type(compat) == "table" then
		if type(_G) == "table" then
			_G.__RayfieldCompatibility = compat
		end
		return compat
	end

	return nil
end

local function fallbackGetService(name)
	local ok, service = pcall(function()
		return game:GetService(name)
	end)
	if ok and service then
		if type(cloneref) == "function" then
			local okRef, ref = pcall(cloneref, service)
			if okRef and ref then
				return ref
			end
		end
		return service
	end
	return nil
end

function RuntimeEnv.create(overrides)
	overrides = overrides or {}
	local compatibility = overrides.compatibility or resolveCompatibility()
	local getService = fallbackGetService
	if compatibility and type(compatibility.getService) == "function" then
		getService = compatibility.getService
	end

	local runService = overrides.runService or getService("RunService")
	local useStudio = overrides.useStudio
	if useStudio == nil and runService then
		local okStudio, studio = pcall(function()
			return runService:IsStudio()
		end)
		useStudio = okStudio and studio or false
	end
	if useStudio == nil then
		useStudio = false
	end

	return {
		useStudio = useStudio,
		runtimeRootUrl = overrides.runtimeRootUrl or ((_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"),
		compatibility = compatibility,
		services = {
			RunService = runService,
			UserInputService = overrides.userInputService or getService("UserInputService"),
			TweenService = overrides.tweenService or getService("TweenService"),
			HttpService = overrides.httpService or getService("HttpService")
		}
	}
end

return RuntimeEnv
]])
put("src/core/ui-state.lua", [[-- Rayfield UI State Management Module
-- Handles notifications, search, hide/show, minimize/maximize

local UIStateModule = {}

function UIStateModule.init(ctx)
	local self = {}

	-- Inject dependencies
	self.TweenService = ctx.TweenService
	self.Animation = ctx.Animation or ctx.TweenService
	self.Main = ctx.Main
	self.Topbar = ctx.Topbar
	self.TabList = ctx.TabList
	self.Elements = ctx.Elements
	self.Notifications = ctx.Notifications
	self.MPrompt = ctx.MPrompt
	self.dragInteract = ctx.dragInteract
	self.dragBarCosmetic = ctx.dragBarCosmetic
	self.dragBar = ctx.dragBar
	self.dragOffset = ctx.dragOffset
	self.dragOffsetMobile = ctx.dragOffsetMobile
	self.getIcon = ctx.getIcon
	self.getAssetUri = ctx.getAssetUri
	self.getSelectedTheme = ctx.getSelectedTheme
	self.rayfieldDestroyed = ctx.rayfieldDestroyed
	self.getSetting = ctx.getSetting
	self.useMobileSizing = ctx.useMobileSizing
	self.useMobilePrompt = ctx.useMobilePrompt

	-- Module state
	local searchOpen = false
	local Debounce = false
	local Minimised = false
	local Hidden = false

	-- Forward declare functions
	local closeSearch

	local function playTween(instance, tweenInfo, properties)
		if instance then
			self.Animation:Create(instance, tweenInfo, properties):Play()
		end
	end

	-- Extract code starts here

	local function Notify(data) -- action e.g open messages
		task.spawn(function()
			data = type(data) == "table" and data or {}
			if self.rayfieldDestroyed() then
				return
			end
			if not (self.Notifications and self.Notifications.Parent) then
				return
			end
	
			local template = self.Notifications:FindFirstChild("Template")
			local listLayout = self.Notifications:FindFirstChildOfClass("UIListLayout")
			if not (template and template:IsA("Frame") and listLayout) then
				return
			end
	
			-- Notification Object Creation
			local newNotification = template:Clone()
			newNotification.Name = data.Title or 'No Title Provided'
			newNotification.Parent = self.Notifications
			newNotification.LayoutOrder = #self.Notifications:GetChildren()
			newNotification.Visible = false
	
			local function isNotificationValid()
				return not self.rayfieldDestroyed()
					and newNotification
					and newNotification.Parent
					and self.Notifications
					and self.Notifications.Parent
					and listLayout
					and listLayout.Parent == self.Notifications
			end
	
			-- Set Data
			newNotification.Title.Text = data.Title or "Unknown Title"
			newNotification.Description.Text = data.Content or "Unknown Content"
	
			if data.Image then
				if typeof(data.Image) == 'string' and self.getIcon then
					local iconSuccess, asset = pcall(self.getIcon, data.Image)
					if iconSuccess and asset then
						newNotification.Icon.Image = 'rbxassetid://' .. tostring(asset.id or 0)
						newNotification.Icon.ImageRectOffset = asset.imageRectOffset or Vector2.new(0, 0)
						newNotification.Icon.ImageRectSize = asset.imageRectSize or Vector2.new(0, 0)
					else
						newNotification.Icon.Image = self.getAssetUri(data.Image)
					end
				else
					newNotification.Icon.Image = self.getAssetUri(data.Image)
				end
			else
				newNotification.Icon.Image = "rbxassetid://" .. 0
			end
	
			-- Set initial transparency values
	
			newNotification.Title.TextColor3 = self.getSelectedTheme().TextColor
			newNotification.Description.TextColor3 = self.getSelectedTheme().TextColor
			newNotification.BackgroundColor3 = self.getSelectedTheme().Background
			newNotification.UIStroke.Color = self.getSelectedTheme().TextColor
			newNotification.Icon.ImageColor3 = self.getSelectedTheme().TextColor
	
			newNotification.BackgroundTransparency = 1
			newNotification.Title.TextTransparency = 1
			newNotification.Description.TextTransparency = 1
			newNotification.UIStroke.Transparency = 1
			newNotification.Shadow.ImageTransparency = 1
			newNotification.Size = UDim2.new(1, 0, 0, 800)
			newNotification.Icon.ImageTransparency = 1
			newNotification.Icon.BackgroundTransparency = 1
	
			task.wait()
			if not isNotificationValid() then
				if newNotification and newNotification.Parent then
					newNotification:Destroy()
				end
				return
			end
	
			newNotification.Visible = true
	
			if data.Actions then
				warn('Rayfield | Not seeing your actions in notifications?')
				print("Notification Actions are being sunset for now, keep up to date on when they're back in the discord. (sirius.menu/discord)")
			end
	
			-- Calculate textbounds and set initial values
			local bounds = {newNotification.Title.TextBounds.Y, newNotification.Description.TextBounds.Y}
			local listPadding = -(listLayout.Padding.Offset)
			newNotification.Size = UDim2.new(1, -60, 0, listPadding)
	
			newNotification.Icon.Size = UDim2.new(0, 32, 0, 32)
			newNotification.Icon.Position = UDim2.new(0, 20, 0.5, 0)
	
			self.Animation:Create(newNotification, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Size = UDim2.new(1, 0, 0, math.max(bounds[1] + bounds[2] + 31, 60))}):Play()
	
			task.wait(0.15)
			self.Animation:Create(newNotification, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0.45}):Play()
			self.Animation:Create(newNotification.Title, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {TextTransparency = 0}):Play()
	
			task.wait(0.05)
	
			self.Animation:Create(newNotification.Icon, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {ImageTransparency = 0}):Play()
	
			task.wait(0.05)
			self.Animation:Create(newNotification.Description, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {TextTransparency = 0.35}):Play()
			self.Animation:Create(newNotification.UIStroke, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {Transparency = 0.95}):Play()
			self.Animation:Create(newNotification.Shadow, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {ImageTransparency = 0.82}):Play()
	
			local waitDuration = math.min(math.max((#newNotification.Description.Text * 0.1) + 2.5, 3), 10)
			task.wait(data.Duration or waitDuration)
			if not isNotificationValid() then
				if newNotification and newNotification.Parent then
					newNotification:Destroy()
				end
				return
			end
	
			newNotification.Icon.Visible = false
			self.Animation:Create(newNotification, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {BackgroundTransparency = 1}):Play()
			self.Animation:Create(newNotification.UIStroke, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {Transparency = 1}):Play()
			self.Animation:Create(newNotification.Shadow, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {ImageTransparency = 1}):Play()
			self.Animation:Create(newNotification.Title, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
			self.Animation:Create(newNotification.Description, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
	
			self.Animation:Create(newNotification, TweenInfo.new(1, Enum.EasingStyle.Exponential), {Size = UDim2.new(1, -90, 0, 0)}):Play()
	
			task.wait(1)
			if not isNotificationValid() then
				if newNotification and newNotification.Parent then
					newNotification:Destroy()
				end
				return
			end
	
			self.Animation:Create(newNotification, TweenInfo.new(1, Enum.EasingStyle.Exponential), {Size = UDim2.new(1, -90, 0, listPadding)}):Play()
	
			newNotification.Visible = false
			newNotification:Destroy()
		end)
	end
	
	local function openSearch()
		searchOpen = true
	
		self.Main.Search.BackgroundTransparency = 1
		self.Main.Search.Shadow.ImageTransparency = 1
		self.Main.Search.Input.TextTransparency = 1
		self.Main.Search.Search.ImageTransparency = 1
		self.Main.Search.UIStroke.Transparency = 1
		self.Main.Search.Size = UDim2.new(1, 0, 0, 80)
		self.Main.Search.Position = UDim2.new(0.5, 0, 0, 70)
	
		self.Main.Search.Input.Interactable = true
	
		self.Main.Search.Visible = true
	
		for _, tabbtn in ipairs(self.TabList:GetChildren()) do
			if tabbtn.ClassName == "Frame" and tabbtn.Name ~= "Placeholder" then
				tabbtn.Interact.Visible = false
				self.Animation:Create(tabbtn, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {BackgroundTransparency = 1}):Play()
				self.Animation:Create(tabbtn.Title, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
				self.Animation:Create(tabbtn.Image, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {ImageTransparency = 1}):Play()
				self.Animation:Create(tabbtn.UIStroke, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {Transparency = 1}):Play()
			end
		end
	
		self.Main.Search.Input:CaptureFocus()
		self.Animation:Create(self.Main.Search.Shadow, TweenInfo.new(0.05, Enum.EasingStyle.Quint), {ImageTransparency = 0.95}):Play()
		self.Animation:Create(self.Main.Search, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {Position = UDim2.new(0.5, 0, 0, 57), BackgroundTransparency = 0.9}):Play()
		self.Animation:Create(self.Main.Search.UIStroke, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {Transparency = 0.8}):Play()
		self.Animation:Create(self.Main.Search.Input, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {TextTransparency = 0.2}):Play()
		self.Animation:Create(self.Main.Search.Search, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {ImageTransparency = 0.5}):Play()
		self.Animation:Create(self.Main.Search, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {Size = UDim2.new(1, -35, 0, 35)}):Play()
	end
	
	local function closeSearch()
		searchOpen = false
	
		self.Animation:Create(self.Main.Search, TweenInfo.new(0.35, Enum.EasingStyle.Quint), {BackgroundTransparency = 1, Size = UDim2.new(1, -55, 0, 30)}):Play()
		self.Animation:Create(self.Main.Search.Search, TweenInfo.new(0.15, Enum.EasingStyle.Quint), {ImageTransparency = 1}):Play()
		self.Animation:Create(self.Main.Search.Shadow, TweenInfo.new(0.15, Enum.EasingStyle.Quint), {ImageTransparency = 1}):Play()
		self.Animation:Create(self.Main.Search.UIStroke, TweenInfo.new(0.15, Enum.EasingStyle.Quint), {Transparency = 1}):Play()
		self.Animation:Create(self.Main.Search.Input, TweenInfo.new(0.15, Enum.EasingStyle.Quint), {TextTransparency = 1}):Play()
	
		for _, tabbtn in ipairs(self.TabList:GetChildren()) do
			if tabbtn.ClassName == "Frame" and tabbtn.Name ~= "Placeholder" then
				tabbtn.Interact.Visible = true
				if tostring(self.Elements.UIPageLayout.CurrentPage) == tabbtn.Title.Text then
					self.Animation:Create(tabbtn, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0}):Play()
					self.Animation:Create(tabbtn.Image, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {ImageTransparency = 0}):Play()
					self.Animation:Create(tabbtn.Title, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {TextTransparency = 0}):Play()
					self.Animation:Create(tabbtn.UIStroke, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {Transparency = 1}):Play()
				else
					self.Animation:Create(tabbtn, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0.7}):Play()
					self.Animation:Create(tabbtn.Image, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {ImageTransparency = 0.2}):Play()
					self.Animation:Create(tabbtn.Title, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {TextTransparency = 0.2}):Play()
					self.Animation:Create(tabbtn.UIStroke, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {Transparency = 0.5}):Play()
				end
			end
		end
	
		self.Main.Search.Input.Text = ''
		self.Main.Search.Input.Interactable = false
	end
	
	local function Hide(notify)
		if self.MPrompt then
			self.MPrompt.Title.TextColor3 = Color3.fromRGB(255, 255, 255)
			self.MPrompt.Position = UDim2.new(0.5, 0, 0, -50)
			self.MPrompt.Size = UDim2.new(0, 40, 0, 10)
			self.MPrompt.BackgroundTransparency = 1
			self.MPrompt.Title.TextTransparency = 1
			self.MPrompt.Visible = true
		end
	
		task.spawn(closeSearch)
	
		Debounce = true
		if notify then
			if self.useMobilePrompt then
				Notify({Title = "Interface Hidden", Content = "The interface has been hidden, you can unhide the interface by tapping 'Show'.", Duration = 7, Image = 4400697855})
			else
				Notify({Title = "Interface Hidden", Content = "The interface has been hidden, you can unhide the interface by tapping " .. tostring(self.getSetting("General", "rayfieldOpen")) .. ".", Duration = 7, Image = 4400697855})
			end
		end

		playTween(self.Main, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {Size = UDim2.new(0, 470, 0, 0)})
		playTween(self.Main, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {BackgroundTransparency = 1})
		playTween(self.Topbar, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {Size = UDim2.new(0, 470, 0, 45)})
		playTween(self.Topbar, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {BackgroundTransparency = 1})
		playTween(self.Topbar and self.Topbar:FindFirstChild("Divider"), TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {BackgroundTransparency = 1})
		playTween(self.Topbar and self.Topbar:FindFirstChild("CornerRepair"), TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {BackgroundTransparency = 1})
		playTween(self.Topbar and self.Topbar:FindFirstChild("Title"), TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {TextTransparency = 1})
		playTween(self.Main and self.Main:FindFirstChild("Shadow") and self.Main.Shadow:FindFirstChild("Image"), TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {ImageTransparency = 1})
		playTween(self.Topbar and self.Topbar:FindFirstChild("UIStroke"), TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {Transparency = 1})
		playTween(self.dragBarCosmetic, TweenInfo.new(0.25, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {BackgroundTransparency = 1})
	
		if self.useMobilePrompt and self.MPrompt then
			self.Animation:Create(self.MPrompt, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {Size = UDim2.new(0, 120, 0, 30), Position = UDim2.new(0.5, 0, 0, 20), BackgroundTransparency = 0.3}):Play()
			self.Animation:Create(self.MPrompt.Title, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {TextTransparency = 0.3}):Play()
		end
	
		if self.Topbar then
			for _, TopbarButton in ipairs(self.Topbar:GetChildren()) do
				if TopbarButton.ClassName == "ImageButton" then
					playTween(TopbarButton, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {ImageTransparency = 1})
				end
			end
		end
	
		for _, tabbtn in ipairs(self.TabList:GetChildren()) do
			if tabbtn.ClassName == "Frame" and tabbtn.Name ~= "Placeholder" then
				self.Animation:Create(tabbtn, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {BackgroundTransparency = 1}):Play()
				self.Animation:Create(tabbtn.Title, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
				self.Animation:Create(tabbtn.Image, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {ImageTransparency = 1}):Play()
				self.Animation:Create(tabbtn.UIStroke, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {Transparency = 1}):Play()
			end
		end
	
		if self.dragInteract then
			self.dragInteract.Visible = false
		end
	
		for _, tab in ipairs(self.Elements:GetChildren()) do
			if tab.Name ~= "Template" and tab.ClassName == "ScrollingFrame" and tab.Name ~= "Placeholder" then
				for _, element in ipairs(tab:GetChildren()) do
					if element.ClassName == "Frame" then
						if element.Name ~= "SectionSpacing" and element.Name ~= "Placeholder" then
							if element.Name == "SectionTitle" or element.Name == 'SearchTitle-fsefsefesfsefesfesfThanks' then
								self.Animation:Create(element.Title, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
							elseif element.Name == 'Divider' then
								self.Animation:Create(element.Divider, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {BackgroundTransparency = 1}):Play()
							else
								self.Animation:Create(element, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {BackgroundTransparency = 1}):Play()
								self.Animation:Create(element.UIStroke, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {Transparency = 1}):Play()
								self.Animation:Create(element.Title, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
							end
							for _, child in ipairs(element:GetChildren()) do
								if child.ClassName == "Frame" or child.ClassName == "TextLabel" or child.ClassName == "TextBox" or child.ClassName == "ImageButton" or child.ClassName == "ImageLabel" then
									child.Visible = false
								end
							end
						end
					end
				end
			end
		end
	
		task.wait(0.5)
		self.Main.Visible = false
		Debounce = false
	end
	
	local function Maximise()
		Debounce = true
		if self.Topbar and self.Topbar:FindFirstChild("ChangeSize") then
			self.Topbar.ChangeSize.Image = "rbxassetid://" .. 10137941941
		end
	
		playTween(self.Topbar and self.Topbar:FindFirstChild("UIStroke"), TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {Transparency = 1})
		playTween(self.Main and self.Main:FindFirstChild("Shadow") and self.Main.Shadow:FindFirstChild("Image"), TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {ImageTransparency = 0.6})
		playTween(self.Topbar and self.Topbar:FindFirstChild("CornerRepair"), TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0})
		playTween(self.Topbar and self.Topbar:FindFirstChild("Divider"), TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0})
		playTween(self.dragBarCosmetic, TweenInfo.new(0.25, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {BackgroundTransparency = 0.7})
		playTween(self.Main, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {Size = self.useMobileSizing and UDim2.new(0, 500, 0, 275) or UDim2.new(0, 500, 0, 475)})
		playTween(self.Topbar, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {Size = UDim2.new(0, 500, 0, 45)})
		if self.TabList then
			self.TabList.Visible = true
		end
		task.wait(0.2)
	
		if self.Elements then
			self.Elements.Visible = true
		end
	
		for _, tab in ipairs(self.Elements:GetChildren()) do
			if tab.Name ~= "Template" and tab.ClassName == "ScrollingFrame" and tab.Name ~= "Placeholder" then
				for _, element in ipairs(tab:GetChildren()) do
					if element.ClassName == "Frame" then
						if element.Name ~= "SectionSpacing" and element.Name ~= "Placeholder" then
							if element.Name == "SectionTitle" or element.Name == 'SearchTitle-fsefsefesfsefesfesfThanks' then
								self.Animation:Create(element.Title, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {TextTransparency = 0.4}):Play()
							elseif element.Name == 'Divider' then
								self.Animation:Create(element.Divider, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0.85}):Play()
							else
								self.Animation:Create(element, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0}):Play()
								self.Animation:Create(element.UIStroke, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {Transparency = 0}):Play()
								self.Animation:Create(element.Title, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {TextTransparency = 0}):Play()
							end
							for _, child in ipairs(element:GetChildren()) do
								if child.ClassName == "Frame" or child.ClassName == "TextLabel" or child.ClassName == "TextBox" or child.ClassName == "ImageButton" or child.ClassName == "ImageLabel" then
									child.Visible = true
								end
							end
						end
					end
				end
			end
		end
	
		task.wait(0.1)
	
		for _, tabbtn in ipairs(self.TabList:GetChildren()) do
			if tabbtn.ClassName == "Frame" and tabbtn.Name ~= "Placeholder" then
				if tostring(self.Elements.UIPageLayout.CurrentPage) == tabbtn.Title.Text then
					self.Animation:Create(tabbtn, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0}):Play()
					self.Animation:Create(tabbtn.Image, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {ImageTransparency = 0}):Play()
					self.Animation:Create(tabbtn.Title, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {TextTransparency = 0}):Play()
					self.Animation:Create(tabbtn.UIStroke, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {Transparency = 1}):Play()
				else
					self.Animation:Create(tabbtn, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0.7}):Play()
					self.Animation:Create(tabbtn.Image, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {ImageTransparency = 0.2}):Play()
					self.Animation:Create(tabbtn.Title, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {TextTransparency = 0.2}):Play()
					self.Animation:Create(tabbtn.UIStroke, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {Transparency = 0.5}):Play()
				end
	
			end
		end
	
		task.wait(0.5)
		Debounce = false
	end
	
	
	local function Unhide()
		Debounce = true
		self.Main.Position = UDim2.new(0.5, 0, 0.5, 0)
		self.Main.Visible = true
		playTween(self.Main, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {Size = self.useMobileSizing and UDim2.new(0, 500, 0, 275) or UDim2.new(0, 500, 0, 475)})
		playTween(self.Topbar, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {Size = UDim2.new(0, 500, 0, 45)})
		playTween(self.Main and self.Main:FindFirstChild("Shadow") and self.Main.Shadow:FindFirstChild("Image"), TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {ImageTransparency = 0.6})
		playTween(self.Main, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0})
		playTween(self.Topbar, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0})
		playTween(self.Topbar and self.Topbar:FindFirstChild("Divider"), TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0})
		playTween(self.Topbar and self.Topbar:FindFirstChild("CornerRepair"), TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0})
		playTween(self.Topbar and self.Topbar:FindFirstChild("Title"), TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {TextTransparency = 0})
	
		if self.MPrompt then
			self.Animation:Create(self.MPrompt, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {Size = UDim2.new(0, 40, 0, 10), Position = UDim2.new(0.5, 0, 0, -50), BackgroundTransparency = 1}):Play()
			self.Animation:Create(self.MPrompt.Title, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
	
			task.spawn(function()
				task.wait(0.5)
				self.MPrompt.Visible = false
			end)
		end
	
		if Minimised then
			task.spawn(Maximise)
		end
	
		if self.dragBar then
			self.dragBar.Position = self.useMobileSizing
				and UDim2.new(0.5, 0, 0.5, self.dragOffsetMobile)
				or UDim2.new(0.5, 0, 0.5, self.dragOffset)
		end
	
		if self.dragInteract then
			self.dragInteract.Visible = true
		end
	
		if self.Topbar then
			for _, TopbarButton in ipairs(self.Topbar:GetChildren()) do
				if TopbarButton.ClassName == "ImageButton" then
					if TopbarButton.Name == 'Icon' then
						playTween(TopbarButton, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {ImageTransparency = 0})
					else
						playTween(TopbarButton, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {ImageTransparency = 0.8})
					end
				end
			end
		end
	
		for _, tabbtn in ipairs(self.TabList:GetChildren()) do
			if tabbtn.ClassName == "Frame" and tabbtn.Name ~= "Placeholder" then
				if tostring(self.Elements.UIPageLayout.CurrentPage) == tabbtn.Title.Text then
					self.Animation:Create(tabbtn, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0}):Play()
					self.Animation:Create(tabbtn.Title, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {TextTransparency = 0}):Play()
					self.Animation:Create(tabbtn.Image, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {ImageTransparency = 0}):Play()
					self.Animation:Create(tabbtn.UIStroke, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {Transparency = 1}):Play()
				else
					self.Animation:Create(tabbtn, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0.7}):Play()
					self.Animation:Create(tabbtn.Image, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {ImageTransparency = 0.2}):Play()
					self.Animation:Create(tabbtn.Title, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {TextTransparency = 0.2}):Play()
					self.Animation:Create(tabbtn.UIStroke, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {Transparency = 0.5}):Play()
				end
			end
		end
	
		for _, tab in ipairs(self.Elements:GetChildren()) do
			if tab.Name ~= "Template" and tab.ClassName == "ScrollingFrame" and tab.Name ~= "Placeholder" then
				for _, element in ipairs(tab:GetChildren()) do
					if element.ClassName == "Frame" then
						if element.Name ~= "SectionSpacing" and element.Name ~= "Placeholder" then
							if element.Name == "SectionTitle" or element.Name == 'SearchTitle-fsefsefesfsefesfesfThanks' then
								self.Animation:Create(element.Title, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {TextTransparency = 0.4}):Play()
							elseif element.Name == 'Divider' then
								self.Animation:Create(element.Divider, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0.85}):Play()
							else
								self.Animation:Create(element, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0}):Play()
								self.Animation:Create(element.UIStroke, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {Transparency = 0}):Play()
								self.Animation:Create(element.Title, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {TextTransparency = 0}):Play()
							end
							for _, child in ipairs(element:GetChildren()) do
								if child.ClassName == "Frame" or child.ClassName == "TextLabel" or child.ClassName == "TextBox" or child.ClassName == "ImageButton" or child.ClassName == "ImageLabel" then
									child.Visible = true
								end
							end
						end
					end
				end
			end
		end
	
		playTween(self.dragBarCosmetic, TweenInfo.new(0.25, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {BackgroundTransparency = 0.5})
	
		task.wait(0.5)
		Minimised = false
		Debounce = false
	end
	
	local function Minimise()
		Debounce = true
		if self.Topbar and self.Topbar:FindFirstChild("ChangeSize") then
			self.Topbar.ChangeSize.Image = "rbxassetid://" .. 11036884234
		end
	
		if self.Topbar and self.Topbar:FindFirstChild("UIStroke") then
			self.Topbar.UIStroke.Color = self.getSelectedTheme().ElementStroke
		end
	
		task.spawn(closeSearch)
	
		for _, tabbtn in ipairs(self.TabList:GetChildren()) do
			if tabbtn.ClassName == "Frame" and tabbtn.Name ~= "Placeholder" then
				self.Animation:Create(tabbtn, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {BackgroundTransparency = 1}):Play()
				self.Animation:Create(tabbtn.Image, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {ImageTransparency = 1}):Play()
				self.Animation:Create(tabbtn.Title, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
				self.Animation:Create(tabbtn.UIStroke, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {Transparency = 1}):Play()
			end
		end
	
		for _, tab in ipairs(self.Elements:GetChildren()) do
			if tab.Name ~= "Template" and tab.ClassName == "ScrollingFrame" and tab.Name ~= "Placeholder" then
				for _, element in ipairs(tab:GetChildren()) do
					if element.ClassName == "Frame" then
						if element.Name ~= "SectionSpacing" and element.Name ~= "Placeholder" then
							if element.Name == "SectionTitle" or element.Name == 'SearchTitle-fsefsefesfsefesfesfThanks' then
								self.Animation:Create(element.Title, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
							elseif element.Name == 'Divider' then
								self.Animation:Create(element.Divider, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {BackgroundTransparency = 1}):Play()
							else
								self.Animation:Create(element, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {BackgroundTransparency = 1}):Play()
								self.Animation:Create(element.UIStroke, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {Transparency = 1}):Play()
								self.Animation:Create(element.Title, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
							end
							for _, child in ipairs(element:GetChildren()) do
								if child.ClassName == "Frame" or child.ClassName == "TextLabel" or child.ClassName == "TextBox" or child.ClassName == "ImageButton" or child.ClassName == "ImageLabel" then
									child.Visible = false
								end
							end
						end
					end
				end
			end
		end
	
		playTween(self.dragBarCosmetic, TweenInfo.new(0.25, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {BackgroundTransparency = 1})
		playTween(self.Topbar and self.Topbar:FindFirstChild("UIStroke"), TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {Transparency = 0})
		playTween(self.Main and self.Main:FindFirstChild("Shadow") and self.Main.Shadow:FindFirstChild("Image"), TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {ImageTransparency = 1})
		playTween(self.Topbar and self.Topbar:FindFirstChild("CornerRepair"), TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {BackgroundTransparency = 1})
		playTween(self.Topbar and self.Topbar:FindFirstChild("Divider"), TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {BackgroundTransparency = 1})
		playTween(self.Main, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {Size = UDim2.new(0, 495, 0, 45)})
		playTween(self.Topbar, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {Size = UDim2.new(0, 495, 0, 45)})
	
		task.wait(0.3)
	
		if self.Elements then
			self.Elements.Visible = false
		end
		if self.TabList then
			self.TabList.Visible = false
		end
	
		task.wait(0.2)
		Debounce = false
	end

	-- Export functions
	self.Notify = Notify
	self.openSearch = openSearch
	self.closeSearch = closeSearch
	self.Hide = Hide
	self.Unhide = Unhide
	self.Maximise = Maximise
	self.Minimise = Minimise
	self.getSearchOpen = function() return searchOpen end
	self.getDebounce = function() return Debounce end
	self.setDebounce = function(value) Debounce = value end
	self.getMinimised = function() return Minimised end
	self.setMinimised = function(value) Minimised = value end
	self.getHidden = function() return Hidden end
	self.setHidden = function(value) Hidden = value end
	
	return self
end

return UIStateModule
]])
put("src/core/window-controller.lua", [[local WindowController = {}

local function loadByPath(path)
	local client = _G and _G.__RayfieldApiClient
	if not client then
		error("Rayfield ApiClient is not initialized")
	end
	local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
	return client.fetchAndExecute(root .. path)
end

function WindowController.run(_runtime)
	return loadByPath("src/entry/rayfield-modified.runtime.lua")
end

return WindowController
]])
put("src/entry/module-map.lua", [[return {
	theme = {"src/services/theme.lua", "feature/rayfield-theme.lua"},
	settings = {"src/services/settings.lua", "feature/rayfield-settings.lua"},
	elementSync = {"src/services/element-sync.lua", "src/services/element-sync.lua"},
	keybindSequence = {"src/services/keybind-sequence.lua", "src/services/keybind-sequence.lua"},
	config = {"src/services/config.lua", "feature/rayfield-config.lua"},
	utilities = {"src/services/utilities.lua", "feature/rayfield-utilities.lua"},
	uiState = {"src/core/ui-state.lua", "feature/rayfield-ui-state.lua"},
	elements = {"src/ui/elements/factory/init.lua", "feature/rayfield-elements.lua"},
	elementsExtracted = {"src/ui/elements/widgets/index.lua", "feature/rayfield-elements-extracted.lua"},
	widgetsBootstrap = {"src/ui/elements/widgets/bootstrap.lua", "src/ui/elements/widgets/bootstrap.lua"},
	drag = {"src/feature/drag/init.lua", "feature/rayfield-drag.lua"},
	tabSplit = {"src/feature/tabsplit/init.lua", "feature/rayfield-tab-split.lua"},
	miniWindow = {"src/feature/mini-window/init.lua", "feature/mini-window-system.lua"},
	enhanced = {"src/feature/enhanced/init.lua", "feature/rayfield-enhanced.lua"},
	advanced = {"src/feature/enhanced/advanced.lua", "feature/rayfield-advanced-features.lua"},
	animationEngine = {"src/core/animation/engine.lua", "src/core/animation/engine.lua"},
	animationPublic = {"src/core/animation/public.lua", "src/core/animation/public.lua"},
	animationSequence = {"src/core/animation/sequence.lua", "src/core/animation/sequence.lua"},
	animationUI = {"src/core/animation/ui.lua", "src/core/animation/ui.lua"},
	animationText = {"src/core/animation/text.lua", "src/core/animation/text.lua"},
	animationEasing = {"src/core/animation/easing.lua", "src/core/animation/easing.lua"},
	animationCleanup = {"src/core/animation/cleanup.lua", "src/core/animation/cleanup.lua"},
	allInOne = {"src/entry/rayfield-all-in-one.entry.lua", "Main%20loader/rayfield-all-in-one.lua", "feature/rayfield-all-in-one.lua"},
	modifiedEntry = {"src/entry/rayfield-modified.entry.lua", "Main%20loader/rayfield-modified.lua"}
}
]])
put("src/entry/rayfield-all-in-one.entry.lua", [=[--[[
	Rayfield Enhanced V2 - All-in-One Loader

	===========================================
	DUAL-EXECUTION BEHAVIOR (Improvement 3)
	===========================================

	This loader has two different behaviors depending on how it's called:

	1. FIRST EXECUTION (Auto-Execute Mode):
	   - When loaded for the first time (_G.RayfieldAllInOneLoaded is nil/false)
	   - Automatically loads Rayfield based on CONFIG.AUTO_MODE setting
	   - Exports loaded UI to _G.Rayfield and _G.RayfieldUI
	   - Returns loader table by default (safer for executors that freeze on large return values)
	   - Sets _G.RayfieldAllInOneLoaded = true to track state

	   Example:
	     local loader = loadstring(game:HttpGet('...'))()
	     -- UI is exported globally:
	     local Window = _G.Rayfield:CreateWindow({...})

	2. SUBSEQUENT EXECUTIONS (Loader Table Mode):
	   - When loaded again (_G.RayfieldAllInOneLoaded is true)
	   - Returns the AllInOne loader table with all methods
	   - Does NOT auto-execute to prevent duplicate loading
	   - Allows manual control via loader.loadBase(), loader.loadEnhanced(), etc.

	   Example:
	     local loader = loadstring(game:HttpGet('...'))()
	     -- loader is the AllInOne table with methods
	     local UI = loader.loadEnhanced()

	To control this behavior:
	   - Set AUTO_EXECUTE = false in CONFIG (or configure({autoExecute = false}))
	     to disable auto-execution
	   - Set AUTO_EXECUTE_RETURN (or configure({autoExecuteReturn = "ui"/"loader"/"none"}))
	     to control what first execution returns
	   - Reset _G.RayfieldAllInOneLoaded = nil to force auto-execution again

	===========================================

	Usage:
		loadstring(game:HttpGet('https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/Main%20loader/rayfield-all-in-one.lua'))()

	Hoc nu host trn Pastebin:
		loadstring(game:HttpGet('https://pastebin.com/raw/YOUR_CODE'))()
]]

local AllInOne = {}
local compileString = loadstring or load
if not compileString then
	error("No Lua compiler function available (loadstring/load)")
end
local HttpService = game:GetService("HttpService")

local function compileChunk(source, label)
	if type(source) ~= "string" then
		error("Invalid Lua source for " .. tostring(label) .. ": " .. type(source))
	end
	source = source:gsub("^\239\187\191", "")
	source = source:gsub("^\0+", "")
	local chunk, err = compileString(source)
	if not chunk then
		error("Failed to compile " .. tostring(label) .. ": " .. tostring(err))
	end
	return chunk
end

local MODULE_ROOT_URL = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
_G.__RAYFIELD_RUNTIME_ROOT_URL = MODULE_ROOT_URL
local apiClientSource = game:HttpGet(MODULE_ROOT_URL .. "src/api/client.lua")
local ApiClient = compileChunk(apiClientSource, "src/api/client.lua")()
if _G then
	_G.__RayfieldApiClient = ApiClient
end

-- ============================================
-- CONFIGURATION
-- ============================================

local CONFIG = {
	-- URLs ca cc modules (thay bng URLs tht ca bn)
	BASE_URL = "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/",
	
	-- Hoc dng Pastebin
	USE_PASTEBIN = false,
	PASTEBIN_CODES = {
		base = "XXXXXXXX",
		enhanced = "YYYYYYYY",
		advanced = "ZZZZZZZZ"
	},
	
	-- Cache modules  trnh load li
	CACHE_ENABLED = true,
	
	-- Auto mode selection
	AUTO_MODE = "enhanced", -- "base", "enhanced", "advanced"

	-- Auto execute on first load (set false for loader-table only behavior)
	AUTO_EXECUTE = true,

	-- Return mode for first auto-execution:
	-- "loader" = return AllInOne (recommended)
	-- "ui" = return UI table from quickSetup
	-- "none" = return nil
	AUTO_EXECUTE_RETURN = "loader",

	-- Auto reload when GitHub has a new commit
	AUTO_RELOAD_ENABLED = true,
	AUTO_RELOAD_INTERVAL = 120, -- seconds
	AUTO_RELOAD_REPO = "Ahlstarr-Mayjishan/Rayfield-mod",
	AUTO_RELOAD_BRANCH = "main",
	AUTO_RELOAD_CLEAR_CACHE = true,
	
	-- Default settings
	DEFAULT_SETTINGS = {
		errorThreshold = 5,
		rateLimit = 10,
		autoCleanup = true
	}
}

-- ============================================
-- CACHE SYSTEM
-- ============================================

_G.RayfieldCache = _G.RayfieldCache or {}

local function getCached(key)
	if CONFIG.CACHE_ENABLED and _G.RayfieldCache[key] then
		print(" [Rayfield] Using cached:", key)
		return _G.RayfieldCache[key]
	end
	return nil
end

local function setCache(key, value)
	if CONFIG.CACHE_ENABLED then
		_G.RayfieldCache[key] = value
	end
end

local function getCacheKey(name, url)
	return tostring(name) .. "|" .. tostring(url)
end

local function isCachedModuleUsable(name, moduleValue)
	if type(moduleValue) ~= "table" then
		return false
	end

	-- Base module holds live GUI refs; if destroyed, force reload instead of reusing stale cache.
	if name == "base" then
		if type(moduleValue.CreateWindow) ~= "function" then
			return false
		end
		if type(moduleValue.IsDestroyed) == "function" then
			local ok, destroyed = pcall(moduleValue.IsDestroyed, moduleValue)
			if ok and destroyed then
				return false
			end
		end
	end

	return true
end

-- ============================================
-- MODULE LOADER
-- ============================================

local function loadModule(name, url)
	local cacheKey = getCacheKey(name, url)

	-- Check cache
	local cached = getCached(cacheKey)
	if cached then
		if isCachedModuleUsable(name, cached) then
			return cached
		end
		_G.RayfieldCache[cacheKey] = nil
		print(" [Rayfield] Cache invalidated:", cacheKey)
	end
	
	print(" [Rayfield] Loading:", name)
	
	local success, result = pcall(function()
		return ApiClient.fetchAndExecute(url)
	end)
	
	if not success then
		error(" Failed to load " .. name .. ": " .. tostring(result))
	end
	
	-- Cache result
	setCache(cacheKey, result)
	
	print(" [Rayfield] Loaded:", name)
	return result
end

-- ============================================
-- URL BUILDER
-- ============================================

local function getModuleUrl(moduleName)
	if CONFIG.USE_PASTEBIN then
		local code = CONFIG.PASTEBIN_CODES[moduleName]
		if not code then
			error("No Pastebin code for: " .. moduleName)
		end
		return "https://pastebin.com/raw/" .. code
	else
		local fileNames = {
			base = "Main%20loader/rayfield-modified.lua",
			enhanced = "src/entry/rayfield-enhanced.entry.lua",
			advanced = "src/feature/enhanced/advanced.lua"
		}
		return CONFIG.BASE_URL .. fileNames[moduleName]
	end
end

-- ============================================
-- AUTO RELOAD (COMMIT WATCHER)
-- ============================================

_G.RayfieldAllInOneAutoReloadState = _G.RayfieldAllInOneAutoReloadState or {
	running = false,
	reloading = false,
	token = 0,
	lastCommit = nil,
	lastReloadAt = nil,
	onReload = nil
}
local AutoReloadState = _G.RayfieldAllInOneAutoReloadState

local function shortCommit(commit)
	if type(commit) ~= "string" then
		return "unknown"
	end
	return string.sub(commit, 1, 7)
end

local function resolveRepoBranch()
	local repo = CONFIG.AUTO_RELOAD_REPO
	local branch = CONFIG.AUTO_RELOAD_BRANCH

	if (not repo or repo == "") and type(CONFIG.BASE_URL) == "string" then
		local owner, repoName, parsedBranch = string.match(CONFIG.BASE_URL, "raw%.githubusercontent%.com/([^/]+)/([^/]+)/([^/]+)/")
		if owner and repoName then
			repo = owner .. "/" .. repoName
			if not branch or branch == "" then
				branch = parsedBranch or "main"
			end
		end
	end

	if not branch or branch == "" then
		branch = "main"
	end

	return repo, branch
end

local function fetchLatestCommit()
	if CONFIG.USE_PASTEBIN then
		return nil, "auto reload only supports GitHub source"
	end

	local repo, branch = resolveRepoBranch()
	if not repo or repo == "" then
		return nil, "cannot resolve repository for auto reload"
	end

	local stamp = tostring(math.floor(os.clock() * 1000))
	local url = "https://api.github.com/repos/" .. repo .. "/commits/" .. branch .. "?_=" .. stamp

	local okHttp, body = pcall(function()
		return game:HttpGet(url)
	end)
	if not okHttp then
		return nil, tostring(body)
	end

	local okDecode, payload = pcall(function()
		return HttpService:JSONDecode(body)
	end)
	if not okDecode or type(payload) ~= "table" then
		return nil, "failed to decode GitHub response"
	end

	if type(payload.sha) ~= "string" or payload.sha == "" then
		return nil, "commit sha missing from response"
	end

	return payload.sha
end

local function exportCurrentUI(ui)
	if not ui or type(ui) ~= "table" then
		return
	end
	AllInOne.currentUI = ui
	_G.RayfieldUI = ui
	_G.Rayfield = ui.Rayfield
end

local function reloadForNewCommit(newCommit)
	if AutoReloadState.reloading then
		return false, "reload is already in progress"
	end

	AutoReloadState.reloading = true
	local previousRayfield = _G.Rayfield
	local previousUI = AllInOne.currentUI or _G.RayfieldUI
	local mode = (previousUI and previousUI.mode) or CONFIG.AUTO_MODE

	if CONFIG.AUTO_RELOAD_CLEAR_CACHE then
		AllInOne.clearCache()
	end

	local okLoad, reloadedUI = pcall(AllInOne.quickSetup, {
		mode = mode,
		errorThreshold = CONFIG.DEFAULT_SETTINGS.errorThreshold,
		rateLimit = CONFIG.DEFAULT_SETTINGS.rateLimit,
		autoCleanup = CONFIG.DEFAULT_SETTINGS.autoCleanup
	})

	if not okLoad then
		AutoReloadState.reloading = false
		return false, "reload failed: " .. tostring(reloadedUI)
	end

	if previousRayfield and previousRayfield ~= reloadedUI.Rayfield and type(previousRayfield.Destroy) == "function" then
		pcall(function()
			previousRayfield:Destroy()
		end)
	end

	exportCurrentUI(reloadedUI)
	AutoReloadState.lastCommit = newCommit or AutoReloadState.lastCommit
	AutoReloadState.lastReloadAt = os.time()

	if type(AutoReloadState.onReload) == "function" then
		pcall(AutoReloadState.onReload, reloadedUI, previousUI, newCommit)
	end

	AutoReloadState.reloading = false
	return true
end

local function stopAutoReloadWatcher(silent)
	AutoReloadState.running = false
	AutoReloadState.token = (AutoReloadState.token or 0) + 1
	if not silent then
		print(" [Rayfield] Auto reload stopped")
	end
end

local function startAutoReloadWatcher()
	if not CONFIG.AUTO_RELOAD_ENABLED then
		return false, "auto reload is disabled"
	end
	if CONFIG.USE_PASTEBIN then
		return false, "auto reload requires GitHub source"
	end
	if AutoReloadState.running then
		return true
	end

	local interval = tonumber(CONFIG.AUTO_RELOAD_INTERVAL) or 120
	if interval < 30 then
		interval = 30
	end
	CONFIG.AUTO_RELOAD_INTERVAL = interval

	local repo, branch = resolveRepoBranch()
	if not repo or repo == "" then
		return false, "cannot resolve repository"
	end

	AutoReloadState.running = true
	AutoReloadState.token = (AutoReloadState.token or 0) + 1
	local token = AutoReloadState.token

	local initialCommit, initialError = fetchLatestCommit()
	if initialCommit then
		AutoReloadState.lastCommit = initialCommit
		print(" [Rayfield] Auto reload watching " .. repo .. "@" .. branch .. " (" .. shortCommit(initialCommit) .. ")")
	elseif initialError then
		warn(" [Rayfield] Auto reload initial check failed: " .. tostring(initialError))
	end

	task.spawn(function()
		while AutoReloadState.running and AutoReloadState.token == token do
			task.wait(interval)
			if not AutoReloadState.running or AutoReloadState.token ~= token then
				break
			end

			local latestCommit, err = fetchLatestCommit()
			if latestCommit then
				local knownCommit = AutoReloadState.lastCommit
				if knownCommit and knownCommit ~= latestCommit then
					print(" [Rayfield] New commit detected: " .. shortCommit(knownCommit) .. " -> " .. shortCommit(latestCommit))
					local okReload, reloadError = reloadForNewCommit(latestCommit)
					if okReload then
						print(" [Rayfield] UI reloaded from latest commit (" .. shortCommit(latestCommit) .. ")")
					else
						warn(" [Rayfield] Auto reload failed: " .. tostring(reloadError))
					end
				elseif not knownCommit then
					AutoReloadState.lastCommit = latestCommit
				end
			elseif err then
				warn(" [Rayfield] Auto reload check failed: " .. tostring(err))
			end
		end
	end)

	return true
end

-- ============================================
-- LOAD FUNCTIONS
-- ============================================

function AllInOne.loadBase()
	print("\n")
	print(" Rayfield All-in-One: Base Mode")
	print("")
	
	local Rayfield = loadModule("base", getModuleUrl("base"))
	
	print(" Ready: Base UI")
	print("\n")
	
	return {
		Rayfield = Rayfield,
		mode = "base"
	}
end

function AllInOne.loadEnhanced()
	print("\n")
	print(" Rayfield All-in-One: Enhanced Mode")
	print("")
	
	local Rayfield = loadModule("base", getModuleUrl("base"))
	local Enhancement = loadModule("enhanced", getModuleUrl("enhanced"))
	
	local EnhancedRayfield, ErrorMgr, GC, RemoteProt, LeakDetector, Profiler = 
		Enhancement.createEnhancedRayfield(Rayfield)
	
	print(" Ready: Base + Enhanced V2")
	print("\n")
	
	return {
		Rayfield = EnhancedRayfield,
		ErrorManager = ErrorMgr,
		GarbageCollector = GC,
		RemoteProtection = RemoteProt,
		MemoryLeakDetector = LeakDetector,
		Profiler = Profiler,
		Enhancement = Enhancement,
		mode = "enhanced"
	}
end

function AllInOne.loadAdvanced()
	print("\n")
	print(" Rayfield All-in-One: Advanced Mode")
	print("")
	
	local Rayfield = loadModule("base", getModuleUrl("base"))
	local Enhancement = loadModule("enhanced", getModuleUrl("enhanced"))
	local Advanced = loadModule("advanced", getModuleUrl("advanced"))
	
	local EnhancedRayfield, ErrorMgr, GC, RemoteProt, LeakDetector, Profiler = 
		Enhancement.createEnhancedRayfield(Rayfield)
	
	print(" Ready: Full Stack (Base + Enhanced + Advanced)")
	print("\n")
	
	return {
		Rayfield = EnhancedRayfield,
		ErrorManager = ErrorMgr,
		GarbageCollector = GC,
		RemoteProtection = RemoteProt,
		MemoryLeakDetector = LeakDetector,
		Profiler = Profiler,
		Enhancement = Enhancement,
		Advanced = Advanced,
		StatePersistence = Advanced.StatePersistence,
		mode = "advanced"
	}
end

function AllInOne.loadAll()
	return AllInOne.loadAdvanced()
end

-- ============================================
-- QUICK SETUP
-- ============================================

function AllInOne.quickSetup(config)
	config = config or {}
	local mode = config.mode or CONFIG.AUTO_MODE
	
	local UI
	if mode == "base" then
		UI = AllInOne.loadBase()
	elseif mode == "enhanced" then
		UI = AllInOne.loadEnhanced()
	elseif mode == "advanced" or mode == "all" then
		UI = AllInOne.loadAdvanced()
	else
		error("Invalid mode: " .. tostring(mode))
	end
	
	-- Apply settings
	if UI.ErrorManager then
		if config.errorThreshold then
			UI.ErrorManager.errorThreshold = config.errorThreshold
		end
		if config.rateLimit then
			UI.ErrorManager.defaultRateLimit = config.rateLimit
		end
	end
	
	if UI.GarbageCollector and config.autoCleanup then
		UI.GarbageCollector.autoCleanupInterval = config.cleanupInterval or 60
	end

	AllInOne.currentUI = UI

	if CONFIG.AUTO_RELOAD_ENABLED and not AutoReloadState.running then
		local okStart, errStart = startAutoReloadWatcher()
		if not okStart and errStart then
			warn(" [Rayfield] Auto reload is enabled but failed to start: " .. tostring(errStart))
		end
	end
	
	return UI
end

-- ============================================
-- CONFIGURE
-- ============================================

function AllInOne.configure(config)
	if config.baseUrl then
		CONFIG.BASE_URL = config.baseUrl
	end
	
	if config.usePastebin ~= nil then
		CONFIG.USE_PASTEBIN = config.usePastebin
	end
	
	if config.pastebinCodes then
		for k, v in pairs(config.pastebinCodes) do
			CONFIG.PASTEBIN_CODES[k] = v
		end
	end
	
	if config.cacheEnabled ~= nil then
		CONFIG.CACHE_ENABLED = config.cacheEnabled
	end
	
	if config.autoMode then
		CONFIG.AUTO_MODE = config.autoMode
	end

	if config.autoExecute ~= nil then
		CONFIG.AUTO_EXECUTE = config.autoExecute
	end

	if config.autoExecuteReturn then
		local mode = tostring(config.autoExecuteReturn):lower()
		if mode == "loader" or mode == "ui" or mode == "none" then
			CONFIG.AUTO_EXECUTE_RETURN = mode
		else
			warn(" [Rayfield] Invalid autoExecuteReturn: " .. tostring(config.autoExecuteReturn) .. " (use 'loader', 'ui', or 'none')")
		end
	end

	if config.autoReload ~= nil then
		CONFIG.AUTO_RELOAD_ENABLED = config.autoReload and true or false
	end

	if config.autoReloadEnabled ~= nil then
		CONFIG.AUTO_RELOAD_ENABLED = config.autoReloadEnabled and true or false
	end

	if config.autoReloadInterval ~= nil then
		local interval = tonumber(config.autoReloadInterval)
		if interval and interval > 0 then
			CONFIG.AUTO_RELOAD_INTERVAL = interval
		else
			warn(" [Rayfield] Invalid autoReloadInterval: " .. tostring(config.autoReloadInterval))
		end
	end

	if config.autoReloadRepo then
		CONFIG.AUTO_RELOAD_REPO = tostring(config.autoReloadRepo)
	end

	if config.autoReloadBranch then
		CONFIG.AUTO_RELOAD_BRANCH = tostring(config.autoReloadBranch)
	end

	if config.autoReloadClearCache ~= nil then
		CONFIG.AUTO_RELOAD_CLEAR_CACHE = config.autoReloadClearCache and true or false
	end

	if config.autoReloadCallback ~= nil then
		if type(config.autoReloadCallback) == "function" then
			AutoReloadState.onReload = config.autoReloadCallback
		else
			warn(" [Rayfield] autoReloadCallback must be a function")
		end
	end

	if CONFIG.AUTO_RELOAD_ENABLED then
		if AutoReloadState.running then
			stopAutoReloadWatcher(true)
		end
		local okStart, errStart = startAutoReloadWatcher()
		if not okStart and errStart then
			warn(" [Rayfield] Auto reload start failed: " .. tostring(errStart))
		end
	else
		stopAutoReloadWatcher(true)
	end
	
	print(" [Rayfield] Configuration updated")
end

-- ============================================
-- UTILITIES
-- ============================================

function AllInOne.clearCache()
	_G.RayfieldCache = {}
	if type(_G.__RayfieldApiModuleCache) == "table" then
		table.clear(_G.__RayfieldApiModuleCache)
	end
	print(" [Rayfield] Cache cleared")
end

function AllInOne.checkForUpdates()
	local latestCommit, err = fetchLatestCommit()
	if not latestCommit then
		return {
			ok = false,
			error = err
		}
	end

	local currentCommit = AutoReloadState.lastCommit
	return {
		ok = true,
		latestCommit = latestCommit,
		currentCommit = currentCommit,
		hasUpdate = currentCommit ~= nil and latestCommit ~= currentCommit
	}
end

function AllInOne.reloadNow()
	local latestCommit, err = fetchLatestCommit()
	if not latestCommit then
		return false, "cannot fetch latest commit: " .. tostring(err)
	end
	local okReload, errReload = reloadForNewCommit(latestCommit)
	return okReload, errReload
end

function AllInOne.startAutoReload()
	CONFIG.AUTO_RELOAD_ENABLED = true
	return startAutoReloadWatcher()
end

function AllInOne.stopAutoReload()
	CONFIG.AUTO_RELOAD_ENABLED = false
	stopAutoReloadWatcher()
end

function AllInOne.setAutoReloadCallback(callback)
	if callback ~= nil and type(callback) ~= "function" then
		error("auto reload callback must be a function or nil")
	end
	AutoReloadState.onReload = callback
end

function AllInOne.info()
	print("\n")
	print(" Rayfield All-in-One Loader")
	print("")
	print("Version: 2.1.0")
	print("Cache Enabled:", CONFIG.CACHE_ENABLED)
	print("Auto Mode:", CONFIG.AUTO_MODE)
	print("Auto Execute:", CONFIG.AUTO_EXECUTE)
	print("Auto Execute Return:", CONFIG.AUTO_EXECUTE_RETURN)
	print("Auto Reload:", CONFIG.AUTO_RELOAD_ENABLED)
	print("Auto Reload Interval:", CONFIG.AUTO_RELOAD_INTERVAL)
	print("Auto Reload Repo:", CONFIG.AUTO_RELOAD_REPO .. "@" .. CONFIG.AUTO_RELOAD_BRANCH)
	print("Last Seen Commit:", AutoReloadState.lastCommit and shortCommit(AutoReloadState.lastCommit) or "n/a")
	print("\nCached Modules:")
	for name, _ in pairs(_G.RayfieldCache) do
		print("  ", name)
	end
	print("\nAvailable Modes:")
	print("   loadBase() - Base UI only")
	print("   loadEnhanced() - Base + Enhanced V2")
	print("   loadAdvanced() - Full Stack")
	print("   loadAll() - Same as loadAdvanced()")
	print("   quickSetup({mode = 'enhanced'}) - Quick setup")
	print("   startAutoReload() / stopAutoReload()")
	print("   checkForUpdates() / reloadNow()")
	print("\n")
end

-- ============================================
-- AUTO EXECUTE
-- ============================================

-- Improvement 3: Dual-execution behavior with clear documentation
-- First execution: Auto-loads UI and returns per CONFIG.AUTO_EXECUTE_RETURN
-- Subsequent executions: Returns AllInOne loader table (manual control)
if CONFIG.AUTO_EXECUTE and not _G.RayfieldAllInOneLoaded then
	_G.RayfieldAllInOneLoaded = true

	print("\n")
	print(" Rayfield All-in-One Auto-Loading")
	print("")
	print("Mode:", CONFIG.AUTO_MODE)
	print("\n")

	-- Auto load theo config
	local UI = AllInOne.quickSetup({
		mode = CONFIG.AUTO_MODE,
		errorThreshold = CONFIG.DEFAULT_SETTINGS.errorThreshold,
		rateLimit = CONFIG.DEFAULT_SETTINGS.rateLimit,
		autoCleanup = CONFIG.DEFAULT_SETTINGS.autoCleanup
	})

	-- Export to global
	_G.Rayfield = UI.Rayfield
	_G.RayfieldUI = UI
	AllInOne.currentUI = UI

	print(" [Rayfield] Auto-loaded successfully!")
	print("Access via: _G.Rayfield or _G.RayfieldUI")
	print("Return mode:", CONFIG.AUTO_EXECUTE_RETURN, "\n")

	if CONFIG.AUTO_RELOAD_ENABLED then
		local okStart, errStart = startAutoReloadWatcher()
		if not okStart and errStart then
			warn(" [Rayfield] Auto reload start failed: " .. tostring(errStart))
		end
	end

	-- Return lightweight loader by default to avoid executor freeze on large return objects
	if CONFIG.AUTO_EXECUTE_RETURN == "ui" then
		return UI
	elseif CONFIG.AUTO_EXECUTE_RETURN == "none" then
		return nil
	end
	return AllInOne
end

-- Return loader table on subsequent executions (allows manual control)
return AllInOne
]=])
put("src/entry/rayfield-enhanced.entry.lua", [[local compileString = loadstring or load
if not compileString then
	error("No Lua compiler function available (loadstring/load)")
end

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
local Client = compileString(game:HttpGet(root .. "src/api/client.lua"))()
if _G then
	_G.__RayfieldApiClient = Client
end
return Client.fetchAndExecute(root .. "src/feature/enhanced/init.lua")
]])
put("src/entry/rayfield-modified.entry.lua", [[-- Canonical entry orchestrator for Rayfield modified runtime

local client = _G and _G.__RayfieldApiClient
if not client then
	local compileString = loadstring or load
	if not compileString then
		error("No Lua compiler function available (loadstring/load)")
	end

	local function compileChunk(source, label)
		if type(source) ~= "string" then
			error("Invalid Lua source for " .. tostring(label) .. ": " .. type(source))
		end
		source = source:gsub("^\239\187\191", "")
		source = source:gsub("^\0+", "")
		local chunk, err = compileString(source)
		if not chunk then
			error("Failed to compile " .. tostring(label) .. ": " .. tostring(err))
		end
		return chunk
	end

	local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
	local clientSource = game:HttpGet(root .. "src/api/client.lua")
	client = compileChunk(clientSource, "src/api/client.lua")()
	if _G then
		_G.__RayfieldApiClient = client
	end
end

local root = (_G and _G.__RAYFIELD_RUNTIME_ROOT_URL) or "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"

-- Force fresh module graph per bootstrap run to avoid stale API module cache
-- when users rerun scripts in the same executor session.
pcall(function()
	local cache = client.fetchAndExecute(root .. "src/api/cache.lua")
	if cache and type(cache.clear) == "function" then
		cache.clear()
	end
end)

local RuntimeEnv = client.fetchAndExecute(root .. "src/core/runtime-env.lua")
local WindowController = client.fetchAndExecute(root .. "src/core/window-controller.lua")

-- Initialize UI orchestration modules so they are part of the canonical graph.
-- The runtime implementation still lives in rayfield-modified.runtime.lua for full compatibility.
local WindowUi = client.fetchAndExecute(root .. "src/ui/window/init.lua")
local TopbarUi = client.fetchAndExecute(root .. "src/ui/topbar/init.lua")
local TabsUi = client.fetchAndExecute(root .. "src/ui/tabs/init.lua")
local NotificationsUi = client.fetchAndExecute(root .. "src/ui/notifications/init.lua")

local runtime = RuntimeEnv.create()
WindowUi.init(runtime)
TopbarUi.init(runtime)
TabsUi.init(runtime)
NotificationsUi.init(runtime)

return WindowController.run(runtime)
]])
put("src/entry/rayfield-modified.runtime.lua", [=[--[[

	Rayfield Interface Suite
	by Sirius

	shlex  | Designing + Programming
	iRay   | Programming
	Max    | Programming
	Damian | Programming

	Modified Version with Extended API:
	- Element:Destroy() - Remove elements after creation
	- Element:Show() / :Hide() - Toggle element visibility
	- Element:SetVisible(bool) - Set visibility programmatically
	- Tab:Clear() - Remove all elements in tab
	- Section:Clear() - Remove all elements in section
	- Tab:GetElements() - Get list of all elements
	- Tab:FindElement(name) - Find element by name
	- Element:GetParent() - Get parent tab/section
	- Dropdown:Clear() visual fix - Updates UI immediately

]]

if debugX then
	warn('Initialising Rayfield')
end

local Compatibility = nil
local function getService(name)
	local service = game:GetService(name)
	if type(cloneref) == "function" then
		local okRef, ref = pcall(cloneref, service)
		if okRef and ref then
			return ref
		end
	end
	return service
end

-- Loads and executes a function hosted on a remote URL. Cancels the request if the requested URL takes too long to respond.
-- Errors with the function are caught and logged to the output
local function loadWithTimeout(url: string, timeout: number?): ...any
	assert(type(url) == "string", "Expected string, got " .. type(url))
	timeout = timeout or 5
	local requestCompleted = false
	local success, result = false, nil

	local requestThread = task.spawn(function()
		local fetchSuccess, fetchResult = pcall(game.HttpGet, game, url) -- game:HttpGet(url)
		-- Handle executor/network edge-cases where fetchResult can be nil/non-string.
		if not fetchSuccess then
			success, result = false, tostring(fetchResult or "HTTP request failed")
			requestCompleted = true
			return
		end

		if type(fetchResult) ~= "string" then
			success, result = false, "Invalid HTTP response type: " .. type(fetchResult)
			requestCompleted = true
			return
		end

		-- If the request succeeds but content is empty, surface a readable error.
		if #fetchResult == 0 then
			success, result = false, "Empty response"
			requestCompleted = true
			return
		end
		local content = fetchResult -- Fetched content

		-- Improvement 2: Validate content before passing to loadstring
		if type(content) ~= "string" then
			success, result = false, "Invalid content type: expected string, got " .. type(content)
			requestCompleted = true
			return
		end

		if #content == 0 then
			success, result = false, "Content is empty"
			requestCompleted = true
			return
		end

		local execSuccess, execResult = pcall(function()
			return loadstring(content)()
		end)
		success, result = execSuccess, execResult
		requestCompleted = true
	end)

	local timeoutThread = task.delay(timeout, function()
		if not requestCompleted then
			warn("Request for " .. url .. " timed out after " .. tostring(timeout) .. " seconds")
			task.cancel(requestThread)
			result = "Request timed out"
			requestCompleted = true
		end
	end)

	-- Wait for completion or timeout
	while not requestCompleted do
		task.wait()
	end
	-- Cancel timeout thread if still running when request completes
	if coroutine.status(timeoutThread) ~= "dead" then
		task.cancel(timeoutThread)
	end
	if not success then
		warn("Failed to process " .. tostring(url) .. ": " .. tostring(result))
	end
	return if success then result else nil
end

local requestsDisabled = true --getgenv and getgenv().DISABLE_RAYFIELD_REQUESTS
local InterfaceBuild = '3K3W'
local Release = "Build 1.68"
local RayfieldFolder = "Rayfield"
local ConfigurationFolder = RayfieldFolder.."/Configurations"
local ConfigurationExtension = ".rfld"
local settingsTable = {
	General = {
		-- if needs be in order just make getSetting(name)
		rayfieldOpen = {Type = 'bind', Value = 'K', Name = 'Rayfield Keybind'},
		-- buildwarnings
		-- rayfieldprompts

	},
	System = {
		usageAnalytics = {Type = 'toggle', Value = true, Name = 'Anonymised Analytics'},
	}
}

local HttpService = getService('HttpService')
local RunService = getService('RunService')

-- Environment Check
local useStudio = RunService:IsStudio() or false

local prompt = useStudio and require(script.Parent.prompt) or loadWithTimeout('https://raw.githubusercontent.com/SiriusSoftwareLtd/Sirius/refs/heads/request/prompt.lua')
local requestFunc = (syn and syn.request) or (fluxus and fluxus.request) or (http and http.request) or http_request or request

-- Validate prompt loaded correctly
if not prompt and not useStudio then
	warn("Failed to load prompt library, using fallback")
	prompt = {
		create = function() end -- No-op fallback
	}
end


-- The function below provides a safe alternative for calling error-prone functions
-- Especially useful for filesystem function (writefile, makefolder, etc.)
local function callSafely(func, ...)
	if func then
		local success, result = pcall(func, ...)
		if not success then
			warn("Rayfield | Function failed with error: ", result)
			return false
		else
			return result
		end
	end
end

-- Ensures a folder exists by creating it if needed
local function ensureFolder(folderPath)
	if isfolder and not callSafely(isfolder, folderPath) then
		callSafely(makefolder, folderPath)
	end
end

if debugX then
	warn('Now Loading Settings Configuration')
end

-- Note: Settings functions will be initialized after modules are loaded

if debugX then
	warn('Settings Loaded')
end

local analyticsLib
local sendReport = function(ev_n, sc_n) warn("Failed to load report function") end
if not requestsDisabled then
	if debugX then
		warn('Querying Settings for Reporter Information')
	end	
	analyticsLib = loadWithTimeout("https://analytics.sirius.menu/script")
	if not analyticsLib then
		warn("Failed to load analytics reporter")
		analyticsLib = nil
	elseif analyticsLib and type(analyticsLib.load) == "function" then
		analyticsLib:load()
	else
		warn("Analytics library loaded but missing load function")
		analyticsLib = nil
	end
	sendReport = function(ev_n, sc_n)
		if not (type(analyticsLib) == "table" and type(analyticsLib.isLoaded) == "function" and analyticsLib:isLoaded()) then
			warn("Analytics library not loaded")
			return
		end
		if useStudio then
			print('Sending Analytics')
		else
			if debugX then warn('Reporting Analytics') end
			analyticsLib:report(
				{
					["name"] = ev_n,
					["script"] = {["name"] = sc_n, ["version"] = Release}
				},
				{
					["version"] = InterfaceBuild
				}
			)
			if debugX then warn('Finished Report') end
		end
	end
	local shouldReportExecution = false
	if type(cachedSettings) == "table" then
		shouldReportExecution = (next(cachedSettings) == nil) or (cachedSettings.System and cachedSettings.System.usageAnalytics and cachedSettings.System.usageAnalytics.Value)
	elseif cachedSettings == nil then
		shouldReportExecution = true
	end

	if shouldReportExecution then
		sendReport("execution", "Rayfield")
	end
end

local promptUser = 2

if promptUser == 1 and prompt and type(prompt.create) == "function" then
	prompt.create(
		'Be cautious when running scripts',
	    [[Please be careful when running scripts from unknown developers. This script has already been ran.

<font transparency='0.3'>Some scripts may steal your items or in-game goods.</font>]],
		'Okay',
		'',
		function()

		end
	)
end

if debugX then
	warn('Moving on to continue initialisation')
end

local RayfieldLibrary = {
	Flags = {},
	Theme = {
		Default = {
			TextColor = Color3.fromRGB(240, 240, 240),

			Background = Color3.fromRGB(25, 25, 25),
			Topbar = Color3.fromRGB(34, 34, 34),
			Shadow = Color3.fromRGB(20, 20, 20),

			NotificationBackground = Color3.fromRGB(20, 20, 20),
			NotificationActionsBackground = Color3.fromRGB(230, 230, 230),

			TabBackground = Color3.fromRGB(80, 80, 80),
			TabStroke = Color3.fromRGB(85, 85, 85),
			TabBackgroundSelected = Color3.fromRGB(210, 210, 210),
			TabTextColor = Color3.fromRGB(240, 240, 240),
			SelectedTabTextColor = Color3.fromRGB(50, 50, 50),

			ElementBackground = Color3.fromRGB(35, 35, 35),
			ElementBackgroundHover = Color3.fromRGB(40, 40, 40),
			SecondaryElementBackground = Color3.fromRGB(25, 25, 25),
			ElementStroke = Color3.fromRGB(50, 50, 50),
			SecondaryElementStroke = Color3.fromRGB(40, 40, 40),

			SliderBackground = Color3.fromRGB(50, 138, 220),
			SliderProgress = Color3.fromRGB(50, 138, 220),
			SliderStroke = Color3.fromRGB(58, 163, 255),

			ToggleBackground = Color3.fromRGB(30, 30, 30),
			ToggleEnabled = Color3.fromRGB(0, 146, 214),
			ToggleDisabled = Color3.fromRGB(100, 100, 100),
			ToggleEnabledStroke = Color3.fromRGB(0, 170, 255),
			ToggleDisabledStroke = Color3.fromRGB(125, 125, 125),
			ToggleEnabledOuterStroke = Color3.fromRGB(100, 100, 100),
			ToggleDisabledOuterStroke = Color3.fromRGB(65, 65, 65),

			DropdownSelected = Color3.fromRGB(40, 40, 40),
			DropdownUnselected = Color3.fromRGB(30, 30, 30),

			InputBackground = Color3.fromRGB(30, 30, 30),
			InputStroke = Color3.fromRGB(65, 65, 65),
			PlaceholderColor = Color3.fromRGB(178, 178, 178)
		},

		Ocean = {
			TextColor = Color3.fromRGB(230, 240, 240),

			Background = Color3.fromRGB(20, 30, 30),
			Topbar = Color3.fromRGB(25, 40, 40),
			Shadow = Color3.fromRGB(15, 20, 20),

			NotificationBackground = Color3.fromRGB(25, 35, 35),
			NotificationActionsBackground = Color3.fromRGB(230, 240, 240),

			TabBackground = Color3.fromRGB(40, 60, 60),
			TabStroke = Color3.fromRGB(50, 70, 70),
			TabBackgroundSelected = Color3.fromRGB(100, 180, 180),
			TabTextColor = Color3.fromRGB(210, 230, 230),
			SelectedTabTextColor = Color3.fromRGB(20, 50, 50),

			ElementBackground = Color3.fromRGB(30, 50, 50),
			ElementBackgroundHover = Color3.fromRGB(40, 60, 60),
			SecondaryElementBackground = Color3.fromRGB(30, 45, 45),
			ElementStroke = Color3.fromRGB(45, 70, 70),
			SecondaryElementStroke = Color3.fromRGB(40, 65, 65),

			SliderBackground = Color3.fromRGB(0, 110, 110),
			SliderProgress = Color3.fromRGB(0, 140, 140),
			SliderStroke = Color3.fromRGB(0, 160, 160),

			ToggleBackground = Color3.fromRGB(30, 50, 50),
			ToggleEnabled = Color3.fromRGB(0, 130, 130),
			ToggleDisabled = Color3.fromRGB(70, 90, 90),
			ToggleEnabledStroke = Color3.fromRGB(0, 160, 160),
			ToggleDisabledStroke = Color3.fromRGB(85, 105, 105),
			ToggleEnabledOuterStroke = Color3.fromRGB(50, 100, 100),
			ToggleDisabledOuterStroke = Color3.fromRGB(45, 65, 65),

			DropdownSelected = Color3.fromRGB(30, 60, 60),
			DropdownUnselected = Color3.fromRGB(25, 40, 40),

			InputBackground = Color3.fromRGB(30, 50, 50),
			InputStroke = Color3.fromRGB(50, 70, 70),
			PlaceholderColor = Color3.fromRGB(140, 160, 160)
		},

		AmberGlow = {
			TextColor = Color3.fromRGB(255, 245, 230),

			Background = Color3.fromRGB(45, 30, 20),
			Topbar = Color3.fromRGB(55, 40, 25),
			Shadow = Color3.fromRGB(35, 25, 15),

			NotificationBackground = Color3.fromRGB(50, 35, 25),
			NotificationActionsBackground = Color3.fromRGB(245, 230, 215),

			TabBackground = Color3.fromRGB(75, 50, 35),
			TabStroke = Color3.fromRGB(90, 60, 45),
			TabBackgroundSelected = Color3.fromRGB(230, 180, 100),
			TabTextColor = Color3.fromRGB(250, 220, 200),
			SelectedTabTextColor = Color3.fromRGB(50, 30, 10),

			ElementBackground = Color3.fromRGB(60, 45, 35),
			ElementBackgroundHover = Color3.fromRGB(70, 50, 40),
			SecondaryElementBackground = Color3.fromRGB(55, 40, 30),
			ElementStroke = Color3.fromRGB(85, 60, 45),
			SecondaryElementStroke = Color3.fromRGB(75, 50, 35),

			SliderBackground = Color3.fromRGB(220, 130, 60),
			SliderProgress = Color3.fromRGB(250, 150, 75),
			SliderStroke = Color3.fromRGB(255, 170, 85),

			ToggleBackground = Color3.fromRGB(55, 40, 30),
			ToggleEnabled = Color3.fromRGB(240, 130, 30),
			ToggleDisabled = Color3.fromRGB(90, 70, 60),
			ToggleEnabledStroke = Color3.fromRGB(255, 160, 50),
			ToggleDisabledStroke = Color3.fromRGB(110, 85, 75),
			ToggleEnabledOuterStroke = Color3.fromRGB(200, 100, 50),
			ToggleDisabledOuterStroke = Color3.fromRGB(75, 60, 55),

			DropdownSelected = Color3.fromRGB(70, 50, 40),
			DropdownUnselected = Color3.fromRGB(55, 40, 30),

			InputBackground = Color3.fromRGB(60, 45, 35),
			InputStroke = Color3.fromRGB(90, 65, 50),
			PlaceholderColor = Color3.fromRGB(190, 150, 130)
		},

		Light = {
			TextColor = Color3.fromRGB(40, 40, 40),

			Background = Color3.fromRGB(245, 245, 245),
			Topbar = Color3.fromRGB(230, 230, 230),
			Shadow = Color3.fromRGB(200, 200, 200),

			NotificationBackground = Color3.fromRGB(250, 250, 250),
			NotificationActionsBackground = Color3.fromRGB(240, 240, 240),

			TabBackground = Color3.fromRGB(235, 235, 235),
			TabStroke = Color3.fromRGB(215, 215, 215),
			TabBackgroundSelected = Color3.fromRGB(255, 255, 255),
			TabTextColor = Color3.fromRGB(80, 80, 80),
			SelectedTabTextColor = Color3.fromRGB(0, 0, 0),

			ElementBackground = Color3.fromRGB(240, 240, 240),
			ElementBackgroundHover = Color3.fromRGB(225, 225, 225),
			SecondaryElementBackground = Color3.fromRGB(235, 235, 235),
			ElementStroke = Color3.fromRGB(210, 210, 210),
			SecondaryElementStroke = Color3.fromRGB(210, 210, 210),

			SliderBackground = Color3.fromRGB(150, 180, 220),
			SliderProgress = Color3.fromRGB(100, 150, 200), 
			SliderStroke = Color3.fromRGB(120, 170, 220),

			ToggleBackground = Color3.fromRGB(220, 220, 220),
			ToggleEnabled = Color3.fromRGB(0, 146, 214),
			ToggleDisabled = Color3.fromRGB(150, 150, 150),
			ToggleEnabledStroke = Color3.fromRGB(0, 170, 255),
			ToggleDisabledStroke = Color3.fromRGB(170, 170, 170),
			ToggleEnabledOuterStroke = Color3.fromRGB(100, 100, 100),
			ToggleDisabledOuterStroke = Color3.fromRGB(180, 180, 180),

			DropdownSelected = Color3.fromRGB(230, 230, 230),
			DropdownUnselected = Color3.fromRGB(220, 220, 220),

			InputBackground = Color3.fromRGB(240, 240, 240),
			InputStroke = Color3.fromRGB(180, 180, 180),
			PlaceholderColor = Color3.fromRGB(140, 140, 140)
		},

		Amethyst = {
			TextColor = Color3.fromRGB(240, 240, 240),

			Background = Color3.fromRGB(30, 20, 40),
			Topbar = Color3.fromRGB(40, 25, 50),
			Shadow = Color3.fromRGB(20, 15, 30),

			NotificationBackground = Color3.fromRGB(35, 20, 40),
			NotificationActionsBackground = Color3.fromRGB(240, 240, 250),

			TabBackground = Color3.fromRGB(60, 40, 80),
			TabStroke = Color3.fromRGB(70, 45, 90),
			TabBackgroundSelected = Color3.fromRGB(180, 140, 200),
			TabTextColor = Color3.fromRGB(230, 230, 240),
			SelectedTabTextColor = Color3.fromRGB(50, 20, 50),

			ElementBackground = Color3.fromRGB(45, 30, 60),
			ElementBackgroundHover = Color3.fromRGB(50, 35, 70),
			SecondaryElementBackground = Color3.fromRGB(40, 30, 55),
			ElementStroke = Color3.fromRGB(70, 50, 85),
			SecondaryElementStroke = Color3.fromRGB(65, 45, 80),

			SliderBackground = Color3.fromRGB(100, 60, 150),
			SliderProgress = Color3.fromRGB(130, 80, 180),
			SliderStroke = Color3.fromRGB(150, 100, 200),

			ToggleBackground = Color3.fromRGB(45, 30, 55),
			ToggleEnabled = Color3.fromRGB(120, 60, 150),
			ToggleDisabled = Color3.fromRGB(94, 47, 117),
			ToggleEnabledStroke = Color3.fromRGB(140, 80, 170),
			ToggleDisabledStroke = Color3.fromRGB(124, 71, 150),
			ToggleEnabledOuterStroke = Color3.fromRGB(90, 40, 120),
			ToggleDisabledOuterStroke = Color3.fromRGB(80, 50, 110),

			DropdownSelected = Color3.fromRGB(50, 35, 70),
			DropdownUnselected = Color3.fromRGB(35, 25, 50),

			InputBackground = Color3.fromRGB(45, 30, 60),
			InputStroke = Color3.fromRGB(80, 50, 110),
			PlaceholderColor = Color3.fromRGB(178, 150, 200)
		},

		Green = {
			TextColor = Color3.fromRGB(30, 60, 30),

			Background = Color3.fromRGB(235, 245, 235),
			Topbar = Color3.fromRGB(210, 230, 210),
			Shadow = Color3.fromRGB(200, 220, 200),

			NotificationBackground = Color3.fromRGB(240, 250, 240),
			NotificationActionsBackground = Color3.fromRGB(220, 235, 220),

			TabBackground = Color3.fromRGB(215, 235, 215),
			TabStroke = Color3.fromRGB(190, 210, 190),
			TabBackgroundSelected = Color3.fromRGB(245, 255, 245),
			TabTextColor = Color3.fromRGB(50, 80, 50),
			SelectedTabTextColor = Color3.fromRGB(20, 60, 20),

			ElementBackground = Color3.fromRGB(225, 240, 225),
			ElementBackgroundHover = Color3.fromRGB(210, 225, 210),
			SecondaryElementBackground = Color3.fromRGB(235, 245, 235), 
			ElementStroke = Color3.fromRGB(180, 200, 180),
			SecondaryElementStroke = Color3.fromRGB(180, 200, 180),

			SliderBackground = Color3.fromRGB(90, 160, 90),
			SliderProgress = Color3.fromRGB(70, 130, 70),
			SliderStroke = Color3.fromRGB(100, 180, 100),

			ToggleBackground = Color3.fromRGB(215, 235, 215),
			ToggleEnabled = Color3.fromRGB(60, 130, 60),
			ToggleDisabled = Color3.fromRGB(150, 175, 150),
			ToggleEnabledStroke = Color3.fromRGB(80, 150, 80),
			ToggleDisabledStroke = Color3.fromRGB(130, 150, 130),
			ToggleEnabledOuterStroke = Color3.fromRGB(100, 160, 100),
			ToggleDisabledOuterStroke = Color3.fromRGB(160, 180, 160),

			DropdownSelected = Color3.fromRGB(225, 240, 225),
			DropdownUnselected = Color3.fromRGB(210, 225, 210),

			InputBackground = Color3.fromRGB(235, 245, 235),
			InputStroke = Color3.fromRGB(180, 200, 180),
			PlaceholderColor = Color3.fromRGB(120, 140, 120)
		},

		Bloom = {
			TextColor = Color3.fromRGB(60, 40, 50),

			Background = Color3.fromRGB(255, 240, 245),
			Topbar = Color3.fromRGB(250, 220, 225),
			Shadow = Color3.fromRGB(230, 190, 195),

			NotificationBackground = Color3.fromRGB(255, 235, 240),
			NotificationActionsBackground = Color3.fromRGB(245, 215, 225),

			TabBackground = Color3.fromRGB(240, 210, 220),
			TabStroke = Color3.fromRGB(230, 200, 210),
			TabBackgroundSelected = Color3.fromRGB(255, 225, 235),
			TabTextColor = Color3.fromRGB(80, 40, 60),
			SelectedTabTextColor = Color3.fromRGB(50, 30, 50),

			ElementBackground = Color3.fromRGB(255, 235, 240),
			ElementBackgroundHover = Color3.fromRGB(245, 220, 230),
			SecondaryElementBackground = Color3.fromRGB(255, 235, 240), 
			ElementStroke = Color3.fromRGB(230, 200, 210),
			SecondaryElementStroke = Color3.fromRGB(230, 200, 210),

			SliderBackground = Color3.fromRGB(240, 130, 160),
			SliderProgress = Color3.fromRGB(250, 160, 180),
			SliderStroke = Color3.fromRGB(255, 180, 200),

			ToggleBackground = Color3.fromRGB(240, 210, 220),
			ToggleEnabled = Color3.fromRGB(255, 140, 170),
			ToggleDisabled = Color3.fromRGB(200, 180, 185),
			ToggleEnabledStroke = Color3.fromRGB(250, 160, 190),
			ToggleDisabledStroke = Color3.fromRGB(210, 180, 190),
			ToggleEnabledOuterStroke = Color3.fromRGB(220, 160, 180),
			ToggleDisabledOuterStroke = Color3.fromRGB(190, 170, 180),

			DropdownSelected = Color3.fromRGB(250, 220, 225),
			DropdownUnselected = Color3.fromRGB(240, 210, 220),

			InputBackground = Color3.fromRGB(255, 235, 240),
			InputStroke = Color3.fromRGB(220, 190, 200),
			PlaceholderColor = Color3.fromRGB(170, 130, 140)
		},

		DarkBlue = {
			TextColor = Color3.fromRGB(230, 230, 230),

			Background = Color3.fromRGB(20, 25, 30),
			Topbar = Color3.fromRGB(30, 35, 40),
			Shadow = Color3.fromRGB(15, 20, 25),

			NotificationBackground = Color3.fromRGB(25, 30, 35),
			NotificationActionsBackground = Color3.fromRGB(45, 50, 55),

			TabBackground = Color3.fromRGB(35, 40, 45),
			TabStroke = Color3.fromRGB(45, 50, 60),
			TabBackgroundSelected = Color3.fromRGB(40, 70, 100),
			TabTextColor = Color3.fromRGB(200, 200, 200),
			SelectedTabTextColor = Color3.fromRGB(255, 255, 255),

			ElementBackground = Color3.fromRGB(30, 35, 40),
			ElementBackgroundHover = Color3.fromRGB(40, 45, 50),
			SecondaryElementBackground = Color3.fromRGB(35, 40, 45), 
			ElementStroke = Color3.fromRGB(45, 50, 60),
			SecondaryElementStroke = Color3.fromRGB(40, 45, 55),

			SliderBackground = Color3.fromRGB(0, 90, 180),
			SliderProgress = Color3.fromRGB(0, 120, 210),
			SliderStroke = Color3.fromRGB(0, 150, 240),

			ToggleBackground = Color3.fromRGB(35, 40, 45),
			ToggleEnabled = Color3.fromRGB(0, 120, 210),
			ToggleDisabled = Color3.fromRGB(70, 70, 80),
			ToggleEnabledStroke = Color3.fromRGB(0, 150, 240),
			ToggleDisabledStroke = Color3.fromRGB(75, 75, 85),
			ToggleEnabledOuterStroke = Color3.fromRGB(20, 100, 180), 
			ToggleDisabledOuterStroke = Color3.fromRGB(55, 55, 65),

			DropdownSelected = Color3.fromRGB(30, 70, 90),
			DropdownUnselected = Color3.fromRGB(25, 30, 35),

			InputBackground = Color3.fromRGB(25, 30, 35),
			InputStroke = Color3.fromRGB(45, 50, 60), 
			PlaceholderColor = Color3.fromRGB(150, 150, 160)
		},

		Serenity = {
			TextColor = Color3.fromRGB(50, 55, 60),
			Background = Color3.fromRGB(240, 245, 250),
			Topbar = Color3.fromRGB(215, 225, 235),
			Shadow = Color3.fromRGB(200, 210, 220),

			NotificationBackground = Color3.fromRGB(210, 220, 230),
			NotificationActionsBackground = Color3.fromRGB(225, 230, 240),

			TabBackground = Color3.fromRGB(200, 210, 220),
			TabStroke = Color3.fromRGB(180, 190, 200),
			TabBackgroundSelected = Color3.fromRGB(175, 185, 200),
			TabTextColor = Color3.fromRGB(50, 55, 60),
			SelectedTabTextColor = Color3.fromRGB(30, 35, 40),

			ElementBackground = Color3.fromRGB(210, 220, 230),
			ElementBackgroundHover = Color3.fromRGB(220, 230, 240),
			SecondaryElementBackground = Color3.fromRGB(200, 210, 220),
			ElementStroke = Color3.fromRGB(190, 200, 210),
			SecondaryElementStroke = Color3.fromRGB(180, 190, 200),

			SliderBackground = Color3.fromRGB(200, 220, 235),  -- Lighter shade
			SliderProgress = Color3.fromRGB(70, 130, 180),
			SliderStroke = Color3.fromRGB(150, 180, 220),

			ToggleBackground = Color3.fromRGB(210, 220, 230),
			ToggleEnabled = Color3.fromRGB(70, 160, 210),
			ToggleDisabled = Color3.fromRGB(180, 180, 180),
			ToggleEnabledStroke = Color3.fromRGB(60, 150, 200),
			ToggleDisabledStroke = Color3.fromRGB(140, 140, 140),
			ToggleEnabledOuterStroke = Color3.fromRGB(100, 120, 140),
			ToggleDisabledOuterStroke = Color3.fromRGB(120, 120, 130),

			DropdownSelected = Color3.fromRGB(220, 230, 240),
			DropdownUnselected = Color3.fromRGB(200, 210, 220),

			InputBackground = Color3.fromRGB(220, 230, 240),
			InputStroke = Color3.fromRGB(180, 190, 200),
			PlaceholderColor = Color3.fromRGB(150, 150, 150)
		},
	}
}

-- Compatibility wrapper for loadstring (some executors use different names)
local compileString = loadstring or load
if not compileString then
	error("No Lua compiler function available (loadstring/load). Your executor may not support dynamic code loading.")
end

-- Load external modules through shared API loader
local MODULE_ROOT_URL = "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"
_G.__RAYFIELD_RUNTIME_ROOT_URL = MODULE_ROOT_URL

local ApiClient = compileString(game:HttpGet(MODULE_ROOT_URL .. "src/api/client.lua"))()
Compatibility = ApiClient.fetchAndExecute(MODULE_ROOT_URL .. "src/services/compatibility.lua")
if type(Compatibility) ~= "table" then
	error("Invalid compatibility module: expected table")
end
if _G then
	_G.__RayfieldCompatibility = Compatibility
end
if type(Compatibility.getService) == "function" then
	getService = Compatibility.getService
end

local WidgetBootstrap = ApiClient.fetchAndExecute(MODULE_ROOT_URL .. "src/ui/elements/widgets/bootstrap.lua")
if type(WidgetBootstrap) ~= "table" or type(WidgetBootstrap.bootstrapWidget) ~= "function" then
	error("Invalid widget bootstrap module: missing bootstrapWidget")
end
if _G then
	_G.__RayfieldWidgetBootstrap = WidgetBootstrap
end
local ApiLoader = ApiClient.fetchAndExecute(MODULE_ROOT_URL .. "src/api/loader.lua")

local function getScriptRef()
	local scriptRef = nil
	pcall(function()
		scriptRef = script
	end)
	return scriptRef
end

local function loadModule(moduleName)
	return ApiLoader.load(moduleName, {
		tryStudioRequire = useStudio,
		scriptRef = getScriptRef()
	})
end

local ThemeModule = loadModule("theme")
local SettingsModuleLib = loadModule("settings")
local ElementSyncModuleLib = loadModule("elementSync")
local KeybindSequenceLib = loadModule("keybindSequence")
local DragModuleLib = loadModule("drag")
local UIStateModuleLib = loadModule("uiState")
local ElementsModuleLib = loadModule("elements")
local ConfigModuleLib = loadModule("config")
local UtilitiesModuleLib = loadModule("utilities")
local TabSplitModuleLib = loadModule("tabSplit")
local AnimationEngineLib = loadModule("animationEngine")
local AnimationPublicLib = loadModule("animationPublic")
local AnimationSequenceLib = loadModule("animationSequence")
local AnimationUILib = loadModule("animationUI")
local AnimationTextLib = loadModule("animationText")
local AnimationCleanupLib = loadModule("animationCleanup")

-- Services
local UserInputService = getService("UserInputService")
local TweenService = getService("TweenService")
local Players = getService("Players")
local CoreGui = getService("CoreGui")

local AnimationEngine = AnimationEngineLib.new({
	TweenService = TweenService,
	RunService = RunService,
	Cleanup = AnimationCleanupLib,
	mode = "raw"
})
local Animation = AnimationEngine
local RayfieldAnimate = AnimationPublicLib.bindToRayfield(RayfieldLibrary, AnimationEngine, {
	Sequence = AnimationSequenceLib,
	UI = AnimationUILib,
	Text = AnimationTextLib
})
if _G then
	_G.__RayfieldSharedAnimationEngine = AnimationEngine
	_G.__RayfieldSharedAnimateFacade = RayfieldAnimate
end

-- Interface Management

local Rayfield
if useStudio then
	Rayfield = script.Parent:FindFirstChild('Rayfield')
else
	-- Try to load GUI from Roblox asset
	local success, result = pcall(function()
		return game:GetObjects("rbxassetid://10804731440")[1]
	end)

	if success and result then
		Rayfield = result
	else
		-- Fallback: Some executors don't support game:GetObjects()
		warn("Rayfield | game:GetObjects() failed. Your executor may not support loading GUI assets.")
		warn("Rayfield | Error: " .. tostring(result))
		error("Unable to load Rayfield GUI. Your executor may not support game:GetObjects(). Try using a different executor or loading from a local file.")
	end
end

if not Rayfield then
	error("Rayfield GUI failed to load. Please check your executor compatibility.")
end

local buildAttempts = 0
local correctBuild = false
local warned
local globalLoaded
local rayfieldDestroyed = false -- True when RayfieldLibrary:Destroy() is called

repeat
	if Rayfield:FindFirstChild('Build') and Rayfield.Build.Value == InterfaceBuild then
		correctBuild = true
		break
	end

	correctBuild = false

	if not warned then
		warn('Rayfield | Build Mismatch')
		print('Rayfield may encounter issues as you are running an incompatible interface version ('.. ((Rayfield:FindFirstChild('Build') and Rayfield.Build.Value) or 'No Build') ..').\n\nThis version of Rayfield is intended for interface build '..InterfaceBuild..'.')
		warned = true
	end

	local oldRayfield = Rayfield
	if useStudio then
		Rayfield = script.Parent:FindFirstChild('Rayfield')
	else
		local success, result = pcall(function()
			return game:GetObjects("rbxassetid://10804731440")[1]
		end)
		if success and result then
			Rayfield = result
		else
			warn("Rayfield | Failed to reload GUI on retry: " .. tostring(result))
			break
		end
	end

	if oldRayfield and not useStudio then
		oldRayfield:Destroy()
	end

	buildAttempts = buildAttempts + 1
until buildAttempts >= 2

Rayfield.Enabled = false

local rayfieldContainer = nil
if Compatibility and type(Compatibility.protectAndParent) == "function" then
	rayfieldContainer = Compatibility.protectAndParent(Rayfield, nil, {
		useStudio = useStudio
	})
elseif not useStudio then
	Rayfield.Parent = CoreGui
	rayfieldContainer = CoreGui
end

if Compatibility and type(Compatibility.dedupeGuiByName) == "function" then
	Compatibility.dedupeGuiByName(rayfieldContainer, Rayfield.Name, Rayfield, "-Old")
elseif not useStudio and rayfieldContainer then
	for _, Interface in ipairs(rayfieldContainer:GetChildren()) do
		if Interface.Name == Rayfield.Name and Interface ~= Rayfield then
			Interface.Enabled = false
			Interface.Name = "Rayfield-Old"
		end
	end
end


local minSize = Vector2.new(1024, 768)
local useMobileSizing

if Rayfield.AbsoluteSize.X < minSize.X and Rayfield.AbsoluteSize.Y < minSize.Y then
	useMobileSizing = true
end

if UserInputService.TouchEnabled then
	useMobilePrompt = true
end


-- Object Variables

local Main = Rayfield.Main
if not Main then
	error("Rayfield GUI structure error: Main container not found. The GUI asset may be corrupted or incompatible.")
end

local MPrompt = Rayfield:FindFirstChild('Prompt')
local Topbar = Main.Topbar
local Elements = Main.Elements
local LoadingFrame = Main.LoadingFrame
local TabList = Main.TabList

-- Validate critical GUI components
if not Elements then
	error("Rayfield GUI structure error: Elements container not found. The GUI asset may be corrupted.")
end
if not Elements:FindFirstChild('Template') then
	error("Rayfield GUI structure error: Elements.Template not found. The GUI asset may be corrupted.")
end
if not TabList then
	error("Rayfield GUI structure error: TabList container not found. The GUI asset may be corrupted.")
end

local dragBar = Rayfield:FindFirstChild('Drag')
local dragInteract = dragBar and dragBar.Interact or nil
local dragBarCosmetic = dragBar and dragBar.Drag or nil

local dragOffset = 255
local dragOffsetMobile = 150

Rayfield.DisplayOrder = 100
LoadingFrame.Version.Text = Release

-- Thanks to Latte Softworks for the Lucide integration for Roblox
local Icons = useStudio and require(script.Parent.icons) or loadWithTimeout('https://raw.githubusercontent.com/SiriusSoftwareLtd/Rayfield/refs/heads/main/icons.lua')

-- Variables
local CFileName = nil
local CEnabled = false
local Minimised = false
local Hidden = false
local Debounce = false
local searchOpen = false
local Notifications = Rayfield.Notifications
local ElementSyncSystem = nil
local keybindConnections = {} -- For storing keybind connections to disconnect when Rayfield is destroyed
local uiToggleKeybindMatcher = KeybindSequenceLib.newMatcher({
	maxSteps = 4,
	stepTimeoutMs = 800
})
local cachedUiToggleKeybindRaw = nil
local cachedUiToggleKeybindSpec = nil

local function resolveUiToggleKeybindSpec(rawBinding)
	if rawBinding == cachedUiToggleKeybindRaw and cachedUiToggleKeybindSpec then
		return cachedUiToggleKeybindSpec
	end

	local canonical, steps = KeybindSequenceLib.normalize(rawBinding, {
		maxSteps = 4
	})
	if not canonical then
		cachedUiToggleKeybindRaw = nil
		cachedUiToggleKeybindSpec = nil
		return nil
	end

	cachedUiToggleKeybindRaw = rawBinding
	cachedUiToggleKeybindSpec = {
		canonical = canonical,
		steps = steps
	}
	return cachedUiToggleKeybindSpec
end

AnimationEngine:SetUiSuppressionProvider(function()
	return Hidden == true or Minimised == true or rayfieldDestroyed == true
end)

-- Initialize Theme Module
local ThemeSystem = ThemeModule.init({
	Rayfield = Rayfield,
	Main = Main,
	Topbar = Topbar,
	Elements = Elements,
	Notifications = Notifications,
	Icons = Icons
})

local bindTheme = ThemeSystem.bindTheme

-- Apply Reactive Theme to Main UI (with nil guards for UI structure resilience)
bindTheme(Main, "BackgroundColor3", "Background")
bindTheme(Topbar, "BackgroundColor3", "Topbar")

local cornerRepair = Topbar:FindFirstChild("CornerRepair")
if cornerRepair then
	bindTheme(cornerRepair, "BackgroundColor3", "Topbar")
end

local shadow = Main:FindFirstChild("Shadow")
if shadow and shadow:FindFirstChild("Image") then
	bindTheme(shadow.Image, "ImageColor3", "Shadow")
end

if Topbar:FindFirstChild("ChangeSize") then
	bindTheme(Topbar.ChangeSize, "ImageColor3", "TextColor")
end
if Topbar:FindFirstChild("Hide") then
	bindTheme(Topbar.Hide, "ImageColor3", "TextColor")
end
if Topbar:FindFirstChild("Search") then
	bindTheme(Topbar.Search, "ImageColor3", "TextColor")
end

if Topbar:FindFirstChild('Settings') then
	bindTheme(Topbar.Settings, "ImageColor3", "TextColor")
	if Topbar:FindFirstChild('Divider') then
		bindTheme(Topbar.Divider, "BackgroundColor3", "ElementStroke")
	end
end

-- Search UI Reactive (guarded)
local searchFrame = Main:FindFirstChild("Search")
if searchFrame then
	bindTheme(searchFrame, "BackgroundColor3", "TextColor")
	if searchFrame:FindFirstChild("Shadow") then
		bindTheme(searchFrame.Shadow, "ImageColor3", "TextColor")
	end
	if searchFrame:FindFirstChild("Search") then
		bindTheme(searchFrame.Search, "ImageColor3", "TextColor")
	end
	if searchFrame:FindFirstChild("Input") then
		bindTheme(searchFrame.Input, "PlaceholderColor3", "TextColor")
	end
	if searchFrame:FindFirstChild("UIStroke") then
		bindTheme(searchFrame.UIStroke, "Color", "SecondaryElementStroke")
	end
end

-- Initialize Settings Module
local SettingsSystem = SettingsModuleLib.init({
	RayfieldFolder = RayfieldFolder,
	ConfigurationExtension = ConfigurationExtension,
	HttpService = HttpService,
	useStudio = useStudio,
	callSafely = callSafely,
	Topbar = Topbar,
	TabList = TabList,
	Elements = Elements
})

-- Initialize Configuration Module
local ConfigSystem = ConfigModuleLib.init({
	HttpService = HttpService,
	RayfieldLibrary = RayfieldLibrary,
	callSafely = callSafely,
	ConfigurationFolder = ConfigurationFolder,
	ConfigurationExtension = ConfigurationExtension,
	getCFileName = function() return CFileName end,
	getCEnabled = function() return CEnabled end,
	getGlobalLoaded = function() return globalLoaded end,
	useStudio = useStudio,
	debugX = debugX
})

-- Initialize Utilities Module (will be fully initialized after UI elements are created)
local UtilitiesSystem = nil -- Initialized later after UI elements exist

-- Expose theme definitions to RayfieldLibrary
RayfieldLibrary.Theme = ThemeModule.Themes

-- Use theme system's selected theme
local SelectedTheme = ThemeSystem.SelectedTheme

-- Theme helpers
local function ChangeTheme(Theme)
	ThemeSystem.ChangeTheme(Theme)
	SelectedTheme = ThemeSystem.SelectedTheme
end

local function getIcon(name)
	return ThemeSystem.getIcon(name)
end

-- Settings wrapper functions
local function getSetting(category, name)
	return SettingsSystem.getSetting(category, name)
end

local function overrideSetting(category, name, value)
	return SettingsSystem.overrideSetting(category, name, value)
end

local function saveSettings()
	return SettingsSystem.saveSettings()
end

local function updateSetting(category, setting, value)
	return SettingsSystem.updateSetting(category, setting, value)
end

local function loadSettings()
	return SettingsSystem.loadSettings()
end

local function createSettings(window)
	return SettingsSystem.createSettings(window)
end

-- Local settings references
local settingsTable = SettingsSystem.settingsTable
local settingsCreated = SettingsSystem.settingsCreated
local settingsInitialized = SettingsSystem.settingsInitialized
local overriddenSettings = SettingsSystem.overriddenSettings
local cachedSettings = SettingsSystem.cachedSettings

-- Call initial loadSettings
loadSettings()

-- If requests/analytics have been disabled by developer, set the user-facing setting to false as well
if requestsDisabled then
	overrideSetting("System", "usageAnalytics", false)
end

-- Initialize Drag Module
local DragSystem = DragModuleLib.init({
	UserInputService = UserInputService,
	TweenService = TweenService,
	Animation = Animation,
	RunService = RunService,
	HttpService = HttpService,
	Main = Main,
	Topbar = Topbar,
	Elements = Elements,
	Rayfield = Rayfield,
	Icons = Icons,
	getIcon = getIcon,
	getAssetUri = getAssetUri,
	getSelectedTheme = function() return SelectedTheme end,
	rayfieldDestroyed = function() return rayfieldDestroyed end,
	ElementSync = {
		resync = function(token, reason)
			if ElementSyncSystem and type(ElementSyncSystem.resync) == "function" then
				return ElementSyncSystem.resync(token, reason)
			end
			return false
		end
	}
})

-- Detach helper wrapper
local function makeElementDetachable(guiObject, elementName, elementType)
	return DragSystem.makeElementDetachable(guiObject, elementName, elementType)
end

-- Initialize UI State Module
local UIStateSystem = UIStateModuleLib.init({
	TweenService = TweenService,
	Animation = Animation,
	Main = Main,
	Topbar = Topbar,
	TabList = TabList,
	Elements = Elements,
	Notifications = Notifications,
	MPrompt = MPrompt,
	dragInteract = dragInteract,
	dragBarCosmetic = dragBarCosmetic,
	dragBar = dragBar,
	dragOffset = dragOffset,
	dragOffsetMobile = dragOffsetMobile,
	getIcon = getIcon,
	getAssetUri = getAssetUri,
	getSelectedTheme = function() return SelectedTheme end,
	rayfieldDestroyed = function() return rayfieldDestroyed end,
	getSetting = getSetting,
	useMobileSizing = useMobileSizing,
	useMobilePrompt = useMobilePrompt
})

local TabSplitSystem = nil

-- Wrapper functions for UI State
local function openSearch()
	UIStateSystem.openSearch()
	searchOpen = UIStateSystem.getSearchOpen()
end

local function closeSearch()
	UIStateSystem.closeSearch()
	searchOpen = UIStateSystem.getSearchOpen()
end

local function Hide(notify)
	UIStateSystem.Hide(notify)
	Hidden = UIStateSystem.getHidden()
	Debounce = UIStateSystem.getDebounce()
	AnimationEngine:SetUiSuppressed(Hidden or Minimised or rayfieldDestroyed)
	if TabSplitSystem then
		TabSplitSystem.syncHidden(Hidden)
		TabSplitSystem.syncMinimized(Minimised)
	end
end

local function Unhide()
	UIStateSystem.Unhide()
	Hidden = UIStateSystem.getHidden()
	Minimised = UIStateSystem.getMinimised()
	Debounce = UIStateSystem.getDebounce()
	AnimationEngine:SetUiSuppressed(Hidden or Minimised or rayfieldDestroyed)
	if TabSplitSystem then
		TabSplitSystem.syncHidden(Hidden)
		TabSplitSystem.syncMinimized(Minimised)
	end
end

local function Maximise()
	UIStateSystem.Maximise()
	Minimised = UIStateSystem.getMinimised()
	Debounce = UIStateSystem.getDebounce()
	AnimationEngine:SetUiSuppressed(Hidden or Minimised or rayfieldDestroyed)
	if TabSplitSystem then
		TabSplitSystem.syncMinimized(Minimised)
	end
end

local function Minimise()
	UIStateSystem.Minimise()
	Minimised = UIStateSystem.getMinimised()
	Debounce = UIStateSystem.getDebounce()
	AnimationEngine:SetUiSuppressed(Hidden or Minimised or rayfieldDestroyed)
	if TabSplitSystem then
		TabSplitSystem.syncMinimized(Minimised)
	end
end

-- Converts ID to asset URI. Returns rbxassetid://0 if ID is not a number
local function getAssetUri(id: any): string
	return UtilitiesSystem and UtilitiesSystem.getAssetUri(id, Icons) or ("rbxassetid://" .. (type(id) == "number" and id or 0))
end

local function makeDraggable(object, dragObject, enableTaptic, tapticOffset)
	if UtilitiesSystem then
		UtilitiesSystem.makeDraggable(object, dragObject, enableTaptic, tapticOffset)
	else
		warn("Rayfield | UtilitiesSystem not initialized yet")
	end
end

-- Note: Old makeDraggable implementation moved to rayfield-utilities.lua module

-- Note: Drag/Detach system code has been moved to rayfield-drag.lua module

-- Configuration wrapper functions
local function PackColor(Color)
	return ConfigSystem.PackColor(Color)
end

local function UnpackColor(Color)
	return ConfigSystem.UnpackColor(Color)
end

local function LoadConfiguration(Configuration)
	return ConfigSystem.LoadConfiguration(Configuration)
end

local function SaveConfiguration()
	return ConfigSystem.SaveConfiguration()
end

-- Note: UI State Management (Notify, Search, Hide/Minimize) moved to rayfield-ui-state.lua module

-- Wrapper for RayfieldLibrary:Notify
function RayfieldLibrary:Notify(data)
	return UIStateSystem.Notify(data)
end

-- Note: saveSettings, updateSetting, and createSettings are now handled by SettingsModule

function RayfieldLibrary:CreateWindow(Settings)
	if Rayfield:FindFirstChild('Loading') then
		if getgenv and not getgenv().rayfieldCached then
			Rayfield.Enabled = true
			Rayfield.Loading.Visible = true

			task.wait(1.4)
			Rayfield.Loading.Visible = false
		end
	end

	if getgenv then getgenv().rayfieldCached = true end

	if not correctBuild and not Settings.DisableBuildWarnings then
		task.delay(3, 
			function() 
				RayfieldLibrary:Notify({Title = 'Build Mismatch', Content = 'Rayfield may encounter issues as you are running an incompatible interface version ('.. ((Rayfield:FindFirstChild('Build') and Rayfield.Build.Value) or 'No Build') ..').\n\nThis version of Rayfield is intended for interface build '..InterfaceBuild..'.\n\nTry rejoining and then run the script twice.', Image = 4335487866, Duration = 15})		
			end)
	end

	if Settings.ToggleUIKeybind then -- Can either be a string, sequence, or an Enum.KeyCode
		local canonical, _, normalizeErr = KeybindSequenceLib.normalize(Settings.ToggleUIKeybind, {
			maxSteps = 4
		})
		assert(canonical, "ToggleUIKeybind must be a valid keybind/sequence: " .. tostring(normalizeErr))
		overrideSetting("General", "rayfieldOpen", canonical)
		cachedUiToggleKeybindRaw = nil
		cachedUiToggleKeybindSpec = nil
		uiToggleKeybindMatcher:reset()
	end

	ensureFolder(RayfieldFolder)

	-- Attempt to report an event to analytics
	if not requestsDisabled then
		sendReport("window_created", Settings.Name or "Unknown")
	end
	local Passthrough = false
	Topbar.Title.Text = Settings.Name

	Main.Size = UDim2.new(0, 420, 0, 100)
	Main.Visible = true
	Main.BackgroundTransparency = 1
	if Main:FindFirstChild('Notice') then Main.Notice.Visible = false end
	Main.Shadow.Image.ImageTransparency = 1

	LoadingFrame.Title.TextTransparency = 1
	LoadingFrame.Subtitle.TextTransparency = 1

	if Settings.ShowText then
		MPrompt.Title.Text = 'Show '..Settings.ShowText
	end

	LoadingFrame.Version.TextTransparency = 1
	LoadingFrame.Title.Text = Settings.LoadingTitle or "Rayfield"
	LoadingFrame.Subtitle.Text = Settings.LoadingSubtitle or "Interface Suite"

	if Settings.LoadingTitle ~= "Rayfield Interface Suite" then
		LoadingFrame.Version.Text = "Rayfield UI"
	end

	if Settings.Icon and Settings.Icon ~= 0 and Topbar:FindFirstChild('Icon') then
		Topbar.Icon.Visible = true
		Topbar.Title.Position = UDim2.new(0, 47, 0.5, 0)

		if Settings.Icon then
			if typeof(Settings.Icon) == 'string' and Icons then
				local asset = getIcon(Settings.Icon)

				Topbar.Icon.Image = 'rbxassetid://'..asset.id
				Topbar.Icon.ImageRectOffset = asset.imageRectOffset
				Topbar.Icon.ImageRectSize = asset.imageRectSize
			else
				Topbar.Icon.Image = getAssetUri(Settings.Icon)
			end
		else
			Topbar.Icon.Image = "rbxassetid://" .. 0
		end
	end

	if dragBar then
		dragBar.Visible = false
		dragBarCosmetic.BackgroundTransparency = 1
		dragBar.Visible = true
	end

	if Settings.Theme then
		local success, result = pcall(ChangeTheme, Settings.Theme)
		if not success then
			local success, result2 = pcall(ChangeTheme, 'Default')
			if not success then
				warn('CRITICAL ERROR - NO DEFAULT THEME')
				print(result2)
			end
			warn('issue rendering theme. no theme on file')
			print(result)
		end
	end

	Topbar.Visible = false
	TabList.Visible = false
	Elements.Visible = false
	LoadingFrame.Visible = true

	-- Improvement 1: Disable notification loop by default to reduce resource usage
	-- Users can explicitly set DisableRayfieldPrompts = false to enable notifications
	if Settings.DisableRayfieldPrompts == nil then
		Settings.DisableRayfieldPrompts = true -- Default to disabled
	end

	-- Tab split settings
	if Settings.EnableTabSplit == nil then
		Settings.EnableTabSplit = true
	end
	if type(Settings.TabSplitHoldDuration) ~= "number" or Settings.TabSplitHoldDuration <= 0 then
		Settings.TabSplitHoldDuration = 3
	end
	if Settings.AllowSettingsTabSplit == nil then
		Settings.AllowSettingsTabSplit = false
	end
	if Settings.MaxSplitTabs ~= nil then
		local maxSplitTabs = tonumber(Settings.MaxSplitTabs)
		if maxSplitTabs and maxSplitTabs >= 1 then
			Settings.MaxSplitTabs = math.floor(maxSplitTabs)
		else
			Settings.MaxSplitTabs = nil
		end
	end

	if not Settings.DisableRayfieldPrompts then
		task.spawn(function()
			while true do
				task.wait(math.random(180, 600))
				RayfieldLibrary:Notify({
					Title = "Rayfield Interface",
					Content = "Enjoying this UI library? Find it at sirius.menu/discord",
					Duration = 7,
					Image = 4370033185,
				})
			end
		end)
	end

	pcall(function()
		if not Settings.ConfigurationSaving.FileName then
			Settings.ConfigurationSaving.FileName = tostring(game.PlaceId)
		end

		if Settings.ConfigurationSaving.Enabled == nil then
			Settings.ConfigurationSaving.Enabled = false
		end

		CFileName = Settings.ConfigurationSaving.FileName
		ConfigurationFolder = Settings.ConfigurationSaving.FolderName or ConfigurationFolder
		CEnabled = Settings.ConfigurationSaving.Enabled

		if Settings.ConfigurationSaving.Enabled then
			ensureFolder(ConfigurationFolder)
		end
	end)

	-- Initialize Utilities Module now that UI elements exist
	UtilitiesSystem = UtilitiesModuleLib.init({
		TweenService = TweenService,
		Animation = Animation,
		RunService = RunService,
		UserInputService = UserInputService,
		getService = getService,
		Main = Main,
		Rayfield = Rayfield,
		dragBar = dragBar,
		dragBarCosmetic = dragBarCosmetic,
		getHidden = function() return Hidden end,
		useMobileSizing = useMobileSizing,
		Hide = Hide,
		Unhide = Unhide,
		getDebounce = function() return Debounce end,
		setRayfieldDestroyed = function(val) rayfieldDestroyed = val end,
		keybindConnections = keybindConnections
	})

	makeDraggable(Main, Topbar, false, {dragOffset, dragOffsetMobile})
	if dragBar then dragBar.Position = useMobileSizing and UDim2.new(0.5, 0, 0.5, dragOffsetMobile) or UDim2.new(0.5, 0, 0.5, dragOffset) makeDraggable(Main, dragInteract, true, {dragOffset, dragOffsetMobile}) end

	for _, TabButton in ipairs(TabList:GetChildren()) do
		if TabButton.ClassName == "Frame" and TabButton.Name ~= "Placeholder" then
			TabButton.BackgroundTransparency = 1
			TabButton.Title.TextTransparency = 1
			TabButton.Image.ImageTransparency = 1
			TabButton.UIStroke.Transparency = 1
		end
	end

	if Settings.Discord and Settings.Discord.Enabled and not useStudio then
		ensureFolder(RayfieldFolder.."/Discord Invites")

		if callSafely(isfile, RayfieldFolder.."/Discord Invites".."/"..Settings.Discord.Invite..ConfigurationExtension) then
			if requestFunc then
				pcall(function()
					requestFunc({
						Url = 'http://127.0.0.1:6463/rpc?v=1',
						Method = 'POST',
						Headers = {
							['Content-Type'] = 'application/json',
							Origin = 'https://discord.com'
						},
						Body = HttpService:JSONEncode({
							cmd = 'INVITE_BROWSER',
							nonce = HttpService:GenerateGUID(false),
							args = {code = Settings.Discord.Invite}
						})
					})
				end)
			end

			if Settings.Discord.RememberJoins then -- We do logic this way so if the developer changes this setting, the user still won't be prompted, only new users
				callSafely(writefile, RayfieldFolder.."/Discord Invites".."/"..Settings.Discord.Invite..ConfigurationExtension,"Rayfield RememberJoins is true for this invite, this invite will not ask you to join again")
			end
		end
	end

	if (Settings.KeySystem) then
		if not Settings.KeySettings then
			Passthrough = true
			return
		end

		ensureFolder(RayfieldFolder.."/Key System")

		if typeof(Settings.KeySettings.Key) == "string" then Settings.KeySettings.Key = {Settings.KeySettings.Key} end

		if Settings.KeySettings.GrabKeyFromSite then
			for i, Key in ipairs(Settings.KeySettings.Key) do
				local Success, Response = pcall(function()
					Settings.KeySettings.Key[i] = tostring(game:HttpGet(Key):gsub("[\n\r]", " "))
					Settings.KeySettings.Key[i] = string.gsub(Settings.KeySettings.Key[i], " ", "")
				end)
				if not Success then
					print("Rayfield | "..Key.." Error " ..tostring(Response))
					warn('Check docs.sirius.menu for help with Rayfield specific development.')
				end
			end
		end

		if not Settings.KeySettings.FileName then
			Settings.KeySettings.FileName = "No file name specified"
		end

		if callSafely(isfile, RayfieldFolder.."/Key System".."/"..Settings.KeySettings.FileName..ConfigurationExtension) then
			for _, MKey in ipairs(Settings.KeySettings.Key) do
				local savedKeys = callSafely(readfile, RayfieldFolder.."/Key System".."/"..Settings.KeySettings.FileName..ConfigurationExtension)
				if savedKeys and string.find(savedKeys, MKey) then
					Passthrough = true
				end
			end
		end

		if not Passthrough then
			local AttemptsRemaining = math.random(2, 5)
			Rayfield.Enabled = false
			local KeyUI = useStudio and script.Parent:FindFirstChild('Key') or game:GetObjects("rbxassetid://11380036235")[1]

			KeyUI.Enabled = true

			local keyUiContainer = nil
			if Compatibility and type(Compatibility.protectAndParent) == "function" then
				keyUiContainer = Compatibility.protectAndParent(KeyUI, nil, {
					useStudio = useStudio
				})
			elseif not useStudio then
				KeyUI.Parent = CoreGui
				keyUiContainer = CoreGui
			end

			if Compatibility and type(Compatibility.dedupeGuiByName) == "function" then
				Compatibility.dedupeGuiByName(keyUiContainer, KeyUI.Name, KeyUI, "-Old")
			elseif not useStudio and keyUiContainer then
				for _, Interface in ipairs(keyUiContainer:GetChildren()) do
					if Interface.Name == KeyUI.Name and Interface ~= KeyUI then
						Interface.Enabled = false
						Interface.Name = "KeyUI-Old"
					end
				end
			end

			local KeyMain = KeyUI.Main
			KeyMain.Title.Text = Settings.KeySettings.Title or Settings.Name
			KeyMain.Subtitle.Text = Settings.KeySettings.Subtitle or "Key System"
			KeyMain.NoteMessage.Text = Settings.KeySettings.Note or "No instructions"

			KeyMain.Size = UDim2.new(0, 467, 0, 175)
			KeyMain.BackgroundTransparency = 1
			KeyMain.Shadow.Image.ImageTransparency = 1
			KeyMain.Title.TextTransparency = 1
			KeyMain.Subtitle.TextTransparency = 1
			KeyMain.KeyNote.TextTransparency = 1
			KeyMain.Input.BackgroundTransparency = 1
			KeyMain.Input.UIStroke.Transparency = 1
			KeyMain.Input.InputBox.TextTransparency = 1
			KeyMain.NoteTitle.TextTransparency = 1
			KeyMain.NoteMessage.TextTransparency = 1
			KeyMain.Hide.ImageTransparency = 1

			Animation:Create(KeyMain, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0}):Play()
			Animation:Create(KeyMain, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Size = UDim2.new(0, 500, 0, 187)}):Play()
			Animation:Create(KeyMain.Shadow.Image, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {ImageTransparency = 0.5}):Play()
			task.wait(0.05)
			Animation:Create(KeyMain.Title, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {TextTransparency = 0}):Play()
			Animation:Create(KeyMain.Subtitle, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {TextTransparency = 0}):Play()
			task.wait(0.05)
			Animation:Create(KeyMain.KeyNote, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {TextTransparency = 0}):Play()
			Animation:Create(KeyMain.Input, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0}):Play()
			Animation:Create(KeyMain.Input.UIStroke, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {Transparency = 0}):Play()
			Animation:Create(KeyMain.Input.InputBox, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {TextTransparency = 0}):Play()
			task.wait(0.05)
			Animation:Create(KeyMain.NoteTitle, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {TextTransparency = 0}):Play()
			Animation:Create(KeyMain.NoteMessage, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {TextTransparency = 0}):Play()
			task.wait(0.15)
			Animation:Create(KeyMain.Hide, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {ImageTransparency = 0.3}):Play()


			KeyUI.Main.Input.InputBox.FocusLost:Connect(function()
				if #KeyUI.Main.Input.InputBox.Text == 0 then return end
				local KeyFound = false
				local FoundKey = ''
				for _, MKey in ipairs(Settings.KeySettings.Key) do
					--if string.find(KeyMain.Input.InputBox.Text, MKey) then
					--	KeyFound = true
					--	FoundKey = MKey
					--end


					-- stricter key check
					if KeyMain.Input.InputBox.Text == MKey then
						KeyFound = true
						FoundKey = MKey
					end
				end
				if KeyFound then 
					Animation:Create(KeyMain, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundTransparency = 1}):Play()
					Animation:Create(KeyMain, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Size = UDim2.new(0, 467, 0, 175)}):Play()
					Animation:Create(KeyMain.Shadow.Image, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {ImageTransparency = 1}):Play()
					Animation:Create(KeyMain.Title, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
					Animation:Create(KeyMain.Subtitle, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
					Animation:Create(KeyMain.KeyNote, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
					Animation:Create(KeyMain.Input, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {BackgroundTransparency = 1}):Play()
					Animation:Create(KeyMain.Input.UIStroke, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {Transparency = 1}):Play()
					Animation:Create(KeyMain.Input.InputBox, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
					Animation:Create(KeyMain.NoteTitle, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
					Animation:Create(KeyMain.NoteMessage, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
					Animation:Create(KeyMain.Hide, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {ImageTransparency = 1}):Play()
					task.wait(0.51)
					Passthrough = true
					KeyMain.Visible = false
					if Settings.KeySettings.SaveKey then
						callSafely(writefile, RayfieldFolder.."/Key System".."/"..Settings.KeySettings.FileName..ConfigurationExtension, FoundKey)
						RayfieldLibrary:Notify({Title = "Key System", Content = "The key for this script has been saved successfully.", Image = 3605522284})
					end
				else
					if AttemptsRemaining == 0 then
						Animation:Create(KeyMain, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundTransparency = 1}):Play()
						Animation:Create(KeyMain, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Size = UDim2.new(0, 467, 0, 175)}):Play()
						Animation:Create(KeyMain.Shadow.Image, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {ImageTransparency = 1}):Play()
						Animation:Create(KeyMain.Title, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
						Animation:Create(KeyMain.Subtitle, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
						Animation:Create(KeyMain.KeyNote, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
						Animation:Create(KeyMain.Input, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {BackgroundTransparency = 1}):Play()
						Animation:Create(KeyMain.Input.UIStroke, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {Transparency = 1}):Play()
						Animation:Create(KeyMain.Input.InputBox, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
						Animation:Create(KeyMain.NoteTitle, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
						Animation:Create(KeyMain.NoteMessage, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
						Animation:Create(KeyMain.Hide, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {ImageTransparency = 1}):Play()
						task.wait(0.45)
						Players.LocalPlayer:Kick("No Attempts Remaining")
						game:Shutdown()
					end
					KeyMain.Input.InputBox.Text = ""
					AttemptsRemaining = AttemptsRemaining - 1
					Animation:Create(KeyMain, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Size = UDim2.new(0, 467, 0, 175)}):Play()
					Animation:Create(KeyMain, TweenInfo.new(0.4, Enum.EasingStyle.Elastic), {Position = UDim2.new(0.495,0,0.5,0)}):Play()
					task.wait(0.1)
					Animation:Create(KeyMain, TweenInfo.new(0.4, Enum.EasingStyle.Elastic), {Position = UDim2.new(0.505,0,0.5,0)}):Play()
					task.wait(0.1)
					Animation:Create(KeyMain, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {Position = UDim2.new(0.5,0,0.5,0)}):Play()
					Animation:Create(KeyMain, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Size = UDim2.new(0, 500, 0, 187)}):Play()
				end
			end)

			KeyMain.Hide.MouseButton1Click:Connect(function()
				Animation:Create(KeyMain, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundTransparency = 1}):Play()
				Animation:Create(KeyMain, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {Size = UDim2.new(0, 467, 0, 175)}):Play()
				Animation:Create(KeyMain.Shadow.Image, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {ImageTransparency = 1}):Play()
				Animation:Create(KeyMain.Title, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
				Animation:Create(KeyMain.Subtitle, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
				Animation:Create(KeyMain.KeyNote, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
				Animation:Create(KeyMain.Input, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {BackgroundTransparency = 1}):Play()
				Animation:Create(KeyMain.Input.UIStroke, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {Transparency = 1}):Play()
				Animation:Create(KeyMain.Input.InputBox, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
				Animation:Create(KeyMain.NoteTitle, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
				Animation:Create(KeyMain.NoteMessage, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
				Animation:Create(KeyMain.Hide, TweenInfo.new(0.4, Enum.EasingStyle.Exponential), {ImageTransparency = 1}):Play()
				task.wait(0.51)
				RayfieldLibrary:Destroy()
				KeyUI:Destroy()
			end)
		else
			Passthrough = true
		end
	end
	if Settings.KeySystem then
		repeat task.wait() until Passthrough
	end

	Notifications.Template.Visible = false
	Notifications.Visible = true
	Rayfield.Enabled = true

	task.wait(0.5)
	Animation:Create(Main, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0}):Play()
	Animation:Create(Main.Shadow.Image, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {ImageTransparency = 0.6}):Play()
	task.wait(0.1)
	Animation:Create(LoadingFrame.Title, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {TextTransparency = 0}):Play()
	task.wait(0.05)
	Animation:Create(LoadingFrame.Subtitle, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {TextTransparency = 0}):Play()
	task.wait(0.05)
	Animation:Create(LoadingFrame.Version, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {TextTransparency = 0}):Play()


	Elements.Template.LayoutOrder = 100000
	Elements.Template.Visible = false

	Elements.UIPageLayout.FillDirection = Enum.FillDirection.Horizontal
	TabList.Template.Visible = false

	-- Tab
	local FirstTab = false
	local Window = {}

	-- Recreate tab split system per-window setup to keep references fresh
	if TabSplitSystem and TabSplitSystem.destroy then
		TabSplitSystem.destroy()
		TabSplitSystem = nil
	end

	-- Initialize Elements Module
	if ElementSyncSystem and ElementSyncSystem.destroy then
		ElementSyncSystem.destroy()
	end
	ElementSyncSystem = ElementSyncModuleLib.init({
		warn = function(message)
			warn("Rayfield | ElementSync " .. tostring(message))
		end
	})

	local ElementsSystem = ElementsModuleLib.init({
		TweenService = TweenService,
		Animation = Animation,
		RunService = RunService,
		UserInputService = UserInputService,
		HttpService = HttpService,
		Main = Main,
		Topbar = Topbar,
		TabList = TabList,
		Elements = Elements,
		Rayfield = Rayfield,
		RayfieldLibrary = RayfieldLibrary,
		Icons = Icons,
		getIcon = getIcon,
		getAssetUri = getAssetUri,
		getSelectedTheme = function() return SelectedTheme end,
		rayfieldDestroyed = function() return rayfieldDestroyed end,
		getMinimised = function() return Minimised end,
		getSetting = getSetting,
		bindTheme = bindTheme,
		SaveConfiguration = SaveConfiguration,
		makeElementDetachable = makeElementDetachable,
		KeybindSequence = KeybindSequenceLib,
		keybindConnections = keybindConnections,
		getDebounce = function() return Debounce end,
		setDebounce = function(val) Debounce = val end,
		useMobileSizing = useMobileSizing,
		ElementSync = ElementSyncSystem,
		Settings = Settings
	})

	TabSplitSystem = TabSplitModuleLib.init({
		UserInputService = UserInputService,
		RunService = RunService,
		TweenService = TweenService,
		Animation = Animation,
		HttpService = HttpService,
		Rayfield = Rayfield,
		Main = Main,
		Topbar = Topbar,
		TabList = TabList,
		Elements = Elements,
		getSelectedTheme = function() return SelectedTheme end,
		rayfieldDestroyed = function() return rayfieldDestroyed end,
		useMobileSizing = useMobileSizing,
		Notify = function(data)
			RayfieldLibrary:Notify(data)
		end,
		getBlockedState = function()
			return Debounce or searchOpen
		end,
		enabled = Settings.EnableTabSplit,
		holdDuration = Settings.TabSplitHoldDuration,
		allowSettingsSplit = Settings.AllowSettingsTabSplit,
		maxSplitTabs = Settings.MaxSplitTabs
	})
	TabSplitSystem.syncHidden(Hidden)
	TabSplitSystem.syncMinimized(Minimised)

	-- Wrapper for Window:CreateTab
	function Window:CreateTab(Name, Image, Ext)
		local tab = ElementsSystem.CreateTab(Name, Image, Ext)
		FirstTab = ElementsSystem.getFirstTab()
		if TabSplitSystem and tab and tab.GetInternalRecord then
			local ok, tabRecord = pcall(function()
				return tab:GetInternalRecord()
			end)
			if ok and tabRecord then
				TabSplitSystem.registerTab(tabRecord)
			end
		end
		return tab
	end

	local function playStartupAnimation()
		Elements.Visible = true

		task.wait(1.1)
		Animation:Create(Main, TweenInfo.new(0.7, Enum.EasingStyle.Exponential, Enum.EasingDirection.InOut), {Size = UDim2.new(0, 390, 0, 90)}):Play()
		task.wait(0.3)
		Animation:Create(LoadingFrame.Title, TweenInfo.new(0.2, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
		Animation:Create(LoadingFrame.Subtitle, TweenInfo.new(0.2, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
		Animation:Create(LoadingFrame.Version, TweenInfo.new(0.2, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()
		task.wait(0.1)
		Animation:Create(Main, TweenInfo.new(0.6, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out), {Size = useMobileSizing and UDim2.new(0, 500, 0, 275) or UDim2.new(0, 500, 0, 475)}):Play()
		Animation:Create(Main.Shadow.Image, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {ImageTransparency = 0.6}):Play()

		local topbarDivider = Topbar:FindFirstChild("Divider")
		local topbarCornerRepair = Topbar:FindFirstChild("CornerRepair")
		local topbarTitle = Topbar:FindFirstChild("Title")
		local topbarSearch = Topbar:FindFirstChild("Search")
		local topbarSettings = Topbar:FindFirstChild("Settings")
		local topbarChangeSize = Topbar:FindFirstChild("ChangeSize")
		local topbarHide = Topbar:FindFirstChild("Hide")

		Topbar.BackgroundTransparency = 1
		if topbarDivider then
			topbarDivider.Size = UDim2.new(0, 0, 0, 1)
			topbarDivider.BackgroundColor3 = SelectedTheme.ElementStroke
		end
		if topbarCornerRepair then
			topbarCornerRepair.BackgroundTransparency = 1
		end
		if topbarTitle then
			topbarTitle.TextTransparency = 1
		end
		if topbarSearch then
			topbarSearch.ImageTransparency = 1
		end
		if topbarSettings then
			topbarSettings.ImageTransparency = 1
		end
		if topbarChangeSize then
			topbarChangeSize.ImageTransparency = 1
		end
		if topbarHide then
			topbarHide.ImageTransparency = 1
		end

		task.wait(0.5)
		Topbar.Visible = true
		TabList.Visible = true
		Animation:Create(Topbar, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0}):Play()
		if topbarCornerRepair then
			Animation:Create(topbarCornerRepair, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0}):Play()
		end
		task.wait(0.1)
		if topbarDivider then
			Animation:Create(topbarDivider, TweenInfo.new(1, Enum.EasingStyle.Exponential), {Size = UDim2.new(1, 0, 0, 1)}):Play()
		end
		if topbarTitle then
			Animation:Create(topbarTitle, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {TextTransparency = 0}):Play()
		end
		task.wait(0.05)
		if topbarSearch then
			Animation:Create(topbarSearch, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {ImageTransparency = 0.8}):Play()
		end
		task.wait(0.05)
		if topbarSettings then
			Animation:Create(topbarSettings, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {ImageTransparency = 0.8}):Play()
			task.wait(0.05)
		end
		if topbarChangeSize then
			Animation:Create(topbarChangeSize, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {ImageTransparency = 0.8}):Play()
			task.wait(0.05)
		end
		if topbarHide then
			Animation:Create(topbarHide, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {ImageTransparency = 0.8}):Play()
		end
		task.wait(0.3)

		if dragBar and dragBarCosmetic then
			Animation:Create(dragBarCosmetic, TweenInfo.new(0.6, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0.7}):Play()
		end

		LoadingFrame.Visible = false
		Topbar.Visible = true
		TabList.Visible = true
		Elements.Visible = true
	end

	function Window.ModifyTheme(NewTheme)
		local success = pcall(ChangeTheme, NewTheme)
		if not success then
			RayfieldLibrary:Notify({Title = 'Unable to Change Theme', Content = 'We are unable find a theme on file.', Image = 4400704299})
		else
			RayfieldLibrary:Notify({Title = 'Theme Changed', Content = 'Successfully changed theme to '..(typeof(NewTheme) == 'string' and NewTheme or 'Custom Theme')..'.', Image = 4483362748})
		end
	end

	local success, result = pcall(function()
		createSettings(Window)
	end)

	if not success then warn('Rayfield had an issue creating settings.') end

	local startupSuccess, startupResult = pcall(function()
		playStartupAnimation()
	end)
	if not startupSuccess then
		warn("Rayfield had an issue during startup animation: " .. tostring(startupResult))
		LoadingFrame.Visible = false
		Topbar.Visible = true
		TabList.Visible = true
		Elements.Visible = true
	end

	return Window
end

local function setVisibility(visibility: boolean, notify: boolean?)
	if UtilitiesSystem then
		UtilitiesSystem.setVisibility(visibility, notify)
		Hidden = not visibility
		if TabSplitSystem then
			TabSplitSystem.syncHidden(Hidden)
		end
	end
end

function RayfieldLibrary:SetVisibility(visibility: boolean)
	setVisibility(visibility, false)
end

function RayfieldLibrary:IsVisible(): boolean
	return not Hidden
end

local hideHotkeyConnection -- Has to be initialized here since the connection is made later in the script
function RayfieldLibrary:Destroy()
	AnimationEngine:SetUiSuppressed(true)
	-- Cleanup theme connections to prevent memory leaks on reload
	if ThemeSystem and ThemeSystem.cleanup then
		ThemeSystem.cleanup()
	end
	if TabSplitSystem and TabSplitSystem.destroy then
		TabSplitSystem.destroy()
		TabSplitSystem = nil
	end
	if UtilitiesSystem then
		UtilitiesSystem.destroy(hideHotkeyConnection)
	end
	if AnimationEngine and AnimationEngine.Destroy then
		AnimationEngine:Destroy()
	end
	if ElementSyncSystem and ElementSyncSystem.destroy then
		ElementSyncSystem.destroy()
		ElementSyncSystem = nil
	end

	-- Reset global runtime/cache flags so the next execution reloads a fresh UI tree.
	pcall(function()
		if getgenv then
			local env = getgenv()
			env.rayfieldCached = nil
		end
	end)
	_G.Rayfield = nil
	_G.RayfieldUI = nil
	_G.RayfieldAllInOneLoaded = nil
	if type(_G.RayfieldCache) == "table" then
		table.clear(_G.RayfieldCache)
	end
	if type(_G.__RayfieldApiModuleCache) == "table" then
		table.clear(_G.__RayfieldApiModuleCache)
	end
end

function RayfieldLibrary:IsDestroyed(): boolean
	if rayfieldDestroyed then
		return true
	end
	local ok, parent = pcall(function()
		return Rayfield.Parent
	end)
	return (not ok) or parent == nil
end

Topbar.ChangeSize.MouseButton1Click:Connect(function()
	if Debounce then return end
	if Minimised then
		Minimised = false
		Maximise()
	else
		Minimised = true
		Minimise()
	end
end)

Main.Search.Input:GetPropertyChangedSignal('Text'):Connect(function()
	if #Main.Search.Input.Text > 0 then
		if not Elements.UIPageLayout.CurrentPage:FindFirstChild('SearchTitle-fsefsefesfsefesfesfThanks') then 
			local searchTitle = Elements.Template.SectionTitle:Clone()
			searchTitle.Parent = Elements.UIPageLayout.CurrentPage
			searchTitle.Name = 'SearchTitle-fsefsefesfsefesfesfThanks'
			searchTitle.LayoutOrder = -100
			searchTitle.Title.Text = "Results from '"..Elements.UIPageLayout.CurrentPage.Name.."'"
			searchTitle.Visible = true
		end
	else
		local searchTitle = Elements.UIPageLayout.CurrentPage:FindFirstChild('SearchTitle-fsefsefesfsefesfesfThanks')

		if searchTitle then
			searchTitle:Destroy()
		end
	end

	for _, element in ipairs(Elements.UIPageLayout.CurrentPage:GetChildren()) do
		if element.ClassName ~= 'UIListLayout' and element.Name ~= 'Placeholder' and element.Name ~= 'SearchTitle-fsefsefesfsefesfesfThanks' then
			if element.Name == 'SectionTitle' then
				if #Main.Search.Input.Text == 0 then
					element.Visible = true
				else
					element.Visible = false
				end
			else
				if string.lower(element.Name):find(string.lower(Main.Search.Input.Text), 1, true) then
					element.Visible = true
				else
					element.Visible = false
				end
			end
		end
	end
end)

Main.Search.Input.FocusLost:Connect(function(enterPressed)
	if #Main.Search.Input.Text == 0 and searchOpen then
		task.wait(0.12)
		closeSearch()
	end
end)

Topbar.Search.MouseButton1Click:Connect(function()
	task.spawn(function()
		if searchOpen then
			closeSearch()
		else
			openSearch()
		end
	end)
end)

if Topbar:FindFirstChild('Settings') then
	Topbar.Settings.MouseButton1Click:Connect(function()
		task.spawn(function()
			for _, OtherTabButton in ipairs(TabList:GetChildren()) do
				if OtherTabButton.Name ~= "Template" and OtherTabButton.ClassName == "Frame" and OtherTabButton ~= TabButton and OtherTabButton.Name ~= "Placeholder" then
					Animation:Create(OtherTabButton, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {BackgroundColor3 = SelectedTheme.TabBackground}):Play()
					Animation:Create(OtherTabButton.Title, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {TextColor3 = SelectedTheme.TabTextColor}):Play()
					Animation:Create(OtherTabButton.Image, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {ImageColor3 = SelectedTheme.TabTextColor}):Play()
					Animation:Create(OtherTabButton, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {BackgroundTransparency = 0.7}):Play()
					Animation:Create(OtherTabButton.Title, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {TextTransparency = 0.2}):Play()
					Animation:Create(OtherTabButton.Image, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {ImageTransparency = 0.2}):Play()
					Animation:Create(OtherTabButton.UIStroke, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {Transparency = 0.5}):Play()
				end
			end

			local settingsPage = Elements:FindFirstChild("Rayfield Settings")
			if settingsPage then
				Elements.UIPageLayout:JumpTo(settingsPage)
			else
				RayfieldLibrary:Notify({
					Title = "Settings Tab",
					Content = "Settings tab is currently split. Dock it back to open from topbar.",
					Duration = 3
				})
			end
		end)
	end)

end


Topbar.Hide.MouseButton1Click:Connect(function()
	setVisibility(Hidden, not useMobileSizing)
end)

hideHotkeyConnection = UserInputService.InputBegan:Connect(function(input, processed)
	if processed then
		return
	end

	local currentBinding = getSetting("General", "rayfieldOpen")
	local uiBindingSpec = resolveUiToggleKeybindSpec(currentBinding)
	if not uiBindingSpec then
		return
	end

	local matched = uiToggleKeybindMatcher:consume(input, uiBindingSpec, UserInputService, processed)
	if matched then
		if Debounce then return end
		if Hidden then
			Hidden = false
			Unhide()
		else
			Hidden = true
			Hide()
		end
	end
end)

if MPrompt then
	MPrompt.Interact.MouseButton1Click:Connect(function()
		if Debounce then return end
		if Hidden then
			Hidden = false
			Unhide()
		end
	end)
end

for _, TopbarButton in ipairs(Topbar:GetChildren()) do
	if TopbarButton.ClassName == "ImageButton" and TopbarButton.Name ~= 'Icon' then
		TopbarButton.MouseEnter:Connect(function()
			Animation:Create(TopbarButton, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {ImageTransparency = 0}):Play()
		end)

		TopbarButton.MouseLeave:Connect(function()
			Animation:Create(TopbarButton, TweenInfo.new(0.7, Enum.EasingStyle.Exponential), {ImageTransparency = 0.8}):Play()
		end)
	end
end


function RayfieldLibrary:LoadConfiguration()
	local config

	if debugX then
		warn('Loading Configuration')
	end

	if useStudio then
		config = [[{"Toggle1adwawd":true,"ColorPicker1awd":{"B":255,"G":255,"R":255},"Slider1dawd":100,"ColorPicfsefker1":{"B":255,"G":255,"R":255},"Slidefefsr1":80,"dawdawd":"","Input1":"hh","Keybind1":"B","Dropdown1":["Ocean"]}]]
	end

	if CEnabled then
		local notified
		local loaded

		local success, result = pcall(function()
			if useStudio and config then
				loaded = LoadConfiguration(config)
				return
			end

			if isfile then 
				if callSafely(isfile, ConfigurationFolder .. "/" .. CFileName .. ConfigurationExtension) then
					loaded = LoadConfiguration(callSafely(readfile, ConfigurationFolder .. "/" .. CFileName .. ConfigurationExtension))
				end
			else
				notified = true
				RayfieldLibrary:Notify({Title = "Rayfield Configurations", Content = "We couldn't enable Configuration Saving as you are not using software with filesystem support.", Image = 4384402990})
			end
		end)

		if success and loaded and not notified then
			RayfieldLibrary:Notify({Title = "Rayfield Configurations", Content = "The configuration file for this script has been loaded from a previous session.", Image = 4384403532})
		elseif not success and not notified then
			warn('Rayfield Configurations Error | '..tostring(result))
			RayfieldLibrary:Notify({Title = "Rayfield Configurations", Content = "We've encountered an issue loading your configuration correctly.\n\nCheck the Developer Console for more information.", Image = 4384402990})
		end
	end

	globalLoaded = true
end



if useStudio then
	-- run w/ studio
	-- Feel free to place your own script here to see how it'd work in Roblox Studio before running it on your execution software.


	--local Window = RayfieldLibrary:CreateWindow({
	--	Name = "Rayfield Example Window",
	--	LoadingTitle = "Rayfield Interface Suite",
	--	Theme = 'Default',
	--	Icon = 0,
	--	LoadingSubtitle = "by Sirius",
	--	ConfigurationSaving = {
	--		Enabled = true,
	--		FolderName = nil, -- Create a custom folder for your hub/game
	--		FileName = "Big Hub52"
	--	},
	--	Discord = {
	--		Enabled = false,
	--		Invite = "noinvitelink", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ABCD would be ABCD
	--		RememberJoins = true -- Set this to false to make them join the discord every time they load it up
	--	},
	--	KeySystem = false, -- Set this to true to use our key system
	--	KeySettings = {
	--		Title = "Untitled",
	--		Subtitle = "Key System",
	--		Note = "No method of obtaining the key is provided",
	--		FileName = "Key", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
	--		SaveKey = true, -- The user's key will be saved, but if you change the key, they will be unable to use your script
	--		GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
	--		Key = {"Hello"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
	--	}
	--})

	--local Tab = Window:CreateTab("Tab Example", 'key-round') -- Title, Image
	--local Tab2 = Window:CreateTab("Tab Example 2", 4483362458) -- Title, Image

	--local Section = Tab2:CreateSection("Section")


	--local ColorPicker = Tab2:CreateColorPicker({
	--	Name = "Color Picker",
	--	Color = Color3.fromRGB(255,255,255),
	--	Flag = "ColorPicfsefker1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	--	Callback = function(Value)
	--		-- The function that takes place every time the color picker is moved/changed
	--		-- The variable (Value) is a Color3fromRGB value based on which color is selected
	--	end
	--})

	--local Slider = Tab2:CreateSlider({
	--	Name = "Slider Example",
	--	Range = {0, 100},
	--	Increment = 10,
	--	Suffix = "Bananas",
	--	CurrentValue = 40,
	--	Flag = "Slidefefsr1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	--	Callback = function(Value)
	--		-- The function that takes place when the slider changes
	--		-- The variable (Value) is a number which correlates to the value the slider is currently at
	--	end,
	--})

	--local Input = Tab2:CreateInput({
	--	Name = "Input Example",
	--	CurrentValue = '',
	--	PlaceholderText = "Input Placeholder",
	--	Flag = 'dawdawd',
	--	RemoveTextAfterFocusLost = false,
	--	Callback = function(Text)
	--		-- The function that takes place when the input is changed
	--		-- The variable (Text) is a string for the value in the text box
	--	end,
	--})


	----RayfieldLibrary:Notify({Title = "Rayfield Interface", Content = "Welcome to Rayfield. These - are the brand new notification design for Rayfield, with custom sizing and Rayfield calculated wait times.", Image = 4483362458})

	--local Section = Tab:CreateSection("Section Example")

	--local Button = Tab:CreateButton({
	--	Name = "Change Theme",
	--	Callback = function()
	--		-- The function that takes place when the button is pressed
	--		Window.ModifyTheme('DarkBlue')
	--	end,
	--})

	--local Toggle = Tab:CreateToggle({
	--	Name = "Toggle Example",
	--	CurrentValue = false,
	--	Flag = "Toggle1adwawd", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	--	Callback = function(Value)
	--		-- The function that takes place when the toggle is pressed
	--		-- The variable (Value) is a boolean on whether the toggle is true or false
	--	end,
	--})

	--local ColorPicker = Tab:CreateColorPicker({
	--	Name = "Color Picker",
	--	Color = Color3.fromRGB(255,255,255),
	--	Flag = "ColorPicker1awd", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	--	Callback = function(Value)
	--		-- The function that takes place every time the color picker is moved/changed
	--		-- The variable (Value) is a Color3fromRGB value based on which color is selected
	--	end
	--})

	--local Slider = Tab:CreateSlider({
	--	Name = "Slider Example",
	--	Range = {0, 100},
	--	Increment = 10,
	--	Suffix = "Bananas",
	--	CurrentValue = 40,
	--	Flag = "Slider1dawd", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	--	Callback = function(Value)
	--		-- The function that takes place when the slider changes
	--		-- The variable (Value) is a number which correlates to the value the slider is currently at
	--	end,
	--})

	--local Input = Tab:CreateInput({
	--	Name = "Input Example",
	--	CurrentValue = "Helo",
	--	PlaceholderText = "Adaptive Input",
	--	RemoveTextAfterFocusLost = false,
	--	Flag = 'Input1',
	--	Callback = function(Text)
	--		-- The function that takes place when the input is changed
	--		-- The variable (Text) is a string for the value in the text box
	--	end,
	--})

	--local thoptions = {}
	--for themename, theme in pairs(RayfieldLibrary.Theme) do
	--	table.insert(thoptions, themename)
	--end

	--local Dropdown = Tab:CreateDropdown({
	--	Name = "Theme",
	--	Options = thoptions,
	--	CurrentOption = {"Default"},
	--	MultipleOptions = false,
	--	Flag = "Dropdown1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	--	Callback = function(Options)
	--		--Window.ModifyTheme(Options[1])
	--		-- The function that takes place when the selected option is changed
	--		-- The variable (Options) is a table of strings for the current selected options
	--	end,
	--})


	--Window.ModifyTheme({
	--	TextColor = Color3.fromRGB(50, 55, 60),
	--	Background = Color3.fromRGB(240, 245, 250),
	--	Topbar = Color3.fromRGB(215, 225, 235),
	--	Shadow = Color3.fromRGB(200, 210, 220),

	--	NotificationBackground = Color3.fromRGB(210, 220, 230),
	--	NotificationActionsBackground = Color3.fromRGB(225, 230, 240),

	--	TabBackground = Color3.fromRGB(200, 210, 220),
	--	TabStroke = Color3.fromRGB(180, 190, 200),
	--	TabBackgroundSelected = Color3.fromRGB(175, 185, 200),
	--	TabTextColor = Color3.fromRGB(50, 55, 60),
	--	SelectedTabTextColor = Color3.fromRGB(30, 35, 40),

	--	ElementBackground = Color3.fromRGB(210, 220, 230),
	--	ElementBackgroundHover = Color3.fromRGB(220, 230, 240),
	--	SecondaryElementBackground = Color3.fromRGB(200, 210, 220),
	--	ElementStroke = Color3.fromRGB(190, 200, 210),
	--	SecondaryElementStroke = Color3.fromRGB(180, 190, 200),

	--	SliderBackground = Color3.fromRGB(200, 220, 235),  -- Lighter shade
	--	SliderProgress = Color3.fromRGB(70, 130, 180),
	--	SliderStroke = Color3.fromRGB(150, 180, 220),

	--	ToggleBackground = Color3.fromRGB(210, 220, 230),
	--	ToggleEnabled = Color3.fromRGB(70, 160, 210),
	--	ToggleDisabled = Color3.fromRGB(180, 180, 180),
	--	ToggleEnabledStroke = Color3.fromRGB(60, 150, 200),
	--	ToggleDisabledStroke = Color3.fromRGB(140, 140, 140),
	--	ToggleEnabledOuterStroke = Color3.fromRGB(100, 120, 140),
	--	ToggleDisabledOuterStroke = Color3.fromRGB(120, 120, 130),

	--	DropdownSelected = Color3.fromRGB(220, 230, 240),
	--	DropdownUnselected = Color3.fromRGB(200, 210, 220),

	--	InputBackground = Color3.fromRGB(220, 230, 240),
	--	InputStroke = Color3.fromRGB(180, 190, 200),
	--	PlaceholderColor = Color3.fromRGB(150, 150, 150)
	--})

	--local Keybind = Tab:CreateKeybind({
	--	Name = "Keybind Example",
	--	CurrentKeybind = "Q",
	--	HoldToInteract = false,
	--	Flag = "Keybind1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	--	Callback = function(Keybind)
	--		-- The function that takes place when the keybind is pressed
	--		-- The variable (Keybind) is a boolean for whether the keybind is being held or not (HoldToInteract needs to be true)
	--	end,
	--})

	--local Label = Tab:CreateLabel("Label Example")

	--local Label2 = Tab:CreateLabel("Warning", 4483362458, Color3.fromRGB(255, 159, 49),  true)

	--local Paragraph = Tab:CreateParagraph({Title = "Paragraph Example", Content = "Paragraph ExampleParagraph ExampleParagraph ExampleParagraph ExampleParagraph ExampleParagraph ExampleParagraph ExampleParagraph ExampleParagraph ExampleParagraph ExampleParagraph ExampleParagraph ExampleParagraph ExampleParagraph Example"})
end

if CEnabled and Main:FindFirstChild('Notice') then
	Main.Notice.BackgroundTransparency = 1
	Main.Notice.Title.TextTransparency = 1
	Main.Notice.Size = UDim2.new(0, 0, 0, 0)
	Main.Notice.Position = UDim2.new(0.5, 0, 0, -100)
	Main.Notice.Visible = true


	Animation:Create(Main.Notice, TweenInfo.new(0.5, Enum.EasingStyle.Exponential, Enum.EasingDirection.InOut), {Size = UDim2.new(0, 280, 0, 35), Position = UDim2.new(0.5, 0, 0, -50), BackgroundTransparency = 0.5}):Play()
	Animation:Create(Main.Notice.Title, TweenInfo.new(0.5, Enum.EasingStyle.Exponential), {TextTransparency = 0.1}):Play()
end
-- AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA why :(
--if not useStudio then
--	task.spawn(loadWithTimeout, "https://raw.githubusercontent.com/SiriusSoftwareLtd/Sirius/refs/heads/request/boost.lua")
--end

task.delay(4, function()
	RayfieldLibrary.LoadConfiguration()
	if Main:FindFirstChild('Notice') and Main.Notice.Visible then
		Animation:Create(Main.Notice, TweenInfo.new(0.5, Enum.EasingStyle.Exponential, Enum.EasingDirection.InOut), {Size = UDim2.new(0, 100, 0, 25), Position = UDim2.new(0.5, 0, 0, -100), BackgroundTransparency = 1}):Play()
		Animation:Create(Main.Notice.Title, TweenInfo.new(0.3, Enum.EasingStyle.Exponential), {TextTransparency = 1}):Play()

		task.wait(0.5)
		Main.Notice.Visible = false
	end
end)

return RayfieldLibrary
]=])
put("src/services/compatibility.lua", [[local Compatibility = {}

local DEFAULT_RUNTIME_ROOT = "https://raw.githubusercontent.com/Ahlstarr-Mayjishan/Rayfield-mod/main/"

local function safePcall(fn, ...)
	local ok, result = pcall(fn, ...)
	if ok then
		return result
	end
	return nil
end

function Compatibility.getCompileString()
	local compileString = loadstring or load
	if not compileString then
		error("No Lua compiler function available (loadstring/load)")
	end
	return compileString
end

function Compatibility.getRuntimeRoot()
	if type(_G) == "table" and type(_G.__RAYFIELD_RUNTIME_ROOT_URL) == "string" and _G.__RAYFIELD_RUNTIME_ROOT_URL ~= "" then
		return _G.__RAYFIELD_RUNTIME_ROOT_URL
	end
	return DEFAULT_RUNTIME_ROOT
end

function Compatibility.getService(name)
	local service = safePcall(function()
		return game:GetService(name)
	end)
	if not service then
		return nil
	end

	if type(cloneref) == "function" then
		local ref = safePcall(cloneref, service)
		if ref then
			return ref
		end
	end

	return service
end

function Compatibility.tryGetHui()
	if type(gethui) == "function" then
		local hui = safePcall(gethui)
		if hui then
			return hui
		end
	end
	return nil
end

function Compatibility.protectGui(guiObject)
	if not guiObject then
		return false
	end

	if type(syn) == "table" and type(syn.protect_gui) == "function" then
		local ok = safePcall(syn.protect_gui, guiObject)
		return ok ~= nil
	end

	if type(protectgui) == "function" then
		local ok = safePcall(protectgui, guiObject)
		return ok ~= nil
	end

	if type(secure_call) == "function" and type(protect_gui) == "function" then
		local ok = safePcall(secure_call, protect_gui, guiObject)
		return ok ~= nil
	end

	return false
end

function Compatibility.getGuiContainer(useStudio, preferredContainer)
	if preferredContainer then
		return preferredContainer
	end

	local coreGui = Compatibility.getService("CoreGui")
	if useStudio then
		return coreGui
	end

	local hui = Compatibility.tryGetHui()
	if hui then
		return hui
	end

	if coreGui then
		local robloxGui = safePcall(function()
			return coreGui:FindFirstChild("RobloxGui")
		end)
		if robloxGui then
			return robloxGui
		end
	end

	return coreGui
end

function Compatibility.protectAndParent(guiObject, preferredContainer, options)
	if not guiObject then
		return nil
	end

	options = options or {}
	local useStudio = options.useStudio == true
	local container = Compatibility.getGuiContainer(useStudio, preferredContainer)

	if not useStudio and not Compatibility.tryGetHui() then
		Compatibility.protectGui(guiObject)
	end

	if container then
		guiObject.Parent = container
	end

	return container
end

function Compatibility.dedupeGuiByName(container, guiName, keepInstance, oldNameSuffix)
	if not (container and guiName) then
		return 0
	end

	local renamedCount = 0
	local suffix = oldNameSuffix or "-Old"
	for _, child in ipairs(container:GetChildren()) do
		if child ~= keepInstance and child.Name == guiName then
			local okEnable = pcall(function()
				child.Enabled = false
			end)
			if not okEnable then
				-- Ignore non-LayerCollector instances sharing same name.
			end
			child.Name = guiName .. suffix
			renamedCount += 1
		end
	end

	return renamedCount
end

if type(_G) == "table" then
	_G.__RayfieldCompatibility = Compatibility
end

return Compatibility

]])
put("src/services/input-dispatcher.lua", [[local Dispatcher = {}

function Dispatcher.new(UserInputService)
	local changed = {}
	local ended = {}
	local conChanged = UserInputService.InputChanged:Connect(function(input)
		for _, cb in pairs(changed) do
			cb(input)
		end
	end)
	local conEnded = UserInputService.InputEnded:Connect(function(input)
		for _, cb in pairs(ended) do
			cb(input)
		end
	end)

	return {
		register = function(_, id, onChanged, onEnded)
			if onChanged then changed[id] = onChanged end
			if onEnded then ended[id] = onEnded end
		end,
		unregister = function(_, id)
			changed[id] = nil
			ended[id] = nil
		end,
		destroy = function()
			table.clear(changed)
			table.clear(ended)
			conChanged:Disconnect()
			conEnded:Disconnect()
		end
	}
end

return Dispatcher
]])
put("src/services/logger.lua", [[local Logger = {}

function Logger.new(config)
	config = config or {}
	local enabled = config.enabled == true
	local prefix = config.prefix or "[Rayfield]"
	return {
		info = function(_, ...)
			if enabled then
				print(prefix, ...)
			end
		end,
		warn = function(_, ...)
			if enabled then
				warn(prefix, ...)
			end
		end
	}
end

return Logger
]])

return {
    name = BUNDLE_NAME,
    count = 31,
    bundle = bundle
}
